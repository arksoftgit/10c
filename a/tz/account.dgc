#define KZSYSSVC_INCL
#include "kzoengaa.h"
#include "tzlodopr.h"
#include "tz__oprs.h"
#include "tzctlopr.h"
#include <string.h>

#ifdef __cplusplus
extern "C"
{
#endif

#include "Zeidonop.H"

zOPER_EXPORT zSHORT OPERATION
ActivateAccountOI( zVIEW  vSubtask );
zOPER_EXPORT zSHORT OPERATION
SaveInstance( zVIEW  vSubtask );
zOPER_EXPORT zSHORT OPERATION
DeleteObjectEntity( zVIEW  vSubtask );
zOPER_EXPORT zSHORT OPERATION
DeleteInstance( zVIEW  vSubtask );
zOPER_EXPORT zSHORT OPERATION
Cleanup( zVIEW   vSubtask );
zOPER_EXPORT zSHORT OPERATION
Setup( zVIEW   vSubtask );
zOPER_EXPORT zSHORT OPERATION
ResetText( zVIEW   vSubtask );
zOPER_EXPORT zSHORT OPERATION
Refresh( zVIEW   vSubtask );

zOPER_EXPORT zSHORT OPERATION
ActivateAccountOI( zVIEW  vSubtask )
{
   zVIEW     vAccount;
   zVIEW     vTZPEAXWO;
   zCHAR     szDlgName[ 34 ];
   zCHAR     szWndName[ 34 ];
   zCHAR     szCtrlName[ 34 ];
// zPCHAR    pchBuffer;
// zLONG     hMem[ 100 ];
   zSHORT    nRC;
   zULONG    ulLth;

#ifdef __cplusplus
   zDecimal  dDec1;
   zDecimal  dDec2;
   zDecimal  dDec3;

   dDec1 = 1.23456;
   dDec2 = (zLONG) 2;

   TraceLineS( "(DGC) ========= s1 = ", (zPCHAR) dDec1 );
   TraceLineS( "(DGC) ========= s2 = ", (zPCHAR) dDec2 );

   dDec3 = dDec1 + dDec2;

   TraceLineS( "(DGC) ========= s1 = ", (zPCHAR) dDec1 );
   TraceLineS( "(DGC) ========= s2 = ", (zPCHAR) dDec2 );
   TraceLineS( "(DGC) ========= s3 = ", (zPCHAR) dDec3 );
#endif

// HICON hIcon = 0;
// hIcon = LoadIcon( hInstance, "ACCOUNT" );
   nRC = GetDlgWndCtrlNames( vSubtask, szDlgName, szWndName, szCtrlName );

   TraceLineS( "GetNames Dlg ", szDlgName );
   TraceLineS( "         Wnd ", szWndName );
   TraceLineS( "        Ctrl ", szCtrlName );

// hInstance = GetApplicationInstance( vSubtask );
// for ( k = 0; k < 10000; k++ )
// {
//    nRC = ActivateOI_FromFile( &vAccount, "ACCOUNT", vSubtask,
//                               "CARLSON.POR", 0 );
//    DropView( vAccount );
// }

#if 0
   nRC = ActivateOI_FromFile( &vAccount, "TZWDLGSO", vSubtask,
                              "d:\\10b\\a\\bin\\sys\\tzpntrad.pwd", zSINGLE );
   nRC = SetNameForView( vAccount, "PainterD", 0, zLEVEL_TASK );
   nRC = ActivateOI_FromFile( &vAccount, "TZWDLGSO", vSubtask,
                              "l:\\10b\\a\\bin\\sys\\tzpntrad.pwd", zSINGLE );
   nRC = SetNameForView( vAccount, "PainterL", 0, zLEVEL_TASK );

// nRC = ActivateOI_FromFile( &vAccount, "TZPESRCO", vSubtask,
//                            "d:\\10a\\a\\bin\\sys\\zeidon.ppe", zSINGLE );
// nRC = SetNameForView( vAccount, "a_zeidon_ppe", 0, zLEVEL_TASK );
// nRC = ActivateOI_FromFile( &vAccount, "TZPESRCO", vSubtask,
//                            "d:\\10a\\w\\bin\\sys\\zeidon.ppe", zSINGLE );
// nRC = SetNameForView( vAccount, "w_zeidon_ppe", 0, zLEVEL_TASK );
#endif

   nRC = ActivateOI_FromFile( &vAccount, "ACCOUNT", vSubtask,
                              "CARLSON.PSV", zMULTIPLE );
   nRC = SetNameForView( vAccount, "ACCOUNTLST", 0, zLEVEL_TASK );
   nRC = ActivateOI_FromFile( &vAccount, "ACCOUNT", vSubtask,
                              "CARLSON.POR", zMULTIPLE );
   nRC = SetNameForView( vAccount, "ACCOUNT", 0, zLEVEL_TASK );

   GetActualAttributeLength( &ulLth, vAccount, "CUSTOMER", "LastName" );
   TraceLineI( "GetActualAttributeLength for ACCOUNT Customer Name ", ulLth );

   GetViewByName( &vAccount, zDBHANDLER_WORK_VIEW_NAME, 0, zLEVEL_SYSTEM );
   TraceLineI( "KZDBHWOB view from account ", (long) vAccount );

   nRC = ActivateEmptyObjectInstance( &vTZPEAXWO, "TZPEAXWO",
                                      vSubtask, zSINGLE );
   nRC = SetNameForView( vTZPEAXWO, "TZPEAXWO", 0, zLEVEL_TASK );
// ulLth = BuildTZPEAXWO( vTZPEAXWO, 0, FALSE );
// TraceLineI( "TZPEAXWO built for Account ... entity cnt: ", ulLth );

#if 0 // def __OS2__
   zSHORT    k;
   for ( k = 0; k < 100; k++ )
   {
      hMem[ k ] = SysAllocMemory( &pchBuffer, (k + 1) * 205,
                                  0, zCOREMEM_ALLOC, 0 );
      if ( (k % 3) == 0 )
      {
         SysFreeMemory( hMem[ k ] );
      }
   }

   TraceLineI( "Application memory allocated = ", SysCheckTaskMemory( ) );

   for ( k = 0; k < 80; k += 2 )
      SysFreeMemory( hMem[ k ] );

   for ( k = 99; k > 20; k -= 2 )
      SysFreeMemory( hMem[ k ] );

   TraceLineI( "Application memory deallocated = ", SysCheckTaskMemory( ) );
#endif

// DisplayObjectInstance( vAccount, "" );

// SetWindowActionBehavior( vSubtask, zWAB_ReplaceWindowWithModelessWindow,
//                          "account", "SubWnd" );
   return( 0 );
}

// this is the first opportunity to get the frame window (it has been
// realized at this point).
zOPER_EXPORT zSHORT OPERATION
SetListColors( zVIEW  vSubtask )
{
   LB_SetColorAttributeName( vSubtask, "ListAccount2", "Balance" );
// LB_SetColorAssociation( vSubtask, "ListAccount2",
//                         0, zRGB_RED, -1, 0, "" );
// LB_SetColorAssociation( vSubtask, "ListAccount2",
//                         0, zRGB_RED, -1, 0, "0" );
   LB_SetColorAssociation( vSubtask, "ListAccount2",
                           1, zRGB_GREEN, -1, 1, "0.00" );
   LB_SetColorAssociation( vSubtask, "ListAccount2",
                           2, zRGB_BLUE, -1, 8, "0.00" );
// LB_SetColorAssociation( vSubtask, "ListAccount2",
//                         0, -1, -1, 1, "0.00" );
   return( 0 );
}

// this is the first opportunity to get the frame window (it has been
// realized at this point).
zOPER_EXPORT zSHORT OPERATION
Setup( zVIEW  vSubtask )
{
   TraceLineS( "Account Setup", "" );
   SetCtrlState( vSubtask, "FirstName",
                    zCONTROL_STATUS_TEXT_COLOR, zRGB( 0, 255, 0 ) );
#if 0
   // become a CodeWright editor

   CWDLLExtraBytes( 0 );
   CWDLLSetArgv( __argv );
   CWDLLSetArgc( __argc );
   CWDLLSetStartDLLName( CWDLL_STARTUP_DLL_NAME );

   /* CW uses the SYSTEM_FONT by default when VARIANT_STANDARD_MDI is
    * specified so this is not necessary.
    */
   CWDLLSetMsgFont( (HFONT)GetStockObject( SYSTEM_FONT ));

   LibSetEnvName( "CWLIB" );

   SysSetMapName(  "CWINI",       "MPINI"       );
   SysSetMapName(  "CWPST",       "MPPST"       );
   SysSetMapName(  "CWEXT",       "MPEXT"       );
   SysSetMapName(  "CWMENU",      "MPMENU"      );

   SysSetMapName( "version",  "V1.00.1" );

   SysSetMapName( "cwstart",      "mpstart" );
   SysSetMapName( "cwdialog",     "mpdialog" );
   SysSetMapName( "cwhelper",     "mphelper" );
   SysSetMapName( "cwmatch",      "mpmatch" );
   SysSetMapName( "cwdiff",       "mpdiff" );
   SysSetMapName( "cwhelp",       "mphelp" );
   SysSetMapName( "cwldraw",      "mpldraw" );
   SysSetMapName( "cwspell",      "mpspell" );

   SysSetMapName( "cua.dll",      "mpcua.dll" );
   SysSetMapName( "brief.dll",    "mpbrief.dll" );
   SysSetMapName( "vi.dll",       "mpvi.dll" );
   SysSetMapName( "epsilon.dll",  "mpepsilon.dll" );

   SysSetMapName( "cua",          "cua" );
   SysSetMapName( "brief",        "brief" );
   SysSetMapName( "vi",           "vi" );
   SysSetMapName( "epsilon",      "epsilon" );

   SysSetMapName( "cwhelp.hlp",   "mphelp.hlp" );
   SysSetMapName( "cwright.ini",  "mp.ini" );
   SysSetMapName( "cwright.idx",  "mp.idx" );
   SysSetMapName( "cwright.pst",  "mp.pst" );
   SysSetMapName( "cwright.ext",  "mp.ext" );
   SysSetMapName( "cwright.mnu",  "mp.mnu" );

   SysSetVariant( SysQVariant()
      | VARIANT_CHILD
      | VARIANT_CWVC
      | VARIANT_SUBCLASS
      | VARIANT_STANDARD_MDI
      | VARIANT_HOOKKEYS
      | VARIANT_SINGLE_MSG_HWND );

   SysSetFlags( SysQFlags()
         | SYSFLAG_CMND_LINE_PROMPT
         | SYSFLAG_NEW_WIN_FOR_BUF
         | SYSFLAG_ONE_BUF_PER_WIN
         | SYSFLAG_WINDOWS_KEYSPEED );

   /* If this is the first instance of the app. register window classes */
   InitializeApplication( );

   /* Since VARIANT_SINGLE_MSG_LINE was specified, these are unused
    * but listed for completeness.
    */
   // CWDLLSetLineHWnd( hwndMsgLine );
   // CWDLLSetColumnHWnd( hwndMsgLine );
   // CWDLLSetROHWnd( hwndMsgLine );
   // CWDLLSetOVRHWnd( hwndMsgLine );


   GetWindowHandle( (zPULONG) &hwndFrame, 0, vSubtask, 0 );
   if ( IsWindow( hwndFrame ) == FALSE )
   {
      TraceLineI( "Invalid hwndFrame ", (long) hwndFrame );
   }
   else
   {
      TraceLineI( "Valid hwndFrame ", (long) hwndFrame );
   }

   CWDLLSetFrame( hwndFrame );

   hwndMDIClient = GetMDI_Client( vSubtask );
   if ( IsWindow( hwndMDIClient ) == FALSE )
   {
      TraceLineI( "Invalid hwndMDIClient ", (long) hwndMDIClient );
   }

   CWDLLSetMDIClient( hwndMDIClient );

   hwndMsgLine = CreateWindow( szMsgLine,
              "",
              WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE,
              0,
              0,
              0,
              0,
              hwndFrame,
              NULL,
              hInstance,
              NULL);

   TraceLineI( "MsgLine hWnd = ", hwndMsgLine );
   CWDLLSetMsgHWnd( hwndMsgLine );


   CWDLLEntry( TRUE );

   bIsCWInitialized = TRUE;
   CWDLLRedrawDlgWindow();

   CWDLLEntry( FALSE );
#endif

   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
Cleanup( zVIEW  vSubtask )
{
#if 0
   CWDLLCleanup();
#endif

   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
ResetText( zVIEW   vSubtask )
{
   zSHORT    nRC;
   zCHAR     szCtrlTag[ 34 ];

   GetCtrlWithFocus( vSubtask, szCtrlTag );
   TraceLineS( "Ctrl with focus ", szCtrlTag );

   nRC = SetCtrlText( vSubtask, "LastName", "ResetText" );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
EditChange( zVIEW   vSubtask )
{
   TraceLineS( "EditChange", "" );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
Refresh( zVIEW   vSubtask )
{
   char szDlgTag[ 34 ];
   char szWndTag[ 34 ];
   char szOperation[ 34 ];
// zULONG ulWnd;
// zULONG ulCtrl;

   static int k = 0;

// MessageBox( 0, "Refresh", "Check GetWindowHandle", MB_OK );
// GetWindowHandle( &ulWnd, &ulCtrl, vSubtask, "FirstName" );

   k++;

   if ( k == 1 )
   {
      SetWindowActionBehavior( vSubtask, zWAB_StartSplitWindow, 0, 0 );
   }

   if ( k <= 2 )
      SetCtrlState( vSubtask, "FirstName",
                    zCONTROL_STATUS_ENABLED, FALSE );

   GetCurrentState( vSubtask, szDlgTag, szWndTag, szOperation );
   TraceLineS( "Refresh Dialog: ", szDlgTag );
   TraceLineS( "Refresh Window: ", szWndTag );
   TraceLineS( "Refresh Operation: ", szOperation );

   SS_LockColumn( vSubtask, "Name", 2, TRUE );
   TraceLineS( "Locking Column 2 in ctrl Name", "" );
   if ( k % 5 < 3 )
   {
      SetCtrlRowColText( vSubtask, "ListAccount2", 0, 1, "HopeOne" );
      SetCtrlState( vSubtask, "FirstName",
                    zCONTROL_STATUS_DISABLE_READONLY, TRUE );
//    MessageBox( 0, "Account Stop", "Check Enabled", MB_OK );
      if ( k % 2 )
         SetCtrlState( vSubtask, "FirstName",
                       zCONTROL_STATUS_ENABLED, FALSE );
      else
         SetCtrlState( vSubtask, "FirstName",
                       zCONTROL_STATUS_ENABLED, TRUE );
   }
   else
   {
      SetCtrlRowColText( vSubtask, "ListAccount2", 0, 1, "HopeTwo" );
      if ( k % 2 )
         SetCtrlState( vSubtask, "FirstName",
                       zCONTROL_STATUS_ENABLED, FALSE );
      else
         SetCtrlState( vSubtask, "FirstName",
                       zCONTROL_STATUS_ENABLED, TRUE );

      SetCtrlState( vSubtask, "FirstName",
                    zCONTROL_STATUS_DISABLE_READONLY, FALSE );
   }

   if ( k == 1 )
   {
      SetCtrlState( vSubtask, "States", zCONTROL_STATUS_ENABLED, FALSE );
      EnableAction( vSubtask, "TabWnd", TRUE );
      EnableAction( vSubtask, "TabWnd", FALSE );
      MB_SetMessage( vSubtask, 1, "Refresh Enable/Disable TabWnd" );
      TraceLineS( "Refresh Enable/Disable TabWnd", "" );
//    SetCtrlState( vSubtask, "TabWnd", zCONTROL_STATUS_ENABLED, FALSE );
   }
   else
   if ( k == 2 )
   {
      SetCtrlState( vSubtask, "States", zCONTROL_STATUS_ENABLED, TRUE );
      EnableAction( vSubtask, "TabWnd", TRUE );
      MB_SetMessage( vSubtask, 1, "Refresh Enable TabWnd" );
      TraceLineS( "Refresh Enable TabWnd", "" );
//    SetCtrlState( vSubtask, "TabWnd", zCONTROL_STATUS_ENABLED, TRUE );
   }
   else
   if ( k % 2 )
   {
      SetCtrlState( vSubtask, "States", zCONTROL_STATUS_ENABLED, k % 2 );
      EnableAction( vSubtask, "TabWnd", FALSE );
      MB_SetMessage( vSubtask, 1, "Refresh Disable TabWnd" );
      TraceLineS( "Refresh Disable TabWnd", "" );
   }
   else
   {
      SetCtrlState( vSubtask, "States", zCONTROL_STATUS_ENABLED, k % 2 );
      EnableAction( vSubtask, "TabWnd", TRUE );
      MB_SetMessage( vSubtask, 1, "Refresh Re-Enable TabWnd" );
      TraceLineS( "Refresh Re-Enable TabWnd", "" );
   }

   SetCtrlState( vSubtask, "NewText", zCONTROL_STATUS_VISIBLE, k % 2 );
   return( 0 );

#if 0

#ifdef __OS2__
   zVIEW  vAccount;
   zSHORT nRC;
   char   szBuffer[ 128 ];

   OperatorPrompt( vSubtask, "Title is Title", "Message is Message",
                   zBUTTONS_OK, zRESPONSE_OK, TRUE, zICON_QUESTION );
   szBuffer[ 0 ] = 0;
   OperatorPromptForInput( vSubtask, "Title is Title", "Message is Message",
                           TRUE, szBuffer, sizeof( szBuffer ) );
   SetWindowActionBehavior( vSubtask, zWAB_StayOnWindowWithRefresh, 0, 0 );

   return( 0 );

   nRC = GetViewByName( &vAccount, "ACCOUNT", 0, zLEVEL_TASK );
   if ( nRC <= 0 )
   {
      nRC = ActivateOI_FromFile( &vAccount, "ACCOUNT", vSubtask,
                                 "CARLSON.POR", 0 );
      nRC = SetNameForView( vAccount, "ACCOUNT", 0, zLEVEL_TASK );
      TraceLineX( "Activate ACCOUNT view ", (long) vAccount );
      SetWindowActionBehavior( vSubtask, zWAB_StayOnWindowWithRefresh, 0, 0 );
   }
   else
   {
      TraceLineX( "Dropping ACCOUNT view ", (long) vAccount );
      nRC = CommitOI_ToFile( vAccount, "CARLSON.POR", 0 );
      DropView( vAccount );
      SetWindowActionBehavior( vSubtask, zWAB_StayOnWindow, 0, 0 );
   }
#else
   AbortTask( "Account aborting" );
#endif

#if 0
   ResetText( vSubtask );
   SetWindowState( vSubtask, zWINDOW_STATUS_ASYNC, TRUE );
// MessageBox( 0, "SetWindowState", "ASYNC ON", MB_OK );

#ifndef __OS2__
   while ( IsKeyQueued( vSubtask, VK_ESCAPE, TRUE ) == FALSE ) // VK_ESCAPE  0x1B
   {
   }
#endif

// MessageBox( 0, "SetWindowState", "ASYNC OFF", MB_OK );
   SetWindowState( vSubtask, zWINDOW_STATUS_ASYNC, FALSE );
#endif
   return( 0 );
#endif
}

zOPER_EXPORT zSHORT OPERATION
GetCurrentActiveTab( zVIEW   vSubtask )
{
// TraceLineI( "GetActiveTab ", TAB_GetActiveTab( vSubtask, "TagTab" ) );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
EditLoseFocus( zVIEW   vSubtask )
{
   char szBalance[ 32 ];
   static zSHORT k = 0;
   zVIEW vAccount;
   zDecimal dBalance;

   GetViewByName( &vAccount, "ACCOUNT", 0, zLEVEL_TASK );
   GetStringFromAttribute( szBalance, vAccount, "ACCOUNT", "Balance" );
   GetDecimalFromAttribute( &dBalance, vAccount, "ACCOUNT", "Balance" );
   TraceLineS( "Decimal value ############################### ", szBalance );
   szBalance[ 0 ] = '0' + (k % 10);
   SetCtrlText( vSubtask, "Decimal", szBalance );
   dBalance = k;
   //SysConvertLongToDecimal( (zLONG) k, &dBalance );
   SetAttributeFromDecimal( vAccount, "ACCOUNT", "Balance", dBalance );

   k++;
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
Hotkey( zVIEW   vSubtask )
{
   char szReturnCtrlTag[ 33 ];

// SysMessageBox( "Hotkey", "?", TRUE );
   GetCtrlWithFocus( vSubtask, szReturnCtrlTag );
   TraceLineS( "Hotkey Ctrl with Focus ======> ", szReturnCtrlTag );
   SetCtrlState( vSubtask, "FirstName",
                    zCONTROL_STATUS_TEXT_COLOR, zRGB_CYAN );
//                  zCONTROL_STATUS_TEXT_COLOR, zRGB_YELLOW );
   SetCtrlState( vSubtask, "LastName",
                    zCONTROL_STATUS_TEXT_COLOR, zRGB_RED );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F1( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "F1" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "F1" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F2( zVIEW   vSubtask )
{
#ifdef __OS2__
   zSHORT  k;

   TraceLineS( "Hotkey Operation ", "F2" );
   for ( k = 0; k < 20; k++ )
   {
      SysWait( 500 );
   }
#else
   zSHORT  k;

   TraceLineS( "Hotkey Operation ", "F2" );
   SysMessageBox( "Mouse", "F2 Capture", TRUE );
   for ( k = 0; k < 200; k++ )
   {
      TraceLineS( "Hotkey PumpMessages", "" );
      PumpMessages( vSubtask );

      SysWait( 50 );
   }
#endif

   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "F2" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   SysMessageBox( "Mouse", "F2 Release", TRUE );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F3( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "F3" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "F3" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F4( zVIEW   vSubtask )
{
   zVIEW vEmd;

   TraceLineS( "Hotkey Operation ", "F4" );
   vEmd = FindDialogWindow( 0, "Menu", "Menu" );
   if ( vEmd )
   {
      SetWindowState( vEmd, zWINDOW_STATUS_RESTORE, TRUE );
//    SetWindowState( vEmd, zWINDOW_STATUS_DESTROY, TRUE );
      SetWindowActionBehavior( vEmd, zWAB_ReturnToParent |
                                     zWAB_ProcessImmediateAction,
                               0, 0 );
   }

   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "F4" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F5( zVIEW   vSubtask )
{
   static short k = 0;

   k++;
   LB_SortByColumn( vSubtask, "ListAccount2", 1, k % 4 - 1 );
   TraceLineS( "Hotkey Operation ", "F5" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "F5" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F6( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "F6" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "F6" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F7( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "F7" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "F7" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F8( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "F8" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "F8" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F9( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "F9" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "F9" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F10( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "F10" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "F10" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F11( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "F11" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "F11" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
F12( zVIEW   vSubtask )
{
   char  szFirstName[ 34 ];
   zVIEW vAccount;

   TraceLineS( "Hotkey Operation ", "F12" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   GetCtrlText( vSubtask, "FirstName", szFirstName, sizeof( szFirstName ) );
   TraceLineS( "FirstName contents ", szFirstName );

   GetViewByName( &vAccount, "ACCOUNT", 0, zLEVEL_TASK );
   GetStringFromAttribute( szFirstName, vAccount, "CUSTOMER", "FirstName" );
   TraceLineS( "FirstName attribute ", szFirstName );

   SetCtrlText( vSubtask, "FirstName", "F12" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
Add( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "Add" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "Add" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
Subtract( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "Subtract" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "Subtract" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
Multiply( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "Multiply" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "Multiply" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
Divide( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "Divide" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "Divide" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
Enter( zVIEW   vSubtask )
{
   TraceLineS( "Hotkey Operation ", "Enter" );
   SetFocusToCtrl( vSubtask, "FirstName" );
   SetCtrlText( vSubtask, "FirstName", "Enter" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
New( zVIEW   vSubtask )
{
   TraceLineS( "Get/Lose focus", "" );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
SetTab( zVIEW   vSubtask )
{
   char szTag[ 3 ];
   short k;

   szTag[ 0 ] = 'S';
   szTag[ 2 ] = 0;
   for ( k = 1; k <= 5; k++ )
   {
      szTag[ 1 ] = '0' + (char) k;
      if ( GetCtrlState( vSubtask, szTag, zCONTROL_STATUS_CHECKED ) )
      {
         TAB_SetActiveTab( vSubtask, "TagTab", k );
         break;
      }
   }

   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
HideTab( zVIEW   vSubtask )
{
   char szTag[ 3 ];
   short k;

   szTag[ 0 ] = 'H';
   szTag[ 2 ] = 0;
   for ( k = 1; k <= 5; k++ )
   {
      szTag[ 1 ] = '0' + (char) k;
      if ( GetCtrlState( vSubtask, szTag, zCONTROL_STATUS_CHECKED ) )
      {
         TAB_HideTab( vSubtask, "TagTab", k, TRUE );
      }
      else
      {
         TAB_HideTab( vSubtask, "TagTab", k, FALSE );
      }
   }

   return( 0 );
}

#if 0    // code to save all PWD's using OK button on Workstation
   char   szBuffer[ 256 ];
   zVIEW  vDialog;
   zVIEW  vLPLR;
   zSHORT nRC;

   zVIEW  vTZPESRCO;
   zBOOL  bPE_Activated = FALSE;

   // Activate the presentation environment
   if ( GetViewByName( &vTZPESRCO, "TZPESRCO", 0, zLEVEL_TASK ) < 1 )
   {
      zVIEW vMetaList;

      bPE_Activated = TRUE;
      RetrieveViewForMetaList( &vMetaList, zREFER_PENV_META );
      if ( SetCursorFirstEntity( vMetaList, "W_MetaDef", "" ) < zCURSOR_SET )
      {
         MessageSend( vSubtask, "PN00201", "Dialog",
                      "Presentation Environment does not exist!\n"
                      "Painter exiting.",
                      zMSGQ_OBJECT_CONSTRAINT_ERROR, zBEEP );
         SetWindowActionBehavior( vSubtask, zWAB_ReturnToParent, 0, 0 );
         return( -16 );
      }
      else
      {
         ActivateMetaOI( &vTZPESRCO, vMetaList, zREFER_PENV_META, zSINGLE );
         SetNameForView( vTZPESRCO, "TZPESRCO", 0, zLEVEL_TASK );
         DropView( vMetaList );
      }
   }

   zstrcpy( szBuffer, "Converting Dialog:  " );
   RetrieveViewForMetaList( &vLPLR, zSOURCE_DIALOG_META );
   nRC = SetCursorFirstEntity( vLPLR, "W_MetaDef", "" );
   while ( nRC >= zCURSOR_SET )
   {
      ActivateMetaOI( &vDialog, vLPLR, zSOURCE_DIALOG_META, zSINGLE );
      SetCursorFirstEntity( vDialog, "Window", "" );
      GetStringFromAttribute( szBuffer + 19, vDialog, "Dialog", "Tag" );
      MB_SetMessage( vSubtask, 1, szBuffer );
      CommitMetaOI( vDialog, zSOURCE_DIALOG_META );
      DropView( vDialog );
      nRC = SetCursorNextEntity( vLPLR, "W_MetaDef", "" );
   }

   if ( bPE_Activated )
      DropView( vTZPESRCO );

   SetWindowActionBehavior( vSubtask, zWAB_StayOnWindow, 0, 0 );
   return( 0 );
#endif

zOPER_EXPORT zSHORT OPERATION
RefreshAX_Events( zVIEW  vSubtask )
{
   RefreshCtrl( vSubtask, "Events" );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
Test( zVIEW  vSubtask )
{
   MapCtrl( vSubtask, "Calendar1" );
   RefreshCtrl( vSubtask, "Text1" );

// SetCtrlText( vSubtask, "Test1", "Test&One" );
// SetCtrlText( vSubtask, "Test2", "Test&Two" );
   TraceLineS( "Called Test operation", "" );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
TabPrebuild( zVIEW  vSubtask )
{
   static  nState = 0;

#if 0
   nState %= 3;

   if ( nState == 0 )
   {
      SetWindowActionBehavior( vSubtask, zWAB_ReplaceWindowWithModalWindow |
                                             zWAB_ProcessImmediateAction,
                               "ACCOUNT", "Subwnd" );
   }
   else
   if ( nState == 1 )
   {
      SetWindowActionBehavior( vSubtask, zWAB_ReplaceWindowWithModalWindow |
                                             zWAB_ProcessImmediateAction,
                               "ACCOUNT", "Bitmap" );
   }
   else
   if ( nState == 2 )
#endif
   {
      SetWindowActionBehavior( vSubtask, zWAB_StayOnWindow, 0, 0 );
   }

   nState++;

   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
TabPostbuild( zVIEW  vSubtask )
{
   SetCtrlState( vSubtask, "City", zCONTROL_STATUS_ENABLED, FALSE );
// SetCtrlState( vSubtask, "TabRadio", zCONTROL_STATUS_ENABLED, FALSE );
   SetCtrlState( vSubtask, "One", zCONTROL_STATUS_TEXT_COLOR,
                 RGB( 0, 255, 0 ) );
   SetCtrlState( vSubtask, "Three", zCONTROL_STATUS_TEXT_COLOR,
                 RGB( 0, 255, 0 ) );
   SetCtrlState( vSubtask, "Center", zCONTROL_STATUS_TEXT_COLOR,
                 RGB( 0, 255, 0 ) );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
SubwndPrebuild( zVIEW  vSubtask )
{
   static  nState = 0;

#if 0
   nState %= 2;

   if ( nState == 0 )
   {
      SetWindowActionBehavior( vSubtask, zWAB_ReplaceWindowWithModalWindow |
                                             zWAB_ProcessImmediateAction,
                               "ACCOUNT", "Tabwnd" );
   }
   else
   if ( nState == 1 )
#endif
   {
      SetWindowActionBehavior( vSubtask, zWAB_StayOnWindow, 0, 0 );
   }

   nState++;

   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
NewDraft( zVIEW  vSubtask )
{
   zVIEW     vAccount;
   zSHORT    nRC;

   nRC = GetViewByName( &vAccount, "ACCOUNT", 0, zLEVEL_TASK );
   CreateEntity( vAccount, "DRAFTS", zPOS_AFTER );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
SaveInstance( zVIEW  vSubtask )
{
   char      szTag[ 34 ];
   zVIEW     vAccount;
   zSHORT    RESULT;
   zSHORT    nRC;

   GetLastCommandTag( vSubtask, szTag );
   TraceLineS( "LastCommandTag ", szTag );
   RESULT = GetViewByName( &vAccount, "ACCOUNT", 0, zLEVEL_TASK );
   nRC = CommitOI_ToFile( vAccount, "CARLSON.POR", 0 );
   return( 0 );
}


zOPER_EXPORT zSHORT OPERATION
DeleteObjectEntity( zVIEW  vSubtask )
{
   zVIEW     vAccount;
   zSHORT    RESULT;
   zSHORT    nRC;

   RESULT = GetViewByName( &vAccount, "ACCOUNT", 0, zLEVEL_TASK );
   nRC = DeleteEntity( vAccount, "CUSTOMER", zPOS_NEXT );
   return( 0 );
}


zOPER_EXPORT zSHORT OPERATION
DeleteInstance( zVIEW  vSubtask )
{
   zVIEW     vAccount;
   zCHAR     szT[ 25 ];
   zSHORT    RESULT;

   RESULT = GetViewByName( &vAccount, "ACCOUNT", 0, zLEVEL_TASK );
   ZeidonStringCopy( szT, 1, 0, "Test \n ", 1, 0, 24 );
   return( 0 );
}


zOPER_EXPORT zSHORT OPERATION
Prompt( zVIEW   vSubtask )
{
   zVIEW v;


   SfCreateSubtask( &vSubtask, 0, "EMD_Opt1" );
   if ( ActivateObjectInstance( &v, "mCustO", vSubtask, 0,
                                zACTIVATE_ROOTONLY_MULTIPLE ) < 0 )
   {
   }

   SysMessageBox( "DGC", "Got it", 0 );

   return 0;
#if 0

   MSG     msg;
   zSHORT  k;

   for ( k = 0; k < 10; k++ )
   {
      while ( PeekMessage( &msg, 0, 0, 0, PM_REMOVE ) )
      {
         TranslateMessage( &msg );
         DispatchMessage( &msg );
      }

      SysWait( 200 );
   }

#else

   zVIEW   vBitmapSubtask;

// ED_HiliteText( vSubtask, "Prompt", 1, 12 );
   SetWindowActionBehavior( vSubtask, zWAB_StartModalSubwindow |
                                          zWAB_ProcessImmediateAction,
                            "ACCOUNT", "Bitmap" );
   if ( GetSubtaskForWindowName( vSubtask, &vBitmapSubtask, "Bitmap" ) == 0 )
   {
      TraceLineS( "ACCOUNT Bitmap subtask found", "" );
      SetWindowState( vBitmapSubtask, zWINDOW_STATUS_UPDATE, 0 );
      SysWait( 3000 );     // three seconds

      SetWindowActionBehavior( vBitmapSubtask,
                               zWAB_ReturnToParent |
                                           zWAB_ProcessImmediateAction |
                                           zWAB_ProcessImmediateReturn,
                               "ACCOUNT", "Bitmap" );
   }
   else
   {
      TraceLineS( "ACCOUNT Bitmap subtask NOT found", "" );
   }

#endif

   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
SwitchBitmap( zVIEW   vSubtask )
{
#if 1

   ReplacePrimaryMenu( vSubtask, "Alternate" );
   AddOptionToMenu( vSubtask, "File", "Cancel",
                    "Popup", "Popup", "", 512 + 48 );
   AddOptionToMenu( vSubtask, "Popup", "",
                    "NewCan", "NewCan", "Cancel", 2 );
   AddOptionToMenu( vSubtask, "Popup", "",
                    "NewOK", "NewOK", "OK", 4 );
   RemoveOptionFromMenu( vSubtask, "NewCan" );
   AddOptionToMenu( vSubtask, "Popup", "NewOK",
                    "NewCan", "NewCan", "Cancel", 1 );
   return( 0 );

#else
#if 0
   static int k = 0;

   SetCtrlState( vSubtask, "LastNameGroup", zCONTROL_STATUS_ENABLED,
                    k++ % 2 ? TRUE : FALSE );
   SetFocusToCtrl( vSubtask, "FirstName" );
// ED_HiliteText( vSubtask, "FirstName", 1, 0 );
   MiListOE_Memory( 0 );
   return( 0 );
#else
   zLONG x;
   zLONG y;
   zLONG cx;
   zLONG cy;

#if 0
   char  szFileName[ 128 ];
   zstrcpy( szFileName, "d:\\9h\\a\\zdr\\guenter.txt" );
   OperatorPromptForFile( vSubtask, szFileName, sizeof( szFileName ),
                          "All Files (*.*)|*.*|Text Files (*.txt)|*.txt|",
                          "txt", TRUE );
   TraceLineS( "Prompt FileName = ", szFileName );
   zstrcpy( szFileName, "d:\\9h\\w\\bin\\zdctl.dll" );
   OperatorPromptForFile( vSubtask, szFileName, sizeof( szFileName ),
                          "All Files (*.*)|*.*|DLL Files (*.dll)|*.dll|",
                          "dll", FALSE );
   TraceLineS( "SaveAs FileName = ", szFileName );
   return( 0 );
#else

   GetCtrlSize( vSubtask, "BmpBtn", &cx, &cy, TRUE );
   SetCtrlSize( vSubtask, "BmpBtn", 36, 40, TRUE );
   BMP_SetBitmapFileName( vSubtask, "SwitchBmp",
                          "d:\\9j\\a\\zdr\\preview2.bmp" );
   SetWindowState( vSubtask, zWINDOW_STATUS_UPDATE, 0 );
   SysWait( 1000 );     // one seconds

   GetCtrlPosition( vSubtask, "BmpBtn", &x, &y, TRUE );
   SetCtrlPosition( vSubtask, "BmpBtn", x + 10, y + 10, TRUE );
   SetWindowState( vSubtask, zWINDOW_STATUS_UPDATE, 0 );
   SysWait( 1000 );     // one seconds
   BMP_SetBitmapResource( vSubtask, "SwitchBmp", "account", 111 );
   SetCtrlPosition( vSubtask, "BmpBtn", x - 30, y + 30, TRUE );
   SetWindowState( vSubtask, zWINDOW_STATUS_UPDATE, 0 );
   SysWait( 1000 );     // one seconds
   BMP_SetBitmapResource( vSubtask, "SwitchBmp", "account", 112 );
   SetCtrlPosition( vSubtask, "BmpBtn", x + 50, y + 50, TRUE );
   SetWindowState( vSubtask, zWINDOW_STATUS_UPDATE, 0 );
   SysWait( 1000 );     // one seconds
   BMP_SetBitmapResource( vSubtask, "SwitchBmp", "account", 113 );
   SetCtrlPosition( vSubtask, "BmpBtn", x - 70, y + 70, TRUE );
   SetWindowState( vSubtask, zWINDOW_STATUS_UPDATE, 0 );
   SysWait( 1000 );     // one seconds
   BMP_SetBitmapFileName( vSubtask, "SwitchBmp",
                          "d:\\9j\\a\\zdr\\preview1.bmp" );
   SetWindowState( vSubtask, zWINDOW_STATUS_UPDATE, 0 );
   SysWait( 1000 );     // one seconds
   SetCtrlPosition( vSubtask, "BmpBtn", x, y, TRUE );
   SetCtrlSize( vSubtask, "BmpBtn", cx, cy, TRUE );
   return( 0 );
#endif
#endif
#endif
}

zOPER_EXPORT zSHORT OPERATION
Hilite123( zVIEW   vSubtask )
{
   static zSHORT k = 0;
   k++;
   HiliteListBoxItem( vSubtask, "ListAccount2", TRUE, k % 3 );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
DeleteTransaction( zVIEW   vSubtask )
{
   zVIEW vAccount;

   GetViewByName( &vAccount, "ACCOUNT", 0, zLEVEL_TASK );
   DeleteEntity( vAccount, "ACCOUNT", zREPOS_NEXT );
// DeleteEntity( vAccount, "TRANSACTION", zREPOS_NEXT );
   RefreshCtrl( vSubtask, "ListAccount" );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
AddTransaction( zVIEW   vSubtask )
{
   zVIEW vAccount;

   GetViewByName( &vAccount, "ACCOUNT", 0, zLEVEL_TASK );
   CreateEntity( vAccount, "ACCOUNT", zREPOS_NEXT );
   SetAttributeFromString( vAccount, "ACCOUNT", "Type", "Check" );
   SetAttributeFromString( vAccount, "ACCOUNT", "Number", "1111111" );
   SetAttributeFromString( vAccount, "ACCOUNT", "Balance", "7.77" );
   SetAttributeFromString( vAccount, "ACCOUNT", "CustomerIdNbr", "747" );

// DeleteEntity( vAccount, "TRANSACTION", zREPOS_NEXT );
   RefreshCtrl( vSubtask, "ListAccount" );
   RefreshCtrl( vSubtask, "ListAccount2" );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
CellSelect( zVIEW   vSubtask )
{
   zVIEW vAccount;

   GetViewByName( &vAccount, "ACCOUNT", 0, zLEVEL_TASK );
   SetCursorLastEntity( vAccount, "TRANSACTION", "ACCOUNT" );
// SetCursorLastEntity( vAccount, "TRANSACTION", "CUSTOMER" );
   RefreshCtrl( vSubtask, "ListAccount" );
   return( 0 );
}

#if 0
zOPER_EXPORT zSHORT OPERATION
FileNew( zVIEW  vSubtask )
{
   HWND hWnd = 0;
   HWND hWndParent = CreateMDI_Child( vSubtask, "account.c" );
   HWINDOW hWindow = WinCreateChild( hWndParent );
   HBUFFER hBuffer = BufCreate( NIL, "d:\\9b\\a\\tz\\account.c", FALSE );
   if ( IsWindow( hWndParent ) == FALSE )
   {
      TraceLineI( "Invalid hWndParent ", (long) hWndParent );
   }
   else
   if ( IsWindow( hWndParent ) == FALSE )
   {
      TraceLineI( "Valid hWndParent ", (long) hWndParent );
   }

   hWnd = GetHWND_FromCW_Window( hWindow );
   if ( IsWindow( hWnd ) )
   {
      TraceLineI( "Account CW Child HWND = ", (long) hWnd );
   }
   else
   {
      char szBuffer[ 32 ];
      long lWnd;

      szBuffer[ 0 ] = 0;

      TraceLineI( "Account CW Child Invalid HWND = ", (long) hWnd );
      OperatorPromptForInput( vSubtask, "GetValid CW Child hWnd",
                              "hWnd:", FALSE, szBuffer, sizeof( szBuffer ) );
      lWnd = atol( szBuffer );
      hWnd = (HWND) lWnd;
      TraceLineI( "Account CW Child new HWND = ", (long) lWnd );
      TraceLineI( "Account CW Child new HWND = ", (long) hWnd );
   }

   if ( hWnd )
   {
      SetWindowPos( hWnd, HWND_TOP, 0, 0, 0, 0,
                    SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW );
   }

   WinAttachBuf( hWindow, hBuffer );
   TraceLineI( "Account MDI Child HWND = ", (long) hWndParent );
   TraceLineI( "Account hBuffer = ", (long) hBuffer );

   return( 0 );
}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CloseAllChildren ()                                        *
 *                                                                          *
 *  PURPOSE    : Destroys all MDI child windows.                            *
 *                                                                          *
 ****************************************************************************/
VOID PASCAL
CloseAllChildren ( void )
{
   HWND hwndT;

   /* hide the MDI client window to avoid multiple repaints */
   ShowWindow( hwndMDIClient, SW_HIDE );

   /* As long as the MDI client has a child, destroy it */
   while ( hwndT = GetWindow (hwndMDIClient, GW_CHILD))
   {
      /* Skip the icon title windows */
      while (hwndT && GetWindow (hwndT, GW_OWNER))
         hwndT = GetWindow (hwndT, GW_HWNDNEXT);

      if (!hwndT)
         break;

      SendMessage (hwndMDIClient, WM_MDIDESTROY, (WORD)hwndT, 0L);
   }
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CommandHandler ()                                          *
 *                                                                          *
 *  PURPOSE    : Processes all "frame" WM_COMMAND messages.                 *
 *                                                                          *
 ****************************************************************************/
VOID PASCAL
CommandHandler ( HWND hwnd, WPARAM wParam )
{
   switch (wParam)
   {
   case IDM_FILENEW:
      /* Add a new, empty MDI child */
      // AddFile (NULL);
      MessageBox( 0, "AddFile", "CommandHandler", MB_OK );
      break;

   case IDM_FILEOPEN:
      LibFunctionExec( "DlgOpenFile" );
      break;

   case IDM_FILESAVE:
      BufWrite();
      break;

   case IDM_FILESAVEAS:
      LibFunctionExec( "DlgSaveAs" );
      break;

   case IDM_FILEPRINT:
      LibFunctionExec( "DlgPrint" );
      break;

   case IDM_FILESETUP:
      LibFunctionExec( "DlgPrintSetup" );
      break;

   case IDM_FILEMENU:  // lengthen/shorten the size of the MDI menu
      {
         HMENU hMenu;
         HMENU hWindowMenu;
         int i;

         if (lpMenu == (LPSTR)IDMULTIPAD)
         {
            lpMenu = (LPSTR)IDMULTIPAD2;
            i  = SHORTMENU;
         }
         else
         {
            lpMenu = (LPSTR)IDMULTIPAD;
            i  = WINDOWMENU;
         }

         hMenu = LoadMenu (hInstance, lpMenu);
         hWindowMenu = GetSubMenu (hMenu, i);

         /* Set the new menu */
         hMenu = (HMENU)SendMessage (hwndMDIClient,
               WM_MDISETMENU,
               0,
               MAKELONG(hMenu,hWindowMenu));

         DestroyMenu (hMenu);
         DrawMenuBar (hwndFrame);
         break;
      }

   case IDM_FILEEXIT:
      /* Close Multipad */
      SendMessage (hwnd, WM_CLOSE, 0, 0L);
      break;

   case IDM_HELPABOUT:
      {
         /* Bring up the ubiquitous Ego box */
         FARPROC lpfn;

         lpfn = MakeProcInstance((FARPROC)AboutDlgProc, hInstance);
         DialogBox (hInstance, IDD_ABOUT, hwnd, (DLGPROC)lpfn);
         FreeProcInstance (lpfn);
      }

      break;

   case IDM_SEARCHFIND:
      // Put up the CW Search dialog box
      LibFunctionExec( "srchCommand NULL IDM_SRCH_SEARCH" );
      break;

   case IDM_SEARCHNEXT:
      /* Repeat last search */
      LibFunctionExec( "srchCommand NULL IDM_SRCH_AGAIN" );
      break;

   // The following are window commands - these are handled by the
   // MDI Client.
   //
   case IDM_WINDOWTILE:
      /* Tile MDI windows */
      SendMessage (hwndMDIClient, WM_MDITILE, 0, 0L);
      break;

   case IDM_WINDOWCASCADE:
      /* Cascade MDI windows */
      SendMessage (hwndMDIClient, WM_MDICASCADE, 0, 0L);
      break;

   case IDM_WINDOWICONS:
      /* Auto - arrange MDI icons */
      SendMessage (hwndMDIClient, WM_MDIICONARRANGE, 0, 0L);
      break;

   case IDM_WINDOWCLOSEALL:
      /* Abort operation if something is not saved */
      if (!QueryCloseAllChildren())
      break;

      CloseAllChildren();

      /* Show the window since CloseAllChildren() hides the window
       * for fewer repaints.
       */
      ShowWindow( hwndMDIClient, SW_SHOW);

      break;

   default:
      /*
      * This is essential, since there are frame WM_COMMANDS generated
      * by the MDI system for activating child windows via the
      * window menu.
      */
      DefFrameProc(hwnd, hwndMDIClient, WM_COMMAND, wParam, 0L);
   }
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MPError ( hwnd, flags, id, ...)                            *
 *                                                                          *
 *  PURPOSE    : Flashes a Message Box to the user. The format string is    *
 *       taken from the STRINGTABLE.                                        *
 *                                                                          *
 *  RETURNS    : Returns value returned by MessageBox() to the caller.      *
 *                                                                          *
 ****************************************************************************/
short FAR CDECL
MPError( HWND hwnd, UINT bFlags, UINT id, ...)
{
   char sz[160];
   char szFmt[128];

   LoadString (hInstance, id, szFmt, sizeof (szFmt));
   wvsprintf (sz, szFmt, (LPSTR)(&id + 1));
   LoadString (hInstance, IDS_APPNAME, szFmt, sizeof (szFmt));
   return MessageBox (hwndFrame, sz, szFmt, bFlags);
}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   : QueryCloseAllChildren()                                    *
 *                                                                          *
 *  PURPOSE    : Asks the child windows if it is ok to close up app. Nothing*
 *       is destroyed at this point. The z-order is not changed.            *
 *                                                                          *
 *  RETURNS    : TRUE - If all children agree to the query.                 *
 *       FALSE- If any one of them disagrees.                               *
 *                                                                          *
 ****************************************************************************/
BOOL PASCAL
QueryCloseAllChildren( void )
{
   HWND hwndT;

   for ( hwndT = GetWindow (hwndMDIClient, GW_CHILD);
      hwndT;
      hwndT = GetWindow (hwndT, GW_HWNDNEXT)       )
   {
      /* Skip if an icon title window */
      if (GetWindow (hwndT, GW_OWNER))
         continue;

      if (SendMessage (hwndT, WM_QUERYENDSESSION, 0, 0L))
         return FALSE;
   }
   return TRUE;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : QueryCloseChild (hwnd)                                     *
 *                                                                          *
 *  PURPOSE    : If the child MDI is unsaved, allow the user to save, not   *
 *               save, or cancel the close operation.                       *
 *                                                                          *
 *  RETURNS    : TRUE  - if user chooses save or not save, or if the file   *
 *                       has not changed.                                   *
 *       FALSE - otherwise.                                                 *
 *                                                                          *
 ****************************************************************************/
BOOL PASCAL
QueryCloseChild( HWND hWnd )
{
   char     sz [64];
   register int i;

   HWINDOW hWindow;
   HBUFFER hBufCur = BufQCurrentBuffer();
   HBUFFER hBuffer;
   HWND    hWndEdit;
   BOOL    modified = FALSE;

   hWndEdit = (HWND)GetWindowWord (hWnd, GWW_HWNDEDIT);
   hWindow = CWDLLFindWinNode( hWndEdit );
   if (hWindow)
   {
      hBuffer = WinQAttached( hWindow );
      if (hBuffer)
      {
         BufSwitchBuffer( hBuffer );
         modified = BufQModified();
         BufSwitchBuffer( hBufCur );
         if (modified == FALSE)
            return TRUE;
      }
   }
   else
      return TRUE;

   GetWindowText (hWnd, sz, sizeof(sz));

   /* Ask user whether to save / not save / cancel */
   i = MPError (hWnd,
      MB_YESNOCANCEL|MB_ICONQUESTION,IDS_CLOSESAVE,
      (LPSTR)sz);

   switch (i)
   {
   case IDYES:
      /* User wants file saved */
      if (hBuffer)
      {
         BufSwitchBuffer( hBuffer );
         BufWrite();
         BufSwitchBuffer( hBufCur );
      }
      break;

   case IDNO:
      /* User doesn't want file saved */
      break;

   default:
      /* We couldn't do the messagebox, or not ok to close */
      return FALSE;
   }
   return TRUE;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : AboutDlgProc ( hwnd, msg, wParam, lParam )                 *
 *                                                                          *
 *  PURPOSE    : Dialog function for the About MultiPad... dialog.          *
 *                                                                          *
 ****************************************************************************/
BOOL FAR PASCAL __export
AboutDlgProc ( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
   switch (msg)
   {
   case WM_INITDIALOG:
      /* nothing to initialize */
      break;

   case WM_COMMAND:
      switch (wParam)
      {
      case IDOK:
      case IDCANCEL:
         EndDialog(hwnd, 0);
         break;

      default:
         return FALSE;
      }
      break;

   default:
      return FALSE;
   }

   return TRUE;
}


HWND
GetHWND_FromCW_Window( HWINDOW hWindow )
{
   HWINDOW hCur;
   HWND    hWnd;

   hCur = WinQCurrentWindow();

   WinSwitchWindow( hWindow );
   hWnd = WinQHCurrent();
   WinSwitchWindow( hCur );
   return( hWnd );
}
#endif

zOPER_EXPORT zSHORT OPERATION
InitMenu( zVIEW   vSubtask )
{
#if 0
   static zSHORT k = 0;

   if ( k % 10 == 0 )
   {
      zPCHAR pch = (zPCHAR)
         GetOptionState( vSubtask, "Window3", zOPTION_STATUS_TEXT );
      TraceLineS( "Window3 text: ", pch );
      SetOptionState( vSubtask, "Window3",
                      zOPTION_STATUS_TEXT, (zLONG) "HowBoutThis" );
      k = 0;
   }
   else
   if ( k % 10 == 1 )
   {
      SetOptionState( vSubtask, "Window3", zOPTION_STATUS_CHECKED, TRUE );
   }
   else
   if ( k % 10 == 2 )
   {
      SetOptionState( vSubtask, "Window3", zOPTION_STATUS_ENABLED, FALSE );
   }
   else
   if ( k % 10 == 3 )
   {
      SetOptionState( vSubtask, "Window3", zOPTION_STATUS_VISIBLE, FALSE );
   }
   else
   if ( k % 10 == 4 )
   {
      SetOptionState( vSubtask, "Window3", zOPTION_STATUS_VISIBLE, TRUE );
   }
   else
   if ( k % 10 == 5 )
   {
      SetOptionState( vSubtask, "Windows", zOPTION_STATUS_VISIBLE, FALSE );
   }
   else
   if ( k % 10 == 6 )
   {
      SetOptionState( vSubtask, "Windows", zOPTION_STATUS_VISIBLE, TRUE );
   }
   else
   if ( k % 10 == 7 )
   {
      SetOptionState( vSubtask, "Window2", zOPTION_STATUS_VISIBLE, FALSE );
   }
   else
   if ( k % 10 == 8 )
   {
      SetOptionState( vSubtask, "Window2", zOPTION_STATUS_VISIBLE, TRUE );
   }
   else
   if ( k % 10 == 9 )
   {
      zPCHAR pch = (zPCHAR)
         GetOptionState( vSubtask, "Window3", zOPTION_STATUS_TEXT );
      TraceLineS( "Window3 text: ", pch );
      SetOptionState( vSubtask, "Window3", zOPTION_STATUS_ENABLED, TRUE );
      SetOptionState( vSubtask, "Window3",
                      zOPTION_STATUS_TEXT, (zLONG) "Window3" );
   }


   k++;
#endif
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
InitPopup( zVIEW   vSubtask )
{
   return( 0 );
}

//===========================================================================
//===========================================================================
//===========================================================================
zOPER_EXPORT zSHORT OPERATION
RemotePrint( zVIEW  vSubtask )
{
   OpenRemoteReportFromClient( vSubtask, "KZRPSRCO",
                               "oTZRPSRCO_FormatDocPage",
                               "AccountR", "CUSTOMER",
                               "ACCOUNT" );
   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
DoTheReport( zVIEW  vSubtask )
{

   zVIEW  vAccount;
   zBOOL  bPrintPreview;
   char   szReturnTag[ 34 ];

   GetLastCommandTag( vSubtask, szReturnTag );
   if ( zstrcmp( szReturnTag, "PrintPreview" ) == 0 )
   {
      bPrintPreview = TRUE;

      // This routine prints a report on the current ERD in memory.
      GetViewByName( &vAccount, "ACCOUNT", 0, zLEVEL_TASK );
//    GetViewByName( &vLPLR, "TaskLPLR", 0, zLEVEL_TASK );

      // Set up current DateTime for report.
//    SysGetDateTime( szTimeStamp );
//    SetAttributeFromString( vLPLR, "LPLR", "CurrentDateTime", szTimeStamp );

      FormatSubobjectOnDoc( vAccount, "CUSTOMER", vSubtask,
                            "AccountR", 1 + 8 + 32 );
   }
   else
   {
      bPrintPreview = TRUE;
      OpenReport( vSubtask, "account", "PrintPage",
                  bPrintPreview, TRUE, TRUE, TRUE,
                  "AccountR", "CUSTOMER" );
   }


   return( 0 );
}

#define zESCAPE_STEP 100

int zOPER_EXPORT OPERATION
PrintPage( zVIEW vSubtask, zSHORT nPageNbr,
           zSHORT nPageWidth, zSHORT nPageHeight )
{
#if 1

   char   szBuffer[ 256 ];
   zSHORT nExtentX;
   zSHORT nExtentY;
   long   lEscapement = 3600;
   long   lFontSize, k;

// lEscapement = (nPageNbr % 4) * 900;
   zstrcpy( szBuffer, "Try this" );
   for ( lFontSize = 324; lFontSize < 400; lFontSize += 80 )
   {
      SetCtrlState( vSubtask, "Vertical", 98, lFontSize );
      lEscapement = 3600 - zESCAPE_STEP;
   // lEscapement = 900 - zESCAPE_STEP;
      for ( k = 0; k < (3600 / zESCAPE_STEP) + 1; k++ )
   // for ( k = 0; k < 10; k++ )
      {
         lEscapement += zESCAPE_STEP;
         if ( lEscapement > 3600 )
            lEscapement = zESCAPE_STEP;

         CreateFontForReport( vSubtask, "vertical", (zSHORT) lFontSize, TRUE, TRUE,
                              TRUE, TRUE, 0, (zSHORT) lEscapement, "Arial" );
         SelectFontForReport( vSubtask, "vertical" );
         nExtentX = GetTextWidth( vSubtask, szBuffer );
         nExtentY = GetTextHeight( vSubtask, szBuffer );
         PrintTextToReport( vSubtask, szBuffer, 600, 800,
                            1400, 1600, 0, 0, 0, lEscapement, 0 );

         DrawRectangleToReport( vSubtask, 600, 800,
                                1400, 1600, 2, 0, 255, 3 );
      // SysWait( 125 );     // 1/8 second
         SysWait( 50 );      // 1/20 second
      // SysWait( 1000 );    // 1 second
      }
   }

   return( 1 );

#else

   zSHORT nExtentX;
   zSHORT nExtentY;
   char szBuffer[ 80 ];

   // Do the text stuff
   const char* lines[ 6 ] =
   {
      "*L1: (x) This small text starts at DC origin*",
      "*L2: Text only (1 page of 6 lines)  This large text should be centered*",
      "*L3: This small text should be right-justified*",
      "*L4: This bold text should be on the bottom of the page*",
      "*L5: L4 might not be displayed if driver gives wrong size information*",
      "*L6: This line runs vertically.*"
   };

   TraceLineI( "Page Width = ", nPageWidth );
   TraceLineI( "Page Height = ", nPageHeight );

   CreateFontForReport( vSubtask, "small", -18,
                        FALSE, FALSE, FALSE, FALSE, 0, 0, 0 );
   CreateFontForReport( vSubtask, "big", -24,
                        TRUE, FALSE, FALSE, FALSE, 0, 0, 0 );
   CreateFontForReport( vSubtask, "bold", -34,
                        TRUE, FALSE, FALSE, FALSE, 0, 0, 0 );
   CreateFontForReport( vSubtask, "italic", -18,
                        FALSE, TRUE, FALSE, FALSE, 0, 0, 0 );
   CreateFontForReport( vSubtask, "vertical", -24,
                        TRUE, FALSE, FALSE, FALSE, 0, 2700, 0 );
   // top of the page
   strcpy( szBuffer, lines[ 0 ] );
   szBuffer[ 6 ] = (char) ('0' + nPageNbr);
   SelectFontForReport( vSubtask, "small" );
   nExtentX = GetTextWidth( vSubtask, lines[ 0 ] );
   nExtentY = GetTextHeight( vSubtask, lines[ 0 ] );
   PrintTextToReport( vSubtask, szBuffer, 0, 0, nExtentX, nExtentY,
                      0, 0, 0, 0, 0 );

   // centered
   SelectFontForReport( vSubtask, "big" );
   nExtentX = GetTextWidth( vSubtask, lines[ 1 ] );
   nExtentY = GetTextHeight( vSubtask, lines[ 1 ] );
   PrintTextToReport( vSubtask, lines[ 1 ],
                      (nPageWidth / 2) - (nExtentX / 2),
                      (nPageHeight / 2) - (nExtentY / 2),
                      (nPageWidth / 2) - (nExtentX / 2) + nExtentX,
                      (nPageHeight / 2) - (nExtentY / 2) + nExtentY,
                      0, 0, 0, 0, 0 );

   // right justified, above vertical center
   SelectFontForReport( vSubtask, "small" );
   nExtentX = GetTextWidth( vSubtask, lines[ 2 ] );
   nExtentY = GetTextHeight( vSubtask, lines[ 2 ] );
   PrintTextToReport( vSubtask, lines[ 2 ],
                      nPageWidth - nExtentX,
                      (nPageHeight / 2) - (5 * nExtentY),
                      nPageWidth,
                      (nPageHeight / 2) - (5 * nExtentY) + nExtentY,
                      0, 0, 0, 0, 0 );

   // bottom of page
   SelectFontForReport( vSubtask, "bold" );
   nExtentX = GetTextWidth( vSubtask, lines[ 3 ] );
   nExtentY = GetTextHeight( vSubtask, lines[ 3 ] );
   PrintTextToReport( vSubtask, lines[ 3 ], 0,
                      nPageHeight - nExtentY,
                      nExtentX, nPageHeight,
                      0, 0, 0, 0, 0 );

   // below vertical center, left side
   SelectFontForReport( vSubtask, "italic" );
   nExtentX = GetTextWidth( vSubtask, lines[ 4 ] );
   nExtentY = GetTextHeight( vSubtask, lines[ 4 ] );
   PrintTextToReport( vSubtask, lines[ 4 ], 0,
                      (nPageHeight / 2) + (5 * nExtentY),
                      nExtentX,
                      (nPageHeight / 2) + (5 * nExtentY) + nExtentY,
                      0, 0, 0, 0, 0 );

   // right of center line, top, text rotated 270 degrees (vertical)
   SelectFontForReport( vSubtask, "vertical" );
   nExtentX = GetTextWidth( vSubtask, lines[ 5 ] );
   nExtentY = GetTextHeight( vSubtask, lines[ 5 ] );
   PrintTextToReport( vSubtask, lines[ 5 ],
                      (nPageWidth / 2), 30, (nPageWidth / 2) + nExtentX,
                      400 + nExtentY,
                      0, 0, 0, 0, 0 );
#if 0
  TPoint p( pageSize.cx / 4, pageSize.cy / 4 );
  dc.SelectStockObject( HOLLOW_BRUSH );

  dc.Rectangle( p.x, p.y, pageSize.cx-p.x, pageSize.cy-p.y );
  dc.Rectangle( 0, 0, pageSize.cx, pageSize.cy );
  dc.MoveTo( 0, 0 );
  dc.LineTo( pageSize.cx, pageSize.cy );
  dc.MoveTo( pageSize.cx, 0 );
  dc.LineTo( 0, pageSize.cy );
  dc.MoveTo( pageSize.cx / 2, -50 );
  dc.LineTo( pageSize.cx / 2, pageSize.cy + 50 );

  dc.Ellipse( pageSize.cx / 2 - pageSize.cx / 4,
              pageSize.cy / 2 - pageSize.cy / 4,
              pageSize.cx / 2 + pageSize.cx / 4,
              pageSize.cy / 2 + pageSize.cy / 4 );
#endif

   // Do the graphics stuff if this band can handle it
   nExtentX = nPageWidth / 4;
   nExtentY = nPageHeight / 4;

   DrawRectangleToReport( vSubtask, nExtentX, nExtentY,
                          nPageWidth - nExtentX,
                          nPageHeight - nExtentY, 1, 0, 0, 0 );
   DrawRectangleToReport( vSubtask, 0, 0, nPageWidth, nPageHeight,
                          2, 0, 0, 0 );

   DrawLineToReport( vSubtask, 0, 0, nPageWidth, nPageHeight, 2, 0, 0, 0 );
   DrawLineToReport( vSubtask, nPageWidth, 0, 0, nPageHeight, 1, 0, 0, 0 );
   DrawLineToReport( vSubtask, nPageWidth / 2, -50,
                     nPageWidth / 2, nPageHeight + 50, 1, 0, 0, 0 );

   DrawEllipseToReport( vSubtask, nPageWidth / 2 - nPageWidth / 4,
                        nPageHeight / 2 - nPageHeight / 4,
                        nPageWidth / 2 + nPageWidth / 4,
                        nPageHeight / 2 + nPageHeight / 4, 1, 0, 0 );

   return( 0 );
#endif
}

zOPER_EXPORT zSHORT OPERATION
TabPreChange( zVIEW vSubtask )
{
   static zSHORT nCnt = 0;
   nCnt++;
   if ( nCnt % 2 )
      return( -1 );
   else
      return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
SwitchText( zVIEW   vSubtask )
{
   long k = 3400;
   long i, j;

   for ( i = 9; i < 80; i += 10 )
   {
      SetCtrlState( vSubtask, "Vertical", 98, i );
      for ( j = 0; j <= 40; j++ )
      {
         k += 100;
         if ( k >= 3600 )
            k = 0;

         SetCtrlState( vSubtask, "Vertical", 99, k );
         RefreshCtrl( vSubtask, "Vertical" );
         SetWindowState( vSubtask, zWINDOW_STATUS_UPDATE, 0 );
         SysWait( 100);     // 1/10 second
      }
   }

   SetCtrlState( vSubtask, "Vertical", 99, 0 );
   RefreshCtrl( vSubtask, "Vertical" );
   SetWindowState( vSubtask, zWINDOW_STATUS_UPDATE, 0 );

   return( 0 );
}

zOPER_EXPORT zSHORT OPERATION
AfterUpdate( zVIEW   vSubtask )
{
   return( 0 );
   long k = 3400;
   long i, j;

   for ( i = 9; i < 80; i += 10 )
   {
      SetCtrlState( vSubtask, "Vertical", 98, i );
      for ( j = 0; j <= 40; j++ )
      {
         k += 100;
         if ( k >= 3600 )
            k = 0;

         SetCtrlState( vSubtask, "Vertical", 99, k );
         RefreshCtrl( vSubtask, "Vertical" );
         SetWindowState( vSubtask, zWINDOW_STATUS_UPDATE, 0 );
         SysWait( 125 );     // 1/8 second
      }
   }

   SetCtrlState( vSubtask, "Vertical", 99, 0 );
   RefreshCtrl( vSubtask, "Vertical" );
   SetWindowState( vSubtask, zWINDOW_STATUS_UPDATE, 0 );

   return( 0 );
}


//===========================================================================
//===========================================================================
//===========================================================================

#if 0

   LANGID langID = GetUserDefaultLangID( );
   if ( SetCursorFirstEntityByInteger( vLang, "LangID",
                                       "Key", langID, 0 ) != zCURSOR_SET )
   {
      // Use default if cannot find language specific.
      SetCursorFirstEntityByInteger( vLang, "LangID", "Key", 0, 0 );
   }


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define IDS_ONES_0              100
#define IDS_ONES_1              101
#define IDS_ONES_2              102
#define IDS_ONES_3              103
#define IDS_ONES_4              104
#define IDS_ONES_5              105
#define IDS_ONES_6              106
#define IDS_ONES_7              107
#define IDS_ONES_8              108
#define IDS_ONES_9              109
#define IDS_TEENS_10            110
#define IDS_TEENS_11            111
#define IDS_TEENS_12            112
#define IDS_TEENS_13            113
#define IDS_TEENS_14            114
#define IDS_TEENS_15            115
#define IDS_TEENS_16            116
#define IDS_TEENS_17            117
#define IDS_TEENS_18            118
#define IDS_TEENS_19            119
#define IDS_TENS_0              200
#define IDS_TENS_10             210
#define IDS_TENS_20             220
#define IDS_TENS_30             230
#define IDS_TENS_40             240
#define IDS_TENS_50             250
#define IDS_TENS_60             260
#define IDS_TENS_70             270
#define IDS_TENS_80             280
#define IDS_TENS_90             290
#define IDS_UNKNOWN             999
#define IDS_THOUSAND            1000
#define IDS_MILLION             1001
#define IDS_AND                 1002
#define IDS_HUNDRETHS_DOLLARS   1003
#define IDS_HUNDRED             1004
#define INVALID_DOLLARS_CENTS   0xffffffff

zBOOL   GetDollarsCents( zVIEW vLang, zDecimal& dDollarsCents );
void    SetDollarsCents( zVIEW vLang, zDecimal dDollarsCents );
CString GetDollarsCentsFormatted( zVIEW vLang, zDecimal dDollarsCents );
CString GetDollarsCentsText( zVIEW vLang, zDecimal dDollarsCents );
CString HundredsTensOnes( zVIEW vLang, zDecimal decHundredsTensOnes );
CString TensOnes( zVIEW vLang, zDecimal decTensOnes );

zBOOL
GetDollarsCents( zVIEW     vLang,
                 zDecimal& dDollarsCents,
                 zCPCHAR   cpcDollarsCentsText )
{
   zDecimal dDollars;
   char  szDollarsCents[ 128 ];
   int   nCents;
   char  *pch;
   char  *pchDollars;
   char  *pchCents;

   szDollarsCentsText[ 0 ] = 0;
   zstrncat( szDollarsCentsText, cpcDollarsCentsText,
             sizeof( szDollarsCentsText ) - 1 );

   // strip leading blanks
   for ( pchDollars = cpcDollarsCentsText; *pchDollars == ' '; pchDollars++ )
   {
      if ( *pchDollars == 0 )
      {
         dDollarsCents = 0;
         return( TRUE );
      }
   }

   // parse dollar amount, before optional decimal point
   for ( pch = pchDollars; *pch && (*pch != '.') && (*pch != ' '); pch++ )
   {
      if ( (*pch < '0') || (*pch > '9') )
         return( FALSE );
   }

   zBOOL bDollarsOnly = (*pch == 0);
   *pch = 0;

   if ( zstrlen( pchDollars ) > 8 )
      return( FALSE );

   if ( zstrlen( pchDollars ) == 0 )
   {
      dDollars = 0L;
   }
   else
   {
      dDollars = _ttol( pchDollars );
      if ( dDollars > ((zDecimal) 0xffffffff) / 100 )
         return( FALSE );
   }

   if ( bDollarsOnly )
   {
      nCents = 0;
   }
   else  // decimal point was found
   {
      // parse cents
      for ( pchCents = ++pch; *pch && (*pch != ' '); pch++ )
      {
         if ( (*pch < '0') || (*pch > '9') )
            return( FALSE );
      }

      if ( *pch == ' ' )
      {
         for ( pch++ ; *pch; pch++ )
         {
            if ( *pch != ' ' )
               return( FALSE );
         }
      }

      zSHORT nCentsStrLen = zstrlen( pchCents );
      switch ( nCentsStrLen )
      {
         case 0:
            nCents = 0;
            break;
         case 1:
            nCents = _ttoi( pchCents ) * 10;
            break;
         case 2:
            nCents = _ttoi( pchCents );
            break;
         default:
            return( FALSE );
      }
   }

   dDollarsCents = dDollars * 100 + nCents;
   return( TRUE );
}

void
SetDollarsCents( zVIEW    vLang,
                 zPCHAR   pchDollarCentsText,
                 zDecimal dDollarsCents )
{
   // Convert the zDecimal dollars/cents value to a string
   // display it in the dollars/cents control.

   // If the dollar cent field has been previously determined to be
   // invalid, then don't update it.  Leave the invalid data in the
   // field so the user can correct it, rather than replace it with the
   // literal translation of the INVALID_DOLLARS_CENTS #define value.

   if ( dDollarsCents == INVALID_DOLLARS_CENTS )
      return;

   CString zs = GetDollarsCentsFormatted( dDollarsCents );
   zstrcpy( pchDollarsCentsText, zs );
}

CString
GetDollarsCentsFormatted( zVIEW vLang, zDecimal dDollarsCents )
{
   CString zs;

   if ( dDollarsCents == INVALID_DOLLARS_CENTS )
   {
      zs = GetLangString( vLang, IDS_UNKNOWN );
      return( zs );
   }

   zDecimal dDollars = dDollarsCents / 100;
   WORD wCents = (WORD)(dDollarsCents - 100 * dDollars);

   zs.Format( _T( "%lu.%02u" ), dDollars, wCents );
   return( zs );
}

CString
GetDollarsCentsText( zVIEW vLang, zDecimal dDollarsCents )
{
   CString zs;
   CString zsTemp;

   if ( dDollarsCents == INVALID_DOLLARS_CENTS )
   {
      zs = GetLangString( vLang, IDS_UNKNOWN );
      return( zs );
   }

   zDecimal dDollars = dDollarsCents / 100;
   WORD wCents = (WORD)(dDollarsCents - (dDollars * 100));
   if ( dDollars == 0L )
   {
      zs = GetLangString( vLang, IDS_ONES_0 );   // "Zero"
      zs += ' ';
   }
   else
   {
      if ( dDollars >= 1000000 )
      {
         zDecimal decMillions = dDollars / 1000000;
         CString zsMillions = HundredsTensOnes( decMillions );
         zsTemp = GetLangString( vLang, IDS_MILLION );    // "Million"
         zs = zsMillions;
         zs += ' ';
         zs += zsTemp;
         zs += ' ';
         dDollars -= (decMillions * 1000000);
      }

      if ( dDollars >= 1000 )
      {
         zDecimal decThousands = dDollars / 1000;
         CString zsThousands = HundredsTensOnes( decThousands );
         zsTemp = GetLangString( vLang, IDS_THOUSAND );   // "Thousand"
         zs += zsThousands;
         zs += ' ';
         zs += zsTemp;
         zs += ' ';
         dDollars -= (decThousands * 1000);
      }

      if ( dDollars > 0 )
      {
         CString zsHundredsTensOnes = HundredsTensOnes( dDollars );
         zs += zsHundredsTensOnes;
         zs += ' ';
      }
   }

   char szCents[ 10 ];
   CString zsCents( _itot( wCents, szCents, 10 ) );
   zsTemp = GetLangString( vLang, IDS_AND );    // "and"
   zs += zsTemp;
   zs += ' ';
   zs += zsCents;
   zsTemp = GetLangString( vLang, IDS_HUNDRETHS_DOLLARS );  // "/100ths Dollars"
   zs += zsTemp;
   return( zs );
}

CString
HundredsTensOnes( zVIEW vLang, zDecimal decHundredsTensOnes )
{
   CString zs;
   CString zsTemp;

   if ( decHundredsTensOnes >= 100 )
   {
      zDecimal decHundreds = decHundredsTensOnes / 100;
      CString zsHundreds;
      zsHundreds = GetLangString( vLang, IDS_ONES_0 + decHundreds );
      zsTemp = GetLangString( vLang, IDS_HUNDRED );
      zs = zsHundreds;
      zs += ' ';
      zs += zsTemp;
      zs += ' ';
      decHundredsTensOnes -= (decHundreds * 100);
   }

   if ( decHundredsTensOnes > 0 )
   {
      CString zsTensOnes = TensOnes( decHundredsTensOnes );
      zs += zsTensOnes;
   }

   return( zs );
}

CString
TensOnes( zVIEW vLang, zDecimal decTensOnes )
{
   CString zs;
   CString zsTemp;

   if ( decTensOnes > 19 )
   {
      zDecimal decTens = decTensOnes / 10;
      zsTemp = GetLangString( vLang, IDS_TENS_0 + decTens );
      zs += zsTemp;
      decTensOnes -= (decTens * 10);
      if ( decTensOnes > 0 )
      {
         CString zsOnes;
         zsOnes = GetLangString( vLang, IDS_ONES_0 + decTensOnes );
         zs += '-';
         zs += zsOnes;
      }
   }
   else
   if ( decTensOnes >= 10 )
   {
      CString zsTeens;
      zsTeens = GetLangString( vLang, IDS_TEENS_10 + decTensOnes - 10 );
      zs += zsTeens;
   }
   else
   {
      CString zsOnes;
      zsOnes = GetLangString( vLang, IDS_ONES_0 + decTensOnes );
      zs += zsOnes;
   }

   return( zs );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

zOPER_EXPORT zLONG OPERATION
zdmDollarCents( zLONG        lEntryType,
                LPDOMAINDATA lpDomainData )
{
   LPDOMAIN    lpDomain;
   zSHORT      nRC;

   nRC = zCALL_ERROR;         // Default to in error status...
   lpDomain = zGETPTR( lpDomainData->lpViewAttribute->hDomain );

   switch ( lEntryType )
   {
      case zDME_GET_VARIABLE:
      {
         char szDollarsCentsText[ 128 ];

         szDollarsCentsText[ 0 ] = 0;
         lpDomain = zGETPTR( lpDomainData->lpViewAttribute->hDomain );
         if ( lpDomainData->lpViewAttribute->cType != zTYPE_DECIMAL )
         {
            *sz = lpDomainData->lpViewAttribute->cType;
            *(sz + 1) = 0;
            zstrcat( sz, ", " );
            zstrcat( sz, lpDomainData->lpViewEntity->szName );
            // "TZDME003 - Attribute Type invalid for this Domain"
            SendDomainError( lpDomainData->zView, lpDomain, 8, 3, 0,
                             sz, lpDomainData->lpViewAttribute->szName );
            nRC = zCALL_ERROR;
            break;
         }

         if ( lpDomainData->cType != zTYPE_PIC )
         {
            nRC = GetValueFromRecord( lpDomainData->zView,
                                      lpDomainData->lpViewEntity,
                                      lpDomainData->lpViewAttribute,
                                      &lpAttrValue, &cAttrType,
                                      &uAttrLength );
            if ( nRC )
            {
               nRC = zCALL_ERROR;
               break;
            }

            // If there is no lpRecord, lpAttrValue returns a null.
            if ( lpAttrValue == 0 )
               lpAttrValue = (zPCHAR) &dNullDecimal;
         }

         // determine output data type
         switch ( lpDomainData->cType )
         {
            case zTYPE_STRING:
               // First get the formatting information from the Context or use
               // default.
               if ( lpDomainData->pszContextName && *lpDomainData->pszContextName )
               {
                  if ( GetContext( &lpContext, lpDomain, lpDomainData->pszContextName) )
                  {
                     // Get the formatting characters.
                     nRC = fnGetDecimalFmtStrings( lpContext, szThou, szDecPt,
                                                   &lPrecision );
                     if ( nRC )
                     {
                        // "TZDME019 - International number formatting is
                        //  not available "
                        // We continue with the US default...
                        SendDomainError( lpDomainData->zView, lpDomain, 16, 19, 0,
                                         lpDomainData->lpViewEntity->szName,
                                         lpDomainData->lpViewAttribute->szName );
                     }

                     // Check if the Context is one of the DecimalKeyx values.
                     // If so, there will be no thousands value.
                     zstrcpy( szWorkName, lpDomainData->pszContextName );
                     szWorkName[ 10 ] = 0;
                     if ( zstrcmp( szWorkName, "DecimalKey" ) == 0 )
                     {
                        szThou[0] = 0;
                     }
                     else
                     {
                        // Make sure it's not one of the arithmetic types.
                        if ( fnDecIntContext( lpContext ) )
                        {
                           char  sz2[ 100 ];

                           zstrcpy( sz, lpContext->szName );
                           zstrcat( sz, "/S" );
                           zstrcpy( sz2, lpDomainData->lpViewEntity->szName );
                           zstrcat( sz2, ", " );
                           zstrcat( sz2, lpDomainData->lpViewAttribute->szName );
                           // "TZDME013 - Context/cType Combination is invalid "
                           SendDomainError( lpDomainData->zView, lpDomain, 8, 13, 0, sz, sz2 );
                           return( zCALL_ERROR );
                        }
                     }
                  }
                  else
                  {
                     // "TZDME008 - Could not find context for Domain "
                     SendDomainError( lpDomainData->zView, lpDomain, 8, 8, 0,
                                      lpDomainData->pszContextName, 0 );
                     nRC = zCALL_ERROR;
                     break;
                  }
               }
            else
            {
               GetDefaultContext( &lpContext, lpDomain );
               fnGetDecimalFmtStrings( lpContext, szThou, szDecPt, &lPrecision );
            }

            // Convert the decimal to a basic string.
            if ( SysCompareDecimalToNull( (zPDECIMAL) lpAttrValue ) == 0 )
            {
               *((zPCHAR) lpDomainData->lpData) = 0;
               zstrcpy( sz, "0.0" );
               bWasNull = 1;
            }
            else
            {
               SysAssignDecimalFromDecimal( &dDecimal, (zPDECIMAL) lpAttrValue );
               SysConvertDecimalToString( &dDecimal, sz, (zSHORT) lPrecision );
            }

            // Convert the decimal string to correct precision and international
            // formatting characters.
            if ( szThou[0] == 0 )
            {
               if ( szDecPt[0] == 0 )
                  fnFormatDecimalString( sz, 0, 0, lpDomain->lDecimalFormat );
               else
                  fnFormatDecimalString( sz, 0, szDecPt, lPrecision );
            }
            else
               fnFormatDecimalString( sz, szThou, szDecPt, lPrecision );

            // Return the formatted decimal, unless the return area is not
            // large enough, in that case fill it with '*'.
            if ( lpDomainData->uMaxStringLength && zstrlen( sz ) > lpDomainData->uMaxStringLength )
            {
               zmemset( (zPCHAR) lpDomainData->lpData, '*', lpDomainData->uMaxStringLength );
               *((zPCHAR) lpDomainData->lpData + lpDomainData->uMaxStringLength) = 0;
               // "TZDME021 - Return area not large enough for formatted string "
               SendDomainError( lpDomainData->zView, lpDomain, 8, 21, 0,
                                lpDomainData->lpViewEntity->szName,
                                lpDomainData->lpViewAttribute->szName );
               nRC = zCALL_ERROR;
            }
            else
            {
               zstrcpy( (zPCHAR) lpDomainData->lpData, sz );
               nRC = bWasNull ? -1 : 0;
            }

            break;

            case zTYPE_INTEGER:
               // decimal to long
               if ( SysCompareDecimalToNull( (zPDECIMAL) lpAttrValue ) == 0 )
               {
                  *((zPLONG) lpDomainData->lpData) = 0;
                  nRC = -1;   // indicate attribute is null
               }
               else
               {
                  if ( lpDomainData->pszContextName && *lpDomainData->pszContextName )
                  {
                     if ( zstrcmp( lpDomainData->pszContextName, szlDecimalIntegerRounded ) == 0 )
                     {
                        zDECIMAL dTemp;
                        zDECIMAL dZero;

                        SysConvertLongToDecimal( 0, &dZero );
                        SysAssignDecimalFromDecimal( &dTemp, (zPDECIMAL) lpAttrValue );
                        if ( SysCompareDecimalToDecimal( &dTemp, &dZero ) < 0 )
                           SysConvertDoubleToDecimal( -0.5, &dZero );
                        else
                           SysConvertDoubleToDecimal( 0.5, &dZero );

                        SysAddDecimalToDecimal( &dTemp, &dTemp, &dZero );
                        SysConvertDecimalToLong( &dTemp, (zPLONG) lpDomainData->lpData );
                     }
                     else if ( zstrcmp( lpDomainData->pszContextName, szlDecimalFraction ) == 0 )
                     {
                        zCHAR    sz2[ 100 ];

                        zstrcpy( sz, lpDomainData->pszContextName );
                        zstrcat( sz, "/L" );
                        zstrcpy( sz2, lpDomainData->lpViewEntity->szName );
                        zstrcat( sz2, ", " );
                        zstrcat( sz2, lpDomainData->lpViewAttribute->szName );
                        // "TZDME013 - Context/cType Combination is invalid "
                        SendDomainError( lpDomainData->zView, lpDomain, 8, 13, 0, sz, sz2 );
                        return( zCALL_ERROR );
                     }
                     else
                        SysConvertDecimalToLong( (zPDECIMAL) lpAttrValue,
                                                 (zPLONG) lpDomainData->lpData );
                  }
                  else
                     SysConvertDecimalToLong( (zPDECIMAL) lpAttrValue,
                                              (zPLONG) lpDomainData->lpData );

                  nRC = 0;
               }

               break;

            case zTYPE_DECIMAL:
               // decimal to decimal
               if ( SysCompareDecimalToNull( (zPDECIMAL) lpAttrValue ) == 0 )
               {
                  SysConvertLongToDecimal( 0, (zPDECIMAL) lpDomainData->lpData );
                  nRC = -1;   // indicate attribute is null
               }
               else
               {
                  if ( lpDomainData->pszContextName && *lpDomainData->pszContextName )
                  {
                     if ( zstrcmp( lpDomainData->pszContextName, szlDecimalInteger ) == 0 )
                     {
                        zLONG lTemp;

                        SysConvertDecimalToLong( (zPDECIMAL) lpAttrValue, &lTemp );
                        SysConvertLongToDecimal( lTemp, (zPDECIMAL) lpDomainData->lpData );
                     }
                     else if ( zstrcmp( lpDomainData->pszContextName, szlDecimalFraction ) == 0 )
                     {
                        zLONG    l1;
                        zDECIMAL d1;

                        SysAssignDecimalFromDecimal( &d1, (zPDECIMAL) lpAttrValue );
                        SysConvertDecimalToLong( &d1, &l1 );
                        SysConvertLongToDecimal( l1, &d1 );
                        SysSubtractDecimalFromDecimal( (zPDECIMAL) lpDomainData->lpData,
                                                       (zPDECIMAL) lpAttrValue, &d1 );
                     }
                     else if ( zstrcmp( lpDomainData->pszContextName,
                                        szlDecimalIntegerRounded ) == 0 )
                     {
                        zLONG    l;
                        zDECIMAL d1;
                        zDECIMAL d2;

                        SysAssignDecimalFromDecimal( &d1, (zPDECIMAL) lpAttrValue );
                        SysConvertLongToDecimal( 0, &d2 );
                        if ( SysCompareDecimalToDecimal( &d1, &d2 ) >= 0 )
                           SysConvertDoubleToDecimal( 0.5, &d2 );
                        else
                           SysConvertDoubleToDecimal( -0.5, &d2 );

                        SysAddDecimalToDecimal( &d1, &d1, &d2 );
                        SysConvertDecimalToLong( &d1, &l );
                        SysConvertLongToDecimal( l, (zPDECIMAL) lpDomainData->lpData );
                     }
                     else
                        SysAssignDecimalFromDecimal( (zPDECIMAL) lpDomainData->lpData,
                                                     (zPDECIMAL) lpAttrValue );
                  }
                  else
                     SysAssignDecimalFromDecimal( (zPDECIMAL) lpDomainData->lpData,
                                                  (zPDECIMAL) lpAttrValue );
                  nRC = 0;
               }
               break;

            case zTYPE_PIC:
            // return the picture string for the given context
            {
               zLPCONTEXT   lpContext;

               if ( lpDomainData->pszContextName && *lpDomainData->pszContextName )
               {
                  GetContext( &lpContext, lpDomain, lpDomainData->pszContextName);
               }
               else
                  GetDefaultContext( &lpContext, lpDomain );

               if ( lpContext )
               {
                  zPCHAR lpEditString = zGETPTR( lpContext->hEditString );

                  if ( lpEditString && *lpEditString )
                     zstrcpy( (zPCHAR) lpDomainData->lpData, lpEditString );
                  else
                     *((zPCHAR) lpDomainData->lpData) = 0;
                  nRC = 0;
               }
               else
               {
                  // "TZDME008 - Could not find context for Domain "
                  SendDomainError( lpDomainData->zView, lpDomain, 8, 8, 0,
                                   TrueName( lpDomainData->pszContextName, zSHOW_ZKEY ),
                                   lpDomainData->lpViewAttribute->szName );
                  nRC = zCALL_ERROR;
               }
            }
            break;

          default:
            *sz = lpDomainData->cType;
            *(sz + 1) = 0;
            zstrcat( sz, ", " );
            zstrcat( sz, lpDomainData->lpViewEntity->szName );
            // "TZDME001 - Invalid Input Data Type"
            SendDomainError( lpDomainData->zView, lpDomain, 8, 1,
                             0, sz, lpDomainData->lpViewAttribute->szName );
            nRC = zCALL_ERROR;
         }
         break;
      }

      case zDME_VALIDATE_LPDATA:
      case zDME_SET_ATTRIBUTE:
      case zDME_ADD_TO_ATTRIBUTE:
      case zDME_COMPARE_ATTRIBUTE:
      case zDME_GET_COMPARE_VALUE:
      case zDME_GET_FIRST_TBL_ENT_FOR_ATTR:
      case zDME_GET_NEXT_TBL_ENT_FOR_ATTR:
      case zDME_SET_ATTRIBUTE_VALUE_NEXT:
      case zDME_SET_ATTRIBUTE_VALUE_PREV:
      default:
         // "TZDME004 - Invalid Domain Entry Type "
         SendDomainError( lpDomainData->zView, lpDomain, 8, 4, lEntryType,
                          lpDomainData->lpViewEntity->szName,
                          lpDomainData->lpViewAttribute->szName );
         nRC = zCALL_ERROR;
   }

   return( nRC );
}
#endif

#if 0

zSHORT
GetCurrencyText( LPDOMAINDATA lpDomainData,
                 zDecimal&    dCurrencyText,
                 zCPCHAR      cpcCurrencyTextText )
{
   zDecimal dDollars;
   char     szCurrencyText[ zMAX_DECIMAL_STRING ];
   zSHORT   nCents;
   char     *pch;
   char     *pchDollars;
   char     *pchCents;

   szCurrencyText[ 0 ] = 0;
   zstrncat( szCurrencyText, cpcCurrencyTextText,
             sizeof( szCurrencyText ) - 1 );

   // Strip leading blanks.
   for ( pchDollars = szCurrencyText; *pchDollars == ' '; pchDollars++ )
   {
      if ( *pchDollars == 0 )
      {
         dCurrencyText = 0;
         return( TRUE );
      }
   }

   // Parse dollar amount, before optional decimal point.
   for ( pch = pchDollars; *pch && (*pch != '.') && (*pch != ' '); pch++ )
   {
      if ( (*pch < '0') || (*pch > '9') )
         return( FALSE );
   }

   zBOOL bDollarsOnly = (*pch == 0);
   *pch = 0;

   if ( zstrlen( pchDollars ) > 8 )
      return( FALSE );

   if ( zstrlen( pchDollars ) == 0 )
   {
      dDollars = 0L;
   }
   else
   {
      dDollars = pchDollars;
      if ( dDollars > dInvalidDecimalValue )
         return( FALSE );
   }

   if ( bDollarsOnly )
   {
      nCents = 0;
   }
   else  // decimal point was found
   {
      // Parse cents.
      pch++;
      for ( pchCents = pch; *pch && (*pch != ' '); pch++ )
      {
         if ( (*pch < '0') || (*pch > '9') )
            return( FALSE );
      }

      if ( *pch == ' ' )
      {
         for ( pch++ ; *pch; pch++ )
         {
            if ( *pch != ' ' )
               return( FALSE );
         }
      }

      zSHORT nCentsStrLen = zstrlen( pchCents );
      switch ( nCentsStrLen )
      {
         case 0:
            nCents = 0;
            break;
         case 1:
            nCents = zatol( pchCents ) * 10;
            break;
         case 2:
            nCents = zatol( pchCents );
            break;
         default:
            return( FALSE );
      }
   }

   dCurrencyText = dDollars * 100 + nCents;
   return( TRUE );
}

zSHORT
SetCurrencyText( LPDOMAINDATA lpDomainData,
                 zPCHAR       pchCurrencyTextText,
                 zDecimal     dCurrencyText )
{
   // Convert the zDecimal dollars/cents value to a string.

   // If the dollar cent field has been previously determined to be
   // invalid, then don't update it.  Leave the invalid data in the
   // field so the user can correct it, rather than replace it with the
   // literal translation of the INVALID_DOLLARS_CENTS #define value.

   if ( dCurrencyText == dInvalidDecimalValue )
   {
      return( zstrlen( pchCurrencyTextText ) );
   }

   return( GetCurrencyTextFormatted( lpDomainData,
                                     pchCurrencyTextText,
                                     dCurrencyText ) );
}

zSHORT
GetCurrencyTextFormatted( LPDOMAINDATA lpDomainData,
                          zPCHAR       pchReturnCurrencyText,
                          zDecimal     dCurrencyText )
{
   if ( dCurrencyText == dInvalidDecimalValue )
   {
      return( SysLoadString( lpDomainData->zView,
                             "tzapdmaa", IDS_UNKNOWN,
                             pchReturnCurrencyText,
                             zMAX_DECIMAL_STRING ) );
   }

   zDecimal dDollars = dCurrencyText / 100;
   WORD wCents = (WORD)(dCurrencyText - 100 * dDollars);

   printf( pchReturnCurrencyText, "%lu.%02u", dDollars, wCents );
   return( zstrlen( pchReturnCurrencyText ) );
}

zSHORT
GetCurrencyTextText( LPDOMAINDATA lpDomainData,
                     zPCHAR   pchReturnCurrencyText,
                     zDecimal dCurrencyText )
{
   if ( dCurrencyText == dInvalidDecimalValue )
   {
      return( SysLoadString( lpDomainData->zView,
                             "tzapdmaa", IDS_UNKNOWN,
                             pchReturnCurrencyText,
                             zMAX_DECIMAL_STRING ) );
   }

   zSHORT nLth = 0;

   zDecimal dDollars = dCurrencyText / 100;
   zSHORT nCents = (zSHORT) (dCurrencyText - (dDollars * 100));
   if ( dDollars == 0L )
   {
      nLth += SysLoadString( lpDomainData->zView,
                             "tzapdmaa", IDS_ONES_0,     // "Zero"
                             pchReturnCurrencyText + nLth,
                             zMAX_DECIMAL_STRING - nLth );
      pchReturnCurrencyText[ nLth++ ] = ' ';
   }
   else
   {
      if ( dDollars >= 1000000 )
      {
         zDecimal dMillions = dDollars / 1000000;
         nLth += HundredsTensOnes( lpDomainData,
                                   pchReturnCurrencyText + nLth,
                                   dMillions );
         pchReturnCurrencyText[ nLth++ ] = ' ';
         nLth += SysLoadString( lpDomainData->zView,
                                "tzapdmaa", IDS_MILLION,    // "Million"
                                pchReturnCurrencyText + nLth,
                                zMAX_DECIMAL_STRING - nLth );
         pchReturnCurrencyText[ nLth++ ] = ' ';
         dDollars -= (dMillions * 1000000);
      }

      if ( dDollars >= 1000 )
      {
         zDecimal dThousands = dDollars / 1000;
         nLth += HundredsTensOnes( lpDomainData,
                                   pchReturnCurrencyText + nLth,
                                   dThousands );
         pchReturnCurrencyText[ nLth++ ] = ' ';
         nLth += SysLoadString( lpDomainData->zView,
                                "tzapdmaa", IDS_THOUSAND,   // "Thousand"
                                pchReturnCurrencyText + nLth,
                                zMAX_DECIMAL_STRING - nLth );
         pchReturnCurrencyText[ nLth++ ] = ' ';
         dDollars -= (dThousands * 1000);
      }

      if ( dDollars > 0 )
      {
         nLth += HundredsTensOnes( lpDomainData,
                                   pchReturnCurrencyText + nLth,
                                   dDollars );
         pchReturnCurrencyText[ nLth++ ] = ' ';
      }
   }

   nLth += SysLoadString( lpDomainData->zView,
                          "tzapdmaa", IDS_AND,        // "and"
                          pchReturnCurrencyText + nLth,
                          zMAX_DECIMAL_STRING - nLth );
   pchReturnCurrencyText[ nLth++ ] = ' ';

   zltoa( nCents, pchReturnCurrencyText + nLth );
   nLth += zstrlen( pchReturnCurrencyText + nLth );
   pchReturnCurrencyText[ nLth++ ] = ' ';

   nLth += SysLoadString( lpDomainData->zView,
                          "tzapdmaa",
                          IDS_HUNDRETHS_DOLLARS,      // "/100ths Dollars"
                          pchReturnCurrencyText + nLth,
                          zMAX_DECIMAL_STRING - nLth );
   return( nLth );
}

zSHORT
HundredsTensOnes( LPDOMAINDATA lpDomainData,
                  zPCHAR   pchReturnHundredsTensOnes,
                  zDecimal dHundredsTensOnes )
{
   zSHORT nLth = 0;

   if ( dHundredsTensOnes >= 100 )
   {
      zDecimal dHundreds = dHundredsTensOnes / 100;
      nLth += SysLoadString( lpDomainData->zView,
                             "tzapdmaa",
                             IDS_ONES_0 + dHundreds,
                             pchReturnHundredsTensOnes + nLth,
                             zMAX_DECIMAL_STRING - nLth );
      pchReturnHundredsTensOnes[ nLth++ ] = ' ';
      nLth += SysLoadString( lpDomainData->zView,
                             "tzapdmaa", IDS_HUNDRED,
                             pchReturnHundredsTensOnes + nLth,
                             zMAX_DECIMAL_STRING - nLth );
      pchReturnHundredsTensOnes[ nLth++ ] = ' ';
      dHundredsTensOnes -= (dHundreds * 100);
   }

   if ( dHundredsTensOnes > 0 )
   {
      nLth += TensOnes( lpDomainData,
                        pchReturnHundredsTensOnes + nLth,
                        dHundredsTensOnes );
   }

   return( nLth );
}

zSHORT
TensOnes( LPDOMAINDATA lpDomainData,
          zPCHAR   pchReturnTensOnes,
          zDecimal dTensOnes )
{
   zSHORT nLth = 0;

   if ( dTensOnes > 19 )
   {
      zDecimal dTens = dTensOnes / 10;
      nLth += SysLoadString( lpDomainData->zView,
                             "tzapdmaa",
                             IDS_TENS_0 + dTens,
                             pchReturnTensOnes + nLth,
                             zMAX_DECIMAL_STRING - nLth );
      dTensOnes -= (dTens * 10);
      if ( dTensOnes > 0 )
      {
         nLth += SysLoadString( lpDomainData->zView,
                                "tzapdmaa",
                                IDS_ONES_0 + dTensOnes,
                                pchReturnTensOnes + nLth,
                                zMAX_DECIMAL_STRING - nLth );
         pchReturnTensOnes[ nLth++ ] = '-';
      }
   }
   else
   if ( dTensOnes >= 10 )
   {
      nLth += SysLoadString( lpDomainData->zView,
                             "tzapdmaa",
                             IDS_TEENS_10 + dTensOnes - 10,
                             pchReturnTensOnes + nLth,
                             zMAX_DECIMAL_STRING - nLth );
   }
   else
   {
      nLth += SysLoadString( lpDomainData->zView,
                             "tzapdmaa",
                             IDS_ONES_0 + dTensOnes,
                             pchReturnTensOnes + nLth,
                             zMAX_DECIMAL_STRING - nLth );
   }

   return( nLth );
}

#endif

void
fnGetEntityName( zPCHAR lpEntity, zPCHAR pchEntityName )
{
   zstrcpy( pchEntityName, ((LPVIEWENTITY) lpEntity)->szName );
}

#ifdef __cplusplus
}
#endif

