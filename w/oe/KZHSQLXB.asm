	TITLE	C:\10C\a\oe\KZHSQLXB.C
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_08DFNL@ABSOLUTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06LHNJ@ACTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CICP@ADD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03MJMD@ALL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08HG@ALLOCATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NNIC@ALPHANUMERIC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05BBIN@ALTER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LACO@AND?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03ENCN@ANY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03JPOO@ARE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02EPAG@AS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03HGDG@ASC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HNNJ@ASSERTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02BKOD@AT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@MMGM@AUTHORIZATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@DFOG@AUTOINCREMENT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03JAGK@AVG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JBBL@BEGIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FEKN@BETWEEN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06ICJB@BINARY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IODA@BIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HLBB@BOOLEAN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NOIB@BOTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05CPDG@BREAK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIPA@BROWSE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OLDH@BULK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02HFGP@BY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EHOP@BYTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HJNK@CASCADE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GIOF@CASCADED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LCDH@CASE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LBNA@CAST?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CPI@CATALOG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MLPN@CHAR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09MNBH@CHARACTER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LGJP@CHARACTER_LENGTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@OBEF@CHAR_LENGTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JHFD@CHECK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CINA@CHECKPOINT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05PHOA@CLOSE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GMHN@CLUSTERED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DMIM@COALESCE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HABJ@COLLATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JEOK@COLLATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06LGEH@COLUMN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06NAIG@COMMIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09BMPB@COMMITTED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FDPF@COMPUTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ODJF@CONFIRM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07DKLG@CONNECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@ICLB@CONNECTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@LNCA@CONSTRAINT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GMLE@CONSTRAINTS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08HDIP@CONTINUE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@BOLK@CONTROLROW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07DJAE@CONVERT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@MOMH@CORRESPONDING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05BNPO@COUNT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CCFH@COUNTER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JBCM@CREATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05BLP@CROSS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08CHBF@CURRENCY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HGLC@CURRENT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NEAE@CURRENT_DATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NIMH@CURRENT_TIME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@GGBA@CURRENT_TIMESTAMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@KBKG@CURRENT_USER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MDJJ@CURSOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PKHN@DATABASE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CJNM@DATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08MIJC@DATETIME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IDGA@DAY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OPFP@DBAREA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CLGJ@DBCC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@JGIO@DEALLOCATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DAPA@DEBUG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CJJP@DECLARE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FBHA@DEFAULT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@POBB@DEFERRABLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IEEN@DEFERRED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FMHL@DELETE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PPKB@DESC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FBJG@DESCRIBE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GKAF@DESCRIPTOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@OKKK@DIAGNOSTICS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GADM@DISALLOW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGBA@DISCONNECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HDPG@DISK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08EGKJ@DISTINCT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@EMHJ@DISTINCTROW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@ONJI@DISTRIBUTED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06EIOP@DOMAIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06CGGE@DOUBLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LDDE@DROP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JGEC@DUMMY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CAAA@DUMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OHCC@ELSE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PIHE@END?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GNOH@END_EXEC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LKIC@EQV?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06BKPA@ERRLVL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09EIBF@ERROREXIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MJIP@ESCAPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06GDHH@EXCEPT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09EEOO@EXCEPTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GMDG@EXEC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07DNBH@EXECUTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MBBB@EXISTS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HPFN@EXIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@ILPO@EXPIREDATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08EDIC@EXTERNAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07IODP@EXTRACT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05LLOB@FALSE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KBKM@FETCH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CMDA@FILE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@NPIO@FILLFACTOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05MPDO@FIRST?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JDEL@FLOAT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FFP@FLOAT4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PLLL@FLOAT8?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IPNK@FLOPPY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03EOOH@FOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ECFK@FOREIGN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EJD@FROM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CLJK@FULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03HLIC@GET?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PODI@GETDEFAULT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06EKIF@GLOBAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DLHO@GOTO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DLPA@GRANT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JGM@GROUP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BGHA@GUID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06GNBD@HAVING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JHAN@HOLDLOCK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PJ@HOUR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08MFJF@IDENTITY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@EOA@IDENTITYCOL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JADB@IDENTITY_INSERT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CMNP@IEEEDOUBLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@FEGJ@IEEESINGLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02FDOJ@IF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HLND@IGNORE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09LEPP@IMMEDIATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03BIEI@IMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02HFB@IN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05HKPP@INDEX?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09BAOC@INITIALLY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05EPPB@INNER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05IHIC@INPUT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@PDHJ@INSENSITIVE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06CCAI@INSERT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IJOL@INT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KMGD@INTEGER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PEKL@INTEGER1?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08LBC@INTEGER2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GIDA@INTERSECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JNLE@INTERVAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JMBE@INTO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02PKFC@IS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JCKC@ISOLATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JIJO@JOIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PHBO@KEY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EIJF@KILL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GBPO@LAST?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HHCE@LEADING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PAN@LEFT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JJEC@LEVEL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CNFB@LIKE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MJFP@LINENO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PDLA@LOAD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JIPK@LOCAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07OAKI@LOGICAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08KCOH@LOGICAL1?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NIAI@LONG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GKBM@LONGBINARY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08HLJO@LONGTEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NFKB@MATCH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03OLFE@MAX?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KGIF@MEMO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IAC@MIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IOKL@MINUTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GNDP@MIRROREXIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03HOGL@MOD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05EBDH@MONEY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DOND@MONTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KDIJ@NAMES?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08CHPD@NATIONAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BGPN@NATURAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DFM@NCHAR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04ONKL@NEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NAJC@NEXTLOG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02MMJD@NO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07IMID@NOCHECK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NJNJ@NONCLUSTERED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CBCA@NOT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DFCK@NOTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HGII@NULLIF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MDMK@NUMBER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FIAN@NUMERIC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@PBNP@OCTET_LENGTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02CEBG@OF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CMJG@OFF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FMHE@OFFSETS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GMOF@OLEOBJECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02HAKO@ON?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EJJC@ONCE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MKAH@ONLY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MIME@OPEN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IFCC@OPTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02CHDK@OR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05FBEP@ORDER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05IKJL@OUTER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06BMBF@OUTPUT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HDCH@OVER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PGNB@OVERLAPS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GPH@OWNERACCESS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03BHFD@PAD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PEIP@PARAMETERS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MOBO@PARTIAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MGCH@PERCENT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04ICKI@PERM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JLAF@PERMANENT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CDKK@PIPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05MALJ@PIVOT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OOOE@PLAN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BGJK@POSITION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09LJHE@PRECISION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07OCNH@PREPARE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07JPNB@PRESEVE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07PLFH@PRIMARY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05MJOK@PRINT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05CADC@PRIOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IFKE@PRIVILEGES?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFJE@PROC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HPKL@PROCEDURE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@CNCJ@PROCESSEXIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JPM@PUBLIC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09EHBK@RAISERROR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GHHF@READ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IEGM@READTEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DDMN@REAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@CLEO@RECONFIGURE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DHND@REFERENCES?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NDFO@RELATIVE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DEIL@REPEATABLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GBCL@REPLICATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BEHK@RESTRICT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09NACH@RETAINDAY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PJJM@RETURN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MEJM@REVOKE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JCNK@RIGHT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08EMFJ@ROLLBACK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08MGKJ@ROWCOUNT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LCCO@ROWS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BFNM@RULE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KLBG@SAVE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06NIIF@SCHEMA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JLNB@SCROLL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FCJA@SECOND?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OGAC@SELECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CCJF@SERIALIZABLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CGDO@SESSION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@JGA@SESSION_USER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03BCLC@SET?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07EDEP@SETUSER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05HFLA@SHORT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DPKF@SHUTDOWN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FONC@SINGLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NEFN@SIZE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DMN@SMALLINT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DDNG@SOME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JCH@SPACE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DHID@SQLSTATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@JMMG@STATISTICS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KHBF@STDEV?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OCBH@STDEVP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JDFN@STRING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CPEE@SUM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@JBHB@SYSTEM_USER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DLJE@TABLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07DAKP@TABLEID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CGFH@TAPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FEEL@TEMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09EAGL@TEMPORARY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NILO@TEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FIJO@TEXTSIZE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GJFM@THEN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFBP@TIME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KEAG@TIMESTAMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@OCJA@TIMEZONE_HOUR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@OAII@TIMEZONE_MINUTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02DODL@TO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03JOIO@TOP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NJGC@TRAILING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CGAE@TRAN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@JACB@TRANSACTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09ECBO@TRANSFORM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HNKP@TRANSLATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LOEK@TRANSLATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07GNLP@TRIGGER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LNAG@TRUE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FCAH@TRUNCATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CODK@TSEQUAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@PJEA@UNCOMMITTED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05LNOP@UNION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06LNBM@UNIQUE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CNPM@UNKNOWN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06NDPG@UPDATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DPMH@UPDATETEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05PMKE@USAGE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03OAHE@USE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FMHO@USER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JKMB@USING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05MOEL@VALUE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06KGMH@VALUES?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03KNCG@VAR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09OLDK@VARBINARY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NGFA@VARCHAR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OIBN@VARP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MMOJ@VARYING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CGLB@VIEW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IEGE@VOLUME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KCD@WAITFOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GKK@WHEN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05MCFK@WHERE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05LCLH@WHILE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NHMN@WITH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LDPM@WORK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05FIFP@WRITE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09IKOB@WRITETEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03BDEP@XOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HEBB@YEAR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NAPJ@YESNO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HOL@ZONE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01A@?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FAJB@?$DL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@FNLO@DROP?5INDEX?5?$CFs?5ON?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IAKB@TZTEDBLO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EALC@DBMS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@BCDD@TE_DBMS_Source?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DKGC@DBH_Data?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PCJP@Y?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KJKI@TimestampAsString?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JENC@ODBC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@GNCH@MaxColumnNameLength?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EFNI@Name?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PJGE@TE_FieldDataRel?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FNON@DataType?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DOMO@?$CF?9?$CKs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06CAAP@Length?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FENM@?5varchar?$CI?5?$CFld?5?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CPOG@?5longblob?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09IJHK@?5datetime?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OGMO@?5int?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CLFL@?5double?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DKHG@?5longtext?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@OLJF@?5varchar?$CI?530?5?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@NCMM@TE_TablRec?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@EKKO@Invalid?5DataType?5?8?$CFs?8?5for?5attrib@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KEK@SQL?5DDL?5Generator?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09LPMC@SQL_NULLS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IDDA@NOT?5NULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FGIB@NULL?5?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@HJOL@DefaultOwner?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@CNMG@SQL_TableOwner?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PJCK@?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KOPE@MaxTableNameLength?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DKMG@Desc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02BOOO@?$CK?1?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02FCCF@?1?$CK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BBDM@ZKey?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PAOO@B?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FCOA@?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CNO@ER_Entity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@GKMP@?$CFs?5Main?5key?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CEBI@IndexName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@LKEB@TE_TablRecKey?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@EFNH@U?$CFs_?$CFs_?$CFld0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@HCMD@CREATE?5UNIQUE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGBL@?$CF?$CKs?5?$CFs?0?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@PCJM@?$CFs?5Entity?5?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@HMHF@CREATE?5TABLE?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BAFE@?$CF?$CKs?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GPPE@?0?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NLEE@?5?$CJ?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07JAEB@COMMIT?$DL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01OAK@N?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JNHE@GenCreateTables?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GNHG@DropTables?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@CFLN@GenCreateIdxs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GBEE@GenDropIdxs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PMIC@?4ddl?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MOMC@?$CFs?5CREATE?5DATABASE?5?$CFs?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DDBF@USE?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@IABD@?$CFs?5Indexes?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05FCKF@?$CFs_?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07PHBB@B_AEIOU?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LGDF@?$CF02d?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@PLEK@DROP?5TABLE?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@OLHP@GRANT?5ALL?5ON?5?$CFs?$CFs?5TO?5PUBLIC?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05EGAJ@File?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@MMCL@?5is?5created?5successfully?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@PJOD@Couldn?8t?5create?5file?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@PLHO@Generate?5DDL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@NKCB@Executable?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@JHOI@RetrieveSchema?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DF@MNGA@Couldn?8t?5find?5?8BuildSyncDDL?8?5in?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DNAH@Physical?5Data?5Model?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07LDCE@TE00422?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06NGI@_alter?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@EBOB@?$CFs?5Alter?5script?5for?5?$CFs?5?9?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@FFM@MatchFound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PJM@D?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@FPJB@ALTER?5TABLE?5?$CFs?5ADD?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MKDI@DROP?5TABLE?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@OHJM@ALTER?5TABLE?5?$CFs?$CFs?5DROP?5COLUMN?5?$CFs?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@MGNG@ALTER?5TABLE?5?$CFs?$CF?9?$CKs?5ALTER?5COLUMN?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BAI@KIFF@WARNING?3?5The?5data?5type?5for?5the?5c@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@HFPH@DDL?5Generationg?5Warning?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FJ@KCOE@?$CFs?5WARNING?9?9Following?5index?5may?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@INLJ@DB_DataTypes?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PDAJ@S?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CCA@InternalName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PINC@String?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NAC@ExternalName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FLCE@L?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HDOI@Integer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PBLD@M?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07DBJI@Decimal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KGOM@T?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KMOL@Timestamp?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FIAI@X?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@BADB@TimeStampEx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OMLL@Date?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FLOP@I?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OAHI@Time?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FKLC@F?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GOGB@FixedChar?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@IMGI@Blob?5?$CIlongblob?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PDMC@V?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NGGL@Text?5?$CIlongtext?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06CDGA@Domain?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LBCJ@Lth?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@IKDH@ER_Attribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@FPPC@MaxStringLth?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@CCFO@?$CITE?$CJ?5Invalid?5Physical?5Data?5type?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@EEGE@Invalid?5Physical?5Data?5type?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09PLDP@Zeidon?5TE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02IALC@z_?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02IKBN@B_?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02IPGJ@Bc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PPLE@DATARECORD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@PNOD@CHILDENTITY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JEIA@DATAFIELD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MPNE@FLDTYPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CDIB@XVAATT_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06BLIJ@ATTRIB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NHDL@LOD_EntityParent?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@FMLJ@TE_DBMS_SourceForEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GNEF@SQL_JoinWithParent?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@KKLH@POD_Entity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@FFFI@ER_RelLinkRec?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NHPD@CardMax?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09PPA@ERENT_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DPNM@ERREL_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DPMI@LOD_EntityChild?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NFHJ@ER_EntityRec?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EK@BEMO@You?5need?5to?5do?5a?5?8Set?5DBH?8?5for?5t@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@BDOD@Zeidon?5Tools?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@PBGA@PostXOD_BuildHook?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@JMGI@?$CK?$CK?$CK?5PostXOD_BuildHook?5TZDBHODO?5d@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DKCM@TZDBHODO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KPGG@TimestampPrecision?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PIJH@OBJECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??_C@_0L@GKAF@DESCRIPTOR?$AA@			; `string'
PUBLIC	??_C@_0M@OKKK@DIAGNOSTICS?$AA@			; `string'
PUBLIC	??_C@_08GADM@DISALLOW?$AA@			; `string'
PUBLIC	??_C@_0L@OGBA@DISCONNECT?$AA@			; `string'
PUBLIC	??_C@_04HDPG@DISK?$AA@				; `string'
PUBLIC	??_C@_08EGKJ@DISTINCT?$AA@			; `string'
PUBLIC	??_C@_0M@EMHJ@DISTINCTROW?$AA@			; `string'
PUBLIC	??_C@_0M@ONJI@DISTRIBUTED?$AA@			; `string'
PUBLIC	??_C@_06EIOP@DOMAIN?$AA@			; `string'
PUBLIC	??_C@_06CGGE@DOUBLE?$AA@			; `string'
PUBLIC	??_C@_04LDDE@DROP?$AA@				; `string'
PUBLIC	??_C@_05JGEC@DUMMY?$AA@				; `string'
PUBLIC	??_C@_04CAAA@DUMP?$AA@				; `string'
PUBLIC	??_C@_04OHCC@ELSE?$AA@				; `string'
PUBLIC	??_C@_03PIHE@END?$AA@				; `string'
PUBLIC	??_C@_08GNOH@END_EXEC?$AA@			; `string'
PUBLIC	??_C@_03LKIC@EQV?$AA@				; `string'
PUBLIC	??_C@_06BKPA@ERRLVL?$AA@			; `string'
PUBLIC	??_C@_09EIBF@ERROREXIT?$AA@			; `string'
PUBLIC	??_C@_06MJIP@ESCAPE?$AA@			; `string'
PUBLIC	??_C@_06GDHH@EXCEPT?$AA@			; `string'
PUBLIC	??_C@_09EEOO@EXCEPTION?$AA@			; `string'
PUBLIC	??_C@_04GMDG@EXEC?$AA@				; `string'
PUBLIC	??_C@_07DNBH@EXECUTE?$AA@			; `string'
PUBLIC	??_C@_06MBBB@EXISTS?$AA@			; `string'
PUBLIC	??_C@_04HPFN@EXIT?$AA@				; `string'
PUBLIC	??_C@_0L@ILPO@EXPIREDATE?$AA@			; `string'
PUBLIC	??_C@_08EDIC@EXTERNAL?$AA@			; `string'
PUBLIC	??_C@_07IODP@EXTRACT?$AA@			; `string'
PUBLIC	??_C@_05LLOB@FALSE?$AA@				; `string'
PUBLIC	??_C@_05KBKM@FETCH?$AA@				; `string'
PUBLIC	??_C@_04CMDA@FILE?$AA@				; `string'
PUBLIC	??_C@_0L@NPIO@FILLFACTOR?$AA@			; `string'
PUBLIC	??_C@_05MPDO@FIRST?$AA@				; `string'
PUBLIC	??_C@_05JDEL@FLOAT?$AA@				; `string'
PUBLIC	??_C@_06FFP@FLOAT4?$AA@				; `string'
PUBLIC	??_C@_06PLLL@FLOAT8?$AA@			; `string'
PUBLIC	??_C@_06IPNK@FLOPPY?$AA@			; `string'
PUBLIC	??_C@_03EOOH@FOR?$AA@				; `string'
PUBLIC	??_C@_07ECFK@FOREIGN?$AA@			; `string'
PUBLIC	??_C@_04EJD@FROM?$AA@				; `string'
PUBLIC	??_C@_04CLJK@FULL?$AA@				; `string'
PUBLIC	??_C@_03HLIC@GET?$AA@				; `string'
PUBLIC	??_C@_0L@PODI@GETDEFAULT?$AA@			; `string'
PUBLIC	??_C@_06EKIF@GLOBAL?$AA@			; `string'
PUBLIC	??_C@_04DLHO@GOTO?$AA@				; `string'
PUBLIC	??_C@_05DLPA@GRANT?$AA@				; `string'
PUBLIC	??_C@_05JGM@GROUP?$AA@				; `string'
PUBLIC	??_C@_04BGHA@GUID?$AA@				; `string'
PUBLIC	??_C@_06GNBD@HAVING?$AA@			; `string'
PUBLIC	??_C@_08JHAN@HOLDLOCK?$AA@			; `string'
PUBLIC	??_C@_04PJ@HOUR?$AA@				; `string'
PUBLIC	??_C@_08MFJF@IDENTITY?$AA@			; `string'
PUBLIC	??_C@_0M@EOA@IDENTITYCOL?$AA@			; `string'
PUBLIC	??_C@_0BA@JADB@IDENTITY_INSERT?$AA@		; `string'
PUBLIC	??_C@_0L@CMNP@IEEEDOUBLE?$AA@			; `string'
PUBLIC	??_C@_0L@FEGJ@IEEESINGLE?$AA@			; `string'
PUBLIC	??_C@_02FDOJ@IF?$AA@				; `string'
PUBLIC	??_C@_06HLND@IGNORE?$AA@			; `string'
PUBLIC	??_C@_09LEPP@IMMEDIATE?$AA@			; `string'
PUBLIC	??_C@_03BIEI@IMP?$AA@				; `string'
PUBLIC	??_C@_02HFB@IN?$AA@				; `string'
PUBLIC	??_C@_05HKPP@INDEX?$AA@				; `string'
PUBLIC	??_C@_09BAOC@INITIALLY?$AA@			; `string'
PUBLIC	??_C@_05EPPB@INNER?$AA@				; `string'
PUBLIC	??_C@_05IHIC@INPUT?$AA@				; `string'
PUBLIC	??_C@_0M@PDHJ@INSENSITIVE?$AA@			; `string'
PUBLIC	??_C@_06CCAI@INSERT?$AA@			; `string'
PUBLIC	??_C@_03IJOL@INT?$AA@				; `string'
PUBLIC	??_C@_07KMGD@INTEGER?$AA@			; `string'
PUBLIC	??_C@_08PEKL@INTEGER1?$AA@			; `string'
PUBLIC	??_C@_08LBC@INTEGER2?$AA@			; `string'
PUBLIC	??_C@_09GIDA@INTERSECT?$AA@			; `string'
PUBLIC	??_C@_08JNLE@INTERVAL?$AA@			; `string'
PUBLIC	??_C@_04JMBE@INTO?$AA@				; `string'
PUBLIC	??_C@_02PKFC@IS?$AA@				; `string'
PUBLIC	??_C@_09JCKC@ISOLATION?$AA@			; `string'
PUBLIC	??_C@_04JIJO@JOIN?$AA@				; `string'
PUBLIC	??_C@_03PHBO@KEY?$AA@				; `string'
PUBLIC	??_C@_04EIJF@KILL?$AA@				; `string'
PUBLIC	??_C@_04GBPO@LAST?$AA@				; `string'
PUBLIC	??_C@_07HHCE@LEADING?$AA@			; `string'
PUBLIC	??_C@_04PAN@LEFT?$AA@				; `string'
PUBLIC	??_C@_05JJEC@LEVEL?$AA@				; `string'
PUBLIC	??_C@_04CNFB@LIKE?$AA@				; `string'
PUBLIC	??_C@_06MJFP@LINENO?$AA@			; `string'
PUBLIC	??_C@_04PDLA@LOAD?$AA@				; `string'
PUBLIC	??_C@_05JIPK@LOCAL?$AA@				; `string'
PUBLIC	??_C@_07OAKI@LOGICAL?$AA@			; `string'
PUBLIC	??_C@_08KCOH@LOGICAL1?$AA@			; `string'
PUBLIC	??_C@_04NIAI@LONG?$AA@				; `string'
PUBLIC	??_C@_0L@GKBM@LONGBINARY?$AA@			; `string'
PUBLIC	??_C@_08HLJO@LONGTEXT?$AA@			; `string'
PUBLIC	??_C@_05NFKB@MATCH?$AA@				; `string'
PUBLIC	??_C@_03OLFE@MAX?$AA@				; `string'
PUBLIC	??_C@_04KGIF@MEMO?$AA@				; `string'
PUBLIC	??_C@_03IAC@MIN?$AA@				; `string'
PUBLIC	??_C@_06IOKL@MINUTE?$AA@			; `string'
PUBLIC	??_C@_0L@GNDP@MIRROREXIT?$AA@			; `string'
PUBLIC	??_C@_03HOGL@MOD?$AA@				; `string'
PUBLIC	??_C@_05EBDH@MONEY?$AA@				; `string'
PUBLIC	??_C@_05DOND@MONTH?$AA@				; `string'
PUBLIC	??_C@_05KDIJ@NAMES?$AA@				; `string'
PUBLIC	??_C@_08CHPD@NATIONAL?$AA@			; `string'
PUBLIC	??_C@_07BGPN@NATURAL?$AA@			; `string'
PUBLIC	??_C@_05DFM@NCHAR?$AA@				; `string'
PUBLIC	??_C@_04ONKL@NEXT?$AA@				; `string'
PUBLIC	??_C@_07NAJC@NEXTLOG?$AA@			; `string'
PUBLIC	??_C@_02MMJD@NO?$AA@				; `string'
PUBLIC	??_C@_07IMID@NOCHECK?$AA@			; `string'
PUBLIC	??_C@_0N@NJNJ@NONCLUSTERED?$AA@			; `string'
PUBLIC	??_C@_03CBCA@NOT?$AA@				; `string'
PUBLIC	??_C@_04DFCK@NOTE?$AA@				; `string'
PUBLIC	??_C@_04BAK@NULL?$AA@				; `string'
PUBLIC	??_C@_06HGII@NULLIF?$AA@			; `string'
PUBLIC	??_C@_06MDMK@NUMBER?$AA@			; `string'
PUBLIC	??_C@_07FIAN@NUMERIC?$AA@			; `string'
PUBLIC	??_C@_0N@PBNP@OCTET_LENGTH?$AA@			; `string'
PUBLIC	??_C@_02CEBG@OF?$AA@				; `string'
PUBLIC	??_C@_03CMJG@OFF?$AA@				; `string'
PUBLIC	??_C@_07FMHE@OFFSETS?$AA@			; `string'
PUBLIC	??_C@_09GMOF@OLEOBJECT?$AA@			; `string'
PUBLIC	??_C@_02HAKO@ON?$AA@				; `string'
PUBLIC	??_C@_04EJJC@ONCE?$AA@				; `string'
PUBLIC	??_C@_04MKAH@ONLY?$AA@				; `string'
PUBLIC	??_C@_04MIME@OPEN?$AA@				; `string'
PUBLIC	??_C@_06IFCC@OPTION?$AA@			; `string'
PUBLIC	??_C@_02CHDK@OR?$AA@				; `string'
PUBLIC	??_C@_05FBEP@ORDER?$AA@				; `string'
PUBLIC	??_C@_05IKJL@OUTER?$AA@				; `string'
PUBLIC	??_C@_06BMBF@OUTPUT?$AA@			; `string'
PUBLIC	??_C@_04HDCH@OVER?$AA@				; `string'
PUBLIC	??_C@_08PGNB@OVERLAPS?$AA@			; `string'
PUBLIC	??_C@_0M@GPH@OWNERACCESS?$AA@			; `string'
PUBLIC	??_C@_03BHFD@PAD?$AA@				; `string'
PUBLIC	??_C@_0L@PEIP@PARAMETERS?$AA@			; `string'
PUBLIC	??_C@_07MOBO@PARTIAL?$AA@			; `string'
PUBLIC	??_C@_07MGCH@PERCENT?$AA@			; `string'
PUBLIC	??_C@_04ICKI@PERM?$AA@				; `string'
PUBLIC	??_C@_09JLAF@PERMANENT?$AA@			; `string'
PUBLIC	??_C@_04CDKK@PIPE?$AA@				; `string'
PUBLIC	??_C@_05MALJ@PIVOT?$AA@				; `string'
PUBLIC	??_C@_04OOOE@PLAN?$AA@				; `string'
PUBLIC	??_C@_08BGJK@POSITION?$AA@			; `string'
PUBLIC	??_C@_09LJHE@PRECISION?$AA@			; `string'
PUBLIC	??_C@_07OCNH@PREPARE?$AA@			; `string'
PUBLIC	??_C@_07JPNB@PRESEVE?$AA@			; `string'
PUBLIC	??_C@_07PLFH@PRIMARY?$AA@			; `string'
PUBLIC	??_C@_05MJOK@PRINT?$AA@				; `string'
PUBLIC	??_C@_05CADC@PRIOR?$AA@				; `string'
PUBLIC	??_C@_0L@IFKE@PRIVILEGES?$AA@			; `string'
PUBLIC	??_C@_04CFJE@PROC?$AA@				; `string'
PUBLIC	??_C@_09HPKL@PROCEDURE?$AA@			; `string'
PUBLIC	??_C@_0M@CNCJ@PROCESSEXIT?$AA@			; `string'
PUBLIC	??_C@_06JPM@PUBLIC?$AA@				; `string'
PUBLIC	??_C@_09EHBK@RAISERROR?$AA@			; `string'
PUBLIC	??_C@_04GHHF@READ?$AA@				; `string'
PUBLIC	??_C@_08IEGM@READTEXT?$AA@			; `string'
PUBLIC	??_C@_04DDMN@REAL?$AA@				; `string'
PUBLIC	??_C@_0M@CLEO@RECONFIGURE?$AA@			; `string'
PUBLIC	??_C@_0L@DHND@REFERENCES?$AA@			; `string'
PUBLIC	??_C@_08NDFO@RELATIVE?$AA@			; `string'
PUBLIC	??_C@_0L@DEIL@REPEATABLE?$AA@			; `string'
PUBLIC	??_C@_0M@GBCL@REPLICATION?$AA@			; `string'
PUBLIC	??_C@_08BEHK@RESTRICT?$AA@			; `string'
PUBLIC	??_C@_09NACH@RETAINDAY?$AA@			; `string'
PUBLIC	??_C@_06PJJM@RETURN?$AA@			; `string'
PUBLIC	??_C@_06MEJM@REVOKE?$AA@			; `string'
PUBLIC	??_C@_05JCNK@RIGHT?$AA@				; `string'
PUBLIC	??_C@_08EMFJ@ROLLBACK?$AA@			; `string'
PUBLIC	??_C@_08MGKJ@ROWCOUNT?$AA@			; `string'
PUBLIC	??_C@_04LCCO@ROWS?$AA@				; `string'
PUBLIC	??_C@_04BFNM@RULE?$AA@				; `string'
PUBLIC	??_C@_04KLBG@SAVE?$AA@				; `string'
PUBLIC	??_C@_06NIIF@SCHEMA?$AA@			; `string'
PUBLIC	??_C@_06JLNB@SCROLL?$AA@			; `string'
PUBLIC	??_C@_06FCJA@SECOND?$AA@			; `string'
PUBLIC	??_C@_06OGAC@SELECT?$AA@			; `string'
PUBLIC	??_C@_0N@CCJF@SERIALIZABLE?$AA@			; `string'
PUBLIC	??_C@_07CGDO@SESSION?$AA@			; `string'
PUBLIC	??_C@_0N@JGA@SESSION_USER?$AA@			; `string'
PUBLIC	??_C@_03BCLC@SET?$AA@				; `string'
PUBLIC	??_C@_07EDEP@SETUSER?$AA@			; `string'
PUBLIC	??_C@_05HFLA@SHORT?$AA@				; `string'
PUBLIC	??_C@_08DPKF@SHUTDOWN?$AA@			; `string'
PUBLIC	??_C@_06FONC@SINGLE?$AA@			; `string'
PUBLIC	??_C@_04NEFN@SIZE?$AA@				; `string'
PUBLIC	??_C@_08DMN@SMALLINT?$AA@			; `string'
PUBLIC	??_C@_04DDNG@SOME?$AA@				; `string'
PUBLIC	??_C@_05JCH@SPACE?$AA@				; `string'
PUBLIC	??_C@_08DHID@SQLSTATE?$AA@			; `string'
PUBLIC	??_C@_0L@JMMG@STATISTICS?$AA@			; `string'
PUBLIC	??_C@_05KHBF@STDEV?$AA@				; `string'
PUBLIC	??_C@_06OCBH@STDEVP?$AA@			; `string'
PUBLIC	??_C@_06JDFN@STRING?$AA@			; `string'
PUBLIC	??_C@_03CPEE@SUM?$AA@				; `string'
PUBLIC	??_C@_0M@JBHB@SYSTEM_USER?$AA@			; `string'
PUBLIC	??_C@_05DLJE@TABLE?$AA@				; `string'
PUBLIC	??_C@_07DAKP@TABLEID?$AA@			; `string'
PUBLIC	??_C@_04CGFH@TAPE?$AA@				; `string'
PUBLIC	??_C@_04FEEL@TEMP?$AA@				; `string'
PUBLIC	??_C@_09EAGL@TEMPORARY?$AA@			; `string'
PUBLIC	??_C@_04NILO@TEXT?$AA@				; `string'
PUBLIC	??_C@_08FIJO@TEXTSIZE?$AA@			; `string'
PUBLIC	??_C@_04GJFM@THEN?$AA@				; `string'
PUBLIC	??_C@_04CFBP@TIME?$AA@				; `string'
PUBLIC	??_C@_09KEAG@TIMESTAMP?$AA@			; `string'
PUBLIC	??_C@_0O@OCJA@TIMEZONE_HOUR?$AA@		; `string'
PUBLIC	??_C@_0BA@OAII@TIMEZONE_MINUTE?$AA@		; `string'
PUBLIC	??_C@_02DODL@TO?$AA@				; `string'
PUBLIC	??_C@_03JOIO@TOP?$AA@				; `string'
PUBLIC	??_C@_08NJGC@TRAILING?$AA@			; `string'
PUBLIC	??_C@_04CGAE@TRAN?$AA@				; `string'
PUBLIC	??_C@_0M@JACB@TRANSACTION?$AA@			; `string'
PUBLIC	??_C@_09ECBO@TRANSFORM?$AA@			; `string'
PUBLIC	??_C@_09HNKP@TRANSLATE?$AA@			; `string'
PUBLIC	??_C@_0M@LOEK@TRANSLATION?$AA@			; `string'
PUBLIC	??_C@_07GNLP@TRIGGER?$AA@			; `string'
PUBLIC	??_C@_04LNAG@TRUE?$AA@				; `string'
PUBLIC	??_C@_08FCAH@TRUNCATE?$AA@			; `string'
PUBLIC	??_C@_07CODK@TSEQUAL?$AA@			; `string'
PUBLIC	??_C@_0M@PJEA@UNCOMMITTED?$AA@			; `string'
PUBLIC	??_C@_05LNOP@UNION?$AA@				; `string'
PUBLIC	??_C@_06LNBM@UNIQUE?$AA@			; `string'
PUBLIC	??_C@_07CNPM@UNKNOWN?$AA@			; `string'
PUBLIC	??_C@_06NDPG@UPDATE?$AA@			; `string'
PUBLIC	??_C@_0L@DPMH@UPDATETEXT?$AA@			; `string'
PUBLIC	??_C@_05PMKE@USAGE?$AA@				; `string'
PUBLIC	??_C@_03OAHE@USE?$AA@				; `string'
PUBLIC	??_C@_04FMHO@USER?$AA@				; `string'
PUBLIC	??_C@_05JKMB@USING?$AA@				; `string'
PUBLIC	??_C@_05MOEL@VALUE?$AA@				; `string'
PUBLIC	??_C@_06KGMH@VALUES?$AA@			; `string'
PUBLIC	??_C@_03KNCG@VAR?$AA@				; `string'
PUBLIC	??_C@_09OLDK@VARBINARY?$AA@			; `string'
PUBLIC	??_C@_07NGFA@VARCHAR?$AA@			; `string'
PUBLIC	??_C@_04OIBN@VARP?$AA@				; `string'
PUBLIC	??_C@_07MMOJ@VARYING?$AA@			; `string'
PUBLIC	??_C@_04CGLB@VIEW?$AA@				; `string'
PUBLIC	??_C@_06IEGE@VOLUME?$AA@			; `string'
PUBLIC	??_C@_07KCD@WAITFOR?$AA@			; `string'
PUBLIC	??_C@_04GKK@WHEN?$AA@				; `string'
PUBLIC	??_C@_05MCFK@WHERE?$AA@				; `string'
PUBLIC	??_C@_05LCLH@WHILE?$AA@				; `string'
PUBLIC	??_C@_04NHMN@WITH?$AA@				; `string'
PUBLIC	??_C@_04LDPM@WORK?$AA@				; `string'
PUBLIC	??_C@_05FIFP@WRITE?$AA@				; `string'
PUBLIC	??_C@_09IKOB@WRITETEXT?$AA@			; `string'
PUBLIC	??_C@_03BDEP@XOR?$AA@				; `string'
PUBLIC	??_C@_04HEBB@YEAR?$AA@				; `string'
PUBLIC	??_C@_05NAPJ@YESNO?$AA@				; `string'
PUBLIC	??_C@_04HOL@ZONE?$AA@				; `string'
PUBLIC	??_C@_01A@?$AA?$AA@				; `string'
PUBLIC	_szReservedName
PUBLIC	??_C@_08DFNL@ABSOLUTE?$AA@			; `string'
PUBLIC	??_C@_06LHNJ@ACTION?$AA@			; `string'
PUBLIC	??_C@_03CICP@ADD?$AA@				; `string'
PUBLIC	??_C@_03MJMD@ALL?$AA@				; `string'
PUBLIC	??_C@_08HG@ALLOCATE?$AA@			; `string'
PUBLIC	??_C@_0N@NNIC@ALPHANUMERIC?$AA@			; `string'
PUBLIC	??_C@_05BBIN@ALTER?$AA@				; `string'
PUBLIC	??_C@_03LACO@AND?$AA@				; `string'
PUBLIC	??_C@_03ENCN@ANY?$AA@				; `string'
PUBLIC	??_C@_03JPOO@ARE?$AA@				; `string'
PUBLIC	??_C@_02EPAG@AS?$AA@				; `string'
PUBLIC	??_C@_03HGDG@ASC?$AA@				; `string'
PUBLIC	??_C@_09HNNJ@ASSERTION?$AA@			; `string'
PUBLIC	??_C@_02BKOD@AT?$AA@				; `string'
PUBLIC	??_C@_0O@MMGM@AUTHORIZATION?$AA@		; `string'
PUBLIC	??_C@_0O@DFOG@AUTOINCREMENT?$AA@		; `string'
PUBLIC	??_C@_03JAGK@AVG?$AA@				; `string'
PUBLIC	??_C@_05JBBL@BEGIN?$AA@				; `string'
PUBLIC	??_C@_07FEKN@BETWEEN?$AA@			; `string'
PUBLIC	??_C@_06ICJB@BINARY?$AA@			; `string'
PUBLIC	??_C@_03IODA@BIT?$AA@				; `string'
PUBLIC	??_C@_07HLBB@BOOLEAN?$AA@			; `string'
PUBLIC	??_C@_04NOIB@BOTH?$AA@				; `string'
PUBLIC	??_C@_05CPDG@BREAK?$AA@				; `string'
PUBLIC	??_C@_06MIPA@BROWSE?$AA@			; `string'
PUBLIC	??_C@_04OLDH@BULK?$AA@				; `string'
PUBLIC	??_C@_02HFGP@BY?$AA@				; `string'
PUBLIC	??_C@_04EHOP@BYTE?$AA@				; `string'
PUBLIC	??_C@_07HJNK@CASCADE?$AA@			; `string'
PUBLIC	??_C@_08GIOF@CASCADED?$AA@			; `string'
PUBLIC	??_C@_04LCDH@CASE?$AA@				; `string'
PUBLIC	??_C@_04LBNA@CAST?$AA@				; `string'
PUBLIC	??_C@_07CPI@CATALOG?$AA@			; `string'
PUBLIC	??_C@_04MLPN@CHAR?$AA@				; `string'
PUBLIC	??_C@_09MNBH@CHARACTER?$AA@			; `string'
PUBLIC	??_C@_0BB@LGJP@CHARACTER_LENGTH?$AA@		; `string'
PUBLIC	??_C@_0M@OBEF@CHAR_LENGTH?$AA@			; `string'
PUBLIC	??_C@_05JHFD@CHECK?$AA@				; `string'
PUBLIC	??_C@_0L@CINA@CHECKPOINT?$AA@			; `string'
PUBLIC	??_C@_05PHOA@CLOSE?$AA@				; `string'
PUBLIC	??_C@_09GMHN@CLUSTERED?$AA@			; `string'
PUBLIC	??_C@_08DMIM@COALESCE?$AA@			; `string'
PUBLIC	??_C@_07HABJ@COLLATE?$AA@			; `string'
PUBLIC	??_C@_09JEOK@COLLATION?$AA@			; `string'
PUBLIC	??_C@_06LGEH@COLUMN?$AA@			; `string'
PUBLIC	??_C@_06NAIG@COMMIT?$AA@			; `string'
PUBLIC	??_C@_09BMPB@COMMITTED?$AA@			; `string'
PUBLIC	??_C@_07FDPF@COMPUTE?$AA@			; `string'
PUBLIC	??_C@_07ODJF@CONFIRM?$AA@			; `string'
PUBLIC	??_C@_07DKLG@CONNECT?$AA@			; `string'
PUBLIC	??_C@_0L@ICLB@CONNECTION?$AA@			; `string'
PUBLIC	??_C@_0L@LNCA@CONSTRAINT?$AA@			; `string'
PUBLIC	??_C@_0M@GMLE@CONSTRAINTS?$AA@			; `string'
PUBLIC	??_C@_08HDIP@CONTINUE?$AA@			; `string'
PUBLIC	??_C@_0L@BOLK@CONTROLROW?$AA@			; `string'
PUBLIC	??_C@_07DJAE@CONVERT?$AA@			; `string'
PUBLIC	??_C@_0O@MOMH@CORRESPONDING?$AA@		; `string'
PUBLIC	??_C@_05BNPO@COUNT?$AA@				; `string'
PUBLIC	??_C@_07CCFH@COUNTER?$AA@			; `string'
PUBLIC	??_C@_06JBCM@CREATE?$AA@			; `string'
PUBLIC	??_C@_05BLP@CROSS?$AA@				; `string'
PUBLIC	??_C@_08CHBF@CURRENCY?$AA@			; `string'
PUBLIC	??_C@_07HGLC@CURRENT?$AA@			; `string'
PUBLIC	??_C@_0N@NEAE@CURRENT_DATE?$AA@			; `string'
PUBLIC	??_C@_0N@NIMH@CURRENT_TIME?$AA@			; `string'
PUBLIC	??_C@_0BC@GGBA@CURRENT_TIMESTAMP?$AA@		; `string'
PUBLIC	??_C@_0N@KBKG@CURRENT_USER?$AA@			; `string'
PUBLIC	??_C@_06MDJJ@CURSOR?$AA@			; `string'
PUBLIC	??_C@_08PKHN@DATABASE?$AA@			; `string'
PUBLIC	??_C@_04CJNM@DATE?$AA@				; `string'
PUBLIC	??_C@_08MIJC@DATETIME?$AA@			; `string'
PUBLIC	??_C@_03IDGA@DAY?$AA@				; `string'
PUBLIC	??_C@_06OPFP@DBAREA?$AA@			; `string'
PUBLIC	??_C@_04CLGJ@DBCC?$AA@				; `string'
PUBLIC	??_C@_0L@JGIO@DEALLOCATE?$AA@			; `string'
PUBLIC	??_C@_05DAPA@DEBUG?$AA@				; `string'
PUBLIC	??_C@_07CJJP@DECLARE?$AA@			; `string'
PUBLIC	??_C@_07FBHA@DEFAULT?$AA@			; `string'
PUBLIC	??_C@_0L@POBB@DEFERRABLE?$AA@			; `string'
PUBLIC	??_C@_08IEEN@DEFERRED?$AA@			; `string'
PUBLIC	??_C@_06FMHL@DELETE?$AA@			; `string'
PUBLIC	??_C@_04PPKB@DESC?$AA@				; `string'
PUBLIC	??_C@_08FBJG@DESCRIBE?$AA@			; `string'
;	COMDAT ??_C@_01A@?$AA?$AA@
_BSS	SEGMENT
??_C@_01A@?$AA?$AA@ DB 02H DUP (?)			; `string'
_BSS	ENDS
_DATA	SEGMENT
_szReservedName DD FLAT:??_C@_08DFNL@ABSOLUTE?$AA@
	DD	FLAT:??_C@_06LHNJ@ACTION?$AA@
	DD	FLAT:??_C@_03CICP@ADD?$AA@
	DD	FLAT:??_C@_03MJMD@ALL?$AA@
	DD	FLAT:??_C@_08HG@ALLOCATE?$AA@
	DD	FLAT:??_C@_0N@NNIC@ALPHANUMERIC?$AA@
	DD	FLAT:??_C@_05BBIN@ALTER?$AA@
	DD	FLAT:??_C@_03LACO@AND?$AA@
	DD	FLAT:??_C@_03ENCN@ANY?$AA@
	DD	FLAT:??_C@_03JPOO@ARE?$AA@
	DD	FLAT:??_C@_02EPAG@AS?$AA@
	DD	FLAT:??_C@_03HGDG@ASC?$AA@
	DD	FLAT:??_C@_09HNNJ@ASSERTION?$AA@
	DD	FLAT:??_C@_02BKOD@AT?$AA@
	DD	FLAT:??_C@_0O@MMGM@AUTHORIZATION?$AA@
	DD	FLAT:??_C@_0O@DFOG@AUTOINCREMENT?$AA@
	DD	FLAT:??_C@_03JAGK@AVG?$AA@
	DD	FLAT:??_C@_05JBBL@BEGIN?$AA@
	DD	FLAT:??_C@_07FEKN@BETWEEN?$AA@
	DD	FLAT:??_C@_06ICJB@BINARY?$AA@
	DD	FLAT:??_C@_03IODA@BIT?$AA@
	DD	FLAT:??_C@_07HLBB@BOOLEAN?$AA@
	DD	FLAT:??_C@_04NOIB@BOTH?$AA@
	DD	FLAT:??_C@_05CPDG@BREAK?$AA@
	DD	FLAT:??_C@_06MIPA@BROWSE?$AA@
	DD	FLAT:??_C@_04OLDH@BULK?$AA@
	DD	FLAT:??_C@_02HFGP@BY?$AA@
	DD	FLAT:??_C@_04EHOP@BYTE?$AA@
	DD	FLAT:??_C@_07HJNK@CASCADE?$AA@
	DD	FLAT:??_C@_08GIOF@CASCADED?$AA@
	DD	FLAT:??_C@_04LCDH@CASE?$AA@
	DD	FLAT:??_C@_04LBNA@CAST?$AA@
	DD	FLAT:??_C@_07CPI@CATALOG?$AA@
	DD	FLAT:??_C@_04MLPN@CHAR?$AA@
	DD	FLAT:??_C@_09MNBH@CHARACTER?$AA@
	DD	FLAT:??_C@_0BB@LGJP@CHARACTER_LENGTH?$AA@
	DD	FLAT:??_C@_0M@OBEF@CHAR_LENGTH?$AA@
	DD	FLAT:??_C@_05JHFD@CHECK?$AA@
	DD	FLAT:??_C@_0L@CINA@CHECKPOINT?$AA@
	DD	FLAT:??_C@_05PHOA@CLOSE?$AA@
	DD	FLAT:??_C@_09GMHN@CLUSTERED?$AA@
	DD	FLAT:??_C@_08DMIM@COALESCE?$AA@
	DD	FLAT:??_C@_07HABJ@COLLATE?$AA@
	DD	FLAT:??_C@_09JEOK@COLLATION?$AA@
	DD	FLAT:??_C@_06LGEH@COLUMN?$AA@
	DD	FLAT:??_C@_06NAIG@COMMIT?$AA@
	DD	FLAT:??_C@_09BMPB@COMMITTED?$AA@
	DD	FLAT:??_C@_07FDPF@COMPUTE?$AA@
	DD	FLAT:??_C@_07ODJF@CONFIRM?$AA@
	DD	FLAT:??_C@_07DKLG@CONNECT?$AA@
	DD	FLAT:??_C@_0L@ICLB@CONNECTION?$AA@
	DD	FLAT:??_C@_0L@LNCA@CONSTRAINT?$AA@
	DD	FLAT:??_C@_0M@GMLE@CONSTRAINTS?$AA@
	DD	FLAT:??_C@_08HDIP@CONTINUE?$AA@
	DD	FLAT:??_C@_0L@BOLK@CONTROLROW?$AA@
	DD	FLAT:??_C@_07DJAE@CONVERT?$AA@
	DD	FLAT:??_C@_0O@MOMH@CORRESPONDING?$AA@
	DD	FLAT:??_C@_05BNPO@COUNT?$AA@
	DD	FLAT:??_C@_07CCFH@COUNTER?$AA@
	DD	FLAT:??_C@_06JBCM@CREATE?$AA@
	DD	FLAT:??_C@_05BLP@CROSS?$AA@
	DD	FLAT:??_C@_08CHBF@CURRENCY?$AA@
	DD	FLAT:??_C@_07HGLC@CURRENT?$AA@
	DD	FLAT:??_C@_0N@NEAE@CURRENT_DATE?$AA@
	DD	FLAT:??_C@_0N@NIMH@CURRENT_TIME?$AA@
	DD	FLAT:??_C@_0BC@GGBA@CURRENT_TIMESTAMP?$AA@
	DD	FLAT:??_C@_0N@KBKG@CURRENT_USER?$AA@
	DD	FLAT:??_C@_06MDJJ@CURSOR?$AA@
	DD	FLAT:??_C@_08PKHN@DATABASE?$AA@
	DD	FLAT:??_C@_04CJNM@DATE?$AA@
	DD	FLAT:??_C@_08MIJC@DATETIME?$AA@
	DD	FLAT:??_C@_03IDGA@DAY?$AA@
	DD	FLAT:??_C@_06OPFP@DBAREA?$AA@
	DD	FLAT:??_C@_04CLGJ@DBCC?$AA@
	DD	FLAT:??_C@_0L@JGIO@DEALLOCATE?$AA@
	DD	FLAT:??_C@_05DAPA@DEBUG?$AA@
	DD	FLAT:??_C@_07CJJP@DECLARE?$AA@
	DD	FLAT:??_C@_07FBHA@DEFAULT?$AA@
	DD	FLAT:??_C@_0L@POBB@DEFERRABLE?$AA@
	DD	FLAT:??_C@_08IEEN@DEFERRED?$AA@
	DD	FLAT:??_C@_06FMHL@DELETE?$AA@
	DD	FLAT:??_C@_04PPKB@DESC?$AA@
	DD	FLAT:??_C@_08FBJG@DESCRIBE?$AA@
	DD	FLAT:??_C@_0L@GKAF@DESCRIPTOR?$AA@
	DD	FLAT:??_C@_0M@OKKK@DIAGNOSTICS?$AA@
	DD	FLAT:??_C@_08GADM@DISALLOW?$AA@
	DD	FLAT:??_C@_0L@OGBA@DISCONNECT?$AA@
	DD	FLAT:??_C@_04HDPG@DISK?$AA@
	DD	FLAT:??_C@_08EGKJ@DISTINCT?$AA@
	DD	FLAT:??_C@_0M@EMHJ@DISTINCTROW?$AA@
	DD	FLAT:??_C@_0M@ONJI@DISTRIBUTED?$AA@
	DD	FLAT:??_C@_06EIOP@DOMAIN?$AA@
	DD	FLAT:??_C@_06CGGE@DOUBLE?$AA@
	DD	FLAT:??_C@_04LDDE@DROP?$AA@
	DD	FLAT:??_C@_05JGEC@DUMMY?$AA@
	DD	FLAT:??_C@_04CAAA@DUMP?$AA@
	DD	FLAT:??_C@_04OHCC@ELSE?$AA@
	DD	FLAT:??_C@_03PIHE@END?$AA@
	DD	FLAT:??_C@_08GNOH@END_EXEC?$AA@
	DD	FLAT:??_C@_03LKIC@EQV?$AA@
	DD	FLAT:??_C@_06BKPA@ERRLVL?$AA@
	DD	FLAT:??_C@_09EIBF@ERROREXIT?$AA@
	DD	FLAT:??_C@_06MJIP@ESCAPE?$AA@
	DD	FLAT:??_C@_06GDHH@EXCEPT?$AA@
	DD	FLAT:??_C@_09EEOO@EXCEPTION?$AA@
	DD	FLAT:??_C@_04GMDG@EXEC?$AA@
	DD	FLAT:??_C@_07DNBH@EXECUTE?$AA@
	DD	FLAT:??_C@_06MBBB@EXISTS?$AA@
	DD	FLAT:??_C@_04HPFN@EXIT?$AA@
	DD	FLAT:??_C@_0L@ILPO@EXPIREDATE?$AA@
	DD	FLAT:??_C@_08EDIC@EXTERNAL?$AA@
	DD	FLAT:??_C@_07IODP@EXTRACT?$AA@
	DD	FLAT:??_C@_05LLOB@FALSE?$AA@
	DD	FLAT:??_C@_05KBKM@FETCH?$AA@
	DD	FLAT:??_C@_04CMDA@FILE?$AA@
	DD	FLAT:??_C@_0L@NPIO@FILLFACTOR?$AA@
	DD	FLAT:??_C@_05MPDO@FIRST?$AA@
	DD	FLAT:??_C@_05JDEL@FLOAT?$AA@
	DD	FLAT:??_C@_06FFP@FLOAT4?$AA@
	DD	FLAT:??_C@_06PLLL@FLOAT8?$AA@
	DD	FLAT:??_C@_06IPNK@FLOPPY?$AA@
	DD	FLAT:??_C@_03EOOH@FOR?$AA@
	DD	FLAT:??_C@_07ECFK@FOREIGN?$AA@
	DD	FLAT:??_C@_04EJD@FROM?$AA@
	DD	FLAT:??_C@_04CLJK@FULL?$AA@
	DD	FLAT:??_C@_03HLIC@GET?$AA@
	DD	FLAT:??_C@_0L@PODI@GETDEFAULT?$AA@
	DD	FLAT:??_C@_06EKIF@GLOBAL?$AA@
	DD	FLAT:??_C@_04DLHO@GOTO?$AA@
	DD	FLAT:??_C@_05DLPA@GRANT?$AA@
	DD	FLAT:??_C@_05JGM@GROUP?$AA@
	DD	FLAT:??_C@_04BGHA@GUID?$AA@
	DD	FLAT:??_C@_06GNBD@HAVING?$AA@
	DD	FLAT:??_C@_08JHAN@HOLDLOCK?$AA@
	DD	FLAT:??_C@_04PJ@HOUR?$AA@
	DD	FLAT:??_C@_08MFJF@IDENTITY?$AA@
	DD	FLAT:??_C@_0M@EOA@IDENTITYCOL?$AA@
	DD	FLAT:??_C@_0BA@JADB@IDENTITY_INSERT?$AA@
	DD	FLAT:??_C@_0L@CMNP@IEEEDOUBLE?$AA@
	DD	FLAT:??_C@_0L@FEGJ@IEEESINGLE?$AA@
	DD	FLAT:??_C@_02FDOJ@IF?$AA@
	DD	FLAT:??_C@_06HLND@IGNORE?$AA@
	DD	FLAT:??_C@_09LEPP@IMMEDIATE?$AA@
	DD	FLAT:??_C@_03BIEI@IMP?$AA@
	DD	FLAT:??_C@_02HFB@IN?$AA@
	DD	FLAT:??_C@_05HKPP@INDEX?$AA@
	DD	FLAT:??_C@_09BAOC@INITIALLY?$AA@
	DD	FLAT:??_C@_05EPPB@INNER?$AA@
	DD	FLAT:??_C@_05IHIC@INPUT?$AA@
	DD	FLAT:??_C@_0M@PDHJ@INSENSITIVE?$AA@
	DD	FLAT:??_C@_06CCAI@INSERT?$AA@
	DD	FLAT:??_C@_03IJOL@INT?$AA@
	DD	FLAT:??_C@_07KMGD@INTEGER?$AA@
	DD	FLAT:??_C@_08PEKL@INTEGER1?$AA@
	DD	FLAT:??_C@_08LBC@INTEGER2?$AA@
	DD	FLAT:??_C@_09GIDA@INTERSECT?$AA@
	DD	FLAT:??_C@_08JNLE@INTERVAL?$AA@
	DD	FLAT:??_C@_04JMBE@INTO?$AA@
	DD	FLAT:??_C@_02PKFC@IS?$AA@
	DD	FLAT:??_C@_09JCKC@ISOLATION?$AA@
	DD	FLAT:??_C@_04JIJO@JOIN?$AA@
	DD	FLAT:??_C@_03PHBO@KEY?$AA@
	DD	FLAT:??_C@_04EIJF@KILL?$AA@
	DD	FLAT:??_C@_04GBPO@LAST?$AA@
	DD	FLAT:??_C@_07HHCE@LEADING?$AA@
	DD	FLAT:??_C@_04PAN@LEFT?$AA@
	DD	FLAT:??_C@_05JJEC@LEVEL?$AA@
	DD	FLAT:??_C@_04CNFB@LIKE?$AA@
	DD	FLAT:??_C@_06MJFP@LINENO?$AA@
	DD	FLAT:??_C@_04PDLA@LOAD?$AA@
	DD	FLAT:??_C@_05JIPK@LOCAL?$AA@
	DD	FLAT:??_C@_07OAKI@LOGICAL?$AA@
	DD	FLAT:??_C@_08KCOH@LOGICAL1?$AA@
	DD	FLAT:??_C@_04NIAI@LONG?$AA@
	DD	FLAT:??_C@_0L@GKBM@LONGBINARY?$AA@
	DD	FLAT:??_C@_08HLJO@LONGTEXT?$AA@
	DD	FLAT:??_C@_05NFKB@MATCH?$AA@
	DD	FLAT:??_C@_03OLFE@MAX?$AA@
	DD	FLAT:??_C@_04KGIF@MEMO?$AA@
	DD	FLAT:??_C@_03IAC@MIN?$AA@
	DD	FLAT:??_C@_06IOKL@MINUTE?$AA@
	DD	FLAT:??_C@_0L@GNDP@MIRROREXIT?$AA@
	DD	FLAT:??_C@_03HOGL@MOD?$AA@
	DD	FLAT:??_C@_05EBDH@MONEY?$AA@
	DD	FLAT:??_C@_05DOND@MONTH?$AA@
	DD	FLAT:??_C@_05KDIJ@NAMES?$AA@
	DD	FLAT:??_C@_08CHPD@NATIONAL?$AA@
	DD	FLAT:??_C@_07BGPN@NATURAL?$AA@
	DD	FLAT:??_C@_05DFM@NCHAR?$AA@
	DD	FLAT:??_C@_04ONKL@NEXT?$AA@
	DD	FLAT:??_C@_07NAJC@NEXTLOG?$AA@
	DD	FLAT:??_C@_02MMJD@NO?$AA@
	DD	FLAT:??_C@_07IMID@NOCHECK?$AA@
	DD	FLAT:??_C@_0N@NJNJ@NONCLUSTERED?$AA@
	DD	FLAT:??_C@_03CBCA@NOT?$AA@
	DD	FLAT:??_C@_04DFCK@NOTE?$AA@
	DD	FLAT:??_C@_04BAK@NULL?$AA@
	DD	FLAT:??_C@_06HGII@NULLIF?$AA@
	DD	FLAT:??_C@_06MDMK@NUMBER?$AA@
	DD	FLAT:??_C@_07FIAN@NUMERIC?$AA@
	DD	FLAT:??_C@_0N@PBNP@OCTET_LENGTH?$AA@
	DD	FLAT:??_C@_02CEBG@OF?$AA@
	DD	FLAT:??_C@_03CMJG@OFF?$AA@
	DD	FLAT:??_C@_07FMHE@OFFSETS?$AA@
	DD	FLAT:??_C@_09GMOF@OLEOBJECT?$AA@
	DD	FLAT:??_C@_02HAKO@ON?$AA@
	DD	FLAT:??_C@_04EJJC@ONCE?$AA@
	DD	FLAT:??_C@_04MKAH@ONLY?$AA@
	DD	FLAT:??_C@_04MIME@OPEN?$AA@
	DD	FLAT:??_C@_06IFCC@OPTION?$AA@
	DD	FLAT:??_C@_02CHDK@OR?$AA@
	DD	FLAT:??_C@_05FBEP@ORDER?$AA@
	DD	FLAT:??_C@_05IKJL@OUTER?$AA@
	DD	FLAT:??_C@_06BMBF@OUTPUT?$AA@
	DD	FLAT:??_C@_04HDCH@OVER?$AA@
	DD	FLAT:??_C@_08PGNB@OVERLAPS?$AA@
	DD	FLAT:??_C@_0M@GPH@OWNERACCESS?$AA@
	DD	FLAT:??_C@_03BHFD@PAD?$AA@
	DD	FLAT:??_C@_0L@PEIP@PARAMETERS?$AA@
	DD	FLAT:??_C@_07MOBO@PARTIAL?$AA@
	DD	FLAT:??_C@_07MGCH@PERCENT?$AA@
	DD	FLAT:??_C@_04ICKI@PERM?$AA@
	DD	FLAT:??_C@_09JLAF@PERMANENT?$AA@
	DD	FLAT:??_C@_04CDKK@PIPE?$AA@
	DD	FLAT:??_C@_05MALJ@PIVOT?$AA@
	DD	FLAT:??_C@_04OOOE@PLAN?$AA@
	DD	FLAT:??_C@_08BGJK@POSITION?$AA@
	DD	FLAT:??_C@_09LJHE@PRECISION?$AA@
	DD	FLAT:??_C@_07OCNH@PREPARE?$AA@
	DD	FLAT:??_C@_07JPNB@PRESEVE?$AA@
	DD	FLAT:??_C@_07PLFH@PRIMARY?$AA@
	DD	FLAT:??_C@_05MJOK@PRINT?$AA@
	DD	FLAT:??_C@_05CADC@PRIOR?$AA@
	DD	FLAT:??_C@_0L@IFKE@PRIVILEGES?$AA@
	DD	FLAT:??_C@_04CFJE@PROC?$AA@
	DD	FLAT:??_C@_09HPKL@PROCEDURE?$AA@
	DD	FLAT:??_C@_0M@CNCJ@PROCESSEXIT?$AA@
	DD	FLAT:??_C@_06JPM@PUBLIC?$AA@
	DD	FLAT:??_C@_09EHBK@RAISERROR?$AA@
	DD	FLAT:??_C@_04GHHF@READ?$AA@
	DD	FLAT:??_C@_08IEGM@READTEXT?$AA@
	DD	FLAT:??_C@_04DDMN@REAL?$AA@
	DD	FLAT:??_C@_0M@CLEO@RECONFIGURE?$AA@
	DD	FLAT:??_C@_0L@DHND@REFERENCES?$AA@
	DD	FLAT:??_C@_08NDFO@RELATIVE?$AA@
	DD	FLAT:??_C@_0L@DEIL@REPEATABLE?$AA@
	DD	FLAT:??_C@_0M@GBCL@REPLICATION?$AA@
	DD	FLAT:??_C@_08BEHK@RESTRICT?$AA@
	DD	FLAT:??_C@_09NACH@RETAINDAY?$AA@
	DD	FLAT:??_C@_06PJJM@RETURN?$AA@
	DD	FLAT:??_C@_06MEJM@REVOKE?$AA@
	DD	FLAT:??_C@_05JCNK@RIGHT?$AA@
	DD	FLAT:??_C@_08EMFJ@ROLLBACK?$AA@
	DD	FLAT:??_C@_08MGKJ@ROWCOUNT?$AA@
	DD	FLAT:??_C@_04LCCO@ROWS?$AA@
	DD	FLAT:??_C@_04BFNM@RULE?$AA@
	DD	FLAT:??_C@_04KLBG@SAVE?$AA@
	DD	FLAT:??_C@_06NIIF@SCHEMA?$AA@
	DD	FLAT:??_C@_06JLNB@SCROLL?$AA@
	DD	FLAT:??_C@_06FCJA@SECOND?$AA@
	DD	FLAT:??_C@_06OGAC@SELECT?$AA@
	DD	FLAT:??_C@_0N@CCJF@SERIALIZABLE?$AA@
	DD	FLAT:??_C@_07CGDO@SESSION?$AA@
	DD	FLAT:??_C@_0N@JGA@SESSION_USER?$AA@
	DD	FLAT:??_C@_03BCLC@SET?$AA@
	DD	FLAT:??_C@_07EDEP@SETUSER?$AA@
	DD	FLAT:??_C@_05HFLA@SHORT?$AA@
	DD	FLAT:??_C@_08DPKF@SHUTDOWN?$AA@
	DD	FLAT:??_C@_06FONC@SINGLE?$AA@
	DD	FLAT:??_C@_04NEFN@SIZE?$AA@
	DD	FLAT:??_C@_08DMN@SMALLINT?$AA@
	DD	FLAT:??_C@_04DDNG@SOME?$AA@
	DD	FLAT:??_C@_05JCH@SPACE?$AA@
	DD	FLAT:??_C@_08DHID@SQLSTATE?$AA@
	DD	FLAT:??_C@_0L@JMMG@STATISTICS?$AA@
	DD	FLAT:??_C@_05KHBF@STDEV?$AA@
	DD	FLAT:??_C@_06OCBH@STDEVP?$AA@
	DD	FLAT:??_C@_06JDFN@STRING?$AA@
	DD	FLAT:??_C@_03CPEE@SUM?$AA@
	DD	FLAT:??_C@_0M@JBHB@SYSTEM_USER?$AA@
	DD	FLAT:??_C@_05DLJE@TABLE?$AA@
	DD	FLAT:??_C@_07DAKP@TABLEID?$AA@
	DD	FLAT:??_C@_04CGFH@TAPE?$AA@
	DD	FLAT:??_C@_04FEEL@TEMP?$AA@
	DD	FLAT:??_C@_09EAGL@TEMPORARY?$AA@
	DD	FLAT:??_C@_04NILO@TEXT?$AA@
	DD	FLAT:??_C@_08FIJO@TEXTSIZE?$AA@
	DD	FLAT:??_C@_04GJFM@THEN?$AA@
	DD	FLAT:??_C@_04CFBP@TIME?$AA@
	DD	FLAT:??_C@_09KEAG@TIMESTAMP?$AA@
	DD	FLAT:??_C@_0O@OCJA@TIMEZONE_HOUR?$AA@
	DD	FLAT:??_C@_0BA@OAII@TIMEZONE_MINUTE?$AA@
	DD	FLAT:??_C@_02DODL@TO?$AA@
	DD	FLAT:??_C@_03JOIO@TOP?$AA@
	DD	FLAT:??_C@_08NJGC@TRAILING?$AA@
	DD	FLAT:??_C@_04CGAE@TRAN?$AA@
	DD	FLAT:??_C@_0M@JACB@TRANSACTION?$AA@
	DD	FLAT:??_C@_09ECBO@TRANSFORM?$AA@
	DD	FLAT:??_C@_09HNKP@TRANSLATE?$AA@
	DD	FLAT:??_C@_0M@LOEK@TRANSLATION?$AA@
	DD	FLAT:??_C@_07GNLP@TRIGGER?$AA@
	DD	FLAT:??_C@_04LNAG@TRUE?$AA@
	DD	FLAT:??_C@_08FCAH@TRUNCATE?$AA@
	DD	FLAT:??_C@_07CODK@TSEQUAL?$AA@
	DD	FLAT:??_C@_0M@PJEA@UNCOMMITTED?$AA@
	DD	FLAT:??_C@_05LNOP@UNION?$AA@
	DD	FLAT:??_C@_06LNBM@UNIQUE?$AA@
	DD	FLAT:??_C@_07CNPM@UNKNOWN?$AA@
	DD	FLAT:??_C@_06NDPG@UPDATE?$AA@
	DD	FLAT:??_C@_0L@DPMH@UPDATETEXT?$AA@
	DD	FLAT:??_C@_05PMKE@USAGE?$AA@
	DD	FLAT:??_C@_03OAHE@USE?$AA@
	DD	FLAT:??_C@_04FMHO@USER?$AA@
	DD	FLAT:??_C@_05JKMB@USING?$AA@
	DD	FLAT:??_C@_05MOEL@VALUE?$AA@
	DD	FLAT:??_C@_06KGMH@VALUES?$AA@
	DD	FLAT:??_C@_03KNCG@VAR?$AA@
	DD	FLAT:??_C@_09OLDK@VARBINARY?$AA@
	DD	FLAT:??_C@_07NGFA@VARCHAR?$AA@
	DD	FLAT:??_C@_04OIBN@VARP?$AA@
	DD	FLAT:??_C@_07MMOJ@VARYING?$AA@
	DD	FLAT:??_C@_04CGLB@VIEW?$AA@
	DD	FLAT:??_C@_06IEGE@VOLUME?$AA@
	DD	FLAT:??_C@_07KCD@WAITFOR?$AA@
	DD	FLAT:??_C@_04GKK@WHEN?$AA@
	DD	FLAT:??_C@_05MCFK@WHERE?$AA@
	DD	FLAT:??_C@_05LCLH@WHILE?$AA@
	DD	FLAT:??_C@_04NHMN@WITH?$AA@
	DD	FLAT:??_C@_04LDPM@WORK?$AA@
	DD	FLAT:??_C@_05FIFP@WRITE?$AA@
	DD	FLAT:??_C@_09IKOB@WRITETEXT?$AA@
	DD	FLAT:??_C@_03BDEP@XOR?$AA@
	DD	FLAT:??_C@_04HEBB@YEAR?$AA@
	DD	FLAT:??_C@_05NAPJ@YESNO?$AA@
	DD	FLAT:??_C@_04HOL@ZONE?$AA@
	DD	FLAT:??_C@_01A@?$AA?$AA@
_DATA	ENDS
;	COMDAT ??_C@_08DFNL@ABSOLUTE?$AA@
_DATA	SEGMENT
??_C@_08DFNL@ABSOLUTE?$AA@ DB 'ABSOLUTE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06LHNJ@ACTION?$AA@
_DATA	SEGMENT
??_C@_06LHNJ@ACTION?$AA@ DB 'ACTION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CICP@ADD?$AA@
_DATA	SEGMENT
??_C@_03CICP@ADD?$AA@ DB 'ADD', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03MJMD@ALL?$AA@
_DATA	SEGMENT
??_C@_03MJMD@ALL?$AA@ DB 'ALL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08HG@ALLOCATE?$AA@
_DATA	SEGMENT
??_C@_08HG@ALLOCATE?$AA@ DB 'ALLOCATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NNIC@ALPHANUMERIC?$AA@
_DATA	SEGMENT
??_C@_0N@NNIC@ALPHANUMERIC?$AA@ DB 'ALPHANUMERIC', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05BBIN@ALTER?$AA@
_DATA	SEGMENT
??_C@_05BBIN@ALTER?$AA@ DB 'ALTER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03LACO@AND?$AA@
_DATA	SEGMENT
??_C@_03LACO@AND?$AA@ DB 'AND', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03ENCN@ANY?$AA@
_DATA	SEGMENT
??_C@_03ENCN@ANY?$AA@ DB 'ANY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03JPOO@ARE?$AA@
_DATA	SEGMENT
??_C@_03JPOO@ARE?$AA@ DB 'ARE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02EPAG@AS?$AA@
_DATA	SEGMENT
??_C@_02EPAG@AS?$AA@ DB 'AS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03HGDG@ASC?$AA@
_DATA	SEGMENT
??_C@_03HGDG@ASC?$AA@ DB 'ASC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HNNJ@ASSERTION?$AA@
_DATA	SEGMENT
??_C@_09HNNJ@ASSERTION?$AA@ DB 'ASSERTION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02BKOD@AT?$AA@
_DATA	SEGMENT
??_C@_02BKOD@AT?$AA@ DB 'AT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@MMGM@AUTHORIZATION?$AA@
_DATA	SEGMENT
??_C@_0O@MMGM@AUTHORIZATION?$AA@ DB 'AUTHORIZATION', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@DFOG@AUTOINCREMENT?$AA@
_DATA	SEGMENT
??_C@_0O@DFOG@AUTOINCREMENT?$AA@ DB 'AUTOINCREMENT', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_03JAGK@AVG?$AA@
_DATA	SEGMENT
??_C@_03JAGK@AVG?$AA@ DB 'AVG', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JBBL@BEGIN?$AA@
_DATA	SEGMENT
??_C@_05JBBL@BEGIN?$AA@ DB 'BEGIN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FEKN@BETWEEN?$AA@
_DATA	SEGMENT
??_C@_07FEKN@BETWEEN?$AA@ DB 'BETWEEN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06ICJB@BINARY?$AA@
_DATA	SEGMENT
??_C@_06ICJB@BINARY?$AA@ DB 'BINARY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IODA@BIT?$AA@
_DATA	SEGMENT
??_C@_03IODA@BIT?$AA@ DB 'BIT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HLBB@BOOLEAN?$AA@
_DATA	SEGMENT
??_C@_07HLBB@BOOLEAN?$AA@ DB 'BOOLEAN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NOIB@BOTH?$AA@
_DATA	SEGMENT
??_C@_04NOIB@BOTH?$AA@ DB 'BOTH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05CPDG@BREAK?$AA@
_DATA	SEGMENT
??_C@_05CPDG@BREAK?$AA@ DB 'BREAK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MIPA@BROWSE?$AA@
_DATA	SEGMENT
??_C@_06MIPA@BROWSE?$AA@ DB 'BROWSE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OLDH@BULK?$AA@
_DATA	SEGMENT
??_C@_04OLDH@BULK?$AA@ DB 'BULK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02HFGP@BY?$AA@
_DATA	SEGMENT
??_C@_02HFGP@BY?$AA@ DB 'BY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EHOP@BYTE?$AA@
_DATA	SEGMENT
??_C@_04EHOP@BYTE?$AA@ DB 'BYTE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HJNK@CASCADE?$AA@
_DATA	SEGMENT
??_C@_07HJNK@CASCADE?$AA@ DB 'CASCADE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GIOF@CASCADED?$AA@
_DATA	SEGMENT
??_C@_08GIOF@CASCADED?$AA@ DB 'CASCADED', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LCDH@CASE?$AA@
_DATA	SEGMENT
??_C@_04LCDH@CASE?$AA@ DB 'CASE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LBNA@CAST?$AA@
_DATA	SEGMENT
??_C@_04LBNA@CAST?$AA@ DB 'CAST', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CPI@CATALOG?$AA@
_DATA	SEGMENT
??_C@_07CPI@CATALOG?$AA@ DB 'CATALOG', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MLPN@CHAR?$AA@
_DATA	SEGMENT
??_C@_04MLPN@CHAR?$AA@ DB 'CHAR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09MNBH@CHARACTER?$AA@
_DATA	SEGMENT
??_C@_09MNBH@CHARACTER?$AA@ DB 'CHARACTER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LGJP@CHARACTER_LENGTH?$AA@
_DATA	SEGMENT
??_C@_0BB@LGJP@CHARACTER_LENGTH?$AA@ DB 'CHARACTER_LENGTH', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@OBEF@CHAR_LENGTH?$AA@
_DATA	SEGMENT
??_C@_0M@OBEF@CHAR_LENGTH?$AA@ DB 'CHAR_LENGTH', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JHFD@CHECK?$AA@
_DATA	SEGMENT
??_C@_05JHFD@CHECK?$AA@ DB 'CHECK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@CINA@CHECKPOINT?$AA@
_DATA	SEGMENT
??_C@_0L@CINA@CHECKPOINT?$AA@ DB 'CHECKPOINT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05PHOA@CLOSE?$AA@
_DATA	SEGMENT
??_C@_05PHOA@CLOSE?$AA@ DB 'CLOSE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GMHN@CLUSTERED?$AA@
_DATA	SEGMENT
??_C@_09GMHN@CLUSTERED?$AA@ DB 'CLUSTERED', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DMIM@COALESCE?$AA@
_DATA	SEGMENT
??_C@_08DMIM@COALESCE?$AA@ DB 'COALESCE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HABJ@COLLATE?$AA@
_DATA	SEGMENT
??_C@_07HABJ@COLLATE?$AA@ DB 'COLLATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JEOK@COLLATION?$AA@
_DATA	SEGMENT
??_C@_09JEOK@COLLATION?$AA@ DB 'COLLATION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06LGEH@COLUMN?$AA@
_DATA	SEGMENT
??_C@_06LGEH@COLUMN?$AA@ DB 'COLUMN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06NAIG@COMMIT?$AA@
_DATA	SEGMENT
??_C@_06NAIG@COMMIT?$AA@ DB 'COMMIT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09BMPB@COMMITTED?$AA@
_DATA	SEGMENT
??_C@_09BMPB@COMMITTED?$AA@ DB 'COMMITTED', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FDPF@COMPUTE?$AA@
_DATA	SEGMENT
??_C@_07FDPF@COMPUTE?$AA@ DB 'COMPUTE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07ODJF@CONFIRM?$AA@
_DATA	SEGMENT
??_C@_07ODJF@CONFIRM?$AA@ DB 'CONFIRM', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07DKLG@CONNECT?$AA@
_DATA	SEGMENT
??_C@_07DKLG@CONNECT?$AA@ DB 'CONNECT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@ICLB@CONNECTION?$AA@
_DATA	SEGMENT
??_C@_0L@ICLB@CONNECTION?$AA@ DB 'CONNECTION', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@LNCA@CONSTRAINT?$AA@
_DATA	SEGMENT
??_C@_0L@LNCA@CONSTRAINT?$AA@ DB 'CONSTRAINT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@GMLE@CONSTRAINTS?$AA@
_DATA	SEGMENT
??_C@_0M@GMLE@CONSTRAINTS?$AA@ DB 'CONSTRAINTS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08HDIP@CONTINUE?$AA@
_DATA	SEGMENT
??_C@_08HDIP@CONTINUE?$AA@ DB 'CONTINUE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@BOLK@CONTROLROW?$AA@
_DATA	SEGMENT
??_C@_0L@BOLK@CONTROLROW?$AA@ DB 'CONTROLROW', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07DJAE@CONVERT?$AA@
_DATA	SEGMENT
??_C@_07DJAE@CONVERT?$AA@ DB 'CONVERT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@MOMH@CORRESPONDING?$AA@
_DATA	SEGMENT
??_C@_0O@MOMH@CORRESPONDING?$AA@ DB 'CORRESPONDING', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_05BNPO@COUNT?$AA@
_DATA	SEGMENT
??_C@_05BNPO@COUNT?$AA@ DB 'COUNT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CCFH@COUNTER?$AA@
_DATA	SEGMENT
??_C@_07CCFH@COUNTER?$AA@ DB 'COUNTER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JBCM@CREATE?$AA@
_DATA	SEGMENT
??_C@_06JBCM@CREATE?$AA@ DB 'CREATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05BLP@CROSS?$AA@
_DATA	SEGMENT
??_C@_05BLP@CROSS?$AA@ DB 'CROSS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08CHBF@CURRENCY?$AA@
_DATA	SEGMENT
??_C@_08CHBF@CURRENCY?$AA@ DB 'CURRENCY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HGLC@CURRENT?$AA@
_DATA	SEGMENT
??_C@_07HGLC@CURRENT?$AA@ DB 'CURRENT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NEAE@CURRENT_DATE?$AA@
_DATA	SEGMENT
??_C@_0N@NEAE@CURRENT_DATE?$AA@ DB 'CURRENT_DATE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NIMH@CURRENT_TIME?$AA@
_DATA	SEGMENT
??_C@_0N@NIMH@CURRENT_TIME?$AA@ DB 'CURRENT_TIME', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@GGBA@CURRENT_TIMESTAMP?$AA@
_DATA	SEGMENT
??_C@_0BC@GGBA@CURRENT_TIMESTAMP?$AA@ DB 'CURRENT_TIMESTAMP', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@KBKG@CURRENT_USER?$AA@
_DATA	SEGMENT
??_C@_0N@KBKG@CURRENT_USER?$AA@ DB 'CURRENT_USER', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MDJJ@CURSOR?$AA@
_DATA	SEGMENT
??_C@_06MDJJ@CURSOR?$AA@ DB 'CURSOR', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08PKHN@DATABASE?$AA@
_DATA	SEGMENT
??_C@_08PKHN@DATABASE?$AA@ DB 'DATABASE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CJNM@DATE?$AA@
_DATA	SEGMENT
??_C@_04CJNM@DATE?$AA@ DB 'DATE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08MIJC@DATETIME?$AA@
_DATA	SEGMENT
??_C@_08MIJC@DATETIME?$AA@ DB 'DATETIME', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IDGA@DAY?$AA@
_DATA	SEGMENT
??_C@_03IDGA@DAY?$AA@ DB 'DAY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06OPFP@DBAREA?$AA@
_DATA	SEGMENT
??_C@_06OPFP@DBAREA?$AA@ DB 'DBAREA', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CLGJ@DBCC?$AA@
_DATA	SEGMENT
??_C@_04CLGJ@DBCC?$AA@ DB 'DBCC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@JGIO@DEALLOCATE?$AA@
_DATA	SEGMENT
??_C@_0L@JGIO@DEALLOCATE?$AA@ DB 'DEALLOCATE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05DAPA@DEBUG?$AA@
_DATA	SEGMENT
??_C@_05DAPA@DEBUG?$AA@ DB 'DEBUG', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CJJP@DECLARE?$AA@
_DATA	SEGMENT
??_C@_07CJJP@DECLARE?$AA@ DB 'DECLARE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FBHA@DEFAULT?$AA@
_DATA	SEGMENT
??_C@_07FBHA@DEFAULT?$AA@ DB 'DEFAULT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@POBB@DEFERRABLE?$AA@
_DATA	SEGMENT
??_C@_0L@POBB@DEFERRABLE?$AA@ DB 'DEFERRABLE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IEEN@DEFERRED?$AA@
_DATA	SEGMENT
??_C@_08IEEN@DEFERRED?$AA@ DB 'DEFERRED', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06FMHL@DELETE?$AA@
_DATA	SEGMENT
??_C@_06FMHL@DELETE?$AA@ DB 'DELETE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PPKB@DESC?$AA@
_DATA	SEGMENT
??_C@_04PPKB@DESC?$AA@ DB 'DESC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FBJG@DESCRIBE?$AA@
_DATA	SEGMENT
??_C@_08FBJG@DESCRIBE?$AA@ DB 'DESCRIBE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GKAF@DESCRIPTOR?$AA@
_DATA	SEGMENT
??_C@_0L@GKAF@DESCRIPTOR?$AA@ DB 'DESCRIPTOR', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@OKKK@DIAGNOSTICS?$AA@
_DATA	SEGMENT
??_C@_0M@OKKK@DIAGNOSTICS?$AA@ DB 'DIAGNOSTICS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GADM@DISALLOW?$AA@
_DATA	SEGMENT
??_C@_08GADM@DISALLOW?$AA@ DB 'DISALLOW', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGBA@DISCONNECT?$AA@
_DATA	SEGMENT
??_C@_0L@OGBA@DISCONNECT?$AA@ DB 'DISCONNECT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HDPG@DISK?$AA@
_DATA	SEGMENT
??_C@_04HDPG@DISK?$AA@ DB 'DISK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08EGKJ@DISTINCT?$AA@
_DATA	SEGMENT
??_C@_08EGKJ@DISTINCT?$AA@ DB 'DISTINCT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@EMHJ@DISTINCTROW?$AA@
_DATA	SEGMENT
??_C@_0M@EMHJ@DISTINCTROW?$AA@ DB 'DISTINCTROW', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@ONJI@DISTRIBUTED?$AA@
_DATA	SEGMENT
??_C@_0M@ONJI@DISTRIBUTED?$AA@ DB 'DISTRIBUTED', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06EIOP@DOMAIN?$AA@
_DATA	SEGMENT
??_C@_06EIOP@DOMAIN?$AA@ DB 'DOMAIN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06CGGE@DOUBLE?$AA@
_DATA	SEGMENT
??_C@_06CGGE@DOUBLE?$AA@ DB 'DOUBLE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LDDE@DROP?$AA@
_DATA	SEGMENT
??_C@_04LDDE@DROP?$AA@ DB 'DROP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JGEC@DUMMY?$AA@
_DATA	SEGMENT
??_C@_05JGEC@DUMMY?$AA@ DB 'DUMMY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CAAA@DUMP?$AA@
_DATA	SEGMENT
??_C@_04CAAA@DUMP?$AA@ DB 'DUMP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OHCC@ELSE?$AA@
_DATA	SEGMENT
??_C@_04OHCC@ELSE?$AA@ DB 'ELSE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03PIHE@END?$AA@
_DATA	SEGMENT
??_C@_03PIHE@END?$AA@ DB 'END', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GNOH@END_EXEC?$AA@
_DATA	SEGMENT
??_C@_08GNOH@END_EXEC?$AA@ DB 'END_EXEC', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03LKIC@EQV?$AA@
_DATA	SEGMENT
??_C@_03LKIC@EQV?$AA@ DB 'EQV', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06BKPA@ERRLVL?$AA@
_DATA	SEGMENT
??_C@_06BKPA@ERRLVL?$AA@ DB 'ERRLVL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09EIBF@ERROREXIT?$AA@
_DATA	SEGMENT
??_C@_09EIBF@ERROREXIT?$AA@ DB 'ERROREXIT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MJIP@ESCAPE?$AA@
_DATA	SEGMENT
??_C@_06MJIP@ESCAPE?$AA@ DB 'ESCAPE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06GDHH@EXCEPT?$AA@
_DATA	SEGMENT
??_C@_06GDHH@EXCEPT?$AA@ DB 'EXCEPT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09EEOO@EXCEPTION?$AA@
_DATA	SEGMENT
??_C@_09EEOO@EXCEPTION?$AA@ DB 'EXCEPTION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GMDG@EXEC?$AA@
_DATA	SEGMENT
??_C@_04GMDG@EXEC?$AA@ DB 'EXEC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07DNBH@EXECUTE?$AA@
_DATA	SEGMENT
??_C@_07DNBH@EXECUTE?$AA@ DB 'EXECUTE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MBBB@EXISTS?$AA@
_DATA	SEGMENT
??_C@_06MBBB@EXISTS?$AA@ DB 'EXISTS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HPFN@EXIT?$AA@
_DATA	SEGMENT
??_C@_04HPFN@EXIT?$AA@ DB 'EXIT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@ILPO@EXPIREDATE?$AA@
_DATA	SEGMENT
??_C@_0L@ILPO@EXPIREDATE?$AA@ DB 'EXPIREDATE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08EDIC@EXTERNAL?$AA@
_DATA	SEGMENT
??_C@_08EDIC@EXTERNAL?$AA@ DB 'EXTERNAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07IODP@EXTRACT?$AA@
_DATA	SEGMENT
??_C@_07IODP@EXTRACT?$AA@ DB 'EXTRACT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05LLOB@FALSE?$AA@
_DATA	SEGMENT
??_C@_05LLOB@FALSE?$AA@ DB 'FALSE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KBKM@FETCH?$AA@
_DATA	SEGMENT
??_C@_05KBKM@FETCH?$AA@ DB 'FETCH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CMDA@FILE?$AA@
_DATA	SEGMENT
??_C@_04CMDA@FILE?$AA@ DB 'FILE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@NPIO@FILLFACTOR?$AA@
_DATA	SEGMENT
??_C@_0L@NPIO@FILLFACTOR?$AA@ DB 'FILLFACTOR', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05MPDO@FIRST?$AA@
_DATA	SEGMENT
??_C@_05MPDO@FIRST?$AA@ DB 'FIRST', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JDEL@FLOAT?$AA@
_DATA	SEGMENT
??_C@_05JDEL@FLOAT?$AA@ DB 'FLOAT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06FFP@FLOAT4?$AA@
_DATA	SEGMENT
??_C@_06FFP@FLOAT4?$AA@ DB 'FLOAT4', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PLLL@FLOAT8?$AA@
_DATA	SEGMENT
??_C@_06PLLL@FLOAT8?$AA@ DB 'FLOAT8', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IPNK@FLOPPY?$AA@
_DATA	SEGMENT
??_C@_06IPNK@FLOPPY?$AA@ DB 'FLOPPY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03EOOH@FOR?$AA@
_DATA	SEGMENT
??_C@_03EOOH@FOR?$AA@ DB 'FOR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07ECFK@FOREIGN?$AA@
_DATA	SEGMENT
??_C@_07ECFK@FOREIGN?$AA@ DB 'FOREIGN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EJD@FROM?$AA@
_DATA	SEGMENT
??_C@_04EJD@FROM?$AA@ DB 'FROM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CLJK@FULL?$AA@
_DATA	SEGMENT
??_C@_04CLJK@FULL?$AA@ DB 'FULL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03HLIC@GET?$AA@
_DATA	SEGMENT
??_C@_03HLIC@GET?$AA@ DB 'GET', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@PODI@GETDEFAULT?$AA@
_DATA	SEGMENT
??_C@_0L@PODI@GETDEFAULT?$AA@ DB 'GETDEFAULT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06EKIF@GLOBAL?$AA@
_DATA	SEGMENT
??_C@_06EKIF@GLOBAL?$AA@ DB 'GLOBAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DLHO@GOTO?$AA@
_DATA	SEGMENT
??_C@_04DLHO@GOTO?$AA@ DB 'GOTO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05DLPA@GRANT?$AA@
_DATA	SEGMENT
??_C@_05DLPA@GRANT?$AA@ DB 'GRANT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JGM@GROUP?$AA@
_DATA	SEGMENT
??_C@_05JGM@GROUP?$AA@ DB 'GROUP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BGHA@GUID?$AA@
_DATA	SEGMENT
??_C@_04BGHA@GUID?$AA@ DB 'GUID', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06GNBD@HAVING?$AA@
_DATA	SEGMENT
??_C@_06GNBD@HAVING?$AA@ DB 'HAVING', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08JHAN@HOLDLOCK?$AA@
_DATA	SEGMENT
??_C@_08JHAN@HOLDLOCK?$AA@ DB 'HOLDLOCK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PJ@HOUR?$AA@
_DATA	SEGMENT
??_C@_04PJ@HOUR?$AA@ DB 'HOUR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08MFJF@IDENTITY?$AA@
_DATA	SEGMENT
??_C@_08MFJF@IDENTITY?$AA@ DB 'IDENTITY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@EOA@IDENTITYCOL?$AA@
_DATA	SEGMENT
??_C@_0M@EOA@IDENTITYCOL?$AA@ DB 'IDENTITYCOL', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JADB@IDENTITY_INSERT?$AA@
_DATA	SEGMENT
??_C@_0BA@JADB@IDENTITY_INSERT?$AA@ DB 'IDENTITY_INSERT', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@CMNP@IEEEDOUBLE?$AA@
_DATA	SEGMENT
??_C@_0L@CMNP@IEEEDOUBLE?$AA@ DB 'IEEEDOUBLE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@FEGJ@IEEESINGLE?$AA@
_DATA	SEGMENT
??_C@_0L@FEGJ@IEEESINGLE?$AA@ DB 'IEEESINGLE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_02FDOJ@IF?$AA@
_DATA	SEGMENT
??_C@_02FDOJ@IF?$AA@ DB 'IF', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06HLND@IGNORE?$AA@
_DATA	SEGMENT
??_C@_06HLND@IGNORE?$AA@ DB 'IGNORE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09LEPP@IMMEDIATE?$AA@
_DATA	SEGMENT
??_C@_09LEPP@IMMEDIATE?$AA@ DB 'IMMEDIATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03BIEI@IMP?$AA@
_DATA	SEGMENT
??_C@_03BIEI@IMP?$AA@ DB 'IMP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02HFB@IN?$AA@
_DATA	SEGMENT
??_C@_02HFB@IN?$AA@ DB 'IN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05HKPP@INDEX?$AA@
_DATA	SEGMENT
??_C@_05HKPP@INDEX?$AA@ DB 'INDEX', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09BAOC@INITIALLY?$AA@
_DATA	SEGMENT
??_C@_09BAOC@INITIALLY?$AA@ DB 'INITIALLY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05EPPB@INNER?$AA@
_DATA	SEGMENT
??_C@_05EPPB@INNER?$AA@ DB 'INNER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05IHIC@INPUT?$AA@
_DATA	SEGMENT
??_C@_05IHIC@INPUT?$AA@ DB 'INPUT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@PDHJ@INSENSITIVE?$AA@
_DATA	SEGMENT
??_C@_0M@PDHJ@INSENSITIVE?$AA@ DB 'INSENSITIVE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06CCAI@INSERT?$AA@
_DATA	SEGMENT
??_C@_06CCAI@INSERT?$AA@ DB 'INSERT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IJOL@INT?$AA@
_DATA	SEGMENT
??_C@_03IJOL@INT?$AA@ DB 'INT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07KMGD@INTEGER?$AA@
_DATA	SEGMENT
??_C@_07KMGD@INTEGER?$AA@ DB 'INTEGER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08PEKL@INTEGER1?$AA@
_DATA	SEGMENT
??_C@_08PEKL@INTEGER1?$AA@ DB 'INTEGER1', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08LBC@INTEGER2?$AA@
_DATA	SEGMENT
??_C@_08LBC@INTEGER2?$AA@ DB 'INTEGER2', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GIDA@INTERSECT?$AA@
_DATA	SEGMENT
??_C@_09GIDA@INTERSECT?$AA@ DB 'INTERSECT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08JNLE@INTERVAL?$AA@
_DATA	SEGMENT
??_C@_08JNLE@INTERVAL?$AA@ DB 'INTERVAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JMBE@INTO?$AA@
_DATA	SEGMENT
??_C@_04JMBE@INTO?$AA@ DB 'INTO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02PKFC@IS?$AA@
_DATA	SEGMENT
??_C@_02PKFC@IS?$AA@ DB 'IS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JCKC@ISOLATION?$AA@
_DATA	SEGMENT
??_C@_09JCKC@ISOLATION?$AA@ DB 'ISOLATION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JIJO@JOIN?$AA@
_DATA	SEGMENT
??_C@_04JIJO@JOIN?$AA@ DB 'JOIN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03PHBO@KEY?$AA@
_DATA	SEGMENT
??_C@_03PHBO@KEY?$AA@ DB 'KEY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EIJF@KILL?$AA@
_DATA	SEGMENT
??_C@_04EIJF@KILL?$AA@ DB 'KILL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GBPO@LAST?$AA@
_DATA	SEGMENT
??_C@_04GBPO@LAST?$AA@ DB 'LAST', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HHCE@LEADING?$AA@
_DATA	SEGMENT
??_C@_07HHCE@LEADING?$AA@ DB 'LEADING', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PAN@LEFT?$AA@
_DATA	SEGMENT
??_C@_04PAN@LEFT?$AA@ DB 'LEFT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JJEC@LEVEL?$AA@
_DATA	SEGMENT
??_C@_05JJEC@LEVEL?$AA@ DB 'LEVEL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CNFB@LIKE?$AA@
_DATA	SEGMENT
??_C@_04CNFB@LIKE?$AA@ DB 'LIKE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MJFP@LINENO?$AA@
_DATA	SEGMENT
??_C@_06MJFP@LINENO?$AA@ DB 'LINENO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PDLA@LOAD?$AA@
_DATA	SEGMENT
??_C@_04PDLA@LOAD?$AA@ DB 'LOAD', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JIPK@LOCAL?$AA@
_DATA	SEGMENT
??_C@_05JIPK@LOCAL?$AA@ DB 'LOCAL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07OAKI@LOGICAL?$AA@
_DATA	SEGMENT
??_C@_07OAKI@LOGICAL?$AA@ DB 'LOGICAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08KCOH@LOGICAL1?$AA@
_DATA	SEGMENT
??_C@_08KCOH@LOGICAL1?$AA@ DB 'LOGICAL1', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NIAI@LONG?$AA@
_DATA	SEGMENT
??_C@_04NIAI@LONG?$AA@ DB 'LONG', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GKBM@LONGBINARY?$AA@
_DATA	SEGMENT
??_C@_0L@GKBM@LONGBINARY?$AA@ DB 'LONGBINARY', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08HLJO@LONGTEXT?$AA@
_DATA	SEGMENT
??_C@_08HLJO@LONGTEXT?$AA@ DB 'LONGTEXT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05NFKB@MATCH?$AA@
_DATA	SEGMENT
??_C@_05NFKB@MATCH?$AA@ DB 'MATCH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03OLFE@MAX?$AA@
_DATA	SEGMENT
??_C@_03OLFE@MAX?$AA@ DB 'MAX', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04KGIF@MEMO?$AA@
_DATA	SEGMENT
??_C@_04KGIF@MEMO?$AA@ DB 'MEMO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IAC@MIN?$AA@
_DATA	SEGMENT
??_C@_03IAC@MIN?$AA@ DB 'MIN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IOKL@MINUTE?$AA@
_DATA	SEGMENT
??_C@_06IOKL@MINUTE?$AA@ DB 'MINUTE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GNDP@MIRROREXIT?$AA@
_DATA	SEGMENT
??_C@_0L@GNDP@MIRROREXIT?$AA@ DB 'MIRROREXIT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_03HOGL@MOD?$AA@
_DATA	SEGMENT
??_C@_03HOGL@MOD?$AA@ DB 'MOD', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05EBDH@MONEY?$AA@
_DATA	SEGMENT
??_C@_05EBDH@MONEY?$AA@ DB 'MONEY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05DOND@MONTH?$AA@
_DATA	SEGMENT
??_C@_05DOND@MONTH?$AA@ DB 'MONTH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KDIJ@NAMES?$AA@
_DATA	SEGMENT
??_C@_05KDIJ@NAMES?$AA@ DB 'NAMES', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08CHPD@NATIONAL?$AA@
_DATA	SEGMENT
??_C@_08CHPD@NATIONAL?$AA@ DB 'NATIONAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07BGPN@NATURAL?$AA@
_DATA	SEGMENT
??_C@_07BGPN@NATURAL?$AA@ DB 'NATURAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05DFM@NCHAR?$AA@
_DATA	SEGMENT
??_C@_05DFM@NCHAR?$AA@ DB 'NCHAR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04ONKL@NEXT?$AA@
_DATA	SEGMENT
??_C@_04ONKL@NEXT?$AA@ DB 'NEXT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NAJC@NEXTLOG?$AA@
_DATA	SEGMENT
??_C@_07NAJC@NEXTLOG?$AA@ DB 'NEXTLOG', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02MMJD@NO?$AA@
_DATA	SEGMENT
??_C@_02MMJD@NO?$AA@ DB 'NO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07IMID@NOCHECK?$AA@
_DATA	SEGMENT
??_C@_07IMID@NOCHECK?$AA@ DB 'NOCHECK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NJNJ@NONCLUSTERED?$AA@
_DATA	SEGMENT
??_C@_0N@NJNJ@NONCLUSTERED?$AA@ DB 'NONCLUSTERED', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CBCA@NOT?$AA@
_DATA	SEGMENT
??_C@_03CBCA@NOT?$AA@ DB 'NOT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DFCK@NOTE?$AA@
_DATA	SEGMENT
??_C@_04DFCK@NOTE?$AA@ DB 'NOTE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
_DATA	SEGMENT
??_C@_04BAK@NULL?$AA@ DB 'NULL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06HGII@NULLIF?$AA@
_DATA	SEGMENT
??_C@_06HGII@NULLIF?$AA@ DB 'NULLIF', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MDMK@NUMBER?$AA@
_DATA	SEGMENT
??_C@_06MDMK@NUMBER?$AA@ DB 'NUMBER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FIAN@NUMERIC?$AA@
_DATA	SEGMENT
??_C@_07FIAN@NUMERIC?$AA@ DB 'NUMERIC', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@PBNP@OCTET_LENGTH?$AA@
_DATA	SEGMENT
??_C@_0N@PBNP@OCTET_LENGTH?$AA@ DB 'OCTET_LENGTH', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_02CEBG@OF?$AA@
_DATA	SEGMENT
??_C@_02CEBG@OF?$AA@ DB 'OF', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CMJG@OFF?$AA@
_DATA	SEGMENT
??_C@_03CMJG@OFF?$AA@ DB 'OFF', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FMHE@OFFSETS?$AA@
_DATA	SEGMENT
??_C@_07FMHE@OFFSETS?$AA@ DB 'OFFSETS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GMOF@OLEOBJECT?$AA@
_DATA	SEGMENT
??_C@_09GMOF@OLEOBJECT?$AA@ DB 'OLEOBJECT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02HAKO@ON?$AA@
_DATA	SEGMENT
??_C@_02HAKO@ON?$AA@ DB 'ON', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EJJC@ONCE?$AA@
_DATA	SEGMENT
??_C@_04EJJC@ONCE?$AA@ DB 'ONCE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MKAH@ONLY?$AA@
_DATA	SEGMENT
??_C@_04MKAH@ONLY?$AA@ DB 'ONLY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MIME@OPEN?$AA@
_DATA	SEGMENT
??_C@_04MIME@OPEN?$AA@ DB 'OPEN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IFCC@OPTION?$AA@
_DATA	SEGMENT
??_C@_06IFCC@OPTION?$AA@ DB 'OPTION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02CHDK@OR?$AA@
_DATA	SEGMENT
??_C@_02CHDK@OR?$AA@ DB 'OR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05FBEP@ORDER?$AA@
_DATA	SEGMENT
??_C@_05FBEP@ORDER?$AA@ DB 'ORDER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05IKJL@OUTER?$AA@
_DATA	SEGMENT
??_C@_05IKJL@OUTER?$AA@ DB 'OUTER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06BMBF@OUTPUT?$AA@
_DATA	SEGMENT
??_C@_06BMBF@OUTPUT?$AA@ DB 'OUTPUT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HDCH@OVER?$AA@
_DATA	SEGMENT
??_C@_04HDCH@OVER?$AA@ DB 'OVER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08PGNB@OVERLAPS?$AA@
_DATA	SEGMENT
??_C@_08PGNB@OVERLAPS?$AA@ DB 'OVERLAPS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@GPH@OWNERACCESS?$AA@
_DATA	SEGMENT
??_C@_0M@GPH@OWNERACCESS?$AA@ DB 'OWNERACCESS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_03BHFD@PAD?$AA@
_DATA	SEGMENT
??_C@_03BHFD@PAD?$AA@ DB 'PAD', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@PEIP@PARAMETERS?$AA@
_DATA	SEGMENT
??_C@_0L@PEIP@PARAMETERS?$AA@ DB 'PARAMETERS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MOBO@PARTIAL?$AA@
_DATA	SEGMENT
??_C@_07MOBO@PARTIAL?$AA@ DB 'PARTIAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MGCH@PERCENT?$AA@
_DATA	SEGMENT
??_C@_07MGCH@PERCENT?$AA@ DB 'PERCENT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04ICKI@PERM?$AA@
_DATA	SEGMENT
??_C@_04ICKI@PERM?$AA@ DB 'PERM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JLAF@PERMANENT?$AA@
_DATA	SEGMENT
??_C@_09JLAF@PERMANENT?$AA@ DB 'PERMANENT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CDKK@PIPE?$AA@
_DATA	SEGMENT
??_C@_04CDKK@PIPE?$AA@ DB 'PIPE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05MALJ@PIVOT?$AA@
_DATA	SEGMENT
??_C@_05MALJ@PIVOT?$AA@ DB 'PIVOT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OOOE@PLAN?$AA@
_DATA	SEGMENT
??_C@_04OOOE@PLAN?$AA@ DB 'PLAN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08BGJK@POSITION?$AA@
_DATA	SEGMENT
??_C@_08BGJK@POSITION?$AA@ DB 'POSITION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09LJHE@PRECISION?$AA@
_DATA	SEGMENT
??_C@_09LJHE@PRECISION?$AA@ DB 'PRECISION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07OCNH@PREPARE?$AA@
_DATA	SEGMENT
??_C@_07OCNH@PREPARE?$AA@ DB 'PREPARE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07JPNB@PRESEVE?$AA@
_DATA	SEGMENT
??_C@_07JPNB@PRESEVE?$AA@ DB 'PRESEVE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07PLFH@PRIMARY?$AA@
_DATA	SEGMENT
??_C@_07PLFH@PRIMARY?$AA@ DB 'PRIMARY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05MJOK@PRINT?$AA@
_DATA	SEGMENT
??_C@_05MJOK@PRINT?$AA@ DB 'PRINT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05CADC@PRIOR?$AA@
_DATA	SEGMENT
??_C@_05CADC@PRIOR?$AA@ DB 'PRIOR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@IFKE@PRIVILEGES?$AA@
_DATA	SEGMENT
??_C@_0L@IFKE@PRIVILEGES?$AA@ DB 'PRIVILEGES', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CFJE@PROC?$AA@
_DATA	SEGMENT
??_C@_04CFJE@PROC?$AA@ DB 'PROC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HPKL@PROCEDURE?$AA@
_DATA	SEGMENT
??_C@_09HPKL@PROCEDURE?$AA@ DB 'PROCEDURE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@CNCJ@PROCESSEXIT?$AA@
_DATA	SEGMENT
??_C@_0M@CNCJ@PROCESSEXIT?$AA@ DB 'PROCESSEXIT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JPM@PUBLIC?$AA@
_DATA	SEGMENT
??_C@_06JPM@PUBLIC?$AA@ DB 'PUBLIC', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09EHBK@RAISERROR?$AA@
_DATA	SEGMENT
??_C@_09EHBK@RAISERROR?$AA@ DB 'RAISERROR', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GHHF@READ?$AA@
_DATA	SEGMENT
??_C@_04GHHF@READ?$AA@ DB 'READ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IEGM@READTEXT?$AA@
_DATA	SEGMENT
??_C@_08IEGM@READTEXT?$AA@ DB 'READTEXT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DDMN@REAL?$AA@
_DATA	SEGMENT
??_C@_04DDMN@REAL?$AA@ DB 'REAL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@CLEO@RECONFIGURE?$AA@
_DATA	SEGMENT
??_C@_0M@CLEO@RECONFIGURE?$AA@ DB 'RECONFIGURE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DHND@REFERENCES?$AA@
_DATA	SEGMENT
??_C@_0L@DHND@REFERENCES?$AA@ DB 'REFERENCES', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NDFO@RELATIVE?$AA@
_DATA	SEGMENT
??_C@_08NDFO@RELATIVE?$AA@ DB 'RELATIVE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DEIL@REPEATABLE?$AA@
_DATA	SEGMENT
??_C@_0L@DEIL@REPEATABLE?$AA@ DB 'REPEATABLE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@GBCL@REPLICATION?$AA@
_DATA	SEGMENT
??_C@_0M@GBCL@REPLICATION?$AA@ DB 'REPLICATION', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08BEHK@RESTRICT?$AA@
_DATA	SEGMENT
??_C@_08BEHK@RESTRICT?$AA@ DB 'RESTRICT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09NACH@RETAINDAY?$AA@
_DATA	SEGMENT
??_C@_09NACH@RETAINDAY?$AA@ DB 'RETAINDAY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PJJM@RETURN?$AA@
_DATA	SEGMENT
??_C@_06PJJM@RETURN?$AA@ DB 'RETURN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MEJM@REVOKE?$AA@
_DATA	SEGMENT
??_C@_06MEJM@REVOKE?$AA@ DB 'REVOKE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JCNK@RIGHT?$AA@
_DATA	SEGMENT
??_C@_05JCNK@RIGHT?$AA@ DB 'RIGHT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08EMFJ@ROLLBACK?$AA@
_DATA	SEGMENT
??_C@_08EMFJ@ROLLBACK?$AA@ DB 'ROLLBACK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08MGKJ@ROWCOUNT?$AA@
_DATA	SEGMENT
??_C@_08MGKJ@ROWCOUNT?$AA@ DB 'ROWCOUNT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LCCO@ROWS?$AA@
_DATA	SEGMENT
??_C@_04LCCO@ROWS?$AA@ DB 'ROWS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BFNM@RULE?$AA@
_DATA	SEGMENT
??_C@_04BFNM@RULE?$AA@ DB 'RULE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04KLBG@SAVE?$AA@
_DATA	SEGMENT
??_C@_04KLBG@SAVE?$AA@ DB 'SAVE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06NIIF@SCHEMA?$AA@
_DATA	SEGMENT
??_C@_06NIIF@SCHEMA?$AA@ DB 'SCHEMA', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JLNB@SCROLL?$AA@
_DATA	SEGMENT
??_C@_06JLNB@SCROLL?$AA@ DB 'SCROLL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06FCJA@SECOND?$AA@
_DATA	SEGMENT
??_C@_06FCJA@SECOND?$AA@ DB 'SECOND', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06OGAC@SELECT?$AA@
_DATA	SEGMENT
??_C@_06OGAC@SELECT?$AA@ DB 'SELECT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@CCJF@SERIALIZABLE?$AA@
_DATA	SEGMENT
??_C@_0N@CCJF@SERIALIZABLE?$AA@ DB 'SERIALIZABLE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CGDO@SESSION?$AA@
_DATA	SEGMENT
??_C@_07CGDO@SESSION?$AA@ DB 'SESSION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@JGA@SESSION_USER?$AA@
_DATA	SEGMENT
??_C@_0N@JGA@SESSION_USER?$AA@ DB 'SESSION_USER', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_03BCLC@SET?$AA@
_DATA	SEGMENT
??_C@_03BCLC@SET?$AA@ DB 'SET', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07EDEP@SETUSER?$AA@
_DATA	SEGMENT
??_C@_07EDEP@SETUSER?$AA@ DB 'SETUSER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05HFLA@SHORT?$AA@
_DATA	SEGMENT
??_C@_05HFLA@SHORT?$AA@ DB 'SHORT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DPKF@SHUTDOWN?$AA@
_DATA	SEGMENT
??_C@_08DPKF@SHUTDOWN?$AA@ DB 'SHUTDOWN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06FONC@SINGLE?$AA@
_DATA	SEGMENT
??_C@_06FONC@SINGLE?$AA@ DB 'SINGLE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NEFN@SIZE?$AA@
_DATA	SEGMENT
??_C@_04NEFN@SIZE?$AA@ DB 'SIZE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DMN@SMALLINT?$AA@
_DATA	SEGMENT
??_C@_08DMN@SMALLINT?$AA@ DB 'SMALLINT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DDNG@SOME?$AA@
_DATA	SEGMENT
??_C@_04DDNG@SOME?$AA@ DB 'SOME', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JCH@SPACE?$AA@
_DATA	SEGMENT
??_C@_05JCH@SPACE?$AA@ DB 'SPACE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DHID@SQLSTATE?$AA@
_DATA	SEGMENT
??_C@_08DHID@SQLSTATE?$AA@ DB 'SQLSTATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@JMMG@STATISTICS?$AA@
_DATA	SEGMENT
??_C@_0L@JMMG@STATISTICS?$AA@ DB 'STATISTICS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KHBF@STDEV?$AA@
_DATA	SEGMENT
??_C@_05KHBF@STDEV?$AA@ DB 'STDEV', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06OCBH@STDEVP?$AA@
_DATA	SEGMENT
??_C@_06OCBH@STDEVP?$AA@ DB 'STDEVP', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JDFN@STRING?$AA@
_DATA	SEGMENT
??_C@_06JDFN@STRING?$AA@ DB 'STRING', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CPEE@SUM?$AA@
_DATA	SEGMENT
??_C@_03CPEE@SUM?$AA@ DB 'SUM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@JBHB@SYSTEM_USER?$AA@
_DATA	SEGMENT
??_C@_0M@JBHB@SYSTEM_USER?$AA@ DB 'SYSTEM_USER', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05DLJE@TABLE?$AA@
_DATA	SEGMENT
??_C@_05DLJE@TABLE?$AA@ DB 'TABLE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07DAKP@TABLEID?$AA@
_DATA	SEGMENT
??_C@_07DAKP@TABLEID?$AA@ DB 'TABLEID', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CGFH@TAPE?$AA@
_DATA	SEGMENT
??_C@_04CGFH@TAPE?$AA@ DB 'TAPE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04FEEL@TEMP?$AA@
_DATA	SEGMENT
??_C@_04FEEL@TEMP?$AA@ DB 'TEMP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09EAGL@TEMPORARY?$AA@
_DATA	SEGMENT
??_C@_09EAGL@TEMPORARY?$AA@ DB 'TEMPORARY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NILO@TEXT?$AA@
_DATA	SEGMENT
??_C@_04NILO@TEXT?$AA@ DB 'TEXT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FIJO@TEXTSIZE?$AA@
_DATA	SEGMENT
??_C@_08FIJO@TEXTSIZE?$AA@ DB 'TEXTSIZE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GJFM@THEN?$AA@
_DATA	SEGMENT
??_C@_04GJFM@THEN?$AA@ DB 'THEN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CFBP@TIME?$AA@
_DATA	SEGMENT
??_C@_04CFBP@TIME?$AA@ DB 'TIME', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KEAG@TIMESTAMP?$AA@
_DATA	SEGMENT
??_C@_09KEAG@TIMESTAMP?$AA@ DB 'TIMESTAMP', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@OCJA@TIMEZONE_HOUR?$AA@
_DATA	SEGMENT
??_C@_0O@OCJA@TIMEZONE_HOUR?$AA@ DB 'TIMEZONE_HOUR', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@OAII@TIMEZONE_MINUTE?$AA@
_DATA	SEGMENT
??_C@_0BA@OAII@TIMEZONE_MINUTE?$AA@ DB 'TIMEZONE_MINUTE', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_02DODL@TO?$AA@
_DATA	SEGMENT
??_C@_02DODL@TO?$AA@ DB 'TO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03JOIO@TOP?$AA@
_DATA	SEGMENT
??_C@_03JOIO@TOP?$AA@ DB 'TOP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NJGC@TRAILING?$AA@
_DATA	SEGMENT
??_C@_08NJGC@TRAILING?$AA@ DB 'TRAILING', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CGAE@TRAN?$AA@
_DATA	SEGMENT
??_C@_04CGAE@TRAN?$AA@ DB 'TRAN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@JACB@TRANSACTION?$AA@
_DATA	SEGMENT
??_C@_0M@JACB@TRANSACTION?$AA@ DB 'TRANSACTION', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09ECBO@TRANSFORM?$AA@
_DATA	SEGMENT
??_C@_09ECBO@TRANSFORM?$AA@ DB 'TRANSFORM', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HNKP@TRANSLATE?$AA@
_DATA	SEGMENT
??_C@_09HNKP@TRANSLATE?$AA@ DB 'TRANSLATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LOEK@TRANSLATION?$AA@
_DATA	SEGMENT
??_C@_0M@LOEK@TRANSLATION?$AA@ DB 'TRANSLATION', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07GNLP@TRIGGER?$AA@
_DATA	SEGMENT
??_C@_07GNLP@TRIGGER?$AA@ DB 'TRIGGER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LNAG@TRUE?$AA@
_DATA	SEGMENT
??_C@_04LNAG@TRUE?$AA@ DB 'TRUE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FCAH@TRUNCATE?$AA@
_DATA	SEGMENT
??_C@_08FCAH@TRUNCATE?$AA@ DB 'TRUNCATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CODK@TSEQUAL?$AA@
_DATA	SEGMENT
??_C@_07CODK@TSEQUAL?$AA@ DB 'TSEQUAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@PJEA@UNCOMMITTED?$AA@
_DATA	SEGMENT
??_C@_0M@PJEA@UNCOMMITTED?$AA@ DB 'UNCOMMITTED', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05LNOP@UNION?$AA@
_DATA	SEGMENT
??_C@_05LNOP@UNION?$AA@ DB 'UNION', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06LNBM@UNIQUE?$AA@
_DATA	SEGMENT
??_C@_06LNBM@UNIQUE?$AA@ DB 'UNIQUE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CNPM@UNKNOWN?$AA@
_DATA	SEGMENT
??_C@_07CNPM@UNKNOWN?$AA@ DB 'UNKNOWN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06NDPG@UPDATE?$AA@
_DATA	SEGMENT
??_C@_06NDPG@UPDATE?$AA@ DB 'UPDATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DPMH@UPDATETEXT?$AA@
_DATA	SEGMENT
??_C@_0L@DPMH@UPDATETEXT?$AA@ DB 'UPDATETEXT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05PMKE@USAGE?$AA@
_DATA	SEGMENT
??_C@_05PMKE@USAGE?$AA@ DB 'USAGE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03OAHE@USE?$AA@
_DATA	SEGMENT
??_C@_03OAHE@USE?$AA@ DB 'USE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04FMHO@USER?$AA@
_DATA	SEGMENT
??_C@_04FMHO@USER?$AA@ DB 'USER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JKMB@USING?$AA@
_DATA	SEGMENT
??_C@_05JKMB@USING?$AA@ DB 'USING', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05MOEL@VALUE?$AA@
_DATA	SEGMENT
??_C@_05MOEL@VALUE?$AA@ DB 'VALUE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06KGMH@VALUES?$AA@
_DATA	SEGMENT
??_C@_06KGMH@VALUES?$AA@ DB 'VALUES', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03KNCG@VAR?$AA@
_DATA	SEGMENT
??_C@_03KNCG@VAR?$AA@ DB 'VAR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09OLDK@VARBINARY?$AA@
_DATA	SEGMENT
??_C@_09OLDK@VARBINARY?$AA@ DB 'VARBINARY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NGFA@VARCHAR?$AA@
_DATA	SEGMENT
??_C@_07NGFA@VARCHAR?$AA@ DB 'VARCHAR', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OIBN@VARP?$AA@
_DATA	SEGMENT
??_C@_04OIBN@VARP?$AA@ DB 'VARP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MMOJ@VARYING?$AA@
_DATA	SEGMENT
??_C@_07MMOJ@VARYING?$AA@ DB 'VARYING', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CGLB@VIEW?$AA@
_DATA	SEGMENT
??_C@_04CGLB@VIEW?$AA@ DB 'VIEW', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IEGE@VOLUME?$AA@
_DATA	SEGMENT
??_C@_06IEGE@VOLUME?$AA@ DB 'VOLUME', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07KCD@WAITFOR?$AA@
_DATA	SEGMENT
??_C@_07KCD@WAITFOR?$AA@ DB 'WAITFOR', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GKK@WHEN?$AA@
_DATA	SEGMENT
??_C@_04GKK@WHEN?$AA@ DB 'WHEN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05MCFK@WHERE?$AA@
_DATA	SEGMENT
??_C@_05MCFK@WHERE?$AA@ DB 'WHERE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05LCLH@WHILE?$AA@
_DATA	SEGMENT
??_C@_05LCLH@WHILE?$AA@ DB 'WHILE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NHMN@WITH?$AA@
_DATA	SEGMENT
??_C@_04NHMN@WITH?$AA@ DB 'WITH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LDPM@WORK?$AA@
_DATA	SEGMENT
??_C@_04LDPM@WORK?$AA@ DB 'WORK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05FIFP@WRITE?$AA@
_DATA	SEGMENT
??_C@_05FIFP@WRITE?$AA@ DB 'WRITE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09IKOB@WRITETEXT?$AA@
_DATA	SEGMENT
??_C@_09IKOB@WRITETEXT?$AA@ DB 'WRITETEXT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03BDEP@XOR?$AA@
_DATA	SEGMENT
??_C@_03BDEP@XOR?$AA@ DB 'XOR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HEBB@YEAR?$AA@
_DATA	SEGMENT
??_C@_04HEBB@YEAR?$AA@ DB 'YEAR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05NAPJ@YESNO?$AA@
_DATA	SEGMENT
??_C@_05NAPJ@YESNO?$AA@ DB 'YESNO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HOL@ZONE?$AA@
_DATA	SEGMENT
??_C@_04HOL@ZONE?$AA@ DB 'ZONE', 00H			; `string'
_DATA	ENDS
PUBLIC	_fnBuildDropIndex@20
PUBLIC	??_C@_01FAJB@?$DL?$AA@				; `string'
PUBLIC	??_C@_0BJ@FNLO@DROP?5INDEX?5?$CFs?5ON?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
EXTRN	_SysWriteLine@12:NEAR
EXTRN	__imp__sprintf:NEAR
;	COMDAT ??_C@_01FAJB@?$DL?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_01FAJB@?$DL?$AA@ DB ';', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@FNLO@DROP?5INDEX?5?$CFs?5ON?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BJ@FNLO@DROP?5INDEX?5?$CFs?5ON?5?$CFs?$CFs?5?$CFs?$AA@ DB 'DROP IN'
	DB	'DEX %s ON %s%s %s', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTaskView$ = 8
_pchIndexName$ = 12
_pchOwner$ = 16
_pchTableName$ = 20
_f$ = 24
_szLine$ = -500
_fnBuildDropIndex@20 PROC NEAR

; 1896 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H

; 1897 :    zCHAR szLine[ 500 ];
; 1898 : 
; 1899 :    #if defined( SQLSERVER )
; 1900 :       zsprintf( szLine, "DROP INDEX %s%s.%s %s",
; 1901 :                 pchOwner, pchTableName, pchIndexName, LINE_TERMINATOR );
; 1902 :    #else
; 1903 :       zsprintf( szLine, "DROP INDEX %s ON %s%s %s",
; 1904 :                 pchIndexName, pchOwner, pchTableName, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	mov	eax, DWORD PTR _pchTableName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchOwner$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchIndexName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BJ@FNLO@DROP?5INDEX?5?$CFs?5ON?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 1905 :    #endif
; 1906 : 
; 1907 :    if ( fnWriteLine( lpTaskView, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L30991

; 1908 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L30987
$L30991:

; 1909 : 
; 1910 :    return( 0 );

	xor	ax, ax
$L30987:

; 1911 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnBuildDropIndex@20 ENDP
_TEXT	ENDS
PUBLIC	_fnBuildColumn@12
PUBLIC	??_C@_08IAKB@TZTEDBLO?$AA@			; `string'
PUBLIC	??_C@_04EALC@DBMS?$AA@				; `string'
PUBLIC	??_C@_0P@BCDD@TE_DBMS_Source?$AA@		; `string'
PUBLIC	??_C@_08DKGC@DBH_Data?$AA@			; `string'
PUBLIC	??_C@_01PCJP@Y?$AA@				; `string'
PUBLIC	??_C@_0BC@KJKI@TimestampAsString?$AA@		; `string'
PUBLIC	??_C@_04JENC@ODBC?$AA@				; `string'
PUBLIC	??_C@_0BE@GNCH@MaxColumnNameLength?$AA@		; `string'
PUBLIC	??_C@_04EFNI@Name?$AA@				; `string'
PUBLIC	??_C@_0BA@PJGE@TE_FieldDataRel?$AA@		; `string'
PUBLIC	??_C@_08FNON@DataType?$AA@			; `string'
PUBLIC	??_C@_04DOMO@?$CF?9?$CKs?$AA@			; `string'
PUBLIC	??_C@_06CAAP@Length?$AA@			; `string'
PUBLIC	??_C@_0BA@FENM@?5varchar?$CI?5?$CFld?5?$CJ?$AA@	; `string'
PUBLIC	??_C@_09CPOG@?5longblob?$AA@			; `string'
PUBLIC	??_C@_09IJHK@?5datetime?$AA@			; `string'
PUBLIC	??_C@_04OGMO@?5int?$AA@				; `string'
PUBLIC	??_C@_07CLFL@?5double?$AA@			; `string'
PUBLIC	??_C@_09DKHG@?5longtext?$AA@			; `string'
PUBLIC	??_C@_0P@OLJF@?5varchar?$CI?530?5?$CJ?$AA@	; `string'
PUBLIC	??_C@_0L@NCMM@TE_TablRec?$AA@			; `string'
PUBLIC	??_C@_0CK@EKKO@Invalid?5DataType?5?8?$CFs?8?5for?5attrib@ ; `string'
PUBLIC	??_C@_0BC@KEK@SQL?5DDL?5Generator?$AA@		; `string'
PUBLIC	??_C@_09LPMC@SQL_NULLS?$AA@			; `string'
PUBLIC	??_C@_08IDDA@NOT?5NULL?$AA@			; `string'
PUBLIC	??_C@_08FGIB@NULL?5?5?5?5?$AA@			; `string'
EXTRN	_SysMessageBox@16:NEAR
EXTRN	_SetOI_FromBlob@28:NEAR
EXTRN	_CompareAttributeToString@16:NEAR
EXTRN	_GetAddrForAttribute@16:NEAR
EXTRN	_GetViewByName@16:NEAR
EXTRN	_DropView@4:NEAR
EXTRN	_strcat:NEAR
EXTRN	_strlen:NEAR
EXTRN	_SetCursorFirstEntityByAttr@28:NEAR
EXTRN	_GetStringFromAttribute@16:NEAR
EXTRN	_GetIntegerFromAttribute@16:NEAR
;	COMDAT ??_C@_08IAKB@TZTEDBLO?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_08IAKB@TZTEDBLO?$AA@ DB 'TZTEDBLO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EALC@DBMS?$AA@
_DATA	SEGMENT
??_C@_04EALC@DBMS?$AA@ DB 'DBMS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@BCDD@TE_DBMS_Source?$AA@
_DATA	SEGMENT
??_C@_0P@BCDD@TE_DBMS_Source?$AA@ DB 'TE_DBMS_Source', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DKGC@DBH_Data?$AA@
_DATA	SEGMENT
??_C@_08DKGC@DBH_Data?$AA@ DB 'DBH_Data', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PCJP@Y?$AA@
_DATA	SEGMENT
??_C@_01PCJP@Y?$AA@ DB 'Y', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KJKI@TimestampAsString?$AA@
_DATA	SEGMENT
??_C@_0BC@KJKI@TimestampAsString?$AA@ DB 'TimestampAsString', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JENC@ODBC?$AA@
_DATA	SEGMENT
??_C@_04JENC@ODBC?$AA@ DB 'ODBC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@GNCH@MaxColumnNameLength?$AA@
_DATA	SEGMENT
??_C@_0BE@GNCH@MaxColumnNameLength?$AA@ DB 'MaxColumnNameLength', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EFNI@Name?$AA@
_DATA	SEGMENT
??_C@_04EFNI@Name?$AA@ DB 'Name', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PJGE@TE_FieldDataRel?$AA@
_DATA	SEGMENT
??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ DB 'TE_FieldDataRel', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FNON@DataType?$AA@
_DATA	SEGMENT
??_C@_08FNON@DataType?$AA@ DB 'DataType', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DOMO@?$CF?9?$CKs?$AA@
_DATA	SEGMENT
??_C@_04DOMO@?$CF?9?$CKs?$AA@ DB '%-*s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06CAAP@Length?$AA@
_DATA	SEGMENT
??_C@_06CAAP@Length?$AA@ DB 'Length', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FENM@?5varchar?$CI?5?$CFld?5?$CJ?$AA@
_DATA	SEGMENT
??_C@_0BA@FENM@?5varchar?$CI?5?$CFld?5?$CJ?$AA@ DB ' varchar( %ld )', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09CPOG@?5longblob?$AA@
_DATA	SEGMENT
??_C@_09CPOG@?5longblob?$AA@ DB ' longblob', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09IJHK@?5datetime?$AA@
_DATA	SEGMENT
??_C@_09IJHK@?5datetime?$AA@ DB ' datetime', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OGMO@?5int?$AA@
_DATA	SEGMENT
??_C@_04OGMO@?5int?$AA@ DB ' int', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CLFL@?5double?$AA@
_DATA	SEGMENT
??_C@_07CLFL@?5double?$AA@ DB ' double', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09DKHG@?5longtext?$AA@
_DATA	SEGMENT
??_C@_09DKHG@?5longtext?$AA@ DB ' longtext', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@OLJF@?5varchar?$CI?530?5?$CJ?$AA@
_DATA	SEGMENT
??_C@_0P@OLJF@?5varchar?$CI?530?5?$CJ?$AA@ DB ' varchar( 30 )', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@NCMM@TE_TablRec?$AA@
_DATA	SEGMENT
??_C@_0L@NCMM@TE_TablRec?$AA@ DB 'TE_TablRec', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@EKKO@Invalid?5DataType?5?8?$CFs?8?5for?5attrib@
_DATA	SEGMENT
??_C@_0CK@EKKO@Invalid?5DataType?5?8?$CFs?8?5for?5attrib@ DB 'Invalid Dat'
	DB	'aType ''%s'' for attribute %s.%s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KEK@SQL?5DDL?5Generator?$AA@
_DATA	SEGMENT
??_C@_0BC@KEK@SQL?5DDL?5Generator?$AA@ DB 'SQL DDL Generator', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09LPMC@SQL_NULLS?$AA@
_DATA	SEGMENT
??_C@_09LPMC@SQL_NULLS?$AA@ DB 'SQL_NULLS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IDDA@NOT?5NULL?$AA@
_DATA	SEGMENT
??_C@_08IDDA@NOT?5NULL?$AA@ DB 'NOT NULL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FGIB@NULL?5?5?5?5?$AA@
_DATA	SEGMENT
??_C@_08FGIB@NULL?5?5?5?5?$AA@ DB 'NULL    ', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_pchLine$ = 16
_szColName$ = -264
_pchDataType$ = -324
_pchEnd$ = -320
_pch$ = -4
_nLth$ = -8
_nMaxColumnNameLth$ = -268
_szDBH_DataObjectName$ = -316
_vDBH_Data$ = -280
_vTZTEDBLO$ = -272
_vTZDBHODO$ = -276
_bTimestampAsString$ = -328
_l$31017 = -332
_szTableName$31055 = -664
_szMsg$31056 = -632
_fnBuildColumn@12 PROC NEAR

; 1915 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 668				; 0000029cH

; 1916 :    zCHAR    szColName[ MAX_NAME_LTH + 1 ];
; 1917 :    zPCHAR   pchDataType;
; 1918 :    zPCHAR   pchEnd, pch;
; 1919 :    zLONG    nLth;
; 1920 :    zUSHORT  nMaxColumnNameLth = MAX_COLUMNNAME_LTH;

	mov	WORD PTR _nMaxColumnNameLth$[ebp], 18	; 00000012H

; 1921 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 1922 :    zVIEW    vDBH_Data;
; 1923 :    zVIEW    vTZTEDBLO = 0;

	mov	DWORD PTR _vTZTEDBLO$[ebp], 0

; 1924 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 1925 :    zBOOL    bTimestampAsString = FALSE;

	mov	BYTE PTR _bTimestampAsString$[ebp], 0

; 1926 : 
; 1927 :    // If it exists get the object that defines the dbhandler type.
; 1928 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	call	_GetViewByName@16

; 1929 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $L31012

; 1930 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 1931 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByAttr@28
$L31012:

; 1932 : 
; 1933 :    // Try to get the OI that contains DBH-specific data.
; 1934 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 1935 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 1936 : 
; 1937 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 1938 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 1939 : 
; 1940 :    // Try to get the ODBC definition.
; 1941 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 1942 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _vTZDBHODO$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 1943 : 
; 1944 :    // Check to see if there is DBH data set in the TE.
; 1945 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31016

; 1947 :       zLONG l;
; 1948 : 
; 1949 :       bTimestampAsString = ( CompareAttributeToString( vDBH_Data, "ODBC",
; 1950 :                                                        "TimestampAsString",
; 1951 :                                                        "Y" ) == 0 );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BC@KJKI@TimestampAsString?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	movsx	eax, ax
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	BYTE PTR _bTimestampAsString$[ebp], al

; 1952 : 
; 1953 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 1954 :                                     "MaxColumnNameLength" ) != -1 )

	push	OFFSET FLAT:??_C@_0BE@GNCH@MaxColumnNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _l$31017[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16
	movsx	eax, ax
	cmp	eax, -1
	je	SHORT $L31021

; 1956 :          nMaxColumnNameLth = (zSHORT) l;

	mov	cx, WORD PTR _l$31017[ebp]
	mov	WORD PTR _nMaxColumnNameLth$[ebp], cx
$L31021:

; 1959 :    else

	jmp	SHORT $L31026
$L31016:

; 1960 :    // Check to see if there is DBH data set in the DB List object.
; 1961 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $L31025

; 1963 :       bTimestampAsString = ( CompareAttributeToString( vTZDBHODO, "ODBC",
; 1964 :                                                        "TimestampAsString",
; 1965 :                                                        "Y" ) == 0 );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BC@KJKI@TimestampAsString?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vTZDBHODO$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	movsx	eax, ax
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	BYTE PTR _bTimestampAsString$[ebp], al

; 1967 :    else

	jmp	SHORT $L31026
$L31025:

; 1969 :       // If we get here then no info was set for this DBH so use defaults.
; 1970 :       bTimestampAsString = FALSE;

	mov	BYTE PTR _bTimestampAsString$[ebp], 0
$L31026:

; 1972 : 
; 1973 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $L31027

; 1974 :       DropView( vTZDBHODO );

	mov	ecx, DWORD PTR _vTZDBHODO$[ebp]
	push	ecx
	call	_DropView@4
$L31027:

; 1975 : 
; 1976 : #endif
; 1977 : 
; 1978 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31028

; 1979 :       DropView( vDBH_Data );

	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	call	_DropView@4
$L31028:

; 1980 : 
; 1981 :    GetStringFromAttribute( szColName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szColName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 1982 :    GetAddrForAttribute( &pchDataType, vDTE, "TE_FieldDataRel",
; 1983 :                         "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDataType$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 1984 :    RemoveBrackets( szColName );

	lea	ecx, DWORD PTR _szColName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 1985 : 
; 1986 :    pchEnd = pchLine + zstrlen( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, eax
	mov	DWORD PTR _pchEnd$[ebp], ecx

; 1987 :    zsprintf( pchEnd, "%-*s", nMaxColumnNameLth, szColName );

	lea	edx, DWORD PTR _szColName$[ebp]
	push	edx
	mov	eax, DWORD PTR _nMaxColumnNameLth$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	push	OFFSET FLAT:??_C@_04DOMO@?$CF?9?$CKs?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 1988 :    pchEnd = pchEnd + zstrlen( pchEnd );

	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	add	ecx, eax
	mov	DWORD PTR _pchEnd$[ebp], ecx

; 1989 : 
; 1990 : #if defined( ACCESS )
; 1991 : 
; 1992 :    switch ( pchDataType[ 0 ] )
; 1993 :    {
; 1994 :       case zTYPE_STRING:
; 1995 :       case zTYPE_FIXEDCHAR:
; 1996 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 1997 :                                   "Length" );
; 1998 :          zsprintf( pchEnd, " TEXT( %ld )", nLth );
; 1999 : 
; 2000 :          break;
; 2001 : 
; 2002 :       case zTYPE_BLOB:
; 2003 :          zsprintf( pchEnd, " LONGBINARY" );
; 2004 :          break;
; 2005 : 
; 2006 :       case zTYPE_INTEGER:
; 2007 :          zsprintf( pchEnd, " INTEGER" );
; 2008 :          break;
; 2009 : 
; 2010 :       case zTYPE_DECIMAL:
; 2011 :          zsprintf( pchEnd, " DOUBLE" );
; 2012 :          break;
; 2013 : 
; 2014 :       case zTYPE_DATETIME:
; 2015 :       case zTYPE_TIME:
; 2016 :          if ( bTimestampAsString )
; 2017 :             zsprintf( pchEnd, " TEXT( 25 )" );
; 2018 :          else
; 2019 :          {
; 2020 :             switch ( pchDataType[ 0 ] )
; 2021 :             {
; 2022 :                case zTYPE_DATETIME:
; 2023 :                   zsprintf( pchEnd, " DATETIME" );
; 2024 :                   break;
; 2025 : 
; 2026 :                case zTYPE_TIME:
; 2027 :                   zsprintf( pchEnd, " TIME" );
; 2028 :                   break;
; 2029 :             }
; 2030 :          }
; 2031 : 
; 2032 :          break;
; 2033 : 
; 2034 :       case zTYPE_DATE:
; 2035 :          zsprintf( pchEnd, " DATE" );
; 2036 :          break;
; 2037 : 
; 2038 :       // ===
; 2039 :       // === Non-standard types follow here.
; 2040 :       // ===
; 2041 : 
; 2042 :       // Long text fields.
; 2043 :       case 'V':
; 2044 :          zsprintf( pchEnd, " MEMO" );
; 2045 :          break;
; 2046 : 
; 2047 :       // TimeStampEx
; 2048 :       case 'X':
; 2049 :          zsprintf( pchEnd, " TEXT( 30 )" );
; 2050 :          break;
; 2051 : 
; 2052 :       default:
; 2053 :       {
; 2054 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2055 :          zCHAR szMsg[ 300 ];
; 2056 : 
; 2057 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2058 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2059 :                    pchDataType, szTableName, szColName );
; 2060 :          SysMessageBox( vDTE, "SQLBASE DDL Generator", szMsg, 1 );
; 2061 :          return( -1 );
; 2062 :       }
; 2063 : 
; 2064 :    } // switch ( pchDataType[ 0 ] )...
; 2065 : 
; 2066 : #elif defined( DB2 )
; 2067 : 
; 2068 :    switch ( pchDataType[ 0 ] )
; 2069 :    {
; 2070 :       case zTYPE_STRING:
; 2071 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2072 :                                   "Length" );
; 2073 :          zsprintf( pchEnd, " VARCHAR( %ld )", nLth );
; 2074 : 
; 2075 :          break;
; 2076 : 
; 2077 :       case zTYPE_FIXEDCHAR:
; 2078 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2079 :                                   "Length" );
; 2080 :          zsprintf( pchEnd, " CHAR( %ld )", nLth );
; 2081 : 
; 2082 :          break;
; 2083 : 
; 2084 :       case zTYPE_BLOB:
; 2085 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2086 :                                   "Length" );
; 2087 :          zsprintf( pchEnd, " BLOB( %ld )", nLth );
; 2088 :          break;
; 2089 : 
; 2090 :       case zTYPE_DATETIME:
; 2091 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2092 :          break;
; 2093 : 
; 2094 :       case zTYPE_INTEGER:
; 2095 :          zsprintf( pchEnd, " INTEGER" );
; 2096 :          break;
; 2097 : 
; 2098 :       case zTYPE_DECIMAL:
; 2099 :       {
; 2100 :          zLONG nScale;
; 2101 : 
; 2102 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2103 :                                   "Length" );
; 2104 :          if ( nLth > 31 )
; 2105 :             nLth = 31;
; 2106 : 
; 2107 :          GetIntegerFromAttribute( &nScale, vDTE, "TE_FieldDataRel",
; 2108 :                                   "SQL_SCALE" );
; 2109 : 
; 2110 :          zsprintf( pchEnd, " DECIMAL( %ld,%ld )", nLth, nScale );
; 2111 :          break;
; 2112 :       }
; 2113 : 
; 2114 :       case zTYPE_DATE:
; 2115 :          zsprintf( pchEnd, " DATE" );
; 2116 :          break;
; 2117 : 
; 2118 :       case zTYPE_TIME:
; 2119 :          zsprintf( pchEnd, " TIME" );
; 2120 :          break;
; 2121 : 
; 2122 :       // ===
; 2123 :       // === Non-standard types follow here.
; 2124 :       // ===
; 2125 : 
; 2126 :       case 'V':
; 2127 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2128 :                                   "Length" );
; 2129 :          zsprintf( pchEnd, " CLOB( %ld )", nLth );
; 2130 :          break;
; 2131 : 
; 2132 :       // TimeStampEx
; 2133 :       case 'X':
; 2134 :          zsprintf( pchEnd, " VARCHAR( 30 )" );
; 2135 :          break;
; 2136 : 
; 2137 :       default:
; 2138 :       {
; 2139 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2140 :          zCHAR szMsg[ 300 ];
; 2141 : 
; 2142 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2143 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2144 :                    pchDataType, szTableName, szColName );
; 2145 :          SysMessageBox( vDTE, "SQLBASE DDL Generator", szMsg, 1 );
; 2146 :          return( -1 );
; 2147 :       }
; 2148 : 
; 2149 :    } // switch ( pchDataType[ 0 ] )...
; 2150 : 
; 2151 : #elif defined( MYSQL )
; 2152 : 
; 2153 :    switch ( pchDataType[ 0 ] )
; 2154 :    {

	mov	edx, DWORD PTR _pchDataType$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR -668+[ebp], eax
	mov	ecx, DWORD PTR -668+[ebp]
	sub	ecx, 66					; 00000042H
	mov	DWORD PTR -668+[ebp], ecx
	cmp	DWORD PTR -668+[ebp], 22		; 00000016H
	ja	$L31054
	mov	eax, DWORD PTR -668+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L32317[eax]
	jmp	DWORD PTR $L32318[edx*4]
$L31037:

; 2155 :       case zTYPE_STRING:
; 2156 :       case zTYPE_FIXEDCHAR:
; 2157 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2158 :                                   "Length" );

	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _nLth$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 2159 :          zsprintf( pchEnd, " varchar( %ld )", nLth );

	mov	eax, DWORD PTR _nLth$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BA@FENM@?5varchar?$CI?5?$CFld?5?$CJ?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 2160 : 
; 2161 :          break;

	jmp	$L31034
$L31040:

; 2162 : 
; 2163 :       case zTYPE_BLOB:
; 2164 :          zsprintf( pchEnd, " longblob" );

	push	OFFSET FLAT:??_C@_09CPOG@?5longblob?$AA@ ; `string'
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2165 :          break;

	jmp	$L31034
$L31042:

; 2166 : 
; 2167 :       case zTYPE_DATETIME:
; 2168 :          zsprintf( pchEnd, " datetime" );

	push	OFFSET FLAT:??_C@_09IJHK@?5datetime?$AA@ ; `string'
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2169 :          break;

	jmp	$L31034
$L31044:

; 2170 : 
; 2171 :       case zTYPE_INTEGER:
; 2172 :          zsprintf( pchEnd, " int" );

	push	OFFSET FLAT:??_C@_04OGMO@?5int?$AA@	; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2173 :          break;

	jmp	$L31034
$L31046:

; 2174 : 
; 2175 :       case zTYPE_DECIMAL:
; 2176 :          zsprintf( pchEnd, " double" );

	push	OFFSET FLAT:??_C@_07CLFL@?5double?$AA@	; `string'
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2177 :          break;

	jmp	$L31034
$L31048:

; 2178 : 
; 2179 :       case zTYPE_DATE:
; 2180 :          zsprintf( pchEnd, " datetime" );

	push	OFFSET FLAT:??_C@_09IJHK@?5datetime?$AA@ ; `string'
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2181 :          break;

	jmp	$L31034
$L31049:

; 2182 : 
; 2183 :       case zTYPE_TIME:
; 2184 :          zsprintf( pchEnd, " datetime" );

	push	OFFSET FLAT:??_C@_09IJHK@?5datetime?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2185 :          break;

	jmp	$L31034
$L31050:

; 2186 : 
; 2187 :       // ===
; 2188 :       // === Non-standard types follow here.
; 2189 :       // ===
; 2190 : 
; 2191 :       case 'V':
; 2192 :          zsprintf( pchEnd, " longtext" );

	push	OFFSET FLAT:??_C@_09DKHG@?5longtext?$AA@ ; `string'
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2193 :          break;

	jmp	SHORT $L31034
$L31052:

; 2194 : 
; 2195 :       // TimeStampEx
; 2196 :       case 'X':
; 2197 :          zsprintf( pchEnd, " varchar( 30 )" );

	push	OFFSET FLAT:??_C@_0P@OLJF@?5varchar?$CI?530?5?$CJ?$AA@ ; `string'
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2198 :          break;

	jmp	SHORT $L31034
$L31054:

; 2202 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2203 :          zCHAR szMsg[ 300 ];
; 2204 : 
; 2205 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$31055[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 2206 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2207 :                    pchDataType, szTableName, szColName );

	lea	eax, DWORD PTR _szColName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$31055[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchDataType$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CK@EKKO@Invalid?5DataType?5?8?$CFs?8?5for?5attrib@ ; `string'
	lea	eax, DWORD PTR _szMsg$31056[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2208 :          SysMessageBox( vDTE, "SQL DDL Generator", szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$31056[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BC@KEK@SQL?5DDL?5Generator?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysMessageBox@16

; 2209 :          return( -1 );

	or	ax, -1
	jmp	$L30999
$L31034:

; 2213 : 
; 2214 : #elif defined( SQLBASE ) || defined( ODBC )
; 2215 : 
; 2216 :    switch ( pchDataType[ 0 ] )
; 2217 :    {
; 2218 :       case zTYPE_STRING:
; 2219 :       case zTYPE_FIXEDCHAR:
; 2220 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2221 :                                   "Length" );
; 2222 :          zsprintf( pchEnd, " CHAR( %ld )", nLth );
; 2223 : 
; 2224 :          break;
; 2225 : 
; 2226 :       case zTYPE_BLOB:
; 2227 :          zsprintf( pchEnd, " LONG VARCHAR" );
; 2228 :          break;
; 2229 : 
; 2230 :       case zTYPE_INTEGER:
; 2231 :          zsprintf( pchEnd, " INTEGER" );
; 2232 :          break;
; 2233 : 
; 2234 :       case zTYPE_DECIMAL:
; 2235 :       {
; 2236 :          zLONG nScale;
; 2237 : 
; 2238 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2239 :                                   "Length" );
; 2240 :          GetIntegerFromAttribute( &nScale, vDTE, "TE_FieldDataRel",
; 2241 :                                   "SQL_SCALE" );
; 2242 : 
; 2243 :          zsprintf( pchEnd, " DECIMAL( %ld,%ld )", nLth, nScale );
; 2244 :          break;
; 2245 :       }
; 2246 : 
; 2247 :    #ifdef ODBC
; 2248 : 
; 2249 :       case zTYPE_DATETIME:
; 2250 :       case zTYPE_TIME:
; 2251 :          if ( bTimestampAsString )
; 2252 :             zsprintf( pchEnd, " TEXT( 25 )" );
; 2253 :          else
; 2254 :          {
; 2255 :             switch ( pchDataType[ 0 ] )
; 2256 :             {
; 2257 :                case zTYPE_DATETIME:
; 2258 :                   zsprintf( pchEnd, " DATETIME" );
; 2259 :                   break;
; 2260 : 
; 2261 :                case zTYPE_TIME:
; 2262 :                   zsprintf( pchEnd, " TIME" );
; 2263 :                   break;
; 2264 :             }
; 2265 :          }
; 2266 : 
; 2267 :          break;
; 2268 : 
; 2269 :       case zTYPE_DATE:
; 2270 :          zsprintf( pchEnd, " DATE" );
; 2271 :          break;
; 2272 : 
; 2273 :    #else
; 2274 :       case zTYPE_DATETIME:
; 2275 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2276 :          break;
; 2277 : 
; 2278 :       case zTYPE_DATE:
; 2279 :          zsprintf( pchEnd, " DATE" );
; 2280 :          break;
; 2281 : 
; 2282 :       case zTYPE_TIME:
; 2283 :          zsprintf( pchEnd, " TIME" );
; 2284 :          break;
; 2285 :    #endif
; 2286 : 
; 2287 :       // ===
; 2288 :       // === Non-standard types follow here.
; 2289 :       // ===
; 2290 : 
; 2291 :       case 'V':
; 2292 :          zsprintf( pchEnd, " LONG VARCHAR" );
; 2293 :          break;
; 2294 : 
; 2295 :       // TimeStampEx
; 2296 :       case 'X':
; 2297 :          zsprintf( pchEnd, " CHAR( 30 )" );
; 2298 :          break;
; 2299 : 
; 2300 :       default:
; 2301 :       {
; 2302 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2303 :          zCHAR szMsg[ 300 ];
; 2304 : 
; 2305 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2306 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2307 :                    pchDataType, szTableName, szColName );
; 2308 :          SysMessageBox( vDTE, "SQLBASE DDL Generator", szMsg, 1 );
; 2309 :          return( -1 );
; 2310 :       }
; 2311 : 
; 2312 :    } // switch ( pchDataType[ 0 ] )...
; 2313 : 
; 2314 : #elif defined( POSTGRESQL )
; 2315 : 
; 2316 :    switch ( pchDataType[ 0 ] )
; 2317 :    {
; 2318 :       case zTYPE_STRING:
; 2319 :       case zTYPE_FIXEDCHAR:
; 2320 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2321 :                                   "Length" );
; 2322 :          zsprintf( pchEnd, " varchar( %ld )", nLth );
; 2323 : 
; 2324 :          break;
; 2325 : 
; 2326 :       case zTYPE_BLOB:
; 2327 :          zsprintf( pchEnd, " bytea" );
; 2328 :          //zsprintf( pchEnd, " text" );
; 2329 :          break;
; 2330 : 
; 2331 :       case zTYPE_DATETIME:
; 2332 :          zsprintf( pchEnd, " timestamp" );
; 2333 :          break;
; 2334 : 
; 2335 :       case zTYPE_INTEGER:
; 2336 :          zsprintf( pchEnd, " int" );
; 2337 :          break;
; 2338 : 
; 2339 :       case zTYPE_DECIMAL:
; 2340 :          zsprintf( pchEnd, " float4" );
; 2341 :          break;
; 2342 : 
; 2343 :       case zTYPE_DATE:
; 2344 :          zsprintf( pchEnd, " timestamp" );
; 2345 :          break;
; 2346 : 
; 2347 :       case zTYPE_TIME:
; 2348 :          zsprintf( pchEnd, " timestamp" );
; 2349 :          break;
; 2350 : 
; 2351 :       // ===
; 2352 :       // === Non-standard types follow here.
; 2353 :       // ===
; 2354 : 
; 2355 :       case 'V':
; 2356 :          zsprintf( pchEnd, " text" );
; 2357 :          break;
; 2358 : 
; 2359 :       // TimeStampEx
; 2360 :       case 'X':
; 2361 :          zsprintf( pchEnd, " varchar( 30 )" );
; 2362 :          break;
; 2363 : 
; 2364 :       default:
; 2365 :       {
; 2366 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2367 :          zCHAR szMsg[ 300 ];
; 2368 : 
; 2369 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2370 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2371 :                    pchDataType, szTableName, szColName );
; 2372 :          SysMessageBox( vDTE, "SQL DDL Generator", szMsg, 1 );
; 2373 :          return( -1 );
; 2374 :       }
; 2375 : 
; 2376 :    } // switch ( pchDataType[ 0 ] )...
; 2377 : 
; 2378 : #elif defined( SQLSERVER )
; 2379 : 
; 2380 :    switch ( pchDataType[ 0 ] )
; 2381 :    {
; 2382 :       case zTYPE_STRING:
; 2383 :       case zTYPE_FIXEDCHAR:
; 2384 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2385 :                                   "Length" );
; 2386 :          zsprintf( pchEnd, " varchar( %ld )", nLth );
; 2387 : 
; 2388 :          break;
; 2389 : 
; 2390 :       case zTYPE_BLOB:
; 2391 :          zsprintf( pchEnd, " varbinary(max)" );
; 2392 :          break;
; 2393 : 
; 2394 :       case zTYPE_DATETIME:
; 2395 :          zsprintf( pchEnd, " datetime" );
; 2396 :          break;
; 2397 : 
; 2398 :       case zTYPE_INTEGER:
; 2399 :          zsprintf( pchEnd, " int" );
; 2400 :          break;
; 2401 : 
; 2402 :       case zTYPE_DECIMAL:
; 2403 :          zsprintf( pchEnd, " float" );
; 2404 :          break;
; 2405 : 
; 2406 :       case zTYPE_DATE:
; 2407 :          zsprintf( pchEnd, " datetime" );
; 2408 :          break;
; 2409 : 
; 2410 :       case zTYPE_TIME:
; 2411 :          zsprintf( pchEnd, " datetime" );
; 2412 :          break;
; 2413 : 
; 2414 :       // ===
; 2415 :       // === Non-standard types follow here.
; 2416 :       // ===
; 2417 : 
; 2418 :       case 'V':
; 2419 :          zsprintf( pchEnd, " nvarchar(max)" );
; 2420 :          break;
; 2421 : 
; 2422 :       // TimeStampEx
; 2423 :       case 'X':
; 2424 :          zsprintf( pchEnd, " varchar( 30 )" );
; 2425 :          break;
; 2426 : 
; 2427 :       default:
; 2428 :       {
; 2429 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2430 :          zCHAR szMsg[ 300 ];
; 2431 : 
; 2432 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2433 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2434 :                    pchDataType, szTableName, szColName );
; 2435 :          SysMessageBox( vDTE, "SQL DDL Generator", szMsg, 1 );
; 2436 :          return( -1 );
; 2437 :       }
; 2438 : 
; 2439 :    } // switch ( pchDataType[ 0 ] )...
; 2440 : #endif
; 2441 : 
; 2442 :    // Space out the data type string.
; 2443 :    for ( pch = pchEnd + zstrlen( pchEnd );
; 2444 :          pch < pchEnd + MAX_DATATYPE_LTH;
; 2445 :          pch++ )

	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	add	ecx, eax
	mov	DWORD PTR _pch$[ebp], ecx
	jmp	SHORT $L31060
$L31061:
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
$L31060:
	mov	eax, DWORD PTR _pchEnd$[ebp]
	add	eax, 20					; 00000014H
	cmp	DWORD PTR _pch$[ebp], eax
	jae	SHORT $L31062

; 2447 :       *pch = ' ';

	mov	ecx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [ecx], 32			; 00000020H

; 2448 :    }

	jmp	SHORT $L31061
$L31062:

; 2449 : 
; 2450 :    *pch = 0;

	mov	edx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [edx], 0

; 2451 :    pchEnd = pch;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	DWORD PTR _pchEnd$[ebp], eax

; 2452 : 
; 2453 :    // Check to see if column can be NULL.
; 2454 :    if ( CompareAttributeToString( vDTE, "TE_FieldDataRel",
; 2455 :                                   "SQL_NULLS", "Y" ) == 0  )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_09LPMC@SQL_NULLS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L31063

; 2457 :       zstrcat( pchEnd, NOT_NULL_FIELD );

	push	OFFSET FLAT:??_C@_08IDDA@NOT?5NULL?$AA@	; `string'
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2459 :    else

	jmp	SHORT $L31066
$L31063:

; 2460 :       zstrcat( pchEnd, NULL_FIELD );

	push	OFFSET FLAT:??_C@_08FGIB@NULL?5?5?5?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$L31066:

; 2461 : 
; 2462 :    pchEnd = pchLine + zstrlen( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, eax
	mov	DWORD PTR _pchEnd$[ebp], ecx

; 2463 : 
; 2464 :    return( 0 );

	xor	ax, ax
$L30999:

; 2465 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L32318:
	DD	$L31040
	DD	$L31048
	DD	$L31037
	DD	$L31049
	DD	$L31044
	DD	$L31046
	DD	$L31042
	DD	$L31050
	DD	$L31052
	DD	$L31054
$L32317:
	DB	0
	DB	9
	DB	1
	DB	9
	DB	2
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	4
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	6
	DB	9
	DB	7
	DB	9
	DB	8
_fnBuildColumn@12 ENDP
_TEXT	ENDS
PUBLIC	_fnBuildFK_Index@8
PUBLIC	??_C@_0N@HJOL@DefaultOwner?$AA@			; `string'
PUBLIC	??_C@_0P@CNMG@SQL_TableOwner?$AA@		; `string'
PUBLIC	??_C@_01PJCK@?4?$AA@				; `string'
PUBLIC	??_C@_0BD@KOPE@MaxTableNameLength?$AA@		; `string'
PUBLIC	??_C@_04DKMG@Desc?$AA@				; `string'
PUBLIC	??_C@_02BOOO@?$CK?1?$AA@			; `string'
PUBLIC	??_C@_02FCCF@?1?$CK?$AA@			; `string'
PUBLIC	??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_04BBDM@ZKey?$AA@				; `string'
PUBLIC	??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@		; `string'
PUBLIC	??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@ ; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	??_C@_01PAOO@B?$AA@				; `string'
PUBLIC	??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_01FCOA@?5?$AA@				; `string'
PUBLIC	??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@ ; `string'
EXTRN	_strcpy:NEAR
EXTRN	_UfCompressName@32:NEAR
;	COMDAT ??_C@_00A@?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_C@_0N@HJOL@DefaultOwner?$AA@
_DATA	SEGMENT
??_C@_0N@HJOL@DefaultOwner?$AA@ DB 'DefaultOwner', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@CNMG@SQL_TableOwner?$AA@
_DATA	SEGMENT
??_C@_0P@CNMG@SQL_TableOwner?$AA@ DB 'SQL_TableOwner', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PJCK@?4?$AA@
_DATA	SEGMENT
??_C@_01PJCK@?4?$AA@ DB '.', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KOPE@MaxTableNameLength?$AA@
_DATA	SEGMENT
??_C@_0BD@KOPE@MaxTableNameLength?$AA@ DB 'MaxTableNameLength', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DKMG@Desc?$AA@
_DATA	SEGMENT
??_C@_04DKMG@Desc?$AA@ DB 'Desc', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02BOOO@?$CK?1?$AA@
_DATA	SEGMENT
??_C@_02BOOO@?$CK?1?$AA@ DB '*/', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02FCCF@?1?$CK?$AA@
_DATA	SEGMENT
??_C@_02FCCF@?1?$CK?$AA@ DB '/*', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@
_DATA	SEGMENT
??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@ DB '%s Ind'
	DB	'ex for Relationship - ''%s'' %s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BBDM@ZKey?$AA@
_DATA	SEGMENT
??_C@_04BBDM@ZKey?$AA@ DB 'ZKey', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@
_DATA	SEGMENT
??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@ DB '%s_%s_%ld0', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@
_DATA	SEGMENT
??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@ DB 'B_AEIOUYBCDFGHJKLMNP'
	DB	'QRSTVWXZ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PAOO@B?$AA@
_DATA	SEGMENT
??_C@_01PAOO@B?$AA@ DB 'B', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ DB 'CREATE INDEX %s%'
	DB	's %s', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ DB '       '
	DB	'ON %s%s ( %s', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FCOA@?5?$AA@
_DATA	SEGMENT
??_C@_01FCOA@?5?$AA@ DB ' ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@ DB '%*s %s ) %s', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_f$ = 12
_szLine$ = -800
_pch$ = -36
_szKeyName$ = -296
_szOwner$ = -32
_szTableName$ = -880
_pchDefaultOwner$ = -848
_szWorkIdxName$ = -1400
_szDBH_DataObjectName$ = -844
_nMaxTableNameLth$ = -40
_lZKey$ = -884
_vDBH_Data$ = -808
_vTZTEDBLO$ = -300
_vTZDBHODO$ = -804
_l$31096 = -1404
_fnBuildFK_Index@8 PROC NEAR

; 2469 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1404				; 0000057cH

; 2470 :    zCHAR    szLine[ 500 ];
; 2471 :    zPCHAR   pch;
; 2472 :    zCHAR    szKeyName[ MAX_NAME_LTH + 1 ];
; 2473 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 2474 :    zCHAR    szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2475 :    zPCHAR   pchDefaultOwner;
; 2476 :    zCHAR    szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 2477 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 2478 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	WORD PTR _nMaxTableNameLth$[ebp], 30	; 0000001eH

; 2479 :    zLONG    lZKey;
; 2480 :    zVIEW    vDBH_Data;
; 2481 :    zVIEW    vTZTEDBLO;
; 2482 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 2483 : 
; 2484 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",
; 2485 :                         "DefaultOwner" );

	push	OFFSET FLAT:??_C@_0N@HJOL@DefaultOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 2486 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31089
	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $L31088
$L31089:

; 2487 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$L31088:

; 2488 : 
; 2489 :    GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 2490 :    if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	jne	SHORT $L31091
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31091

; 2491 :       zstrcpy( szOwner, pchDefaultOwner );

	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L31091:

; 2492 : 
; 2493 :    if ( szOwner[ 0 ] )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	je	SHORT $L31092

; 2494 :       zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$L31092:

; 2495 : 
; 2496 :    // If it exists get the object that defines the dbhandler type.
; 2497 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_GetViewByName@16

; 2498 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $L31094

; 2499 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 2500 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	call	_SetCursorFirstEntityByAttr@28
$L31094:

; 2501 : 
; 2502 :    // Try to get the OI that contains DBH-specific data.
; 2503 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 2504 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 2505 : 
; 2506 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 2507 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 2508 : 
; 2509 :    // Try to get the ODBC definition.
; 2510 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 2511 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _vTZDBHODO$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 2512 : 
; 2513 :    // Check to see if there is DBH data set in the TE.
; 2514 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31097

; 2516 :       zLONG l;
; 2517 : 
; 2518 :       // Check to see if there is an max length override.
; 2519 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 2520 :                                     "MaxTableNameLength" ) != -1 )

	push	OFFSET FLAT:??_C@_0BD@KOPE@MaxTableNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _l$31096[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16
	movsx	eax, ax
	cmp	eax, -1
	je	SHORT $L31097

; 2522 :          nMaxTableNameLth = (zSHORT) l;

	mov	cx, WORD PTR _l$31096[ebp]
	mov	WORD PTR _nMaxTableNameLth$[ebp], cx
$L31097:

; 2525 : 
; 2526 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $L31100

; 2527 :       DropView( vTZDBHODO );

	mov	edx, DWORD PTR _vTZDBHODO$[ebp]
	push	edx
	call	_DropView@4
$L31100:

; 2528 : #endif
; 2529 : 
; 2530 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31101

; 2531 :       DropView( vDBH_Data );

	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_DropView@4
$L31101:

; 2532 : 
; 2533 :    GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 2534 :    RemoveBrackets( szTableName );

	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 2535 : 
; 2536 :    // Generate a comment identifying the relationship.
; 2537 :    GetAddrForAttribute( &pch, vDTE, "TE_FieldDataRel", "Desc" );

	push	OFFSET FLAT:??_C@_04DKMG@Desc?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 2538 :    if ( pch && pch[ 0 ] )

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $L31107
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L31107

; 2540 :       zsprintf( szLine, "%s Index for Relationship - '%s' %s",
; 2541 :                 COMMENT_START, pch, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2542 : 
; 2543 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31107

; 2544 :          return( -1 );

	or	ax, -1
	jmp	$L31073
$L31107:

; 2546 : 
; 2547 :    GetIntegerFromAttribute( &lZKey, vDTE, "TE_FieldDataRel", "ZKey" );

	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lZKey$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 2548 :    GetStringFromAttribute( szKeyName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szKeyName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 2549 :    RemoveBrackets( szKeyName );

	lea	edx, DWORD PTR _szKeyName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 2550 : 
; 2551 :    // The base name for the index is a concatenation of the table and
; 2552 :    // key name.  To ensure that the index name is unique, we also use the
; 2553 :    // zkey value.
; 2554 :    // NOTE: Becaues of a bug in UfCompressName, we tack on a extra '0' to the
; 2555 :    // name so that the zkey does not get truncated.
; 2556 :    zsprintf( szWorkIdxName, "%s_%s_%ld0", szTableName, szKeyName, lZKey );

	mov	eax, DWORD PTR _lZKey$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szKeyName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkIdxName$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2557 : 
; 2558 :    // Make sure that the index name is a valid length.
; 2559 :    UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,
; 2560 :                    "", "B", "", "B_AEIOUYBCDFGHJKLMNPQRSTVWXZ", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	cx, WORD PTR _nMaxTableNameLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkIdxName$[ebp]
	push	eax
	call	_UfCompressName@32

; 2561 : 
; 2562 :    zsprintf( szLine, "CREATE INDEX %s%s %s",
; 2563 :              szOwner, szWorkIdxName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2564 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31114

; 2565 :       return( -1 );

	or	ax, -1
	jmp	$L31073
$L31114:

; 2566 : 
; 2567 :    zsprintf( szLine, "       ON %s%s ( %s",
; 2568 :              szOwner, szTableName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2569 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31116

; 2570 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L31073
$L31116:

; 2571 : 
; 2572 :    // Write Key-Name.
; 2573 :    zsprintf( szLine, "%*s %s ) %s",
; 2574 :              (zSHORT) COLUMN_INDENT, " ",
; 2575 :              szKeyName,
; 2576 :              LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	ecx, DWORD PTR _szKeyName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	push	10					; 0000000aH
	push	OFFSET FLAT:??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 2577 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31120

; 2578 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L31073
$L31120:

; 2579 : 
; 2580 :    // Write a blank line.
; 2581 :    if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31121

; 2582 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L31073
$L31121:

; 2583 : 
; 2584 :    return( 0 );

	xor	ax, ax
$L31073:

; 2585 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnBuildFK_Index@8 ENDP
_TEXT	ENDS
PUBLIC	_fnBuildIndexFromTablRecKey@12
PUBLIC	??_C@_09CNO@ER_Entity?$AA@			; `string'
PUBLIC	??_C@_0BP@GKMP@?$CFs?5Main?5key?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_09CEBI@IndexName?$AA@			; `string'
PUBLIC	??_C@_0O@LKEB@TE_TablRecKey?$AA@		; `string'
PUBLIC	??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@		; `string'
PUBLIC	??_C@_0M@EFNH@U?$CFs_?$CFs_?$CFld0?$AA@		; `string'
PUBLIC	??_C@_02DILL@?$CFs?$AA@				; `string'
PUBLIC	??_C@_0BM@HCMD@CREATE?5UNIQUE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0L@OGBL@?$CF?$CKs?5?$CFs?0?5?$CFs?$AA@	; `string'
EXTRN	_CheckExistenceOfEntity@8:NEAR
EXTRN	_SetCursorNextEntity@12:NEAR
EXTRN	_SetCursorFirstEntity@12:NEAR
;	COMDAT ??_C@_09CNO@ER_Entity?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_09CNO@ER_Entity?$AA@ DB 'ER_Entity', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@GKMP@?$CFs?5Main?5key?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BP@GKMP@?$CFs?5Main?5key?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ DB '%'
	DB	's Main key for Entity - %s %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09CEBI@IndexName?$AA@
_DATA	SEGMENT
??_C@_09CEBI@IndexName?$AA@ DB 'IndexName', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@LKEB@TE_TablRecKey?$AA@
_DATA	SEGMENT
??_C@_0O@LKEB@TE_TablRecKey?$AA@ DB 'TE_TablRecKey', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@
_DATA	SEGMENT
??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ DB 'TE_FieldDataRelKey', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@EFNH@U?$CFs_?$CFs_?$CFld0?$AA@
_DATA	SEGMENT
??_C@_0M@EFNH@U?$CFs_?$CFs_?$CFld0?$AA@ DB 'U%s_%s_%ld0', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
_DATA	SEGMENT
??_C@_02DILL@?$CFs?$AA@ DB '%s', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@HCMD@CREATE?5UNIQUE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BM@HCMD@CREATE?5UNIQUE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ DB 'CREATE U'
	DB	'NIQUE INDEX %s%s %s', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGBL@?$CF?$CKs?5?$CFs?0?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0L@OGBL@?$CF?$CKs?5?$CFs?0?5?$CFs?$AA@ DB '%*s %s, %s', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_bUnique$ = 12
_f$ = 16
_nLoop$ = -296
_szLine$ = -800
_szOwner$ = -288
_pchDefaultOwner$ = -1104
_szDBH_DataObjectName$ = -844
_nMaxTableNameLth$ = -292
_vDBH_Data$ = -808
_vTZTEDBLO$ = -300
_vTZDBHODO$ = -804
_szTableName$ = -1100
_szName$ = -256
_szWorkIdxName$ = -1620
_l$31148 = -1624
_pch$31155 = -1628
_szEntityName$31161 = -1884
_lZKey$31162 = -1888
_fnBuildIndexFromTablRecKey@12 PROC NEAR

; 2589 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1888				; 00000760H

; 2590 :    zSHORT   nLoop;
; 2591 :    zCHAR    szLine[ 500 ];
; 2592 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 2593 :    zPCHAR   pchDefaultOwner;
; 2594 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 2595 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	WORD PTR _nMaxTableNameLth$[ebp], 30	; 0000001eH

; 2596 :    zVIEW    vDBH_Data;
; 2597 :    zVIEW    vTZTEDBLO;
; 2598 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 2599 :    zCHAR    szTableName[ MAX_NAME_LTH + 1 ];
; 2600 :    zCHAR    szName[ MAX_NAME_LTH + 1 ];
; 2601 :    zCHAR    szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 2602 : 
; 2603 : 
; 2604 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",
; 2605 :                         "DefaultOwner" );

	push	OFFSET FLAT:??_C@_0N@HJOL@DefaultOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 2606 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31143
	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $L31142
$L31143:

; 2607 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$L31142:

; 2608 : 
; 2609 :    GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 2610 :    if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	jne	SHORT $L31144
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31144

; 2611 :       zstrcpy( szOwner, pchDefaultOwner );

	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L31144:

; 2612 : 
; 2613 :    if ( szOwner[ 0 ] )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	je	SHORT $L31145

; 2614 :       zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$L31145:

; 2615 : 
; 2616 :    // If it exists get the object that defines the dbhandler type.
; 2617 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_GetViewByName@16

; 2618 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $L31146

; 2619 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 2620 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	call	_SetCursorFirstEntityByAttr@28
$L31146:

; 2621 : 
; 2622 :    // Try to get the OI that contains DBH-specific data.
; 2623 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 2624 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 2625 : 
; 2626 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 2627 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 2628 : 
; 2629 :    // Try to get the ODBC definition.
; 2630 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 2631 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _vTZDBHODO$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 2632 : 
; 2633 :    // Check to see if there is DBH data set in the TE.
; 2634 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31149

; 2636 :       zLONG l;
; 2637 : 
; 2638 :       // Check to see if there is an max length override.
; 2639 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 2640 :                                     "MaxTableNameLength" ) != -1 )

	push	OFFSET FLAT:??_C@_0BD@KOPE@MaxTableNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _l$31148[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16
	movsx	eax, ax
	cmp	eax, -1
	je	SHORT $L31149

; 2642 :          nMaxTableNameLth = (zSHORT) l;

	mov	cx, WORD PTR _l$31148[ebp]
	mov	WORD PTR _nMaxTableNameLth$[ebp], cx
$L31149:

; 2645 : 
; 2646 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $L31151

; 2647 :       DropView( vTZDBHODO );

	mov	edx, DWORD PTR _vTZDBHODO$[ebp]
	push	edx
	call	_DropView@4
$L31151:

; 2648 : #endif
; 2649 : 
; 2650 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31152

; 2651 :       DropView( vDBH_Data );

	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_DropView@4
$L31152:

; 2652 : 
; 2653 :    // Write comment.
; 2654 :    if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) >= zCURSOR_SET )

	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CheckExistenceOfEntity@8
	movsx	edx, ax
	test	edx, edx
	jl	SHORT $L31157

; 2656 :       zPCHAR pch;
; 2657 : 
; 2658 :       GetAddrForAttribute( &pch, vDTE, "ER_Entity", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pch$31155[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 2659 :       zsprintf( szLine, "%s Main key for Entity - %s %s",
; 2660 :                 COMMENT_START, pch, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	edx, DWORD PTR _pch$31155[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BP@GKMP@?$CFs?5Main?5key?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2661 : 
; 2662 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31157

; 2663 :          return( -1 );

	or	ax, -1
	jmp	$L31129
$L31157:

; 2665 : 
; 2666 :    GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 2667 :    RemoveBrackets( szTableName );

	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 2668 : 
; 2669 :    // If an IndexName value exists in TE_TablRecKey, use it.  Otherwise
; 2670 :    // us the Name value.
; 2671 :    GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "IndexName" );

	push	OFFSET FLAT:??_C@_09CEBI@IndexName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 2672 :    if ( szName[ 0 ] == 0 )

	movsx	eax, BYTE PTR _szName$[ebp]
	test	eax, eax
	jne	$L31160

; 2674 :       zCHAR  szEntityName[ MAX_NAME_LTH + 1 ];
; 2675 :       zLONG  lZKey;
; 2676 : 
; 2677 :       GetStringFromAttribute( szEntityName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$31161[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 2678 :       RemoveBrackets( szEntityName );

	lea	eax, DWORD PTR _szEntityName$31161[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 2679 : 
; 2680 :       GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 2681 :       RemoveBrackets( szName );

	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 2682 : 
; 2683 :       GetIntegerFromAttribute( &lZKey, vDTE, "TE_FieldDataRelKey", "ZKey" );

	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lZKey$31162[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 2684 : 
; 2685 :       // The base name for the index is a concatenation of the table and
; 2686 :       // key name.  To ensure that the index name is unique, we also use the
; 2687 :       // zkey value.
; 2688 :       // NOTE: Becaues of a bug in UfCompressName, we tack on a extra '0' to
; 2689 :       // the name so that the zkey does not get truncated.
; 2690 :       if ( bUnique )

	mov	eax, DWORD PTR _bUnique$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L31164

; 2691 :          zsprintf( szWorkIdxName, "U%s_%s_%ld0", szEntityName, szName, lZKey );

	mov	ecx, DWORD PTR _lZKey$31162[ebp]
	push	ecx
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szEntityName$31161[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0M@EFNH@U?$CFs_?$CFs_?$CFld0?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2692 :       else

	jmp	SHORT $L31166
$L31164:

; 2693 :          zsprintf( szWorkIdxName, "%s_%s_%ld0", szEntityName, szName, lZKey );

	mov	edx, DWORD PTR _lZKey$31162[ebp]
	push	edx
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szEntityName$31161[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@ ; `string'
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H
$L31166:

; 2695 :    else

	jmp	SHORT $L31167
$L31160:

; 2697 :       RemoveBrackets( szName );

	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 2698 :       zsprintf( szWorkIdxName, "%s", szName );

	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_02DILL@?$CFs?$AA@	; `string'
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L31167:

; 2700 : 
; 2701 :    // Make sure that the index name is a valid length.
; 2702 :    UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,
; 2703 :                    "", "B", "", "B_AEIOUYBCDFGHJKLMNPQRSTVWXZ", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ax, WORD PTR _nMaxTableNameLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	call	_UfCompressName@32

; 2704 : 
; 2705 :    if ( bUnique )

	mov	eax, DWORD PTR _bUnique$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L31169

; 2707 :       zsprintf( szLine, "CREATE UNIQUE INDEX %s%s %s",
; 2708 :                 szOwner, szWorkIdxName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BM@HCMD@CREATE?5UNIQUE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2710 :    else

	jmp	SHORT $L31171
$L31169:

; 2711 :       zsprintf( szLine, "CREATE INDEX %s%s %s",
; 2712 :                 szOwner, szWorkIdxName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H
$L31171:

; 2713 : 
; 2714 : 
; 2715 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31172

; 2716 :       return( -1 );

	or	ax, -1
	jmp	$L31129
$L31172:

; 2717 : 
; 2718 :    zsprintf( szLine, "       ON %s%s ( %s",
; 2719 :              szOwner, szTableName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2720 : 
; 2721 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31173

; 2722 :       return( -1 );

	or	ax, -1
	jmp	$L31129
$L31173:

; 2723 : 
; 2724 :    //=================================================================
; 2725 :    //
; 2726 :    // Generate column names for index.
; 2727 :    //
; 2728 :    //=================================================================
; 2729 :    nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRelKey", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31175:

; 2730 :    while( nLoop >= zCURSOR_SET )

	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	$L31176

; 2732 :       GetStringFromAttribute (szName, vDTE, "TE_FieldDataRelKey", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 2733 :       RemoveBrackets( szName );

	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 2734 : 
; 2735 :       nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRelKey", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 2736 :       if ( nLoop >= zCURSOR_SET  )

	movsx	ecx, WORD PTR _nLoop$[ebp]
	test	ecx, ecx
	jl	SHORT $L31177

; 2738 :          // More keys coming, so print line with continuation stuff.
; 2739 :          zsprintf( szLine, "%*s %s, %s",
; 2740 :                    (zSHORT) COLUMN_INDENT, " ",
; 2741 :                    szName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	push	10					; 0000000aH
	push	OFFSET FLAT:??_C@_0L@OGBL@?$CF?$CKs?5?$CFs?0?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 2743 :       else

	jmp	SHORT $L31180
$L31177:

; 2745 :          // No more keys, so end current command.
; 2746 :          zsprintf( szLine, "%*s %s ) %s",
; 2747 :                    (zSHORT) COLUMN_INDENT, " ",
; 2748 :                    szName, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	push	10					; 0000000aH
	push	OFFSET FLAT:??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H
$L31180:

; 2750 : 
; 2751 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31182

; 2752 :          return( -1 );

	or	ax, -1
	jmp	SHORT $L31129
$L31182:

; 2753 : 
; 2754 :    } // while ( nLoop >= zCURSOR_SET )...

	jmp	$L31175
$L31176:

; 2755 : 
; 2756 :    return( 0 );

	xor	ax, ax
$L31129:

; 2757 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnBuildIndexFromTablRecKey@12 ENDP
_TEXT	ENDS
PUBLIC	_fnBuildCreateMainIndex@8
_TEXT	SEGMENT
_vDTE$ = 8
_f$ = 12
_bFirstIndex$ = -4
_nLoop$ = -8
_fnBuildCreateMainIndex@8 PROC NEAR

; 2761 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2762 :    zBOOL    bFirstIndex;
; 2763 :    zSHORT   nLoop;
; 2764 : 
; 2765 :    // Loop through each of the keys for the current table.
; 2766 :    bFirstIndex = TRUE;

	mov	BYTE PTR _bFirstIndex$[ebp], 1

; 2767 :    for ( nLoop = SetCursorFirstEntity( vDTE, "TE_TablRecKey", 0 );
; 2768 :          nLoop >= zCURSOR_SET;
; 2769 :          nLoop = SetCursorNextEntity( vDTE, "TE_TablRecKey", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $L31191
$L31192:
	push	0
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31191:
	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	SHORT $L31193

; 2772 :       if ( fnBuildIndexFromTablRecKey( vDTE, bFirstIndex, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	cl, BYTE PTR _bFirstIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildIndexFromTablRecKey@12
	movsx	eax, ax
	cmp	eax, -1
	jne	SHORT $L31194

; 2773 :          return( -1 );

	or	ax, -1
	jmp	SHORT $L31188
$L31194:

; 2774 : 
; 2775 :       bFirstIndex = FALSE;

	mov	BYTE PTR _bFirstIndex$[ebp], 0

; 2776 : 
; 2777 :    } // for ( "TE_TablRecKey"... )...

	jmp	SHORT $L31192
$L31193:

; 2778 : 
; 2779 :    // Write a blank line.
; 2780 :    if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31195

; 2781 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L31188
$L31195:

; 2782 : 
; 2783 :    return( 0 );

	xor	ax, ax
$L31188:

; 2784 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnBuildCreateMainIndex@8 ENDP
_TEXT	ENDS
PUBLIC	_fnBuildCreateTable@8
PUBLIC	??_C@_0BC@PCJM@?$CFs?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BH@HMHF@CREATE?5TABLE?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_04BAFE@?$CF?$CKs?5?$AA@			; `string'
PUBLIC	??_C@_04GPPE@?0?5?$CFs?$AA@			; `string'
PUBLIC	??_C@_05NLEE@?5?$CJ?5?$CFs?$AA@			; `string'
PUBLIC	??_C@_07JAEB@COMMIT?$DL?$AA@			; `string'
;	COMDAT ??_C@_0BC@PCJM@?$CFs?5Entity?5?9?5?$CFs?5?$CFs?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0BC@PCJM@?$CFs?5Entity?5?9?5?$CFs?5?$CFs?$AA@ DB '%s Entity - %s %s'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@HMHF@CREATE?5TABLE?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BH@HMHF@CREATE?5TABLE?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ DB 'CREATE TAB'
	DB	'LE %s%s ( %s', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BAFE@?$CF?$CKs?5?$AA@
_DATA	SEGMENT
??_C@_04BAFE@?$CF?$CKs?5?$AA@ DB '%*s ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GPPE@?0?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_04GPPE@?0?5?$CFs?$AA@ DB ', %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05NLEE@?5?$CJ?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_05NLEE@?5?$CJ?5?$CFs?$AA@ DB ' ) %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07JAEB@COMMIT?$DL?$AA@
_DATA	SEGMENT
??_C@_07JAEB@COMMIT?$DL?$AA@ DB 'COMMIT;', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_f$ = 12
_szTableName$ = -612
_pch$ = -36
_pchEnd$ = -352
_pchDefaultOwner$ = -356
_szLine$ = -304
_szOwner$ = -32
_szDBH_DataObjectName$ = -348
_nLoop$ = -44
_vDBH_Data$ = -312
_vTZTEDBLO$ = -48
_vTZDBHODO$ = -308
_nMaxTableNameLth$ = -40
_l$31216 = -616
_fnBuildCreateTable@8 PROC NEAR

; 2788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 616				; 00000268H

; 2789 :    zCHAR    szTableName[ MAX_NAME_LTH + 1 ];
; 2790 :    zPCHAR   pch;
; 2791 :    zPCHAR   pchEnd;
; 2792 :    zPCHAR   pchDefaultOwner;
; 2793 :    zCHAR    szLine[ 256 ];
; 2794 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 2795 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 2796 :    zSHORT   nLoop;
; 2797 :    zVIEW    vDBH_Data;
; 2798 :    zVIEW    vTZTEDBLO = 0;

	mov	DWORD PTR _vTZTEDBLO$[ebp], 0

; 2799 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 2800 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	WORD PTR _nMaxTableNameLth$[ebp], 30	; 0000001eH

; 2801 : 
; 2802 :    // If it exists get the object that defines the dbhandler type.
; 2803 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	call	_GetViewByName@16

; 2804 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $L31214

; 2805 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 2806 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByAttr@28
$L31214:

; 2807 : 
; 2808 :    // Try to get the OI that contains DBH-specific data.
; 2809 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 2810 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 2811 : 
; 2812 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 2813 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 2814 : 
; 2815 :    // Try to get the ODBC definition.
; 2816 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 2817 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _vTZDBHODO$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 2818 : 
; 2819 :    // Check to see if there is DBH data set in the TE.
; 2820 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31217

; 2822 :       zLONG l;
; 2823 : 
; 2824 :       // Check to see if there is an max length override.
; 2825 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 2826 :                                     "MaxTableNameLength" ) != -1 )

	push	OFFSET FLAT:??_C@_0BD@KOPE@MaxTableNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$31216[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $L31217

; 2828 :          nMaxTableNameLth = (zSHORT) l;

	mov	dx, WORD PTR _l$31216[ebp]
	mov	WORD PTR _nMaxTableNameLth$[ebp], dx
$L31217:

; 2831 : 
; 2832 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $L31219

; 2833 :       DropView( vTZDBHODO );

	mov	eax, DWORD PTR _vTZDBHODO$[ebp]
	push	eax
	call	_DropView@4
$L31219:

; 2834 : 
; 2835 : #endif
; 2836 : 
; 2837 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31220

; 2838 :       DropView( vDBH_Data );

	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	call	_DropView@4
$L31220:

; 2839 : 
; 2840 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",
; 2841 :                         "DefaultOwner" );

	push	OFFSET FLAT:??_C@_0N@HJOL@DefaultOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDefaultOwner$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 2842 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31222
	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L31221
$L31222:

; 2843 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$L31221:

; 2844 : 
; 2845 :    GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 2846 :    RemoveBrackets( szTableName );

	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 2847 : 
; 2848 :    /* Position on the first column of the table */
; 2849 :    nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 2850 :    if ( nLoop < zCURSOR_SET )

	movsx	ecx, WORD PTR _nLoop$[ebp]
	test	ecx, ecx
	jge	SHORT $L31223

; 2851 :       return( 0 );

	xor	ax, ax
	jmp	$L31201
$L31223:

; 2852 : 
; 2853 :    // Write the CREATE TABLE Statement and the comment only if
; 2854 :    // there are columns in a table.
; 2855 :    if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) >= zCURSOR_SET )

	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	movsx	eax, ax
	test	eax, eax
	jl	SHORT $L31226

; 2857 :       GetAddrForAttribute( &pch, vDTE, "ER_Entity", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 2858 :       zsprintf( szLine, "%s Entity - %s %s",
; 2859 :                 COMMENT_START, pch, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BC@PCJM@?$CFs?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2860 : 
; 2861 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31226

; 2862 :          return( -1 );

	or	ax, -1
	jmp	$L31201
$L31226:

; 2864 : 
; 2865 :    // Determine owner.
; 2866 :    GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 2867 :    if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	jne	SHORT $L31227
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31227

; 2868 :       zstrcpy( szOwner, pchDefaultOwner );

	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L31227:

; 2869 : 
; 2870 :    if ( szOwner[ 0 ] )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	je	SHORT $L31228

; 2871 :       zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$L31228:

; 2872 : 
; 2873 :    zsprintf( szLine, "CREATE TABLE %s%s ( %s",
; 2874 :              szOwner, szTableName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BH@HMHF@CREATE?5TABLE?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2875 : 
; 2876 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31230

; 2877 :       return( -1 );

	or	ax, -1
	jmp	$L31201
$L31230:

; 2878 : 
; 2879 :    //=================================================================
; 2880 :    //
; 2881 :    // Generate column definitions.
; 2882 :    //
; 2883 :    //=================================================================
; 2884 : 
; 2885 :    // Loop for each column in the table.
; 2886 :    while ( nLoop >= zCURSOR_SET )

	movsx	eax, WORD PTR _nLoop$[ebp]
	test	eax, eax
	jl	$L31233

; 2888 :       zsprintf( szLine, "%*s ", (zSHORT) COLUMN_INDENT, " " );

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	push	10					; 0000000aH
	push	OFFSET FLAT:??_C@_04BAFE@?$CF?$CKs?5?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 2889 :       fnBuildColumn( vDTE, f, szLine );

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildColumn@12

; 2890 : 
; 2891 :       pchEnd = &szLine[ zstrlen( szLine ) ];

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	lea	eax, DWORD PTR _szLine$[ebp+eax]
	mov	DWORD PTR _pchEnd$[ebp], eax

; 2892 : 
; 2893 :       nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 2894 :       if ( nLoop >= zCURSOR_SET )

	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	SHORT $L31236

; 2895 :          // More columns comming, so add continuation stuff.
; 2896 :          zsprintf( pchEnd, ", %s", CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_04GPPE@?0?5?$CFs?$AA@	; `string'
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 2897 :       else

	jmp	SHORT $L31238
$L31236:

; 2898 :          // No more columns, so terminate line.
; 2899 :          zsprintf( pchEnd, " ) %s", LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	push	OFFSET FLAT:??_C@_05NLEE@?5?$CJ?5?$CFs?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L31238:

; 2900 : 
; 2901 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31240

; 2902 :          return( -1 );

	or	ax, -1
	jmp	SHORT $L31201
$L31240:

; 2903 : 
; 2904 :    } // while ( nLoop >= zCURSOR_SET )...

	jmp	$L31230
$L31233:

; 2905 : 
; 2906 :    // Write a blank line.
; 2907 :    if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31241

; 2908 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L31201
$L31241:

; 2909 : 
; 2910 :    #if COMMIT_EVERY_TABLE
; 2911 :       if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	push	OFFSET FLAT:??_C@_07JAEB@COMMIT?$DL?$AA@ ; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31242

; 2912 :          return( -1 );

	or	ax, -1
	jmp	SHORT $L31201
$L31242:

; 2913 : 
; 2914 :       if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31244

; 2915 :          return( -1 );

	or	ax, -1
	jmp	SHORT $L31201
$L31244:

; 2916 :    #endif
; 2917 : 
; 2918 :    return( 0 );

	xor	ax, ax
$L31201:

; 2919 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnBuildCreateTable@8 ENDP
_TEXT	ENDS
PUBLIC	_BuildDDL@16
PUBLIC	??_C@_01OAK@N?$AA@				; `string'
PUBLIC	??_C@_0BA@JNHE@GenCreateTables?$AA@		; `string'
PUBLIC	??_C@_0L@GNHG@DropTables?$AA@			; `string'
PUBLIC	??_C@_0O@CFLN@GenCreateIdxs?$AA@		; `string'
PUBLIC	??_C@_0M@GBEE@GenDropIdxs?$AA@			; `string'
PUBLIC	??_C@_04PMIC@?4ddl?$AA@				; `string'
PUBLIC	??_C@_0BM@MOMC@?$CFs?5CREATE?5DATABASE?5?$CFs?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_09DDBF@USE?5?$CFs?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BO@IABD@?$CFs?5Indexes?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_05FCKF@?$CFs_?$CFs?$AA@			; `string'
PUBLIC	??_C@_07PHBB@B_AEIOU?$AA@			; `string'
PUBLIC	??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@		; `string'
PUBLIC	??_C@_04LGDF@?$CF02d?$AA@			; `string'
PUBLIC	??_C@_0BD@PLEK@DROP?5TABLE?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BP@OLHP@GRANT?5ALL?5ON?5?$CFs?$CFs?5TO?5PUBLIC?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_05EGAJ@File?5?$AA@			; `string'
PUBLIC	??_C@_0BK@MMCL@?5is?5created?5successfully?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BG@PJOD@Couldn?8t?5create?5file?5?$AA@	; `string'
PUBLIC	??_C@_0N@PLHO@Generate?5DDL?$AA@		; `string'
EXTRN	_SysOpenFile@12:NEAR
EXTRN	_MB_SetMessage@12:NEAR
EXTRN	_CreateViewFromViewForTask@12:NEAR
EXTRN	_SysCloseFile@12:NEAR
;	COMDAT ??_C@_01OAK@N?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_01OAK@N?$AA@ DB 'N', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JNHE@GenCreateTables?$AA@
_DATA	SEGMENT
??_C@_0BA@JNHE@GenCreateTables?$AA@ DB 'GenCreateTables', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GNHG@DropTables?$AA@
_DATA	SEGMENT
??_C@_0L@GNHG@DropTables?$AA@ DB 'DropTables', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@CFLN@GenCreateIdxs?$AA@
_DATA	SEGMENT
??_C@_0O@CFLN@GenCreateIdxs?$AA@ DB 'GenCreateIdxs', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@GBEE@GenDropIdxs?$AA@
_DATA	SEGMENT
??_C@_0M@GBEE@GenDropIdxs?$AA@ DB 'GenDropIdxs', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PMIC@?4ddl?$AA@
_DATA	SEGMENT
??_C@_04PMIC@?4ddl?$AA@ DB '.ddl', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MOMC@?$CFs?5CREATE?5DATABASE?5?$CFs?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BM@MOMC@?$CFs?5CREATE?5DATABASE?5?$CFs?5?$CFs?5?$CFs?$AA@ DB '%s C'
	DB	'REATE DATABASE %s %s %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09DDBF@USE?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_09DDBF@USE?5?$CFs?5?$CFs?$AA@ DB 'USE %s %s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@IABD@?$CFs?5Indexes?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BO@IABD@?$CFs?5Indexes?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ DB '%s '
	DB	'Indexes for Entity - %s %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05FCKF@?$CFs_?$CFs?$AA@
_DATA	SEGMENT
??_C@_05FCKF@?$CFs_?$CFs?$AA@ DB '%s_%s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07PHBB@B_AEIOU?$AA@
_DATA	SEGMENT
??_C@_07PHBB@B_AEIOU?$AA@ DB 'B_AEIOU', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@
_DATA	SEGMENT
??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ DB 'DataOrRelfieldOrSet', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LGDF@?$CF02d?$AA@
_DATA	SEGMENT
??_C@_04LGDF@?$CF02d?$AA@ DB '%02d', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@PLEK@DROP?5TABLE?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BD@PLEK@DROP?5TABLE?5?$CFs?$CFs?5?$CFs?$AA@ DB 'DROP TABLE %s%s %s'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@OLHP@GRANT?5ALL?5ON?5?$CFs?$CFs?5TO?5PUBLIC?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BP@OLHP@GRANT?5ALL?5ON?5?$CFs?$CFs?5TO?5PUBLIC?5?$CFs?$AA@ DB 'GRA'
	DB	'NT ALL ON %s%s TO PUBLIC %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05EGAJ@File?5?$AA@
_DATA	SEGMENT
??_C@_05EGAJ@File?5?$AA@ DB 'File ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@MMCL@?5is?5created?5successfully?$CB?$AA@
_DATA	SEGMENT
??_C@_0BK@MMCL@?5is?5created?5successfully?$CB?$AA@ DB ' is created succe'
	DB	'ssfully!', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@PJOD@Couldn?8t?5create?5file?5?$AA@
_DATA	SEGMENT
??_C@_0BG@PJOD@Couldn?8t?5create?5file?5?$AA@ DB 'Couldn''t create file ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@PLHO@Generate?5DDL?$AA@
_DATA	SEGMENT
??_C@_0N@PLHO@Generate?5DDL?$AA@ DB 'Generate DDL', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_vEMD$ = 12
_pchFileName$ = 16
_vSubtask$ = 20
_pchTableName$ = -4
_pchDatabaseName$ = -1416
_pch$ = -48
_f$ = -1100
_szLine$ = -1096
_nLth$ = -312
_nRC$ = -316
_nRCTable$ = -308
_nLoop$ = -836
_vTZTEDBLO$ = -840
_vDBH_Data$ = -1108
_szDBH_DataObjectName$ = -1148
_nMaxTableNameLth$ = -832
_szTableName$ = -1412
_szEntityName$ = -304
_pchDefaultOwner$ = -1156
_szOwner$ = -44
_pchGenCreateIdxs$ = -1152
_pchGenDropIdxs$ = -12
_pchGenCreateTables$ = -1112
_pchGenDropTables$ = -8
_szMsg$ = -828
_vTZDBHODO$ = -1104
_l$31282 = -1420
_usForeignKeyCntForTable$31303 = -1424
_szName$31313 = -1680
_szWorkIdxName$31314 = -2196
_szKeyName$31322 = -2456
_pchKeyType$31323 = -2200
_szWorkIdxName$31324 = -2972
_pchKeyType$31359 = -2976
_BuildDDL@16 PROC NEAR

; 2944 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2976				; 00000ba0H

; 2945 :    zPCHAR   pchTableName;
; 2946 :    zPCHAR   pchDatabaseName;
; 2947 :    zPCHAR   pch;
; 2948 :    zLONG    f = -1;

	mov	DWORD PTR _f$[ebp], -1

; 2949 :    zCHAR    szLine[ 256 ];
; 2950 :    zLONG    nLth;
; 2951 :    zSHORT   nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 2952 :    zSHORT   nRCTable;
; 2953 :    zSHORT   nLoop;
; 2954 :    zVIEW    vTZTEDBLO;
; 2955 :    zVIEW    vDBH_Data = 0;

	mov	DWORD PTR _vDBH_Data$[ebp], 0

; 2956 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 2957 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	WORD PTR _nMaxTableNameLth$[ebp], 30	; 0000001eH

; 2958 :    zCHAR    szTableName[ MAX_NAME_LTH + 1 ];
; 2959 :    zCHAR    szEntityName[ MAX_NAME_LTH + 1 ];
; 2960 :    zPCHAR   pchDefaultOwner;
; 2961 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 2962 :    zPCHAR   pchGenCreateIdxs   = "Y";

	mov	DWORD PTR _pchGenCreateIdxs$[ebp], OFFSET FLAT:??_C@_01PCJP@Y?$AA@ ; `string'

; 2963 :    zPCHAR   pchGenDropIdxs     = "N";

	mov	DWORD PTR _pchGenDropIdxs$[ebp], OFFSET FLAT:??_C@_01OAK@N?$AA@ ; `string'

; 2964 :    zPCHAR   pchGenCreateTables = "Y";

	mov	DWORD PTR _pchGenCreateTables$[ebp], OFFSET FLAT:??_C@_01PCJP@Y?$AA@ ; `string'

; 2965 :    zPCHAR   pchGenDropTables   = "Y";

	mov	DWORD PTR _pchGenDropTables$[ebp], OFFSET FLAT:??_C@_01PCJP@Y?$AA@ ; `string'

; 2966 : 
; 2967 :    zCHAR    szMsg[ 512 ];
; 2968 : 
; 2969 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 2970 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 2971 :    zVIEW    vTZDBHODO;
; 2972 : #endif
; 2973 : 
; 2974 :    // If TE_DBMS_Source entity doesn't exist, then nothing to generate.
; 2975 :    if ( CheckExistenceOfEntity( vDTE, "TE_DBMS_Source" ) != zCURSOR_SET )

	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L31279

; 2976 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L31254
$L31279:

; 2977 : 
; 2978 :    // If it exists get the object that defines the dbhandler type.
; 2979 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vSubtask, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_GetViewByName@16

; 2980 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $L31280

; 2981 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 2982 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	call	_SetCursorFirstEntityByAttr@28
$L31280:

; 2983 : 
; 2984 :    // Try to get the OI that contains DBH-specific data.
; 2985 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 2986 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 2987 : 
; 2988 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 2989 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 2990 : 
; 2991 :    // Try to get the ODBC definition.
; 2992 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 2993 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _vTZDBHODO$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 2994 : 
; 2995 :    // Check to see if there is DBH data set in the TE.
; 2996 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	$L31281

; 2998 :       zLONG l;
; 2999 : 
; 3000 :       // Check to see if there is an max length override.
; 3001 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 3002 :                                     "MaxTableNameLength" ) != -1 )

	push	OFFSET FLAT:??_C@_0BD@KOPE@MaxTableNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _l$31282[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16
	movsx	eax, ax
	cmp	eax, -1
	je	SHORT $L31283

; 3004 :          nMaxTableNameLth = (zSHORT) l;

	mov	cx, WORD PTR _l$31282[ebp]
	mov	WORD PTR _nMaxTableNameLth$[ebp], cx
$L31283:

; 3006 : 
; 3007 :       // Get the conditional generate values.
; 3008 :       GetAddrForAttribute( &pchGenCreateTables, vDBH_Data, "ODBC", "GenCreateTables" );

	push	OFFSET FLAT:??_C@_0BA@JNHE@GenCreateTables?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchGenCreateTables$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3009 :       GetAddrForAttribute( &pchGenDropTables,   vDBH_Data, "ODBC", "DropTables" );

	push	OFFSET FLAT:??_C@_0L@GNHG@DropTables?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchGenDropTables$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3010 :       GetAddrForAttribute( &pchGenCreateIdxs,   vDBH_Data, "ODBC", "GenCreateIdxs" );

	push	OFFSET FLAT:??_C@_0O@CFLN@GenCreateIdxs?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchGenCreateIdxs$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3011 :       GetAddrForAttribute( &pchGenDropIdxs,     vDBH_Data, "ODBC", "GenDropIdxs" );

	push	OFFSET FLAT:??_C@_0M@GBEE@GenDropIdxs?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchGenDropIdxs$[ebp]
	push	eax
	call	_GetAddrForAttribute@16
$L31281:

; 3013 : 
; 3014 : #endif
; 3015 : 
; 3016 :    // Create copies of views so we can safely change the cursors.
; 3017 :    CreateViewFromViewForTask( &vDTE, vDTE, 0 );

	push	0
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 3018 :    CreateViewFromViewForTask( &vEMD, vEMD, 0 );

	push	0
	mov	eax, DWORD PTR _vEMD$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vEMD$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 3019 : 
; 3020 :    //
; 3021 :    // Generate the DDL file name and open it.
; 3022 :    //
; 3023 :    nLth = zstrlen( pchFileName );

	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLth$[ebp], eax

; 3024 :    GetStringFromAttribute( pchFileName + nLth,
; 3025 :                            vDTE, "TE_DBMS_Source", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchFileName$[ebp]
	add	ecx, DWORD PTR _nLth$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3026 : 
; 3027 :    // Make sure the filename isn't too long.
; 3028 :    if ( zstrlen( pchFileName + nLth ) > zBASE_FILENAME_LTH )

	mov	edx, DWORD PTR _pchFileName$[ebp]
	add	edx, DWORD PTR _nLth$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 128				; 00000080H
	jbe	SHORT $L31289

; 3029 :       pchFileName[ nLth + zBASE_FILENAME_LTH ] = 0;

	mov	eax, DWORD PTR _pchFileName$[ebp]
	add	eax, DWORD PTR _nLth$[ebp]
	mov	BYTE PTR [eax+128], 0
$L31289:

; 3030 : 
; 3031 :    zstrcat( pchFileName, ".ddl" );

	push	OFFSET FLAT:??_C@_04PMIC@?4ddl?$AA@	; `string'
	mov	ecx, DWORD PTR _pchFileName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3032 :    if ( (f = SysOpenFile( vDTE, pchFileName, COREFILE_WRITE )) < 0 )

	push	64					; 00000040H
	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysOpenFile@12
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jge	SHORT $L31291

; 3033 :       goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31291:

; 3034 : 
; 3035 :    GetAddrForAttribute( &pchDatabaseName, vDTE, "TE_DBMS_Source", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchDatabaseName$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3036 : 
; 3037 : #ifdef CREATE_DB
; 3038 :    zsprintf( szLine, "%s CREATE DATABASE %s %s %s", COMMENT_START,
; 3039 :              pchDatabaseName, COMMENT_END, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	eax, DWORD PTR _pchDatabaseName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BM@MOMC@?$CFs?5CREATE?5DATABASE?5?$CFs?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 3040 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31294

; 3041 :       goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31294:

; 3042 : #endif
; 3043 : 
; 3044 :    //
; 3045 :    // Tell SQL processor what database to use.
; 3046 :    //
; 3047 : 
; 3048 : #if defined( DB2 )
; 3049 : 
; 3050 :    zsprintf( szLine, "CONNECT TO %s %s", pchDatabaseName, LINE_TERMINATOR );
; 3051 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )
; 3052 :       goto EndOfFunction;
; 3053 : 
; 3054 : #elif defined( MYSQL) || defined( SQLSERVER )
; 3055 : 
; 3056 :    zsprintf( szLine, "USE %s %s", pchDatabaseName, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	mov	edx, DWORD PTR _pchDatabaseName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_09DDBF@USE?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 3057 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31296

; 3058 :       goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31296:

; 3059 : 
; 3060 : #endif
; 3061 : 
; 3062 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",
; 3063 :                         "DefaultOwner" );

	push	OFFSET FLAT:??_C@_0N@HJOL@DefaultOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchDefaultOwner$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3064 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31298
	mov	eax, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L31297
$L31298:

; 3065 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$L31297:

; 3066 : 
; 3067 :    //=================================================================
; 3068 :    //
; 3069 :    // Generate Drop Index statements.
; 3070 :    //
; 3071 :    //=================================================================
; 3072 :    if ( pchGenDropIdxs[ 0 ] != 'N' )

	mov	edx, DWORD PTR _pchGenDropIdxs$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 78					; 0000004eH
	je	$L31302

; 3074 :       // Loop for each of the tables.
; 3075 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3076 :             nRCTable >= zCURSOR_SET;
; 3077 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $L31300
$L31301:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$L31300:
	movsx	eax, WORD PTR _nRCTable$[ebp]
	test	eax, eax
	jl	$L31302

; 3079 :          zUSHORT usForeignKeyCntForTable = 0;

	mov	WORD PTR _usForeignKeyCntForTable$31303[ebp], 0

; 3080 : 
; 3081 :          GetStringFromAttribute (szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3082 :          pchTableName = szTableName;

	lea	eax, DWORD PTR _szTableName$[ebp]
	mov	DWORD PTR _pchTableName$[ebp], eax

; 3083 :          RemoveBrackets( pchTableName );

	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3084 : 
; 3085 :          /* Position on the first column of the table */
; 3086 :          nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3087 :          if ( nLoop < zCURSOR_SET )

	movsx	eax, WORD PTR _nLoop$[ebp]
	test	eax, eax
	jge	SHORT $L31304

; 3088 :             continue;

	jmp	$L31301
$L31304:

; 3089 : 
; 3090 :          // Write comment.
; 3091 :          if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) >= zCURSOR_SET )

	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CheckExistenceOfEntity@8
	movsx	edx, ax
	test	edx, edx
	jl	SHORT $L31307

; 3093 :             GetAddrForAttribute( &pch, vDTE, "ER_Entity", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3094 :             zsprintf( szLine, "%s Indexes for Entity - %s %s",
; 3095 :                       COMMENT_START, pch, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BO@IABD@?$CFs?5Indexes?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3096 : 
; 3097 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31307

; 3098 :                goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31307:

; 3100 : 
; 3101 :          // Determine owner.
; 3102 :          GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3103 :          if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	jne	SHORT $L31308
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31308

; 3104 :             zstrcpy( szOwner, pchDefaultOwner );

	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L31308:

; 3105 : 
; 3106 :          if ( szOwner[ 0 ] )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	je	SHORT $L31309

; 3107 :             zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$L31309:

; 3108 : 
; 3109 :          //=================================================================
; 3110 :          //
; 3111 :          // Drop Unique Index.
; 3112 :          //
; 3113 :          //=================================================================
; 3114 : 
; 3115 :          // Loop through each of the keys for the current table.
; 3116 :          for ( nLoop = SetCursorFirstEntity( vDTE, "TE_TablRecKey", 0 );
; 3117 :                nLoop >= zCURSOR_SET;
; 3118 :                nLoop = SetCursorNextEntity( vDTE, "TE_TablRecKey", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $L31310
$L31311:
	push	0
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31310:
	movsx	ecx, WORD PTR _nLoop$[ebp]
	test	ecx, ecx
	jl	$L31312

; 3120 :             zCHAR  szName[ MAX_NAME_LTH + 1 ];
; 3121 :             zCHAR  szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 3122 : 
; 3123 :             // If an IndexName value exists in TE_TablRecKey, use it.  Otherwise
; 3124 :             // us the Name value.
; 3125 :             GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "IndexName");

	push	OFFSET FLAT:??_C@_09CEBI@IndexName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szName$31313[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3126 :             if ( szName[ 0 ] == 0 )

	movsx	ecx, BYTE PTR _szName$31313[ebp]
	test	ecx, ecx
	jne	SHORT $L31315

; 3128 :                GetStringFromAttribute (szEntityName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3129 :                RemoveBrackets( szEntityName );

	lea	ecx, DWORD PTR _szEntityName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3130 : 
; 3131 :                GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szName$31313[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3132 :                RemoveBrackets( szName );

	lea	ecx, DWORD PTR _szName$31313[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3133 : 
; 3134 :                zsprintf( szWorkIdxName, "%s_%s", szEntityName, szName );

	lea	edx, DWORD PTR _szName$31313[ebp]
	push	edx
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_05FCKF@?$CFs_?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkIdxName$31314[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 3136 :             else

	jmp	SHORT $L31317
$L31315:

; 3138 :                RemoveBrackets( szName );

	lea	edx, DWORD PTR _szName$31313[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3139 : 
; 3140 :                zsprintf( szWorkIdxName, "%s", szName );

	lea	eax, DWORD PTR _szName$31313[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02DILL@?$CFs?$AA@	; `string'
	lea	ecx, DWORD PTR _szWorkIdxName$31314[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L31317:

; 3142 : 
; 3143 :             // Make sure that the index name is a valid length.
; 3144 :             UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,
; 3145 :                             "", "B", "", "B_AEIOU", 1 );

	push	1
	push	OFFSET FLAT:??_C@_07PHBB@B_AEIOU?$AA@	; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	dx, WORD PTR _nMaxTableNameLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkIdxName$31314[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkIdxName$31314[ebp]
	push	ecx
	call	_UfCompressName@32

; 3146 : 
; 3147 :             fnBuildDropIndex( vDTE, szWorkIdxName, szOwner, pchTableName, f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchTableName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$31314[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildDropIndex@20

; 3148 : 
; 3149 :          } // for ( "TE_TablRecKey"... )...

	jmp	$L31311
$L31312:

; 3150 : 
; 3151 :          //===============================================================
; 3152 :          //
; 3153 :          // Drop Index for ForeignKeys
; 3154 :          //
; 3155 :          //===============================================================
; 3156 : 
; 3157 :          // Loop through each of the keys for the current table.
; 3158 :          for ( nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );
; 3159 :                nLoop >= zCURSOR_SET;
; 3160 :                nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $L31319
$L31320:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31319:
	movsx	eax, WORD PTR _nLoop$[ebp]
	test	eax, eax
	jl	$L31321

; 3163 :             zCHAR  szKeyName[ MAX_NAME_LTH + 1 ];
; 3164 :             zPCHAR pchKeyType;
; 3165 :             zCHAR  szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 3166 : 
; 3167 :             // If the attribute is not a rel field try the next one.
; 3168 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",
; 3169 :                                  "DataOrRelfieldOrSet" );

	push	OFFSET FLAT:??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchKeyType$31323[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3170 :             if ( pchKeyType[ 0 ] != 'R' )

	mov	eax, DWORD PTR _pchKeyType$31323[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 82					; 00000052H
	je	SHORT $L31326

; 3171 :                continue;

	jmp	SHORT $L31320
$L31326:

; 3172 : 
; 3173 :             // generate a comment identifying the relationship
; 3174 :             GetAddrForAttribute( &pch, vDTE, "TE_FieldDataRel", "Desc" );

	push	OFFSET FLAT:??_C@_04DKMG@Desc?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3175 :             zsprintf( szLine, "%s Index for Relationship - '%s' %s",
; 3176 :                       COMMENT_START, pch, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3177 : 
; 3178 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31327

; 3179 :                goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31327:

; 3180 : 
; 3181 :             GetStringFromAttribute( szKeyName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szKeyName$31322[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3182 :             RemoveBrackets( szKeyName );

	lea	edx, DWORD PTR _szKeyName$31322[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3183 :             zsprintf( szWorkIdxName, "%s_%s", pchTableName, szKeyName );

	lea	eax, DWORD PTR _szKeyName$31322[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_05FCKF@?$CFs_?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szWorkIdxName$31324[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 3184 : 
; 3185 :             // Make sure that the index name is a valid length.
; 3186 :             // MAX_TABLENAME_LTH - 2 because of numbering the indexname
; 3187 :             // in the last two chars.
; 3188 :             UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,
; 3189 :                             "", "B", "", "B_AEIOU", 1 );

	push	1
	push	OFFSET FLAT:??_C@_07PHBB@B_AEIOU?$AA@	; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ax, WORD PTR _nMaxTableNameLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkIdxName$31324[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$31324[ebp]
	push	edx
	call	_UfCompressName@32

; 3190 :             usForeignKeyCntForTable++;

	mov	ax, WORD PTR _usForeignKeyCntForTable$31303[ebp]
	add	ax, 1
	mov	WORD PTR _usForeignKeyCntForTable$31303[ebp], ax

; 3191 :             nLth = zstrlen( szWorkIdxName );

	lea	ecx, DWORD PTR _szWorkIdxName$31324[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLth$[ebp], eax

; 3192 :             zsprintf( &szWorkIdxName[ nLth ], "%02d", usForeignKeyCntForTable );

	mov	edx, DWORD PTR _usForeignKeyCntForTable$31303[ebp]
	and	edx, 65535				; 0000ffffH
	push	edx
	push	OFFSET FLAT:??_C@_04LGDF@?$CF02d?$AA@	; `string'
	mov	eax, DWORD PTR _nLth$[ebp]
	lea	ecx, DWORD PTR _szWorkIdxName$31324[ebp+eax]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 3193 : 
; 3194 :             fnBuildDropIndex( vDTE, szWorkIdxName, szOwner, pchTableName, f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchTableName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$31324[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildDropIndex@20

; 3195 : 
; 3196 :          } // for ( "TE_FieldDataRel" )...

	jmp	$L31320
$L31321:

; 3197 : 
; 3198 :          if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31329

; 3199 :             goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31329:

; 3200 : 
; 3201 :       } // for ( "TE_TableRec" )...

	jmp	$L31301
$L31302:

; 3204 : 
; 3205 :    //=================================================================
; 3206 :    //
; 3207 :    // Generate Drop Table statements.
; 3208 :    //
; 3209 :    //=================================================================
; 3210 : 
; 3211 :    if ( pchGenDropTables[ 0 ] != 'N' )

	mov	eax, DWORD PTR _pchGenDropTables$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 78					; 0000004eH
	je	$L31341

; 3213 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3214 :             nRCTable >= zCURSOR_SET;
; 3215 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $L31331
$L31332:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$L31331:
	movsx	ecx, WORD PTR _nRCTable$[ebp]
	test	ecx, ecx
	jl	$L31333

; 3217 :          /* Position on the first column of the table */
; 3218 :          /* If the table has no columns no DROP statement */
; 3219 :          nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 3220 :          if (nRC < zCURSOR_SET)

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $L31334

; 3221 :             continue;

	jmp	SHORT $L31332
$L31334:

; 3222 : 
; 3223 :          // Determine owner.
; 3224 :          GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3225 :          if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	jne	SHORT $L31335
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31335

; 3226 :             zstrcpy( szOwner, pchDefaultOwner );

	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L31335:

; 3227 : 
; 3228 :          if ( szOwner[ 0 ] )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	je	SHORT $L31336

; 3229 :             zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$L31336:

; 3230 : 
; 3231 :          GetStringFromAttribute (szEntityName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3232 :          pch = szEntityName;

	lea	ecx, DWORD PTR _szEntityName$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx

; 3233 :          RemoveBrackets( pch );

	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3234 : 
; 3235 :          zsprintf( szLine, "DROP TABLE %s%s %s", szOwner, pch, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BD@PLEK@DROP?5TABLE?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3236 : 
; 3237 :          if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31338

; 3238 :             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H
$L31338:

; 3239 :       }

	jmp	$L31332
$L31333:

; 3240 : 
; 3241 :    #if defined( COMMIT_EVERY_TABLE )
; 3242 : 
; 3243 :       if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31339

; 3244 :          goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31339:

; 3245 : 
; 3246 :       if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	push	OFFSET FLAT:??_C@_07JAEB@COMMIT?$DL?$AA@ ; `string'
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31340

; 3247 :          goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31340:

; 3248 : 
; 3249 :    #endif
; 3250 : 
; 3251 :       if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31341

; 3252 :          goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31341:

; 3255 : 
; 3256 :    //=================================================================
; 3257 :    //
; 3258 :    // Generate Create Table statements.
; 3259 :    //
; 3260 :    //=================================================================
; 3261 : 
; 3262 :    if ( pchGenCreateTables[ 0 ] != 'N' )

	mov	eax, DWORD PTR _pchGenCreateTables$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 78					; 0000004eH
	je	SHORT $L31345

; 3264 :       // Loop for each of the tables.
; 3265 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3266 :             nRCTable >= zCURSOR_SET;
; 3267 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $L31343
$L31344:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$L31343:
	movsx	ecx, WORD PTR _nRCTable$[ebp]
	test	ecx, ecx
	jl	SHORT $L31345

; 3269 :          if ( fnBuildCreateTable( vDTE, f ) == -1 )

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildCreateTable@8
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $L31346

; 3270 :             goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31346:

; 3271 :       } // for ( "TE_TableRec" )...

	jmp	SHORT $L31344
$L31345:

; 3274 : 
; 3275 :    //=================================================================
; 3276 :    //
; 3277 :    // Generate Create Index statements.
; 3278 :    //
; 3279 :    //=================================================================
; 3280 : 
; 3281 :    if ( pchGenCreateIdxs[ 0 ] != 'N' )

	mov	edx, DWORD PTR _pchGenCreateIdxs$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 78					; 0000004eH
	je	$L31350

; 3283 :       // Loop for each of the tables.
; 3284 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3285 :             nRCTable >= zCURSOR_SET;
; 3286 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $L31348
$L31349:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$L31348:
	movsx	eax, WORD PTR _nRCTable$[ebp]
	test	eax, eax
	jl	$L31350

; 3288 :          GetStringFromAttribute (szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3289 :          pchTableName = szTableName;

	lea	eax, DWORD PTR _szTableName$[ebp]
	mov	DWORD PTR _pchTableName$[ebp], eax

; 3290 :          RemoveBrackets( pchTableName );

	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3291 : 
; 3292 :          /* Position on the first column of the table */
; 3293 :          nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3294 :          if ( nLoop < zCURSOR_SET )

	movsx	eax, WORD PTR _nLoop$[ebp]
	test	eax, eax
	jge	SHORT $L31351

; 3295 :             continue;

	jmp	SHORT $L31349
$L31351:

; 3296 : 
; 3297 :          if ( fnBuildCreateMainIndex( vDTE, f ) == -1 )

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildCreateMainIndex@8
	movsx	eax, ax
	cmp	eax, -1
	jne	SHORT $L31352

; 3298 :             goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31352:

; 3299 : 
; 3300 :          if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31353

; 3301 :             goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31353:

; 3302 : 
; 3303 :          #if COMMIT_EVERY_TABLE
; 3304 :                if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31354

; 3305 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31354:

; 3306 : 
; 3307 :                if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	push	OFFSET FLAT:??_C@_07JAEB@COMMIT?$DL?$AA@ ; `string'
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31355

; 3308 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31355:

; 3309 :          #endif
; 3310 : 
; 3311 :          //===============================================================
; 3312 :          //
; 3313 :          // Generate Index for ForeignKeys
; 3314 :          //
; 3315 :          //===============================================================
; 3316 : 
; 3317 :          // Loop through each of the keys for the current table.
; 3318 : 
; 3319 :          for ( nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );
; 3320 :                nLoop >= zCURSOR_SET;
; 3321 :                nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $L31356
$L31357:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31356:
	movsx	eax, WORD PTR _nLoop$[ebp]
	test	eax, eax
	jl	$L31358

; 3324 :             zPCHAR pchKeyType;
; 3325 : 
; 3326 :             // If the attribute is not a rel field try the next one.
; 3327 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",
; 3328 :                                  "DataOrRelfieldOrSet" );

	push	OFFSET FLAT:??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchKeyType$31359[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3329 :             if ( pchKeyType[ 0 ] != 'R' )

	mov	eax, DWORD PTR _pchKeyType$31359[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 82					; 00000052H
	je	SHORT $L31360

; 3330 :                continue;

	jmp	SHORT $L31357
$L31360:

; 3331 : 
; 3332 :             if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildFK_Index@8
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $L31361

; 3333 :                goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31361:

; 3334 : 
; 3335 :             #if defined( COMMIT_EVERY_TABLE )
; 3336 : 
; 3337 :                if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31362

; 3338 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31362:

; 3339 : 
; 3340 :                if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	push	OFFSET FLAT:??_C@_07JAEB@COMMIT?$DL?$AA@ ; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31363

; 3341 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31363:

; 3342 : 
; 3343 :             #endif
; 3344 : 
; 3345 :             if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31364

; 3346 :                goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31364:

; 3347 : 
; 3348 :          } // for ( "TE_FieldDataRel" )...

	jmp	$L31357
$L31358:

; 3349 : 
; 3350 :    #if COMMIT_EVERY_TABLE
; 3351 :          if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31365

; 3352 :             goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31365:

; 3353 : 
; 3354 :           if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	push	OFFSET FLAT:??_C@_07JAEB@COMMIT?$DL?$AA@ ; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31366

; 3355 :             goto EndOfFunction;

	jmp	$EndOfFunction$31292
$L31366:

; 3356 :    #endif
; 3357 : 
; 3358 :       } // for ( "TE_TableRec" )...

	jmp	$L31349
$L31350:

; 3361 : 
; 3362 :    //=================================================================
; 3363 :    //
; 3364 :    // Loop through the table names again to create the "GRANT ALL" statements.
; 3365 :    //
; 3366 :    //=================================================================
; 3367 : 
; 3368 : #ifdef GRANT_ALL
; 3369 :    for ( nLoop = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3370 :          nLoop >= zCURSOR_SET;
; 3371 :          nLoop = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $L31367
$L31368:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31367:
	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	$L31369

; 3373 :       /* Position on the first column of the table */
; 3374 :       /* No GRANT if the are no columns in the table */
; 3375 :       nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 3376 :       if (nRC < zCURSOR_SET)

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L31370

; 3377 :          continue;

	jmp	SHORT $L31368
$L31370:

; 3378 : 
; 3379 :       // Determine owner.
; 3380 :       GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3381 :       if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	jne	SHORT $L31371
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31371

; 3382 :          zstrcpy( szOwner, pchDefaultOwner );

	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L31371:

; 3383 : 
; 3384 :       if ( szOwner[ 0 ] )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	je	SHORT $L31372

; 3385 :          zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$L31372:

; 3386 : 
; 3387 :       GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3388 :       pchTableName = szTableName;

	lea	edx, DWORD PTR _szTableName$[ebp]
	mov	DWORD PTR _pchTableName$[ebp], edx

; 3389 :       RemoveBrackets( pchTableName );

	mov	eax, DWORD PTR _pchTableName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3390 :       zsprintf( szLine, "GRANT ALL ON %s%s TO PUBLIC %s",
; 3391 :                 szOwner, pchTableName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BP@OLHP@GRANT?5ALL?5ON?5?$CFs?$CFs?5TO?5PUBLIC?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3392 : 
; 3393 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31374

; 3394 :          goto EndOfFunction;

	jmp	SHORT $EndOfFunction$31292
$L31374:

; 3395 : 
; 3396 :    } // for ( "TE_TableRec" )...

	jmp	$L31368
$L31369:

; 3397 : #endif
; 3398 : 
; 3399 :    if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	push	OFFSET FLAT:??_C@_07JAEB@COMMIT?$DL?$AA@ ; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31375

; 3400 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$31292
$L31375:

; 3401 : 
; 3402 :    // If we get here, then everything is OK.
; 3403 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$31292:

; 3404 : 
; 3405 : EndOfFunction:
; 3406 :    if ( f != -1 )

	cmp	DWORD PTR _f$[ebp], -1
	je	SHORT $L31376

; 3407 :       SysCloseFile( vSubtask, f, 0 );

	push	0
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysCloseFile@12
$L31376:

; 3408 : 
; 3409 :    DropView( vDTE );

	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_DropView@4

; 3410 :    DropView( vEMD );

	mov	eax, DWORD PTR _vEMD$[ebp]
	push	eax
	call	_DropView@4

; 3411 : 
; 3412 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L31377

; 3414 :       zstrcpy( szMsg, "File " );

	push	OFFSET FLAT:??_C@_05EGAJ@File?5?$AA@	; `string'
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3415 :       zstrcat( szMsg, pchFileName );

	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3416 :       zstrcat( szMsg, " is created successfully!" );

	push	OFFSET FLAT:??_C@_0BK@MMCL@?5is?5created?5successfully?$CB?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3417 :      MB_SetMessage( vSubtask, 0, szMsg );

	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_MB_SetMessage@12

; 3419 :    else

	jmp	SHORT $L31380
$L31377:

; 3421 :        zstrcpy( szMsg, "Couldn't create file " );

	push	OFFSET FLAT:??_C@_0BG@PJOD@Couldn?8t?5create?5file?5?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3422 :        zstrcat( szMsg, pchFileName );

	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3423 :       SysMessageBox( vDTE, "Generate DDL", szMsg, 0 );

	push	0
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0N@PLHO@Generate?5DDL?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysMessageBox@16
$L31380:

; 3425 : 
; 3426 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L31254:

; 3427 : 
; 3428 : } // BuildDDL

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_BuildDDL@16 ENDP
_TEXT	ENDS
PUBLIC	_BuildSyncDDL@20
PUBLIC	??_C@_0L@NKCB@Executable?$AA@			; `string'
PUBLIC	??_C@_0P@JHOI@RetrieveSchema?$AA@		; `string'
PUBLIC	??_C@_0DF@MNGA@Couldn?8t?5find?5?8BuildSyncDDL?8?5in?5@ ; `string'
PUBLIC	??_C@_0BE@DNAH@Physical?5Data?5Model?$AA@	; `string'
PUBLIC	??_C@_07LDCE@TE00422?$AA@			; `string'
PUBLIC	??_C@_06NGI@_alter?$AA@				; `string'
PUBLIC	??_C@_0CA@EBOB@?$CFs?5Alter?5script?5for?5?$CFs?5?9?9?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0L@FFM@MatchFound?$AA@			; `string'
PUBLIC	??_C@_01PJM@D?$AA@				; `string'
PUBLIC	??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BE@FPJB@ALTER?5TABLE?5?$CFs?5ADD?5?$AA@	; `string'
PUBLIC	??_C@_0BB@MKDI@DROP?5TABLE?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0CD@OHJM@ALTER?5TABLE?5?$CFs?$CFs?5DROP?5COLUMN?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0CB@MGNG@ALTER?5TABLE?5?$CFs?$CF?9?$CKs?5ALTER?5COLUMN?5@ ; `string'
PUBLIC	??_C@_0BAI@KIFF@WARNING?3?5The?5data?5type?5for?5the?5c@ ; `string'
PUBLIC	??_C@_0BI@HFPH@DDL?5Generationg?5Warning?$AA@	; `string'
PUBLIC	??_C@_0FJ@KCOE@?$CFs?5WARNING?9?9Following?5index?5may?5@ ; `string'
EXTRN	_SysLoadLibrary@8:NEAR
EXTRN	_strcmp:NEAR
EXTRN	_MessageSend@24:NEAR
EXTRN	_SetCursorFirstEntityByString@20:NEAR
EXTRN	_SetCursorNextEntityByString@20:NEAR
EXTRN	_SysFreeLibrary@8:NEAR
EXTRN	_SysGetProc@8:NEAR
EXTRN	_SetAttributeFromString@16:NEAR
;	COMDAT ??_C@_0L@NKCB@Executable?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0L@NKCB@Executable?$AA@ DB 'Executable', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@JHOI@RetrieveSchema?$AA@
_DATA	SEGMENT
??_C@_0P@JHOI@RetrieveSchema?$AA@ DB 'RetrieveSchema', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DF@MNGA@Couldn?8t?5find?5?8BuildSyncDDL?8?5in?5@
_DATA	SEGMENT
??_C@_0DF@MNGA@Couldn?8t?5find?5?8BuildSyncDDL?8?5in?5@ DB 'Couldn''t fin'
	DB	'd ''BuildSyncDDL'' in Generater Executable', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DNAH@Physical?5Data?5Model?$AA@
_DATA	SEGMENT
??_C@_0BE@DNAH@Physical?5Data?5Model?$AA@ DB 'Physical Data Model', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_07LDCE@TE00422?$AA@
_DATA	SEGMENT
??_C@_07LDCE@TE00422?$AA@ DB 'TE00422', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06NGI@_alter?$AA@
_DATA	SEGMENT
??_C@_06NGI@_alter?$AA@ DB '_alter', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@EBOB@?$CFs?5Alter?5script?5for?5?$CFs?5?9?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0CA@EBOB@?$CFs?5Alter?5script?5for?5?$CFs?5?9?9?5?$CFs?5?$CFs?$AA@ DB '%'
	DB	's Alter script for %s -- %s %s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@FFM@MatchFound?$AA@
_DATA	SEGMENT
??_C@_0L@FFM@MatchFound?$AA@ DB 'MatchFound', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PJM@D?$AA@
_DATA	SEGMENT
??_C@_01PJM@D?$AA@ DB 'D', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@ DB '%s Entity %s %s', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@FPJB@ALTER?5TABLE?5?$CFs?5ADD?5?$AA@
_DATA	SEGMENT
??_C@_0BE@FPJB@ALTER?5TABLE?5?$CFs?5ADD?5?$AA@ DB 'ALTER TABLE %s ADD ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MKDI@DROP?5TABLE?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BB@MKDI@DROP?5TABLE?5?$CFs?5?$CFs?$AA@ DB 'DROP TABLE %s %s', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@OHJM@ALTER?5TABLE?5?$CFs?$CFs?5DROP?5COLUMN?5?$CFs?5@
_DATA	SEGMENT
??_C@_0CD@OHJM@ALTER?5TABLE?5?$CFs?$CFs?5DROP?5COLUMN?5?$CFs?5@ DB 'ALTER'
	DB	' TABLE %s%s DROP COLUMN %s %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@MGNG@ALTER?5TABLE?5?$CFs?$CF?9?$CKs?5ALTER?5COLUMN?5@
_DATA	SEGMENT
??_C@_0CB@MGNG@ALTER?5TABLE?5?$CFs?$CF?9?$CKs?5ALTER?5COLUMN?5@ DB 'ALTER'
	DB	' TABLE %s%-*s ALTER COLUMN ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BAI@KIFF@WARNING?3?5The?5data?5type?5for?5the?5c@
_DATA	SEGMENT
??_C@_0BAI@KIFF@WARNING?3?5The?5data?5type?5for?5the?5c@ DB 'WARNING: The'
	DB	' data type for the column %s.%s has been changed and therefor'
	DB	'e had an index deleted.  The column is NOT a key and therefor'
	DB	'e the index was added by the DBA.  An attempt has been made t'
	DB	'o recreate the index in the DDL.  Look for ''WARNING'' in the'
	DB	' DDL file', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@HFPH@DDL?5Generationg?5Warning?$AA@
_DATA	SEGMENT
??_C@_0BI@HFPH@DDL?5Generationg?5Warning?$AA@ DB 'DDL Generationg Warning'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FJ@KCOE@?$CFs?5WARNING?9?9Following?5index?5may?5@
_DATA	SEGMENT
??_C@_0FJ@KCOE@?$CFs?5WARNING?9?9Following?5index?5may?5@ DB '%s WARNING-'
	DB	'-Following index may not have the  same the columns as the or'
	DB	'iginal index: %s', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_vEMD$ = 12
_pchFileName$ = 20
_vSubtask$ = 24
_hLibrary$ = -52
_f$ = -860
_pfn$ = -64
_vDB$ = -8
_vBoth$ = -16
_szDLL$ = -356
_szTableName$ = -912
_szColumnName$ = -96
_szOwner$ = -48
_szLine$ = -856
_pchDefaultOwner$ = -880
_pchDBName$ = -868
_pchDBDesc$ = -876
_k$ = -872
_nRC$ = -60
_nLth$ = -56
_nReturn$ = -4
_bTableDropped$ = -864
_pchTableName$31445 = -916
_lDB_Lth$31450 = -936
_lDTE_Lth$31451 = -932
_szDB_Type$31452 = -928
_szDTE_Type$31453 = -948
_pchColName$31454 = -952
_pchKeyType$31483 = -956
_bFirstAlterOfTable$31491 = -960
_pchMatchFound$31496 = -964
_pchKeyType$31498 = -968
_szEntityName$31500 = -1004
_bFirstAlterForTable$31519 = -1008
_nIndexDroppedCount$31526 = -1012
_szEntityName$31529 = -1048
_szIndex$31535 = -1080
_pchKeyType$31541 = -1084
_szMsg$31553 = -2084
_BuildSyncDDL@20 PROC NEAR

; 3454 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2092				; 0000082cH

; 3455 :    LPLIBRARY hLibrary;
; 3456 :    zLONG     f = -1;

	mov	DWORD PTR _f$[ebp], -1

; 3457 :    zSHORT    (POPERATION pfn)( zVIEW, zPVIEW );
; 3458 :    zVIEW     vDB = 0;

	mov	DWORD PTR _vDB$[ebp], 0

; 3459 :    zVIEW     vBoth[ 2 ];
; 3460 :    zCHAR     szDLL[ zMAX_FILENAME_LTH + 1 ];
; 3461 :    zCHAR     szTableName[ MAX_TABLENAME_LTH + 1 ];
; 3462 :    zCHAR     szColumnName[ MAX_TABLENAME_LTH + 1 ];
; 3463 :    zCHAR     szOwner[ MAX_TABLENAME_LTH + 1 ];
; 3464 :    zCHAR     szLine[ 500 ];
; 3465 :    zPCHAR    pchDefaultOwner;
; 3466 :    zPCHAR    pchDBName;
; 3467 :    zPCHAR    pchDBDesc;
; 3468 :    zSHORT    k, nRC;
; 3469 :    zSHORT    nLth;
; 3470 :    zSHORT    nReturn = zCALL_ERROR;

	mov	WORD PTR _nReturn$[ebp], -16		; fffffff0H

; 3471 :    zBOOL     bTableDropped;
; 3472 : 
; 3473 :    // Make copies of the views so we can safely change the cursors.
; 3474 :    CreateViewFromViewForTask( &vDTE, vDTE, 0 );

	push	0
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 3475 :    CreateViewFromViewForTask( &vEMD, vEMD, 0 );

	push	0
	mov	edx, DWORD PTR _vEMD$[ebp]
	push	edx
	lea	eax, DWORD PTR _vEMD$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 3476 : 
; 3477 :    // First thing we have to do is call the SQL DBH to load the current
; 3478 :    // DB schema.
; 3479 :    GetStringFromAttribute( szDLL,
; 3480 :                            vDTE, "TE_DBMS_Source", "Executable" );

	push	OFFSET FLAT:??_C@_0L@NKCB@Executable?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDLL$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3481 :    hLibrary = SysLoadLibrary( vSubtask, szDLL );

	lea	eax, DWORD PTR _szDLL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 3482 :    if ( hLibrary )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	SHORT $L31416

; 3484 :       pfn = SysGetProc( hLibrary, "RetrieveSchema" );

	push	OFFSET FLAT:??_C@_0P@JHOI@RetrieveSchema?$AA@ ; `string'
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR _pfn$[ebp], eax

; 3485 :       if ( pfn )

	cmp	DWORD PTR _pfn$[ebp], 0
	je	SHORT $L31418

; 3487 :          (*pfn)( vDTE, &vDB );

	lea	eax, DWORD PTR _vDB$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	DWORD PTR _pfn$[ebp]

; 3489 :       else

	jmp	SHORT $L31419
$L31418:

; 3491 :          MessageSend( vSubtask, "TE00422", "Physical Data Model",
; 3492 :                       "Couldn't find 'BuildSyncDDL' in Generater Executable",
; 3493 :                       zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 );

	push	0
	push	300					; 0000012cH
	push	OFFSET FLAT:??_C@_0DF@MNGA@Couldn?8t?5find?5?8BuildSyncDDL?8?5in?5@ ; `string'
	push	OFFSET FLAT:??_C@_0BE@DNAH@Physical?5Data?5Model?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_07LDCE@TE00422?$AA@	; `string'
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_MessageSend@24
$L31419:

; 3495 : 
; 3496 :       SysFreeLibrary( vSubtask, hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysFreeLibrary@8
$L31416:

; 3498 : 
; 3499 :    if ( vDB == 0 )

	cmp	DWORD PTR _vDB$[ebp], 0
	jne	SHORT $L31423

; 3500 :       return( -1 );

	or	ax, -1
	jmp	$L31394
$L31423:

; 3501 : 
; 3502 :    //
; 3503 :    // Generate the DDL file name and open it.
; 3504 :    //
; 3505 :    nLth = zstrlen( pchFileName );

	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax

; 3506 :    GetStringFromAttribute( pchFileName + nLth,
; 3507 :                            vDTE, "TE_DBMS_Source", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	movsx	ecx, WORD PTR _nLth$[ebp]
	mov	edx, DWORD PTR _pchFileName$[ebp]
	add	edx, ecx
	push	edx
	call	_GetStringFromAttribute@16

; 3508 :    zstrcat( pchFileName, "_alter" );

	push	OFFSET FLAT:??_C@_06NGI@_alter?$AA@	; `string'
	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3509 : 
; 3510 :    // Make sure the filename isn't too long.
; 3511 :    if ( zstrlen( pchFileName + nLth ) > zBASE_FILENAME_LTH )

	movsx	ecx, WORD PTR _nLth$[ebp]
	mov	edx, DWORD PTR _pchFileName$[ebp]
	add	edx, ecx
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 128				; 00000080H
	jbe	SHORT $L31425

; 3512 :       pchFileName[ nLth + zBASE_FILENAME_LTH ] = 0;

	movsx	eax, WORD PTR _nLth$[ebp]
	mov	ecx, DWORD PTR _pchFileName$[ebp]
	mov	BYTE PTR [ecx+eax+128], 0
$L31425:

; 3513 : 
; 3514 :    zstrcat( pchFileName, ".ddl" );

	push	OFFSET FLAT:??_C@_04PMIC@?4ddl?$AA@	; `string'
	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3515 :    if ( (f = SysOpenFile( vDTE, pchFileName, COREFILE_WRITE )) < 0 )

	push	64					; 00000040H
	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysOpenFile@12
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jge	SHORT $L31426

; 3516 :       goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31426:

; 3517 : 
; 3518 :    GetAddrForAttribute( &pchDBName, vDTE, "TE_DBMS_Source", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDBName$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3519 :    GetAddrForAttribute( &pchDBDesc, vDTE, "TE_DBMS_Source", "Desc" );

	push	OFFSET FLAT:??_C@_04DKMG@Desc?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchDBDesc$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3520 :    zsprintf( szLine, "%s Alter script for %s -- %s %s",
; 3521 :              COMMENT_START, pchDBName, pchDBDesc, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	eax, DWORD PTR _pchDBDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchDBName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0CA@EBOB@?$CFs?5Alter?5script?5for?5?$CFs?5?9?9?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 3522 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31429

; 3523 :       goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31429:

; 3524 : 
; 3525 :    GetAddrForAttribute( &pchDefaultOwner, vDTE,
; 3526 :                         "TE_DBMS_Source", "DefaultOwner" );

	push	OFFSET FLAT:??_C@_0N@HJOL@DefaultOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3527 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31431
	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $L31430
$L31431:

; 3528 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$L31430:

; 3529 : 
; 3530 :    // Turn off the "MatchFound" flag for all the tables/columns.
; 3531 :    vBoth[ 0 ] = vDTE;

	mov	ecx, DWORD PTR _vDTE$[ebp]
	mov	DWORD PTR _vBoth$[ebp], ecx

; 3532 :    vBoth[ 1 ] = vDB;

	mov	edx, DWORD PTR _vDB$[ebp]
	mov	DWORD PTR _vBoth$[ebp+4], edx

; 3533 :    for ( k = 0; k < 2; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L31432
$L31433:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L31432:
	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 2
	jge	$L31434

; 3535 :       for ( nRC = SetCursorFirstEntity( vBoth[ k ], "TE_TablRec", 0 );
; 3536 :             nRC >= zCURSOR_SET;
; 3537 :             nRC = SetCursorNextEntity( vBoth[ k ], "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vBoth$[ebp+edx*4]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31435
$L31436:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _vBoth$[ebp+ecx*4]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31435:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L31437

; 3539 :          SetAttributeFromString( vBoth[ k ], "TE_TablRec", "MatchFound", "N" );

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _vBoth$[ebp+ecx*4]
	push	edx
	call	_SetAttributeFromString@16

; 3540 : 
; 3541 :          for ( nRC = SetCursorFirstEntity( vBoth[ k ], "TE_FieldDataRel", 0 );
; 3542 :                nRC >= zCURSOR_SET;
; 3543 :                nRC = SetCursorNextEntity( vBoth[ k ], "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _vBoth$[ebp+eax*4]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31439
$L31440:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vBoth$[ebp+edx*4]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31439:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $L31441

; 3545 :             SetAttributeFromString( vBoth[ k ], "TE_FieldDataRel",
; 3546 :                                     "MatchFound", "N" );

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vBoth$[ebp+edx*4]
	push	eax
	call	_SetAttributeFromString@16

; 3547 :          }

	jmp	SHORT $L31440
$L31441:

; 3548 :       }

	jmp	$L31436
$L31437:

; 3549 :    }

	jmp	$L31433
$L31434:

; 3550 : 
; 3551 :    // Now look for matches.
; 3552 :    for ( nRC = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3553 :          nRC >= zCURSOR_SET;
; 3554 :          nRC = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31442
$L31443:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31442:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L31444

; 3556 :       zPCHAR pchTableName;
; 3557 : 
; 3558 :       if ( SetCursorFirstEntityByAttr( vDB, "TE_TablRec", "Name",
; 3559 :                                        vDTE, "TE_TablRec",
; 3560 :                                        "Name", 0 ) < zCURSOR_SET )

	push	0
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorFirstEntityByAttr@28
	movsx	eax, ax
	test	eax, eax
	jge	SHORT $L31446

; 3562 :          continue;

	jmp	SHORT $L31443
$L31446:

; 3564 : 
; 3565 :       GetAddrForAttribute( &pchTableName, vDB, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchTableName$31445[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3566 :       SetAttributeFromString( vDTE, "TE_TablRec", "MatchFound", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 3567 :       SetAttributeFromString( vDB,  "TE_TablRec", "MatchFound", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 3568 : 
; 3569 :       for ( nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );
; 3570 :             nRC >= zCURSOR_SET;
; 3571 :             nRC = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31447
$L31448:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31447:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31449

; 3573 :          zLONG  lDB_Lth;
; 3574 :          zLONG  lDTE_Lth;
; 3575 :          zCHAR  szDB_Type[ 10 ];
; 3576 :          zCHAR  szDTE_Type[ 10 ];
; 3577 :          zPCHAR pchColName;
; 3578 : 
; 3579 :          // Check to see if there is a field in the DB with the same
; 3580 :          // name.
; 3581 :          if ( SetCursorFirstEntityByAttr( vDB, "TE_FieldDataRel", "Name",
; 3582 :                                           vDTE, "TE_FieldDataRel",
; 3583 :                                           "Name", 0 ) < zCURSOR_SET )

	push	0
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetCursorFirstEntityByAttr@28
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $L31455

; 3585 :             // Nope.  No match found, continue with the next one.
; 3586 :             continue;

	jmp	SHORT $L31448
$L31455:

; 3588 : 
; 3589 :          GetAddrForAttribute( &pchColName, vDB, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchColName$31454[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3590 :          GetIntegerFromAttribute( &lDB_Lth,  vDB, "TE_FieldDataRel", "Length" );

	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lDB_Lth$31450[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 3591 :          GetIntegerFromAttribute( &lDTE_Lth, vDTE, "TE_FieldDataRel", "Length" );

	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lDTE_Lth$31451[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 3592 :          GetStringFromAttribute( szDB_Type,  vDB, "TE_FieldDataRel", "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDB_Type$31452[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3593 :          GetStringFromAttribute( szDTE_Type, vDTE, "TE_FieldDataRel", "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDTE_Type$31453[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3594 : 
; 3595 :          // Some datatypes need to be massaged before we compare them.
; 3596 :          #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 3597 :              defined( POSTGRESQL ) || defined( SQLSERVER )
; 3598 : 
; 3599 :             switch ( szDB_Type[ 0 ] )
; 3600 :             {

	mov	al, BYTE PTR _szDB_Type$31452[ebp]
	mov	BYTE PTR -2088+[ebp], al
	cmp	BYTE PTR -2088+[ebp], 68		; 00000044H
	je	SHORT $L31460
	cmp	BYTE PTR -2088+[ebp], 73		; 00000049H
	je	SHORT $L31460
	cmp	BYTE PTR -2088+[ebp], 84		; 00000054H
	je	SHORT $L31460
	jmp	SHORT $L31457
$L31460:

; 3601 :                case zTYPE_DATE:
; 3602 :                case zTYPE_TIME:
; 3603 :                case zTYPE_DATETIME:
; 3604 :                   // In access, all date/time/timestamps are stored as the same
; 3605 :                   // datatype, so we need to set things up so they compare the same.
; 3606 :                   szDB_Type[ 0 ] = szDTE_Type[ 0 ];

	mov	cl, BYTE PTR _szDTE_Type$31453[ebp]
	mov	BYTE PTR _szDB_Type$31452[ebp], cl
$L31457:

; 3609 : 
; 3610 :             // We only care about the length for string types.
; 3611 :             if ( szDB_Type[ 0 ] != zTYPE_STRING || szDB_Type[ 0 ] != zTYPE_FIXEDCHAR )

	movsx	edx, BYTE PTR _szDB_Type$31452[ebp]
	cmp	edx, 83					; 00000053H
	jne	SHORT $L31462
	movsx	eax, BYTE PTR _szDB_Type$31452[ebp]
	cmp	eax, 70					; 00000046H
	je	SHORT $L31461
$L31462:

; 3612 :                lDB_Lth = lDTE_Lth;

	mov	ecx, DWORD PTR _lDTE_Lth$31451[ebp]
	mov	DWORD PTR _lDB_Lth$31450[ebp], ecx
$L31461:

; 3613 : 
; 3614 :          #endif
; 3615 : 
; 3616 :          if ( lDB_Lth != lDTE_Lth || zstrcmp( szDB_Type, szDTE_Type ) != 0 )

	mov	edx, DWORD PTR _lDB_Lth$31450[ebp]
	cmp	edx, DWORD PTR _lDTE_Lth$31451[ebp]
	jne	SHORT $L31470
	movsx	eax, BYTE PTR _szDB_Type$31452[ebp]
	movsx	ecx, BYTE PTR _szDTE_Type$31453[ebp]
	cmp	eax, ecx
	jne	SHORT $L32326
	lea	edx, DWORD PTR _szDTE_Type$31453[ebp]
	push	edx
	lea	eax, DWORD PTR _szDB_Type$31452[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -2092+[ebp], eax
	jmp	SHORT $L32327
$L32326:
	movsx	ecx, BYTE PTR _szDB_Type$31452[ebp]
	movsx	edx, BYTE PTR _szDTE_Type$31453[ebp]
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -2092+[ebp], eax
$L32327:
	cmp	DWORD PTR -2092+[ebp], 0
	je	SHORT $L31469
$L31470:

; 3618 :             #if 0
; 3619 :                zCHAR sz[ 500 ];
; 3620 : 
; 3621 :                zsprintf( sz, "%s.%s  TE Datatype = %s, Length = %d",
; 3622 :                          pchTableName, pchColName, szDTE_Type, lDTE_Lth );
; 3623 :                TraceLineS( sz, "" );
; 3624 :                zsprintf( sz, "%s.%s  DB Datatype = %s, Length = %d",
; 3625 :                          pchTableName, pchColName, szDB_Type, lDB_Lth );
; 3626 :                TraceLineS( sz, "" );
; 3627 :             #endif
; 3628 : 
; 3629 :             // Column is different somehow.
; 3630 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "MatchFound", "D" );

	push	OFFSET FLAT:??_C@_01PJM@D?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 3631 :             SetAttributeFromString( vDB,  "TE_FieldDataRel", "MatchFound", "D" );

	push	OFFSET FLAT:??_C@_01PJM@D?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 3633 :          else

	jmp	SHORT $L31472
$L31469:

; 3635 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "MatchFound", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 3636 :             SetAttributeFromString( vDB,  "TE_FieldDataRel", "MatchFound", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$L31472:

; 3638 : 
; 3639 :       }  // For each TE_FieldDataRel

	jmp	$L31448
$L31449:

; 3640 : 
; 3641 :    }  // For each TE_TablRec

	jmp	$L31443
$L31444:

; 3642 : 
; 3643 :    //
; 3644 :    // Print results.
; 3645 :    //
; 3646 : 
; 3647 :    // Create tables.
; 3648 :    for ( nRC = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3649 :          nRC >= zCURSOR_SET;
; 3650 :          nRC = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31473
$L31474:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31473:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31475

; 3652 :       GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3653 : 
; 3654 :       // If table is in the DB, we don't need to create it.
; 3655 :       if ( CompareAttributeToString( vDTE, "TE_TablRec", "MatchFound", "N" ) != 0 )

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L31476

; 3656 :          continue;

	jmp	SHORT $L31474
$L31476:

; 3657 : 
; 3658 :       if ( fnBuildCreateTable( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildCreateTable@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L31477

; 3659 :          goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31477:

; 3660 : 
; 3661 :       if ( fnBuildCreateMainIndex( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildCreateMainIndex@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L31478

; 3662 :          goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31478:

; 3663 : 
; 3664 :       #if COMMIT_EVERY_TABLE
; 3665 :          if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	push	OFFSET FLAT:??_C@_07JAEB@COMMIT?$DL?$AA@ ; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31479

; 3666 :             return( -1 );

	or	ax, -1
	jmp	$L31394
$L31479:

; 3667 :       #endif
; 3668 : 
; 3669 :       // Create the indexes for the FKs.
; 3670 :       for ( nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );
; 3671 :             nRC >= zCURSOR_SET;
; 3672 :             nRC = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31480
$L31481:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31480:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31482

; 3674 :          zPCHAR pchKeyType;
; 3675 : 
; 3676 :          GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",
; 3677 :                               "DataOrRelfieldOrSet" );

	push	OFFSET FLAT:??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchKeyType$31483[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3678 :          if ( pchKeyType[ 0 ] == 'R' )

	mov	ecx, DWORD PTR _pchKeyType$31483[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 82					; 00000052H
	jne	SHORT $L31487

; 3680 :             if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildFK_Index@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L31485

; 3681 :                goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31485:

; 3682 :             #if defined( COMMIT_EVERY_TABLE )
; 3683 : 
; 3684 :                if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31486

; 3685 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31486:

; 3686 : 
; 3687 :                if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	push	OFFSET FLAT:??_C@_07JAEB@COMMIT?$DL?$AA@ ; `string'
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31487

; 3688 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31487:

; 3692 : 
; 3693 :       }  // For each TE_FieldDataRel

	jmp	$L31481
$L31482:

; 3694 : 
; 3695 :    }  // For each TE_TablRec

	jmp	$L31474
$L31475:

; 3696 : 
; 3697 :    // Add columns to tables.
; 3698 :    for ( nRC = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3699 :          nRC >= zCURSOR_SET;
; 3700 :          nRC = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31488
$L31489:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31488:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L31490

; 3702 :       zBOOL bFirstAlterOfTable;
; 3703 : 
; 3704 :       GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3705 : 
; 3706 :       if ( CompareAttributeToString( vDTE, "TE_TablRec", "MatchFound", "N" ) == 0 )

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L31492

; 3708 :          // We alread created the table, so continue with the next one.
; 3709 :          continue;

	jmp	SHORT $L31489
$L31492:

; 3711 : 
; 3712 :       bFirstAlterOfTable = TRUE;

	mov	BYTE PTR _bFirstAlterOfTable$31491[ebp], 1

; 3713 :       for ( nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );
; 3714 :             nRC >= zCURSOR_SET;
; 3715 :             nRC = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31493
$L31494:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31493:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31495

; 3717 :          zPCHAR pchMatchFound;
; 3718 : 
; 3719 :          GetAddrForAttribute( &pchMatchFound,
; 3720 :                               vDTE, "TE_FieldDataRel", "MatchFound" );

	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchMatchFound$31496[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3721 : 
; 3722 :          if ( pchMatchFound[ 0 ] == 'N' )

	mov	ecx, DWORD PTR _pchMatchFound$31496[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 78					; 0000004eH
	jne	$L31507

; 3724 :             zPCHAR pchKeyType;
; 3725 : 
; 3726 :             // Add a blank line to seperate columns from different tables.
; 3727 :             if ( bFirstAlterOfTable )

	mov	eax, DWORD PTR _bFirstAlterOfTable$31491[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L31503

; 3729 :                zCHAR szEntityName[ zZEIDON_NAME_LTH + 1 ];
; 3730 : 
; 3731 :                bFirstAlterOfTable = FALSE;

	mov	BYTE PTR _bFirstAlterOfTable$31491[ebp], 0

; 3732 :                GetStringFromAttribute( szEntityName, vDTE, "ER_Entity", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$31500[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3733 : 
; 3734 :                if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31501

; 3735 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31501:

; 3736 : 
; 3737 :                zsprintf( szLine, "%s Entity %s %s",
; 3738 :                          COMMENT_START, szEntityName, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	lea	edx, DWORD PTR _szEntityName$31500[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3739 :                if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31503

; 3740 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31503:

; 3742 : 
; 3743 :             GetStringFromAttribute( szColumnName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3744 : 
; 3745 :             zsprintf( szLine, "ALTER TABLE %s " ADD_COLUMN_STMT " ", szTableName );

	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BE@FPJB@ALTER?5TABLE?5?$CFs?5ADD?5?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 3746 :             fnBuildColumn( vDTE, f, szLine );

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildColumn@12

; 3747 :             zstrcat( szLine, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3748 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31505

; 3749 :                goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31505:

; 3750 : 
; 3751 :             // If the attribute is not a rel field try the next one.
; 3752 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",
; 3753 :                                  "DataOrRelfieldOrSet" );

	push	OFFSET FLAT:??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchKeyType$31498[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3754 :             if ( pchKeyType[ 0 ] != 'R' )

	mov	edx, DWORD PTR _pchKeyType$31498[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 82					; 00000052H
	je	SHORT $L31506

; 3755 :                continue;

	jmp	$L31494
$L31506:

; 3756 : 
; 3757 :             if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildFK_Index@8
	movsx	eax, ax
	cmp	eax, -1
	jne	SHORT $L31507

; 3758 :                goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31507:

; 3760 : 
; 3761 :       }  // For each TE_FieldDataRel

	jmp	$L31494
$L31495:

; 3762 : 
; 3763 :       #if COMMIT_EVERY_TABLE
; 3764 :          // Commit the table if we altered it.
; 3765 :          if ( bFirstAlterOfTable == FALSE && fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	mov	ecx, DWORD PTR _bFirstAlterOfTable$31491[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L31508
	push	OFFSET FLAT:??_C@_07JAEB@COMMIT?$DL?$AA@ ; `string'
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31508

; 3766 :             return( -1 );

	or	ax, -1
	jmp	$L31394
$L31508:

; 3767 :       #endif
; 3768 : 
; 3769 :    }  // For each TE_TablRec

	jmp	$L31489
$L31490:

; 3770 : 
; 3771 :    // Drop tables.
; 3772 :    bTableDropped = FALSE;

	mov	BYTE PTR _bTableDropped$[ebp], 0

; 3773 :    for ( nRC = SetCursorFirstEntity( vDB, "TE_TablRec", 0 );
; 3774 :          nRC >= zCURSOR_SET;
; 3775 :          nRC = SetCursorNextEntity( vDB, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31509
$L31510:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31509:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L31511

; 3777 :       GetStringFromAttribute( szTableName, vDB, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3778 :       RemoveBrackets( szTableName );

	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3779 : 
; 3780 :       if ( CompareAttributeToString( vDB, "TE_TablRec", "MatchFound", "Y" ) != 0 )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L31512

; 3782 :          zsprintf( szLine, "DROP TABLE %s %s", szTableName,
; 3783 :                    LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BB@MKDI@DROP?5TABLE?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 3784 : 
; 3785 :          if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31514

; 3786 :             goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31514:

; 3787 : 
; 3788 :          bTableDropped = TRUE;

	mov	BYTE PTR _bTableDropped$[ebp], 1
$L31512:

; 3790 : 
; 3791 :    }  // For each TE_TablRec

	jmp	$L31510
$L31511:

; 3792 : 
; 3793 :    #if COMMIT_EVERY_TABLE
; 3794 :       if ( bTableDropped && fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	mov	edx, DWORD PTR _bTableDropped$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L31515
	push	OFFSET FLAT:??_C@_07JAEB@COMMIT?$DL?$AA@ ; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31515

; 3795 :          return( -1 );

	or	ax, -1
	jmp	$L31394
$L31515:

; 3796 :    #endif
; 3797 : 
; 3798 :    // Drop/alter columns from tables.
; 3799 :    for ( nRC = SetCursorFirstEntity( vDB, "TE_TablRec", 0 );
; 3800 :          nRC >= zCURSOR_SET;
; 3801 :          nRC = SetCursorNextEntity( vDB, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31516
$L31517:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31516:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31518

; 3803 :       zBOOL bFirstAlterForTable;
; 3804 : 
; 3805 :       GetStringFromAttribute( szTableName, vDB, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3806 :       RemoveBrackets( szTableName );

	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3807 : 
; 3808 :       if ( CompareAttributeToString( vDB, "TE_TablRec", "MatchFound", "Y" ) != 0 )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L31520

; 3810 :          // Table deleted, go on to next one.
; 3811 :          continue;

	jmp	SHORT $L31517
$L31520:

; 3813 : 
; 3814 :       // Set the cursor in the TE to match the one in the DB.
; 3815 :       SetCursorFirstEntityByAttr( vDTE, "TE_TablRec", "Name",
; 3816 :                                   vDB,  "TE_TablRec", "Name", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntityByAttr@28

; 3817 : 
; 3818 :       GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3819 :       if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	edx, BYTE PTR _szOwner$[ebp]
	test	edx, edx
	jne	SHORT $L31521
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31521

; 3820 :          zstrcpy( szOwner, pchDefaultOwner );

	mov	eax, DWORD PTR _pchDefaultOwner$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$L31521:

; 3821 : 
; 3822 :       if ( szOwner[ 0 ] )

	movsx	edx, BYTE PTR _szOwner$[ebp]
	test	edx, edx
	je	SHORT $L31522

; 3823 :          zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$L31522:

; 3824 : 
; 3825 :       bFirstAlterForTable = TRUE;

	mov	BYTE PTR _bFirstAlterForTable$31519[ebp], 1

; 3826 :       for ( nRC = SetCursorFirstEntity( vDB, "TE_FieldDataRel", 0 );
; 3827 :             nRC >= zCURSOR_SET;
; 3828 :             nRC = SetCursorNextEntity( vDB, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31523
$L31524:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31523:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L31525

; 3830 :          zSHORT nIndexDroppedCount;
; 3831 : 
; 3832 :          // If a match was found for the column, we don't need to do anything.
; 3833 :          if ( CompareAttributeToString( vDB, "TE_FieldDataRel",
; 3834 :                                         "MatchFound", "Y" ) == 0 )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L31527

; 3836 :             continue;

	jmp	SHORT $L31524
$L31527:

; 3838 : 
; 3839 :          // Print out a comment if this is the first ALTER for the current
; 3840 :          // table.
; 3841 :          if ( bFirstAlterForTable )

	mov	eax, DWORD PTR _bFirstAlterForTable$31519[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L31531

; 3843 :             zCHAR szEntityName[ zZEIDON_NAME_LTH + 1 ];
; 3844 : 
; 3845 :             bFirstAlterForTable = FALSE;

	mov	BYTE PTR _bFirstAlterForTable$31519[ebp], 0

; 3846 :             GetStringFromAttribute( szEntityName, vDTE, "ER_Entity", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$31529[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3847 : 
; 3848 :             if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31530

; 3849 :                goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31530:

; 3850 : 
; 3851 :             zsprintf( szLine, "%s Entity %s %s",
; 3852 :                       COMMENT_START, szEntityName, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	lea	edx, DWORD PTR _szEntityName$31529[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3853 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31531

; 3854 :                goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31531:

; 3856 : 
; 3857 :          GetStringFromAttribute( szColumnName, vDB, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3858 : 
; 3859 :          // Check to see if there is an index on the column.  If there is,
; 3860 :          // then we need to drop it.
; 3861 :          nIndexDroppedCount = 0;

	mov	WORD PTR _nIndexDroppedCount$31526[ebp], 0

; 3862 :          for ( nRC = SetCursorFirstEntityByString( vDB, "TE_FieldDataRelKey",
; 3863 :                                                    "Name", szColumnName,
; 3864 :                                                    "TE_TablRec" );
; 3865 :                nRC >= zCURSOR_SET;
; 3866 :                nRC = SetCursorNextEntityByString( vDB, "TE_FieldDataRelKey",
; 3867 :                                                   "Name", szColumnName,
; 3868 :                                                   "TE_TablRec" ) )

	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31532
$L31533:
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetCursorNextEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
$L31532:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $L31534

; 3870 :             zCHAR szIndex[ MAX_TABLENAME_LTH + 1 ];
; 3871 : 
; 3872 :             GetStringFromAttribute( szIndex, vDB, "TE_TablRecKey", "IndexName" );

	push	OFFSET FLAT:??_C@_09CEBI@IndexName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	lea	eax, DWORD PTR _szIndex$31535[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3873 :             fnBuildDropIndex( vDB, szIndex, szOwner, szTableName, f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szIndex$31535[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_fnBuildDropIndex@20

; 3874 :             nIndexDroppedCount++;

	mov	ax, WORD PTR _nIndexDroppedCount$31526[ebp]
	add	ax, 1
	mov	WORD PTR _nIndexDroppedCount$31526[ebp], ax

; 3875 :          }

	jmp	SHORT $L31533
$L31534:

; 3876 : 
; 3877 :          // Check to see if the column needs to be altered or dropped.
; 3878 :          if ( CompareAttributeToString( vDB, "TE_FieldDataRel",
; 3879 :                                         "MatchFound", "N" ) == 0 )

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L31536

; 3881 :             // Drop the column.
; 3882 :             zsprintf( szLine, "ALTER TABLE %s%s " DROP_COLUMN_STMT " %s %s",
; 3883 :                       szOwner, szTableName, szColumnName, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CD@OHJM@ALTER?5TABLE?5?$CFs?$CFs?5DROP?5COLUMN?5?$CFs?5@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 3884 : 
; 3885 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31538

; 3886 :                goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31538:

; 3888 :          else

	jmp	$L31558
$L31536:

; 3889 :          if ( CompareAttributeToString( vDB, "TE_FieldDataRel",
; 3890 :                                         "MatchFound", "D" ) == 0 )

	push	OFFSET FLAT:??_C@_01PJM@D?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	$L31558

; 3892 :             zPCHAR pchKeyType;
; 3893 : 
; 3894 :             // Alter the column to match the datatype in the TE.
; 3895 :             zsprintf( szLine, "ALTER TABLE %s%-*s ALTER COLUMN ",
; 3896 :                       szOwner, (int) MAX_TABLENAME_LTH, szTableName );

	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	push	30					; 0000001eH
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CB@MGNG@ALTER?5TABLE?5?$CFs?$CF?9?$CKs?5ALTER?5COLUMN?5@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3897 : 
; 3898 :             fnBuildColumn( vDB, f, szLine );

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_fnBuildColumn@12

; 3899 :             zstrcat( szLine, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3900 : 
; 3901 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31544

; 3902 :                goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31544:

; 3903 : 
; 3904 :             // Check to see if we need to re-create any indexes.
; 3905 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",
; 3906 :                                  "DataOrRelfieldOrSet" );

	push	OFFSET FLAT:??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchKeyType$31541[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3907 :             if ( pchKeyType[ 0 ] == 'R' )

	mov	eax, DWORD PTR _pchKeyType$31541[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 82					; 00000052H
	jne	SHORT $L31545

; 3909 :                if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildFK_Index@8
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $L31546

; 3910 :                  goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31546:

; 3911 : 
; 3912 :                // We re-created one of the indexes dropped earlier so decrement
; 3913 :                // count so we'll know if we recreated all the indexes.
; 3914 :                nIndexDroppedCount--;

	mov	dx, WORD PTR _nIndexDroppedCount$31526[ebp]
	sub	dx, 1
	mov	WORD PTR _nIndexDroppedCount$31526[ebp], dx
$L31545:

; 3916 : 
; 3917 :             // If no more indexes need to be recreated, go on to the next col.
; 3918 :             if ( nIndexDroppedCount == 0 )

	movsx	eax, WORD PTR _nIndexDroppedCount$31526[ebp]
	test	eax, eax
	jne	SHORT $L31547

; 3919 :                continue;

	jmp	$L31524
$L31547:

; 3920 : 
; 3921 :             // Check to see if the column we altered is contained in the list of
; 3922 :             // identifiers for the table.  If it is we need to recreate
; 3923 :             // the indexes that were dropped above.
; 3924 :             for ( nRC = SetCursorFirstEntityByString( vDTE, "TE_FieldDataRelKey",
; 3925 :                                                       "Name", szColumnName,
; 3926 :                                                       "TE_TablRec" );
; 3927 : 
; 3928 :                   nRC >= zCURSOR_SET;
; 3929 :                   nRC = SetCursorNextEntityByString( vDTE, "TE_FieldDataRelKey",
; 3930 :                                                      "Name", szColumnName,
; 3931 :                                                       "TE_TablRec" ) )

	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31548
$L31549:
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
$L31548:
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L31550

; 3933 :                if ( fnBuildIndexFromTablRecKey( vDTE, FALSE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildIndexFromTablRecKey@12
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L31551

; 3934 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31427
$L31551:

; 3935 : 
; 3936 :                // We re-created one of the indexes dropped earlier so decrement
; 3937 :                // count so we'll know if we recreated all the indexes.
; 3938 :                nIndexDroppedCount--;

	mov	ax, WORD PTR _nIndexDroppedCount$31526[ebp]
	sub	ax, 1
	mov	WORD PTR _nIndexDroppedCount$31526[ebp], ax

; 3939 :             }

	jmp	SHORT $L31549
$L31550:

; 3940 : 
; 3941 :             if ( nIndexDroppedCount )

	movsx	ecx, WORD PTR _nIndexDroppedCount$31526[ebp]
	test	ecx, ecx
	je	$L31558

; 3943 :                zCHAR szMsg[ 1000 ];
; 3944 : 
; 3945 :                // An index has been dropped for this column because it has been
; 3946 :                // modified but it is not a FK so we don't normally create an
; 3947 :                // index on it.  We'll display a warning and try to create an
; 3948 :                // index for the column.
; 3949 :                zsprintf( szMsg, "WARNING: The data type for the column %s.%s "
; 3950 :                          "has been changed and therefore had an index deleted.  "
; 3951 :                          "The column is NOT a key and therefore the index was "
; 3952 :                          "added by the DBA.  An attempt has been made to "
; 3953 :                          "recreate the index in the DDL.  Look for 'WARNING' "
; 3954 :                          "in the DDL file",
; 3955 :                          szTableName, szColumnName );

	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BAI@KIFF@WARNING?3?5The?5data?5type?5for?5the?5c@ ; `string'
	lea	ecx, DWORD PTR _szMsg$31553[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 3956 :                SysMessageBox( vDTE, "DDL Generationg Warning", szMsg, 0 );

	push	0
	lea	edx, DWORD PTR _szMsg$31553[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BI@HFPH@DDL?5Generationg?5Warning?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysMessageBox@16

; 3957 : 
; 3958 :                zsprintf( szMsg, "%s WARNING--Following index may not have the "
; 3959 :                          " same the columns as the original index: %s",
; 3960 :                          COMMENT_START, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0FJ@KCOE@?$CFs?5WARNING?9?9Following?5index?5may?5@ ; `string'
	lea	ecx, DWORD PTR _szMsg$31553[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 3961 :                if ( fnWriteLine( vDTE, f, szMsg ) < 0 )

	lea	edx, DWORD PTR _szMsg$31553[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31557

; 3962 :                   goto EndOfFunction;

	jmp	SHORT $EndOfFunction$31427
$L31557:

; 3963 : 
; 3964 :                if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildFK_Index@8
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $L31558

; 3965 :                  goto EndOfFunction;

	jmp	SHORT $EndOfFunction$31427
$L31558:

; 3968 : 
; 3969 :       }  // For each TE_FieldDataRel

	jmp	$L31524
$L31525:

; 3970 : 
; 3971 :       #if COMMIT_EVERY_TABLE
; 3972 :          // Commit the table if we altered it.
; 3973 :          if ( bFirstAlterForTable == FALSE && fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	mov	edx, DWORD PTR _bFirstAlterForTable$31519[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L31559
	push	OFFSET FLAT:??_C@_07JAEB@COMMIT?$DL?$AA@ ; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31559

; 3974 :             return( -1 );

	or	ax, -1
	jmp	SHORT $L31394
$L31559:

; 3975 :       #endif
; 3976 : 
; 3977 :    }  // For each TE_TablRec

	jmp	$L31517
$L31518:

; 3978 : 
; 3979 :    // If we get here, then everything's ok.
; 3980 :    nReturn = 0;

	mov	WORD PTR _nReturn$[ebp], 0
$EndOfFunction$31427:

; 3981 : 
; 3982 : EndOfFunction:
; 3983 :    if ( f >= 0 )

	cmp	DWORD PTR _f$[ebp], 0
	jl	SHORT $L31560

; 3984 :       SysCloseFile( vSubtask, f, 0 );

	push	0
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SysCloseFile@12
$L31560:

; 3985 : 
; 3986 :    // Drop the view copies.
; 3987 :    DropView( vDTE );

	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_DropView@4

; 3988 :    DropView( vEMD );

	mov	edx, DWORD PTR _vEMD$[ebp]
	push	edx
	call	_DropView@4

; 3989 : 
; 3990 :    return( nReturn );

	mov	ax, WORD PTR _nReturn$[ebp]
$L31394:

; 3991 : 
; 3992 : } // BuildSyncDDL

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_BuildSyncDDL@20 ENDP
_TEXT	ENDS
PUBLIC	_LoadDataTypes@4
PUBLIC	??_C@_0N@INLJ@DB_DataTypes?$AA@			; `string'
PUBLIC	??_C@_01PDAJ@S?$AA@				; `string'
PUBLIC	??_C@_0N@CCA@InternalName?$AA@			; `string'
PUBLIC	??_C@_06PINC@String?$AA@			; `string'
PUBLIC	??_C@_0N@NAC@ExternalName?$AA@			; `string'
PUBLIC	??_C@_01FLCE@L?$AA@				; `string'
PUBLIC	??_C@_07HDOI@Integer?$AA@			; `string'
PUBLIC	??_C@_01PBLD@M?$AA@				; `string'
PUBLIC	??_C@_07DBJI@Decimal?$AA@			; `string'
PUBLIC	??_C@_01KGOM@T?$AA@				; `string'
PUBLIC	??_C@_09KMOL@Timestamp?$AA@			; `string'
PUBLIC	??_C@_01FIAI@X?$AA@				; `string'
PUBLIC	??_C@_0M@BADB@TimeStampEx?$AA@			; `string'
PUBLIC	??_C@_04OMLL@Date?$AA@				; `string'
PUBLIC	??_C@_01FLOP@I?$AA@				; `string'
PUBLIC	??_C@_04OAHI@Time?$AA@				; `string'
PUBLIC	??_C@_01FKLC@F?$AA@				; `string'
PUBLIC	??_C@_09GOGB@FixedChar?$AA@			; `string'
PUBLIC	??_C@_0BA@IMGI@Blob?5?$CIlongblob?$CJ?$AA@	; `string'
PUBLIC	??_C@_01PDMC@V?$AA@				; `string'
PUBLIC	??_C@_0BA@NGGL@Text?5?$CIlongtext?$CJ?$AA@	; `string'
EXTRN	_CreateEntity@12:NEAR
;	COMDAT ??_C@_0N@INLJ@DB_DataTypes?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0N@INLJ@DB_DataTypes?$AA@ DB 'DB_DataTypes', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PDAJ@S?$AA@
_DATA	SEGMENT
??_C@_01PDAJ@S?$AA@ DB 'S', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@CCA@InternalName?$AA@
_DATA	SEGMENT
??_C@_0N@CCA@InternalName?$AA@ DB 'InternalName', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PINC@String?$AA@
_DATA	SEGMENT
??_C@_06PINC@String?$AA@ DB 'String', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NAC@ExternalName?$AA@
_DATA	SEGMENT
??_C@_0N@NAC@ExternalName?$AA@ DB 'ExternalName', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FLCE@L?$AA@
_DATA	SEGMENT
??_C@_01FLCE@L?$AA@ DB 'L', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HDOI@Integer?$AA@
_DATA	SEGMENT
??_C@_07HDOI@Integer?$AA@ DB 'Integer', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PBLD@M?$AA@
_DATA	SEGMENT
??_C@_01PBLD@M?$AA@ DB 'M', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_07DBJI@Decimal?$AA@
_DATA	SEGMENT
??_C@_07DBJI@Decimal?$AA@ DB 'Decimal', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01KGOM@T?$AA@
_DATA	SEGMENT
??_C@_01KGOM@T?$AA@ DB 'T', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KMOL@Timestamp?$AA@
_DATA	SEGMENT
??_C@_09KMOL@Timestamp?$AA@ DB 'Timestamp', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FIAI@X?$AA@
_DATA	SEGMENT
??_C@_01FIAI@X?$AA@ DB 'X', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@BADB@TimeStampEx?$AA@
_DATA	SEGMENT
??_C@_0M@BADB@TimeStampEx?$AA@ DB 'TimeStampEx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OMLL@Date?$AA@
_DATA	SEGMENT
??_C@_04OMLL@Date?$AA@ DB 'Date', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FLOP@I?$AA@
_DATA	SEGMENT
??_C@_01FLOP@I?$AA@ DB 'I', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OAHI@Time?$AA@
_DATA	SEGMENT
??_C@_04OAHI@Time?$AA@ DB 'Time', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FKLC@F?$AA@
_DATA	SEGMENT
??_C@_01FKLC@F?$AA@ DB 'F', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GOGB@FixedChar?$AA@
_DATA	SEGMENT
??_C@_09GOGB@FixedChar?$AA@ DB 'FixedChar', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@IMGI@Blob?5?$CIlongblob?$CJ?$AA@
_DATA	SEGMENT
??_C@_0BA@IMGI@Blob?5?$CIlongblob?$CJ?$AA@ DB 'Blob (longblob)', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PDMC@V?$AA@
_DATA	SEGMENT
??_C@_01PDMC@V?$AA@ DB 'V', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NGGL@Text?5?$CIlongtext?$CJ?$AA@
_DATA	SEGMENT
??_C@_0BA@NGGL@Text?5?$CIlongtext?$CJ?$AA@ DB 'Text (longtext)', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vType$ = 8
_LoadDataTypes@4 PROC NEAR

; 3996 : {

	push	ebp
	mov	ebp, esp

; 3997 :    //
; 3998 :    // Following are standard types.
; 3999 :    //
; 4000 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4001 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "S" );

	push	OFFSET FLAT:??_C@_01PDAJ@S?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4002 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4003 :                            "String" );

	push	OFFSET FLAT:??_C@_06PINC@String?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4004 : 
; 4005 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4006 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "L" );

	push	OFFSET FLAT:??_C@_01FLCE@L?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4007 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4008 :                            "Integer" );

	push	OFFSET FLAT:??_C@_07HDOI@Integer?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4009 : 
; 4010 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4011 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "M" );

	push	OFFSET FLAT:??_C@_01PBLD@M?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4012 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4013 :                            "Decimal" );

	push	OFFSET FLAT:??_C@_07DBJI@Decimal?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4014 : 
; 4015 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4016 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "T" );

	push	OFFSET FLAT:??_C@_01KGOM@T?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4017 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4018 :                            "Timestamp" );

	push	OFFSET FLAT:??_C@_09KMOL@Timestamp?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4019 : 
; 4020 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4021 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "X" );

	push	OFFSET FLAT:??_C@_01FIAI@X?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4022 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4023 :                            "TimeStampEx" );

	push	OFFSET FLAT:??_C@_0M@BADB@TimeStampEx?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4024 : 
; 4025 : #if defined( SQLSERVER ) && !defined( QUINSOFT )
; 4026 :    /*
; 4027 :    ** The ODBC-driver for SqlServer doesn't support SQL_DATE and SQL_TIME
; 4028 :    */
; 4029 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4030 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "T" );
; 4031 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Date" );
; 4032 : 
; 4033 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4034 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "T" );
; 4035 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Time" );
; 4036 : #else
; 4037 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4038 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "D" );

	push	OFFSET FLAT:??_C@_01PJM@D?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4039 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Date" );

	push	OFFSET FLAT:??_C@_04OMLL@Date?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4040 : 
; 4041 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4042 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "I" );

	push	OFFSET FLAT:??_C@_01FLOP@I?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4043 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Time" );

	push	OFFSET FLAT:??_C@_04OAHI@Time?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4044 : #endif
; 4045 : 
; 4046 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4047 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "F" );

	push	OFFSET FLAT:??_C@_01FKLC@F?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4048 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "FixedChar" );

	push	OFFSET FLAT:??_C@_09GOGB@FixedChar?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4049 : 
; 4050 : #if defined( ACCESS )
; 4051 : 
; 4052 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4053 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4054 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4055 :                            "Blob (Memo)" );     // Blob name.
; 4056 : 
; 4057 :    //
; 4058 :    // Following are DB-specific types.
; 4059 :    //
; 4060 : 
; 4061 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4062 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4063 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Memo" );
; 4064 : 
; 4065 : #elif defined( DB2 )
; 4066 : 
; 4067 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4068 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4069 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Blob" );
; 4070 : 
; 4071 :    //
; 4072 :    // Following are DB-specific types.
; 4073 :    //
; 4074 : 
; 4075 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4076 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4077 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "CLOB" );
; 4078 : 
; 4079 : #elif defined( SQLBASE ) || defined( ODBC )
; 4080 : 
; 4081 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4082 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4083 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4084 :                            "Blob (VarChar)" );     // Blob name.
; 4085 : 
; 4086 :    //
; 4087 :    // Following are DB-specific types.
; 4088 :    //
; 4089 : 
; 4090 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4091 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4092 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "VarChar" );
; 4093 : 
; 4094 : #elif defined( MYSQL )
; 4095 : 
; 4096 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4097 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );

	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4098 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4099 :                            "Blob (longblob)" );       // Blob name.

	push	OFFSET FLAT:??_C@_0BA@IMGI@Blob?5?$CIlongblob?$CJ?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4100 : 
; 4101 :    //
; 4102 :    // Following are DB-specific types.
; 4103 :    //
; 4104 : 
; 4105 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4106 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );

	push	OFFSET FLAT:??_C@_01PDMC@V?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4107 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Text (longtext)" );

	push	OFFSET FLAT:??_C@_0BA@NGGL@Text?5?$CIlongtext?$CJ?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4108 : 
; 4109 : #elif defined( POSTGRESQL ) || defined( SQLSERVER )
; 4110 : 
; 4111 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4112 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4113 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4114 :                            "Blob (bytea)" );       // Blob name.
; 4115 : 
; 4116 :    //
; 4117 :    // Following are DB-specific types.
; 4118 :    //
; 4119 : 
; 4120 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4121 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4122 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Text" );
; 4123 : 
; 4124 : #endif
; 4125 : 
; 4126 :    return( 0 );

	xor	ax, ax

; 4127 : 
; 4128 : } // LoadDataTypes

	pop	ebp
	ret	4
_LoadDataTypes@4 ENDP
_TEXT	ENDS
PUBLIC	_SetDataType@8
PUBLIC	??_C@_06CDGA@Domain?$AA@			; `string'
PUBLIC	??_C@_03LBCJ@Lth?$AA@				; `string'
PUBLIC	??_C@_0N@IKDH@ER_Attribute?$AA@			; `string'
PUBLIC	??_C@_0N@FPPC@MaxStringLth?$AA@			; `string'
PUBLIC	??_C@_0CD@CCFO@?$CITE?$CJ?5Invalid?5Physical?5Data?5type?5@ ; `string'
PUBLIC	??_C@_0BM@EEGE@Invalid?5Physical?5Data?5type?4?$AA@ ; `string'
PUBLIC	??_C@_09PLDP@Zeidon?5TE?$AA@			; `string'
EXTRN	_SetAttributeFromInteger@16:NEAR
EXTRN	_SetAttributeFromAttribute@24:NEAR
EXTRN	_TraceLineS@8:NEAR
EXTRN	__imp___stricmp:NEAR
;	COMDAT ??_C@_06CDGA@Domain?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_06CDGA@Domain?$AA@ DB 'Domain', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03LBCJ@Lth?$AA@
_DATA	SEGMENT
??_C@_03LBCJ@Lth?$AA@ DB 'Lth', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@IKDH@ER_Attribute?$AA@
_DATA	SEGMENT
??_C@_0N@IKDH@ER_Attribute?$AA@ DB 'ER_Attribute', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@FPPC@MaxStringLth?$AA@
_DATA	SEGMENT
??_C@_0N@FPPC@MaxStringLth?$AA@ DB 'MaxStringLth', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@CCFO@?$CITE?$CJ?5Invalid?5Physical?5Data?5type?5@
_DATA	SEGMENT
??_C@_0CD@CCFO@?$CITE?$CJ?5Invalid?5Physical?5Data?5type?5@ DB '(TE) Inva'
	DB	'lid Physical Data type = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@EEGE@Invalid?5Physical?5Data?5type?4?$AA@
_DATA	SEGMENT
??_C@_0BM@EEGE@Invalid?5Physical?5Data?5type?4?$AA@ DB 'Invalid Physical '
	DB	'Data type.', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_09PLDP@Zeidon?5TE?$AA@
_DATA	SEGMENT
??_C@_09PLDP@Zeidon?5TE?$AA@ DB 'Zeidon TE', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_bSetDefault$ = 12
_pchDataType$ = -8
_lLth$ = -4
_bTimestampAsString$ = -12
_pchDomainName$31606 = -16
_vTZTEDBLO$31607 = -20
_vTZDBHODO$31608 = -28
_vDBH_Data$31609 = -24
_szDBH_DataObjectName$31610 = -64
_SetDataType@8 PROC NEAR

; 4150 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 4151 :    zPCHAR pchDataType;
; 4152 :    zLONG  lLth;
; 4153 :    zBOOL  bTimestampAsString = FALSE;

	mov	BYTE PTR _bTimestampAsString$[ebp], 0

; 4154 : 
; 4155 :    if ( bSetDefault )

	mov	eax, DWORD PTR _bSetDefault$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L31624

; 4157 :       zPCHAR pchDomainName;
; 4158 :       zVIEW  vTZTEDBLO;
; 4159 :       zVIEW  vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$31608[ebp], 0

; 4160 :       zVIEW  vDBH_Data = 0;

	mov	DWORD PTR _vDBH_Data$31609[ebp], 0

; 4161 :       zCHAR  szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 4162 : 
; 4163 :       // If it exists get the object that defines the dbhandler type.
; 4164 :       GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );  // vDTE added dks 2009.11.11

	push	2
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	edx, DWORD PTR _vTZTEDBLO$31607[ebp]
	push	edx
	call	_GetViewByName@16

; 4165 :       if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$31607[ebp], 0
	je	SHORT $L31611

; 4166 :          SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 4167 :                                      vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZTEDBLO$31607[ebp]
	push	ecx
	call	_SetCursorFirstEntityByAttr@28
$L31611:

; 4168 : 
; 4169 :       // Try to get the OI that contains DBH-specific data.
; 4170 :       SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 4171 :                       "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDBH_DataObjectName$31610[ebp]
	push	ecx
	lea	edx, DWORD PTR _vDBH_Data$31609[ebp]
	push	edx
	call	_SetOI_FromBlob@28

; 4172 : 
; 4173 :       #if defined( ACCESS ) || defined( ODBC )
; 4174 : 
; 4175 :          // Try to get the ODBC definition.
; 4176 :          SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 4177 :                          "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 4178 : 
; 4179 :          // Check to see if there is DBH data set in the TE.
; 4180 :          if ( vDBH_Data )
; 4181 :          {
; 4182 :             bTimestampAsString =
; 4183 :                          ( CompareAttributeToString( vDBH_Data, "ODBC",
; 4184 :                                                      "TimestampAsString",
; 4185 :                                                      "Y" ) == 0 );
; 4186 :          }
; 4187 :          else
; 4188 :          // Check to see if there is DBH data set in the DB List object.
; 4189 :          if ( vTZDBHODO )
; 4190 :          {
; 4191 :                bTimestampAsString =
; 4192 :                          ( CompareAttributeToString( vTZDBHODO, "ODBC",
; 4193 :                                                      "TimestampAsString",
; 4194 :                                                      "Y" ) == 0 );
; 4195 :          }
; 4196 : 
; 4197 :       #endif
; 4198 : 
; 4199 :       // Set the default data type from the ER attribute domain.  If the
; 4200 :       // domain name is "Date" or "Time" then use SqlBase date/time types.
; 4201 :       GetAddrForAttribute( &pchDomainName, vDTE, "Domain", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDomainName$31606[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4202 : 
; 4203 : #if defined( SQLSERVER ) && !defined( QUINSOFT )
; 4204 :       if ( zstrcmpi( pchDomainName, "Date" ) == 0 ||
; 4205 :            zstrcmpi( pchDomainName, "Time" ) == 0 )
; 4206 :       {
; 4207 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "T" );
; 4208 :       }
; 4209 :       else
; 4210 :       if ( zstrcmpi( pchDomainName, "TimeStampEx" ) == 0 )
; 4211 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "X" );
; 4212 :       else
; 4213 :          // Domain is not Date or Time, so just set the default data type the
; 4214 :          // same as the domain's data type.
; 4215 :          SetAttributeFromAttribute( vDTE, "TE_FieldDataRel", "DataType",
; 4216 :                                     vDTE, "Domain", "DataType" );
; 4217 : #else
; 4218 :       if ( zstrcmpi( pchDomainName, "Date" ) == 0 )

	push	OFFSET FLAT:??_C@_04OMLL@Date?$AA@	; `string'
	mov	edx, DWORD PTR _pchDomainName$31606[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L31613

; 4219 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "D" );

	push	OFFSET FLAT:??_C@_01PJM@D?$AA@		; `string'
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 4220 :       else

	jmp	$L31618
$L31613:

; 4221 :       if ( zstrcmpi( pchDomainName, "Time" ) == 0 )

	push	OFFSET FLAT:??_C@_04OAHI@Time?$AA@	; `string'
	mov	ecx, DWORD PTR _pchDomainName$31606[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L31615

; 4222 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "I" );

	push	OFFSET FLAT:??_C@_01FLOP@I?$AA@		; `string'
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4223 :       else

	jmp	SHORT $L31618
$L31615:

; 4224 :       if ( zstrcmpi( pchDomainName, "TimeStampEx" ) == 0 )

	push	OFFSET FLAT:??_C@_0M@BADB@TimeStampEx?$AA@ ; `string'
	mov	eax, DWORD PTR _pchDomainName$31606[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L31617

; 4225 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "X" );

	push	OFFSET FLAT:??_C@_01FIAI@X?$AA@		; `string'
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4226 :       else

	jmp	SHORT $L31618
$L31617:

; 4227 :          // Domain is not Date or Time, so just set the default data type the
; 4228 :          // same as the domain's data type.
; 4229 :          SetAttributeFromAttribute( vDTE, "TE_FieldDataRel", "DataType",
; 4230 :                                     vDTE, "Domain", "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromAttribute@24
$L31618:

; 4231 : #endif
; 4232 : 
; 4233 :       // Strings with a length > 254 must have a data type of VarChar.
; 4234 :       GetAddrForAttribute( &pchDataType, vDTE, "Domain", "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchDataType$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 4235 :       if ( pchDataType[ 0 ] == zTYPE_STRING )

	mov	eax, DWORD PTR _pchDataType$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $L31624

; 4237 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );

	push	OFFSET FLAT:??_C@_03LBCJ@Lth?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@IKDH@ER_Attribute?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _lLth$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 4238 :          if ( lLth == 0  )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $L31622

; 4239 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );

	push	OFFSET FLAT:??_C@_0N@FPPC@MaxStringLth?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lLth$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16
$L31622:

; 4240 : 
; 4241 :          if ( lLth > MAX_LTH_FOR_STRING )

	cmp	DWORD PTR _lLth$[ebp], 254		; 000000feH
	jle	SHORT $L31624

; 4242 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "V" );

	push	OFFSET FLAT:??_C@_01PDMC@V?$AA@		; `string'
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$L31624:

; 4250 : 
; 4251 :    // Get the data type.
; 4252 :    GetAddrForAttribute( &pchDataType, vDTE, "TE_FieldDataRel", "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchDataType$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 4253 : 
; 4254 :    // Now set the length according to the physical data type.
; 4255 :    switch ( pchDataType[ 0 ] )
; 4256 :    {

	mov	eax, DWORD PTR _pchDataType$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR -68+[ebp], ecx
	mov	edx, DWORD PTR -68+[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR -68+[ebp], edx
	cmp	DWORD PTR -68+[ebp], 22			; 00000016H
	ja	$L31648
	mov	ecx, DWORD PTR -68+[ebp]
	xor	eax, eax
	mov	al, BYTE PTR $L32330[ecx]
	jmp	DWORD PTR $L32331[eax*4]
$L31629:

; 4257 : 
; 4258 :       case zTYPE_STRING:
; 4259 :       case 'V':
; 4260 :       case zTYPE_FIXEDCHAR:
; 4261 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );

	push	OFFSET FLAT:??_C@_03LBCJ@Lth?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@IKDH@ER_Attribute?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _lLth$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 4262 :          if ( lLth == 0  )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $L31630

; 4263 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );

	push	OFFSET FLAT:??_C@_0N@FPPC@MaxStringLth?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lLth$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16
$L31630:

; 4264 : 
; 4265 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", lLth );

	mov	eax, DWORD PTR _lLth$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4266 :          break;

	jmp	$L31626
$L31631:

; 4267 : 
; 4268 :       case zTYPE_BLOB:
; 4269 : 
; 4270 : #if defined( DB2 )
; 4271 :          // DB2 needs a blob length.
; 4272 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );
; 4273 :          if ( lLth == 0  )
; 4274 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );
; 4275 : 
; 4276 :          if ( lLth == 0  )
; 4277 :             lLth = 65536;   // Default length for blobs.
; 4278 : 
; 4279 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", lLth );
; 4280 : #else
; 4281 :          SetAttributeFromAttribute( vDTE, "TE_FieldDataRel", "Length",
; 4282 :                                     vDTE, "ER_Attribute",    "Lth" );

	push	OFFSET FLAT:??_C@_03LBCJ@Lth?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@IKDH@ER_Attribute?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromAttribute@24

; 4283 : #endif
; 4284 : 
; 4285 :          break;

	jmp	$L31626
$L31632:

; 4286 : 
; 4287 :       case zTYPE_INTEGER:
; 4288 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 4 );

	push	4
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4289 :          break;

	jmp	$L31626
$L31633:

; 4290 : 
; 4291 :       case zTYPE_DECIMAL:
; 4292 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );

	push	OFFSET FLAT:??_C@_03LBCJ@Lth?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@IKDH@ER_Attribute?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _lLth$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 4293 :          if ( lLth == 0  )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $L31635

; 4295 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );

	push	OFFSET FLAT:??_C@_0N@FPPC@MaxStringLth?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lLth$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 4296 :             if ( lLth == 0 )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $L31635

; 4297 :                lLth = sizeof( zDECIMAL );

	mov	DWORD PTR _lLth$[ebp], 40		; 00000028H
$L31635:

; 4299 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", lLth );

	mov	eax, DWORD PTR _lLth$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4300 :          break;

	jmp	$L31626
$L31637:

; 4301 : 
; 4302 :       case zTYPE_DATETIME:
; 4303 :       case zTYPE_TIME:
; 4304 :          if ( bTimestampAsString )

	mov	edx, DWORD PTR _bTimestampAsString$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L31638

; 4306 :             // This is only true when we are setting the default value of the
; 4307 :             // data type.  Change the datatype to be a string.
; 4308 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "S" );

	push	OFFSET FLAT:??_C@_01PDAJ@S?$AA@		; `string'
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 4309 :             SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 25 );

	push	25					; 00000019H
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4311 :          else

	jmp	SHORT $L31641
$L31638:

; 4313 :             switch ( pchDataType[ 0 ] )
; 4314 :             {

	mov	edx, DWORD PTR _pchDataType$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR -72+[ebp], al
	cmp	BYTE PTR -72+[ebp], 73			; 00000049H
	je	SHORT $L31645
	cmp	BYTE PTR -72+[ebp], 84			; 00000054H
	je	SHORT $L31644
	jmp	SHORT $L31641
$L31644:

; 4315 :                case zTYPE_DATETIME:
; 4316 :                   SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 4 );

	push	4
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4317 :                   break;

	jmp	SHORT $L31641
$L31645:

; 4318 : 
; 4319 :                case zTYPE_TIME:
; 4320 :                   SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 8 );

	push	8
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16
$L31641:

; 4324 : 
; 4325 :          break;

	jmp	SHORT $L31626
$L31646:

; 4326 : 
; 4327 :       case zTYPE_DATE:
; 4328 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 4 );

	push	4
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 4329 :          break;

	jmp	SHORT $L31626
$L31647:

; 4330 : 
; 4331 :       case 'X':
; 4332 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 30 );

	push	30					; 0000001eH
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4333 :          break;

	jmp	SHORT $L31626
$L31648:

; 4334 : 
; 4335 :       default:
; 4336 :          TraceLineS( "(TE) Invalid Physical Data type = ", pchDataType );

	mov	edx, DWORD PTR _pchDataType$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CD@CCFO@?$CITE?$CJ?5Invalid?5Physical?5Data?5type?5@ ; `string'
	call	_TraceLineS@8

; 4337 :          SysMessageBox( vDTE, "Zeidon TE", "Invalid Physical Data type.", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0BM@EEGE@Invalid?5Physical?5Data?5type?4?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09PLDP@Zeidon?5TE?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysMessageBox@16

; 4338 :          return( 0 );

	xor	ax, ax
	jmp	SHORT $L31601
$L31626:

; 4340 : 
; 4341 :    return( 0 );

	xor	ax, ax
$L31601:

; 4342 : 
; 4343 : } // SetDataType

	mov	esp, ebp
	pop	ebp
	ret	8
$L32331:
	DD	$L31631
	DD	$L31646
	DD	$L31629
	DD	$L31637
	DD	$L31632
	DD	$L31633
	DD	$L31647
	DD	$L31648
$L32330:
	DB	0
	DB	7
	DB	1
	DB	7
	DB	2
	DB	7
	DB	7
	DB	3
	DB	7
	DB	7
	DB	4
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	2
	DB	3
	DB	7
	DB	2
	DB	7
	DB	6
_SetDataType@8 ENDP
_TEXT	ENDS
PUBLIC	_fnChangeReservedName@4
PUBLIC	??_C@_02IALC@z_?$AA@				; `string'
;	COMDAT ??_C@_02IALC@z_?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_02IALC@z_?$AA@ DB 'z_', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchName$ = 8
_k$ = -8
_j$ = -4
_szTemp$31662 = -108
_fnChangeReservedName@4 PROC NEAR

; 4348 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	edi

; 4349 :    zSHORT   k, j;
; 4350 : 
; 4351 :    // List of reserved names is terminated by a empty string.
; 4352 :    for ( k = 0; szReservedName[ k ][ 0 ]; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L31658
$L31659:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L31658:
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _szReservedName[ecx*4]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L31660

; 4354 :       j = zstrcmpi( szReservedName[ k ], pchName );

	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _szReservedName[edx*4]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _j$[ebp], ax

; 4355 :       if ( j == 0 )

	movsx	ecx, WORD PTR _j$[ebp]
	test	ecx, ecx
	jne	SHORT $L31661

; 4357 :          zCHAR szTemp[ 100 ] = "z_";

	mov	dx, WORD PTR ??_C@_02IALC@z_?$AA@
	mov	WORD PTR _szTemp$31662[ebp], dx
	mov	al, BYTE PTR ??_C@_02IALC@z_?$AA@+2
	mov	BYTE PTR _szTemp$31662[ebp+2], al
	mov	ecx, 24					; 00000018H
	xor	eax, eax
	lea	edi, DWORD PTR _szTemp$31662[ebp+3]
	rep stosd
	stosb

; 4358 : 
; 4359 :          // Since we know that all the reserved words are at least 2 chars
; 4360 :          // shorter then the max column/table length, then don't worry about
; 4361 :          // compressing the name.
; 4362 :          zstrcat( szTemp, pchName );

	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTemp$31662[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4363 :          zstrcpy( pchName, szTemp );

	lea	eax, DWORD PTR _szTemp$31662[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 4364 :          return;

	jmp	SHORT $L31660
$L31661:

; 4366 : 
; 4367 :       // Reserved words are listed in alphabetical order.  If the compare
; 4368 :       // returned a value greater than 0, then pchName comes before the current
; 4369 :       // szReservedName, which means there cannot be a match.
; 4370 :       if ( j > 0 )

	movsx	edx, WORD PTR _j$[ebp]
	test	edx, edx
	jle	SHORT $L31664

; 4371 :          return;

	jmp	SHORT $L31660
$L31664:

; 4372 :    }

	jmp	$L31659
$L31660:

; 4373 : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	4
_fnChangeReservedName@4 ENDP
_TEXT	ENDS
PUBLIC	_GenerateName@12
PUBLIC	??_C@_02IKBN@B_?$AA@				; `string'
PUBLIC	??_C@_02IPGJ@Bc?$AA@				; `string'
EXTRN	_SysTranslateString@8:NEAR
EXTRN	__imp____mb_cur_max:DWORD
EXTRN	__imp___pctype:DWORD
EXTRN	__imp___isctype:NEAR
_BSS	SEGMENT
_?nNameCount@?1??GenerateName@@9@9 DW 01H DUP (?)
	ALIGN	4

_?nMaxLth@?1??GenerateName@@9@9 DW 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_02IKBN@B_?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_02IKBN@B_?$AA@ DB 'B_', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02IPGJ@Bc?$AA@
_DATA	SEGMENT
??_C@_02IPGJ@Bc?$AA@ DB 'Bc', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_pchName$ = 12
_cMetaType$ = 16
_vDBH_Data$ = -4
_szDBH_DataObjectName$ = -40
_pch1$ = -48
_pch2$ = -52
_l$ = -44
_nLth$31700 = -56
_GenerateName@12 PROC NEAR

; 4399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 4400 :    static zSHORT nNameCount;   // Used to keep track of duplicate names.
; 4401 :    static zSHORT nMaxLth;      // Used to keep track of duplicate names.
; 4402 : 
; 4403 :    zVIEW  vDBH_Data = 0;

	mov	DWORD PTR _vDBH_Data$[ebp], 0

; 4404 :    zCHAR  szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 4405 :    zPCHAR pch1;
; 4406 :    zPCHAR pch2;
; 4407 :    zLONG  l;
; 4408 : 
; 4409 :    // Try to get the OI that contains DBH-specific data.
; 4410 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 4411 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 4412 : 
; 4413 :    // Eliminate invalid chars.
; 4414 :    for ( pch1 = pch2 = pchName; *pch2; pch2++ )

	mov	ecx, DWORD PTR _pchName$[ebp]
	mov	DWORD PTR _pch2$[ebp], ecx
	mov	edx, DWORD PTR _pch2$[ebp]
	mov	DWORD PTR _pch1$[ebp], edx
	jmp	SHORT $L31682
$L31683:
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax
$L31682:
	mov	ecx, DWORD PTR _pch2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L31684

; 4416 :       // Even though SQLBase allows '@', '#', and '$' we don't generate them.
; 4417 :       if ( zisalnum( *pch2 ) || *pch2 == '_' )

	mov	eax, DWORD PTR __imp____mb_cur_max
	cmp	DWORD PTR [eax], 1
	jle	SHORT $L32334
	push	263					; 00000107H
	mov	ecx, DWORD PTR _pch2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp___isctype
	add	esp, 8
	mov	DWORD PTR -60+[ebp], eax
	jmp	SHORT $L32335
$L32334:
	mov	eax, DWORD PTR _pch2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR __imp___pctype
	mov	eax, DWORD PTR [edx]
	xor	edx, edx
	mov	dx, WORD PTR [eax+ecx*2]
	and	edx, 263				; 00000107H
	mov	DWORD PTR -60+[ebp], edx
$L32335:
	cmp	DWORD PTR -60+[ebp], 0
	jne	SHORT $L31686
	mov	eax, DWORD PTR _pch2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	jne	SHORT $L31685
$L31686:

; 4418 :          *pch1++ = *pch2;  // Copy valid char.

	mov	edx, DWORD PTR _pch1$[ebp]
	mov	eax, DWORD PTR _pch2$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch1$[ebp], edx
$L31685:

; 4419 :    }

	jmp	SHORT $L31683
$L31684:

; 4420 : 
; 4421 :    // Null-terminate string.
; 4422 :    pch1[ 0 ] = 0;

	mov	eax, DWORD PTR _pch1$[ebp]
	mov	BYTE PTR [eax], 0

; 4423 : 
; 4424 :    switch ( cMetaType )
; 4425 :    {

	mov	cl, BYTE PTR _cMetaType$[ebp]
	mov	BYTE PTR -64+[ebp], cl
	cmp	BYTE PTR -64+[ebp], 65			; 00000041H
	je	SHORT $L31695
	cmp	BYTE PTR -64+[ebp], 69			; 00000045H
	je	SHORT $L31691
	cmp	BYTE PTR -64+[ebp], 88			; 00000058H
	je	$L31699
	jmp	$L31688
$L31691:

; 4426 :       case 'E':      // Meta type is Entity
; 4427 :          nNameCount = 1;

	mov	WORD PTR _?nNameCount@?1??GenerateName@@9@9, 1

; 4428 : 
; 4429 :          // Try getting the max length from the DBH-Specific OI.  If one is
; 4430 :          // not specified use the default length.
; 4431 :          if ( vDBH_Data &&
; 4432 :               GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 4433 :                                        "MaxTableNameLength" ) != -1 )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31692
	push	OFFSET FLAT:??_C@_0BD@KOPE@MaxTableNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $L31692

; 4435 :             nMaxLth = (zSHORT) l;

	mov	dx, WORD PTR _l$[ebp]
	mov	WORD PTR _?nMaxLth@?1??GenerateName@@9@9, dx

; 4437 :          else

	jmp	SHORT $L31694
$L31692:

; 4438 :             nMaxLth = MAX_TABLENAME_LTH;

	mov	WORD PTR _?nMaxLth@?1??GenerateName@@9@9, 30 ; 0000001eH
$L31694:

; 4439 : 
; 4440 :          break;

	jmp	$L31688
$L31695:

; 4441 : 
; 4442 :       case 'A':      // Meta type is Attribute
; 4443 :          nNameCount = 1;

	mov	WORD PTR _?nNameCount@?1??GenerateName@@9@9, 1

; 4444 : 
; 4445 :          // Try getting the max length from the DBH-Specific OI.  If one is
; 4446 :          // not specified use the default length.
; 4447 :          if ( vDBH_Data &&
; 4448 :               GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 4449 :                                        "MaxColumnNameLength" ) != -1 )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31696
	push	OFFSET FLAT:??_C@_0BE@GNCH@MaxColumnNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16
	movsx	edx, ax
	cmp	edx, -1
	je	SHORT $L31696

; 4451 :             nMaxLth = (zSHORT) l;

	mov	ax, WORD PTR _l$[ebp]
	mov	WORD PTR _?nMaxLth@?1??GenerateName@@9@9, ax

; 4453 :          else

	jmp	SHORT $L31698
$L31696:

; 4454 :             nMaxLth = MAX_COLUMNNAME_LTH;

	mov	WORD PTR _?nMaxLth@?1??GenerateName@@9@9, 18 ; 00000012H
$L31698:

; 4455 : 
; 4456 :          break;

	jmp	$L31688
$L31699:

; 4460 :          zSHORT nLth;
; 4461 : 
; 4462 :          // When generating new names, we just tack on an incrementing
; 4463 :          // number.  For example, "ColName" becomes "ColName02", "ColName02"
; 4464 :          // becomes "ColName03", etc.
; 4465 : 
; 4466 :          nNameCount++;

	mov	cx, WORD PTR _?nNameCount@?1??GenerateName@@9@9
	add	cx, 1
	mov	WORD PTR _?nNameCount@?1??GenerateName@@9@9, cx

; 4467 :          nLth = zstrlen( pchName );

	mov	edx, DWORD PTR _pchName$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$31700[ebp], ax

; 4468 :          if ( nNameCount > 2 )

	movsx	eax, WORD PTR _?nNameCount@?1??GenerateName@@9@9
	cmp	eax, 2
	jle	SHORT $L31701

; 4469 :             nLth = nLth - 2;

	movsx	ecx, WORD PTR _nLth$31700[ebp]
	sub	ecx, 2
	mov	WORD PTR _nLth$31700[ebp], cx

; 4470 :          else

	jmp	SHORT $L31703
$L31701:

; 4471 :          if ( nLth > nMaxLth - 2 )

	movsx	edx, WORD PTR _nLth$31700[ebp]
	movsx	eax, WORD PTR _?nMaxLth@?1??GenerateName@@9@9
	sub	eax, 2
	cmp	edx, eax
	jle	SHORT $L31703

; 4472 :             nLth = nMaxLth - 2;

	movsx	ecx, WORD PTR _?nMaxLth@?1??GenerateName@@9@9
	sub	ecx, 2
	mov	WORD PTR _nLth$31700[ebp], cx
$L31703:

; 4473 : 
; 4474 :          zsprintf( pchName + nLth, "%02d", nNameCount );

	movsx	edx, WORD PTR _?nNameCount@?1??GenerateName@@9@9
	push	edx
	push	OFFSET FLAT:??_C@_04LGDF@?$CF02d?$AA@	; `string'
	movsx	eax, WORD PTR _nLth$31700[ebp]
	mov	ecx, DWORD PTR _pchName$[ebp]
	add	ecx, eax
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 4475 : 
; 4476 :          // We know name is short enough and no reserved words contain numbers
; 4477 :          // so just return.
; 4478 :          return( 0 );

	xor	ax, ax
	jmp	SHORT $L31672
$L31688:

; 4481 : 
; 4482 :    if ( nMaxLth >= BUFF_SIZE )

	movsx	edx, WORD PTR _?nMaxLth@?1??GenerateName@@9@9
	cmp	edx, 256				; 00000100H
	jl	SHORT $L31704

; 4483 :       nMaxLth = BUFF_SIZE - 1;

	mov	WORD PTR _?nMaxLth@?1??GenerateName@@9@9, 255 ; 000000ffH
$L31704:

; 4484 : 
; 4485 :    // Compress the name if it needs it.
; 4486 :    UfCompressName( pchName,   // Original name.
; 4487 :                    pchName,   // New (shorter) name.
; 4488 :                    nMaxLth,   // Max length of string.
; 4489 :                    "",        // Remove embedded spaces.
; 4490 :                    "",        // Ignore '_' (for now).
; 4491 :                    "Bc",      // Remove lower-case vowels starting from back.
; 4492 :                    "B_",      // Remove '_' starting from back.
; 4493 :                    0 );       // Stop when the name is short enough.

	push	0
	push	OFFSET FLAT:??_C@_02IKBN@B_?$AA@	; `string'
	push	OFFSET FLAT:??_C@_02IPGJ@Bc?$AA@	; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ax, WORD PTR _?nMaxLth@?1??GenerateName@@9@9
	push	eax
	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchName$[ebp]
	push	edx
	call	_UfCompressName@32

; 4494 : 
; 4495 :    // Change string to all upper-case.
; 4496 :    SysTranslateString( pchName, 'U' );

	push	85					; 00000055H
	mov	eax, DWORD PTR _pchName$[ebp]
	push	eax
	call	_SysTranslateString@8

; 4497 : 
; 4498 :    // Make sure generated name doesn't match a reserved word.
; 4499 :    fnChangeReservedName( pchName );

	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	call	_fnChangeReservedName@4

; 4500 : 
; 4501 :    return( 0 );

	xor	ax, ax
$L31672:

; 4502 : 
; 4503 : } // GenerateName

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_GenerateName@12 ENDP
_TEXT	ENDS
PUBLIC	_fnSortDataFields@4
PUBLIC	??_C@_0L@PPLE@DATARECORD?$AA@			; `string'
PUBLIC	??_C@_0M@PNOD@CHILDENTITY?$AA@			; `string'
PUBLIC	??_C@_09JEIA@DATAFIELD?$AA@			; `string'
PUBLIC	??_C@_07MPNE@FLDTYPE?$AA@			; `string'
PUBLIC	??_C@_0L@CDIB@XVAATT_TOK?$AA@			; `string'
PUBLIC	??_C@_06BLIJ@ATTRIB?$AA@			; `string'
EXTRN	_SetViewFromView@8:NEAR
EXTRN	_SetViewToSubobject@8:NEAR
EXTRN	_MoveSubobject@24:NEAR
EXTRN	_SetCursorPrevEntity@12:NEAR
EXTRN	_SetCursorLastEntity@12:NEAR
EXTRN	_SetCursorAbsolutePosition@12:NEAR
EXTRN	_GetAbsolutePositionForEntity@12:NEAR
EXTRN	_DefineHierarchicalCursor@8:NEAR
EXTRN	_DropHierarchicalCursor@4:NEAR
EXTRN	_SetCursorNextEntityHierarchical@12:NEAR
;	COMDAT ??_C@_0L@PPLE@DATARECORD?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0L@PPLE@DATARECORD?$AA@ DB 'DATARECORD', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@PNOD@CHILDENTITY?$AA@
_DATA	SEGMENT
??_C@_0M@PNOD@CHILDENTITY?$AA@ DB 'CHILDENTITY', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JEIA@DATAFIELD?$AA@
_DATA	SEGMENT
??_C@_09JEIA@DATAFIELD?$AA@ DB 'DATAFIELD', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MPNE@FLDTYPE?$AA@
_DATA	SEGMENT
??_C@_07MPNE@FLDTYPE?$AA@ DB 'FLDTYPE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@CDIB@XVAATT_TOK?$AA@
_DATA	SEGMENT
??_C@_0L@CDIB@XVAATT_TOK?$AA@ DB 'XVAATT_TOK', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06BLIJ@ATTRIB?$AA@
_DATA	SEGMENT
??_C@_06BLIJ@ATTRIB?$AA@ DB 'ATTRIB', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vTZZOXODO$ = 8
_usReturnLevel$ = -52
_nRC$ = -48
_szEntityName$ = -44
_vXOD$ = -4
_vXOD2$ = -8
_lPos$31721 = -56
_fnSortDataFields@4 PROC NEAR

; 6361 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 6362 :    zUSHORT usReturnLevel;
; 6363 :    zSHORT  nRC;
; 6364 :    zCHAR   szEntityName[ 33 ];
; 6365 :    zVIEW   vXOD;
; 6366 :    zVIEW   vXOD2;
; 6367 : 
; 6368 :    // If there is no DATARECORD for the root entity then there is nothing
; 6369 :    // to do (this LOD has no physical info).
; 6370 :    if ( CheckExistenceOfEntity( vTZZOXODO, "DATARECORD" ) != zCURSOR_SET )

	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L31716

; 6371 :       return( 0 );

	xor	ax, ax
	jmp	$L31710
$L31716:

; 6372 : 
; 6373 :    CreateViewFromViewForTask( &vTZZOXODO, vTZZOXODO, 0 );

	push	0
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	lea	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 6374 :    CreateViewFromViewForTask( &vXOD, vTZZOXODO, 0 );

	push	0
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 6375 :    CreateViewFromViewForTask( &vXOD2, vTZZOXODO, 0 );

	push	0
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 6376 : 
; 6377 :    // Initialize DATARECORD into szEntityName so that we reference the first
; 6378 :    // ENTITY.
; 6379 :    zstrcpy( szEntityName, "DATARECORD" );

	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 6380 : 
; 6381 :    for ( nRC = DefineHierarchicalCursor( vTZZOXODO, "DATARECORD" );
; 6382 :          nRC >= zCURSOR_SET;
; 6383 :          nRC = SetCursorNextEntityHierarchical( &usReturnLevel,
; 6384 :                                                 szEntityName, vTZZOXODO ) )

	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_DefineHierarchicalCursor@8
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31718
$L31719:
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	lea	eax, DWORD PTR _usReturnLevel$[ebp]
	push	eax
	call	_SetCursorNextEntityHierarchical@12
	mov	WORD PTR _nRC$[ebp], ax
$L31718:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31720

; 6386 :       zLONG lPos;
; 6387 : 
; 6388 :       if ( nRC == zCURSOR_SET_RECURSIVECHILD )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 2
	jne	SHORT $L31722

; 6389 :          SetViewToSubobject( vTZZOXODO, "CHILDENTITY" );

	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_SetViewToSubobject@8
$L31722:

; 6390 : 
; 6391 :       if ( zstrcmp( szEntityName, "DATARECORD" ) != 0 )

	movsx	ecx, BYTE PTR _szEntityName$[ebp]
	movsx	edx, BYTE PTR ??_C@_0L@PPLE@DATARECORD?$AA@
	cmp	ecx, edx
	jne	SHORT $L32337
	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -60+[ebp], eax
	jmp	SHORT $L32338
$L32337:
	movsx	ecx, BYTE PTR _szEntityName$[ebp]
	movsx	edx, BYTE PTR ??_C@_0L@PPLE@DATARECORD?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -60+[ebp], eax
$L32338:
	cmp	DWORD PTR -60+[ebp], 0
	je	SHORT $L31730

; 6392 :          continue;

	jmp	$L31719
$L31730:

; 6393 : 
; 6394 :       GetAbsolutePositionForEntity( &lPos, vTZZOXODO, "DATARECORD" );

	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lPos$31721[ebp]
	push	edx
	call	_GetAbsolutePositionForEntity@12

; 6395 :       SetCursorAbsolutePosition( szEntityName, vXOD, lPos );

	mov	eax, DWORD PTR _lPos$31721[ebp]
	push	eax
	mov	ecx, DWORD PTR _vXOD$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	call	_SetCursorAbsolutePosition@12

; 6396 : 
; 6397 :       // Move blob fields to the end.  We'll start at the end and go back
; 6398 :       // to the beginning. We'll skip the very last entity since it's already
; 6399 :       // last.
; 6400 :       SetCursorLastEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorLastEntity@12

; 6401 :       nRC = SetCursorPrevEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	ecx, DWORD PTR _vXOD$[ebp]
	push	ecx
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31733:

; 6402 :       while ( nRC >= zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L31734

; 6404 :          SetViewFromView( vXOD2, vXOD );

	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_SetViewFromView@8

; 6405 :          nRC = SetCursorPrevEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 6406 : 
; 6407 :          if ( CompareAttributeToString( vXOD2, "DATAFIELD", "FLDTYPE",
; 6408 :                                         "V" ) == 0 ||
; 6409 :               CompareAttributeToString( vXOD2, "DATAFIELD", "FLDTYPE",
; 6410 :                                         "B" ) == 0 )

	push	OFFSET FLAT:??_C@_01PDMC@V?$AA@		; `string'
	push	OFFSET FLAT:??_C@_07MPNE@FLDTYPE?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD2$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L31736
	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_07MPNE@FLDTYPE?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	edx, DWORD PTR _vXOD2$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L31735
$L31736:

; 6412 :             // Move current DATAFIELD to the end.
; 6413 :             MoveSubobject( vXOD2, "DATAFIELD", vXOD2, "DATAFIELD",
; 6414 :                            zPOS_LAST, zREPOS_PREV );

	push	4
	push	2
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	edx, DWORD PTR _vXOD2$[ebp]
	push	edx
	call	_MoveSubobject@24
$L31735:

; 6416 :       }

	jmp	$L31733
$L31734:

; 6417 : 
; 6418 :       // Move Keys fields to the beginning.  We'll start at the end and go back
; 6419 :       // to the beginning. We'll skip the very first entity since it's already
; 6420 :       // first.
; 6421 :       SetViewFromView( vXOD2, vXOD );

	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_SetViewFromView@8

; 6422 :       SetCursorFirstEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12

; 6423 :       nRC = SetCursorNextEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31740:

; 6424 :       while ( nRC >= zCURSOR_SET )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31741

; 6426 :          // Find the correct ATTRIB entity.
; 6427 :          SetCursorFirstEntityByAttr( vXOD, "ATTRIB", "XVAATT_TOK",
; 6428 :                                      vXOD, "DATAFIELD", "XVAATT_TOK", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@CDIB@XVAATT_TOK?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@CDIB@XVAATT_TOK?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06BLIJ@ATTRIB?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorFirstEntityByAttr@28

; 6429 : 
; 6430 :          SetViewFromView( vXOD2, vXOD );

	mov	ecx, DWORD PTR _vXOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vXOD2$[ebp]
	push	edx
	call	_SetViewFromView@8

; 6431 :          nRC = SetCursorNextEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 6432 : 
; 6433 :          // If the attribute is a key move it to the beginning.
; 6434 :          if ( CompareAttributeToString( vXOD2, "ATTRIB", "KEY", "Y" ) == 0 )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_03PHBO@KEY?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06BLIJ@ATTRIB?$AA@	; `string'
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L31744

; 6436 : 
; 6437 :             // Move current DATAFIELD to the beginning.
; 6438 :             MoveSubobject( vXOD2, "DATAFIELD", vXOD2, "DATAFIELD",
; 6439 :                            zPOS_FIRST, zREPOS_NEXT );

	push	3
	push	1
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD2$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_MoveSubobject@24
$L31744:

; 6441 :       }

	jmp	$L31740
$L31741:

; 6442 :    }

	jmp	$L31719
$L31720:

; 6443 : 
; 6444 :    DropHierarchicalCursor( vTZZOXODO );

	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_DropHierarchicalCursor@4

; 6445 :    DropView( vXOD );

	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_DropView@4

; 6446 :    DropView( vXOD2 );

	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_DropView@4

; 6447 :    DropView( vTZZOXODO );

	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_DropView@4

; 6448 : 
; 6449 :    return( 0 );

	xor	ax, ax
$L31710:

; 6450 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnSortDataFields@4 ENDP
_TEXT	ENDS
PUBLIC	_fnSetEntityInformation@12
PUBLIC	??_C@_0BB@NHDL@LOD_EntityParent?$AA@		; `string'
PUBLIC	??_C@_0BI@FMLJ@TE_DBMS_SourceForEntity?$AA@	; `string'
PUBLIC	??_C@_0BD@GNEF@SQL_JoinWithParent?$AA@		; `string'
PUBLIC	??_C@_0L@KKLH@POD_Entity?$AA@			; `string'
PUBLIC	??_C@_0O@FFFI@ER_RelLinkRec?$AA@		; `string'
PUBLIC	??_C@_07NHPD@CardMax?$AA@			; `string'
PUBLIC	??_C@_09PPA@ERENT_TOK?$AA@			; `string'
PUBLIC	??_C@_09DPNM@ERREL_TOK?$AA@			; `string'
PUBLIC	??_C@_0BA@DPMI@LOD_EntityChild?$AA@		; `string'
PUBLIC	??_C@_0N@NFHJ@ER_EntityRec?$AA@			; `string'
EXTRN	_CompareAttributeToInteger@16:NEAR
EXTRN	_ResetViewFromSubobject@4:NEAR
EXTRN	_SetCursorFirstEntityByInteger@20:NEAR
;	COMDAT ??_C@_0BB@NHDL@LOD_EntityParent?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0BB@NHDL@LOD_EntityParent?$AA@ DB 'LOD_EntityParent', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@FMLJ@TE_DBMS_SourceForEntity?$AA@
_DATA	SEGMENT
??_C@_0BI@FMLJ@TE_DBMS_SourceForEntity?$AA@ DB 'TE_DBMS_SourceForEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GNEF@SQL_JoinWithParent?$AA@
_DATA	SEGMENT
??_C@_0BD@GNEF@SQL_JoinWithParent?$AA@ DB 'SQL_JoinWithParent', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@KKLH@POD_Entity?$AA@
_DATA	SEGMENT
??_C@_0L@KKLH@POD_Entity?$AA@ DB 'POD_Entity', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@FFFI@ER_RelLinkRec?$AA@
_DATA	SEGMENT
??_C@_0O@FFFI@ER_RelLinkRec?$AA@ DB 'ER_RelLinkRec', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NHPD@CardMax?$AA@
_DATA	SEGMENT
??_C@_07NHPD@CardMax?$AA@ DB 'CardMax', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09PPA@ERENT_TOK?$AA@
_DATA	SEGMENT
??_C@_09PPA@ERENT_TOK?$AA@ DB 'ERENT_TOK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09DPNM@ERREL_TOK?$AA@
_DATA	SEGMENT
??_C@_09DPNM@ERREL_TOK?$AA@ DB 'ERREL_TOK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DPMI@LOD_EntityChild?$AA@
_DATA	SEGMENT
??_C@_0BA@DPMI@LOD_EntityChild?$AA@ DB 'LOD_EntityChild', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NFHJ@ER_EntityRec?$AA@
_DATA	SEGMENT
??_C@_0N@NFHJ@ER_EntityRec?$AA@ DB 'ER_EntityRec', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vTZZOLODO$ = 8
_vTZZOXODO$ = 12
_lDBMS_ZKey$ = 16
_nRC$ = -4
_lER_EntTok$31769 = -8
_lER_RelTok$31770 = -12
_fnSetEntityInformation@12 PROC NEAR

; 6455 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6456 :    zSHORT nRC;
; 6457 : 
; 6458 :    // First, make sure we've got an entity with DB information.
; 6459 :    if ( CheckExistenceOfEntity( vTZZOXODO, "DATARECORD" ) < zCURSOR_SET )

	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $L31755

; 6460 :       return;

	jmp	$L31768
$L31755:

; 6461 : 
; 6462 :    // Find out if a POD_Entity exists for the DBMS.
; 6463 :    if ( SetCursorFirstEntityByInteger( vTZZOLODO, "TE_DBMS_SourceForEntity",
; 6464 :                                        "ZKey", lDBMS_ZKey,
; 6465 :                                        "LOD_EntityParent" ) == zCURSOR_SET )

	push	OFFSET FLAT:??_C@_0BB@NHDL@LOD_EntityParent?$AA@ ; `string'
	mov	edx, DWORD PTR _lDBMS_ZKey$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BI@FMLJ@TE_DBMS_SourceForEntity?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByInteger@20
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L31756

; 6467 :       // Got a POD_Entity.  Check the JOIN flag.
; 6468 :       if ( CompareAttributeToString( vTZZOLODO, "POD_Entity",
; 6469 :                                      "SQL_JoinWithParent", "Y" ) == 0 )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BD@GNEF@SQL_JoinWithParent?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@KKLH@POD_Entity?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L31759

; 6471 :          SetAttributeFromString( vTZZOXODO, "DATARECORD", "JOIN", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_04JIJO@JOIN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$L31759:

; 6474 :    else

	jmp	SHORT $L31763
$L31756:

; 6475 :    if ( CheckExistenceOfEntity( vTZZOLODO, "ER_RelLinkRec" ) == zCURSOR_SET &&
; 6476 :         CompareAttributeToInteger( vTZZOLODO, "ER_RelLinkRec",
; 6477 :                                    "CardMax", 1 ) == 0 )

	push	OFFSET FLAT:??_C@_0O@FFFI@ER_RelLinkRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L31763
	push	1
	push	OFFSET FLAT:??_C@_07NHPD@CardMax?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@FFFI@ER_RelLinkRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZZOLODO$[ebp]
	push	ecx
	call	_CompareAttributeToInteger@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L31763

; 6479 :       // Join is defaulted to Y if the entity has a x-to-1 relationship
; 6480 :       // with it's parent.
; 6481 :       SetAttributeFromString( vTZZOXODO, "DATARECORD", "JOIN", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_04JIJO@JOIN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$L31763:

; 6483 : 
; 6484 :    // Now do the same thing for any children.
; 6485 :    for ( nRC = SetCursorFirstEntity( vTZZOXODO, "CHILDENTITY", 0 );
; 6486 :          nRC >= zCURSOR_SET;
; 6487 :          nRC = SetCursorNextEntity( vTZZOXODO, "CHILDENTITY", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31766
$L31767:
	push	0
	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31766:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L31768

; 6489 :       zLONG lER_EntTok;
; 6490 :       zLONG lER_RelTok;
; 6491 : 
; 6492 :       GetIntegerFromAttribute( &lER_EntTok, vTZZOXODO, "CHILDENTITY",
; 6493 :                                "ERENT_TOK" );

	push	OFFSET FLAT:??_C@_09PPA@ERENT_TOK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lER_EntTok$31769[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 6494 :       GetIntegerFromAttribute( &lER_RelTok, vTZZOXODO, "CHILDENTITY",
; 6495 :                                "ERREL_TOK" );

	push	OFFSET FLAT:??_C@_09DPNM@ERREL_TOK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lER_RelTok$31770[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 6496 : 
; 6497 :       // Find a matching entity in the LOD.
; 6498 :       for ( nRC = SetCursorFirstEntity( vTZZOLODO, "LOD_EntityChild", 0 );
; 6499 :             nRC >= zCURSOR_SET;
; 6500 :             nRC = SetCursorNextEntity( vTZZOLODO, "LOD_EntityChild", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@DPMI@LOD_EntityChild?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31773
$L31774:
	push	0
	push	OFFSET FLAT:??_C@_0BA@DPMI@LOD_EntityChild?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31773:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31775

; 6502 :          SetViewToSubobject( vTZZOLODO, "LOD_EntityChild" );

	push	OFFSET FLAT:??_C@_0BA@DPMI@LOD_EntityChild?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_SetViewToSubobject@8

; 6503 : 
; 6504 :          if ( CheckExistenceOfEntity( vTZZOLODO,
; 6505 :                                       "ER_EntityRec" ) == zCURSOR_SET &&
; 6506 :               CompareAttributeToInteger( vTZZOLODO, "ER_EntityRec", "ZKey",
; 6507 :                                          lER_EntTok ) == 0 &&
; 6508 :               CheckExistenceOfEntity( vTZZOLODO,
; 6509 :                                       "ER_RelLinkRec" ) == zCURSOR_SET &&
; 6510 :               CompareAttributeToInteger( vTZZOLODO, "ER_RelLinkRec", "ZKey",
; 6511 :                                          lER_EntTok ) == 0 )

	push	OFFSET FLAT:??_C@_0N@NFHJ@ER_EntityRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L31777
	mov	edx, DWORD PTR _lER_EntTok$31769[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NFHJ@ER_EntityRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_CompareAttributeToInteger@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L31777
	push	OFFSET FLAT:??_C@_0O@FFFI@ER_RelLinkRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L31777
	mov	ecx, DWORD PTR _lER_EntTok$31769[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@FFFI@ER_RelLinkRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CompareAttributeToInteger@16
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L31777

; 6513 :             // We found the child entity that matches the CHILDENTITY
; 6514 :             // in the XOD.  Stop 'for' loop.
; 6515 :             break;

	jmp	SHORT $L31775
$L31777:

; 6517 : 
; 6518 :          // That wasn't the right child so reset the subobject.
; 6519 :          ResetViewFromSubobject( vTZZOLODO );

	mov	ecx, DWORD PTR _vTZZOLODO$[ebp]
	push	ecx
	call	_ResetViewFromSubobject@4

; 6520 :       }

	jmp	$L31774
$L31775:

; 6521 : 
; 6522 :       // Once we get here, "LOD_EntityParent" should match "CHILDENTITY".
; 6523 :       // Move "CHILDENTITY" up and call ourselves recursively.
; 6524 :       SetViewToSubobject( vTZZOXODO, "CHILDENTITY" );

	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_SetViewToSubobject@8

; 6525 :       fnSetEntityInformation( vTZZOLODO, vTZZOXODO, lDBMS_ZKey );

	mov	eax, DWORD PTR _lDBMS_ZKey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_fnSetEntityInformation@12

; 6526 : 
; 6527 :       // Now reset the cursors.
; 6528 :       ResetViewFromSubobject( vTZZOLODO );

	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_ResetViewFromSubobject@4

; 6529 :       ResetViewFromSubobject( vTZZOXODO );

	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_ResetViewFromSubobject@4

; 6530 :    }

	jmp	$L31767
$L31768:

; 6531 : 
; 6532 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSetEntityInformation@12 ENDP
_TEXT	ENDS
PUBLIC	_PostXOD_BuildHook@20
PUBLIC	??_C@_0EK@BEMO@You?5need?5to?5do?5a?5?8Set?5DBH?8?5for?5t@ ; `string'
PUBLIC	??_C@_0N@BDOD@Zeidon?5Tools?$AA@		; `string'
PUBLIC	??_C@_0BC@PBGA@PostXOD_BuildHook?$AA@		; `string'
PUBLIC	??_C@_0DA@JMGI@?$CK?$CK?$CK?5PostXOD_BuildHook?5TZDBHODO?5d@ ; `string'
PUBLIC	??_C@_08DKCM@TZDBHODO?$AA@			; `string'
PUBLIC	??_C@_0BD@KPGG@TimestampPrecision?$AA@		; `string'
PUBLIC	??_C@_06PIJH@OBJECT?$AA@			; `string'
EXTRN	_SetAttributeFromBlob@20:NEAR
EXTRN	_ResetView@4:NEAR
EXTRN	_memset:NEAR
;	COMDAT ??_C@_0EK@BEMO@You?5need?5to?5do?5a?5?8Set?5DBH?8?5for?5t@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0EK@BEMO@You?5need?5to?5do?5a?5?8Set?5DBH?8?5for?5t@ DB 'You need t'
	DB	'o do a ''Set DBH'' for this data source before building the x'
	DB	'ods.', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@BDOD@Zeidon?5Tools?$AA@
_DATA	SEGMENT
??_C@_0N@BDOD@Zeidon?5Tools?$AA@ DB 'Zeidon Tools', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@PBGA@PostXOD_BuildHook?$AA@
_DATA	SEGMENT
??_C@_0BC@PBGA@PostXOD_BuildHook?$AA@ DB 'PostXOD_BuildHook', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DA@JMGI@?$CK?$CK?$CK?5PostXOD_BuildHook?5TZDBHODO?5d@
_DATA	SEGMENT
??_C@_0DA@JMGI@?$CK?$CK?$CK?5PostXOD_BuildHook?5TZDBHODO?5d@ DB '*** Post'
	DB	'XOD_BuildHook TZDBHODO does not exist. ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DKCM@TZDBHODO?$AA@
_DATA	SEGMENT
??_C@_08DKCM@TZDBHODO?$AA@ DB 'TZDBHODO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KPGG@TimestampPrecision?$AA@
_DATA	SEGMENT
??_C@_0BD@KPGG@TimestampPrecision?$AA@ DB 'TimestampPrecision', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PIJH@OBJECT?$AA@
_DATA	SEGMENT
??_C@_06PIJH@OBJECT?$AA@ DB 'OBJECT', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vTZTEDBLO$ = 8
_vTZZOXODO$ = 12
_vTZZOLODO$ = 16
_vTZTENVRO_REF$ = 24
_szObjectName$ = -40
_vOI$ = -4
_lDBMS_ZKey$31807 = -44
_sData$31808 = -148
_PostXOD_BuildHook@20 PROC NEAR

; 6546 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H

; 6547 :    zCHAR szObjectName[ zZEIDON_NAME_LTH + 1 ];
; 6548 :    zVIEW vOI;
; 6549 : 
; 6550 :    // See if there is a blob stored in DBH_Data for the TE.
; 6551 :    SetOI_FromBlob( &vOI, szObjectName, vTZZOXODO, vTZTENVRO_REF,
; 6552 :                    "TE_DBMS_Source", "DBH_Data", zMULTIPLE );

	push	256					; 00000100H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZTENVRO_REF$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 6553 : 
; 6554 :    if ( vOI == 0 )

	cmp	DWORD PTR _vOI$[ebp], 0
	jne	SHORT $L31793

; 6555 :        // No blob in the TE.  Get it from the DB list object.
; 6556 :       SetOI_FromBlob( &vOI, szObjectName, vTZZOXODO, vTZTEDBLO,
; 6557 :                       "TE_DBMS_Source", "DBH_Data", zMULTIPLE );

	push	256					; 00000100H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	lea	eax, DWORD PTR _szObjectName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28
$L31793:

; 6558 : 
; 6559 :    if ( vOI == 0 )

	cmp	DWORD PTR _vOI$[ebp], 0
	jne	SHORT $L31794

; 6561 :       // KJS - 08/22/12 - This is being put in because we were getting an 'Invalid View' error on the DropView( vOI ) if
; 6562 :      // a 'Set DBH' hadn't been done on the data source and the db handler was PostgreSQL since TZDBHODO was not ever set.
; 6563 :      // Not actually sure if this is much of an error (should I just put the DropView in the below "If") or if there could
; 6564 :      // be problems if TZDBHODO is not a valid view.
; 6565 :       MessageSend( vTZZOXODO, "PostXOD_BuildHook", "Zeidon Tools",
; 6566 :                    "You need to do a 'Set DBH' for this data source before building the xods.", zMSGQ_SYSTEM_ERROR, TRUE );

	push	1
	push	1000					; 000003e8H
	push	OFFSET FLAT:??_C@_0EK@BEMO@You?5need?5to?5do?5a?5?8Set?5DBH?8?5for?5t@ ; `string'
	push	OFFSET FLAT:??_C@_0N@BDOD@Zeidon?5Tools?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BC@PBGA@PostXOD_BuildHook?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_MessageSend@24

; 6567 :       TraceLineS( "*** PostXOD_BuildHook TZDBHODO does not exist. ", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0DA@JMGI@?$CK?$CK?$CK?5PostXOD_BuildHook?5TZDBHODO?5d@ ; `string'
	call	_TraceLineS@8

; 6568 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L31790
$L31794:

; 6570 : 
; 6571 :    // Check for ODBC object.
; 6572 :    if ( zstrcmp( szObjectName, "TZDBHODO" ) == 0 )

	movsx	eax, BYTE PTR _szObjectName$[ebp]
	movsx	ecx, BYTE PTR ??_C@_08DKCM@TZDBHODO?$AA@
	cmp	eax, ecx
	jne	SHORT $L32341
	push	OFFSET FLAT:??_C@_08DKCM@TZDBHODO?$AA@	; `string'
	lea	edx, DWORD PTR _szObjectName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -152+[ebp], eax
	jmp	SHORT $L32342
$L32341:
	movsx	eax, BYTE PTR _szObjectName$[ebp]
	movsx	ecx, BYTE PTR ??_C@_08DKCM@TZDBHODO?$AA@
	sub	eax, ecx
	xor	edx, edx
	test	eax, eax
	setle	dl
	dec	edx
	and	edx, 2
	add	edx, -1
	mov	DWORD PTR -152+[ebp], edx
$L32342:
	cmp	DWORD PTR -152+[ebp], 0
	jne	$L31805

; 6574 :       zLONG                 lDBMS_ZKey;
; 6575 :       ODBC_ObjectDataRecord sData;
; 6576 : 
; 6577 :       // For ODBC databases we need to sort the DataFields so that the VarChar
; 6578 :       // fields come last in each table.  We also need to put keys first.
; 6579 :       fnSortDataFields( vTZZOXODO );

	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_fnSortDataFields@4

; 6580 : 
; 6581 :       // Set-up ODBC-specific information.
; 6582 :       zmemset( &sData, 0, sizeof( sData ) );

	push	104					; 00000068H
	push	0
	lea	ecx, DWORD PTR _sData$31808[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 6583 :       GetIntegerFromAttribute( &sData.nTimestampPrecision,
; 6584 :                                vOI, "ODBC", "TimestampPrecision" );

	push	OFFSET FLAT:??_C@_0BD@KPGG@TimestampPrecision?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	lea	eax, DWORD PTR _sData$31808[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 6585 :       sData.bStoreTimestampAsString =
; 6586 :             ( CompareAttributeToString( vOI, "ODBC",
; 6587 :                                         "TimestampAsString", "Y" ) == 0 );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BC@KJKI@TimestampAsString?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	neg	edx
	sbb	edx, edx
	inc	edx
	mov	BYTE PTR _sData$31808[ebp+4], dl

; 6588 : 
; 6589 :       SetAttributeFromBlob( vTZZOXODO, "OBJECT", "DBH_Data", (zPVOID) &sData,
; 6590 :                             sizeof( sData ) );

	push	104					; 00000068H
	lea	eax, DWORD PTR _sData$31808[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06PIJH@OBJECT?$AA@	; `string'
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_SetAttributeFromBlob@20

; 6591 : 
; 6592 :       // Go through the LOD and set dbh-specific information for each entity.
; 6593 :       ResetView( vTZZOLODO );

	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_ResetView@4

; 6594 :       ResetView( vTZZOXODO );

	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_ResetView@4

; 6595 : 
; 6596 :       // Set the cursor to the first non-hidden entity.
; 6597 :       SetCursorFirstEntity( vTZZOXODO, "OBJECT", 0 );

	push	0
	push	OFFSET FLAT:??_C@_06PIJH@OBJECT?$AA@	; `string'
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12

; 6598 : 
; 6599 :       GetIntegerFromAttribute( &lDBMS_ZKey, vTZTENVRO_REF, "TE_DBMS_Source",
; 6600 :                                "ZKey" );

	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZTENVRO_REF$[ebp]
	push	edx
	lea	eax, DWORD PTR _lDBMS_ZKey$31807[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 6601 :       fnSetEntityInformation( vTZZOLODO, vTZZOXODO, lDBMS_ZKey );

	mov	ecx, DWORD PTR _lDBMS_ZKey$31807[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_fnSetEntityInformation@12
$L31805:

; 6603 : 
; 6604 :    DropView( vOI );

	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_DropView@4

; 6605 : 
; 6606 :    return( 0 );

	xor	ax, ax
$L31790:

; 6607 : 
; 6608 : } // PostXOD_BuildHook

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_PostXOD_BuildHook@20 ENDP
_TEXT	ENDS
EXTRN	__imp__strchr:NEAR
_TEXT	SEGMENT
_pch$ = 8
_pchKlammer$ = -4
_RemoveBrackets PROC NEAR

; 6616 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6617 :    zPCHAR pchKlammer;
; 6618 : 
; 6619 :    pchKlammer = strchr( pch, '[' );

	push	91					; 0000005bH
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchKlammer$[ebp], eax

; 6620 :    if ( pchKlammer )

	cmp	DWORD PTR _pchKlammer$[ebp], 0
	je	SHORT $L31816
$L31818:

; 6622 :       // Klammern [] wegnehmen.
; 6623 :       while ( *(pchKlammer + 1) != ']' && *(pchKlammer + 1) )

	mov	ecx, DWORD PTR _pchKlammer$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 93					; 0000005dH
	je	SHORT $L31819
	mov	eax, DWORD PTR _pchKlammer$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $L31819

; 6625 :          *pchKlammer = *(pchKlammer + 1);

	mov	edx, DWORD PTR _pchKlammer$[ebp]
	mov	eax, DWORD PTR _pchKlammer$[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx], cl

; 6626 :          pchKlammer++;

	mov	edx, DWORD PTR _pchKlammer$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchKlammer$[ebp], edx

; 6627 :       }

	jmp	SHORT $L31818
$L31819:

; 6628 : 
; 6629 :       *pchKlammer = 0;

	mov	eax, DWORD PTR _pchKlammer$[ebp]
	mov	BYTE PTR [eax], 0
$L31816:

; 6631 : 
; 6632 : } // RemoveBrackets

	mov	esp, ebp
	pop	ebp
	ret	0
_RemoveBrackets ENDP
_TEXT	ENDS
END
