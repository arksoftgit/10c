	TITLE	C:\10C\A\oe\KZOEOIAA.C
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@OFE@lpAppQualView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@EIGE@EntitySpec?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@FPPG@SourceViewName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NIIK@SourceViewID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CPOO@SourceEntityName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@ICOG@SourceAttributeName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FKDH@Oper?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02PKFC@IS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01GFI@?$CI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LACO@AND?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@LOJF@EntityName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@JICG@AttributeName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KPOD@?$DN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KBGO@Value?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KMMP@?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GDMG@LOD_Name?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GOHN@KeyValue?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BJPE@UserName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KMOL@Timestamp?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09NCPC@AllowRead?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KIPN@ZPLOCKO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IMFF@?$CD?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PIFJ@ZeidonLock?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01OAK@N?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@JGEA@Locking?5semaphore?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DE@IKDC@Waited?5too?5long?5to?5write?5pessimi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@FJHF@Expecting?5valid?5OI?5for?5zACTIVATE@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DB@KPMG@Root?5entity?5has?5no?5default?5seque@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IDPE@kzdbhqua?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02CHDK@OR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FHE@?$DM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FAFK@?$DO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08ILBJ@KZDBHQUA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@JJIL@__Load?9in?9progress?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@NCHC@?$CIoi?$CJ?5Database?5unavailable?9?9try?5a@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@FJHI@?$CIoi?$CJ?5Database?5Deadlock?5?9?5Object?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@DAGF@?5Activate?5Retry?5Count?$DN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@FIPO@?$CIoi?$CJ?5Deadlock?5Crash?5?9?5Retry?5Coun@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DP@HHNF@?$CIoi?$CJ?5Database?5Memory?5Limit?5Reach@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DIOI@QualAttrib?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@GCPH@SubQualAttrib?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IDGA@KZOEOIAA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02KKOC@xx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OKGH@?$CFlf?5seconds?5for?5object?5?$CFs?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@EJKO@?$CIoi?$CJ?5Total?5time?5for?5ActivateObje@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@PPBE@?$CIoi?$CJ?5opening?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CKOO@Out?5of?5buffer?5space?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@LIH@Internal?5Core?5Error?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02CJCI@KZ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@KGHM@DBH_MsgProc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@GMLG@_DBH_MsgProc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GIDM@GKH_MsgProc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@KCPG@_GKH_MsgProc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@HCHL@View?5doesn?8t?5have?5an?5OI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@ECGE@Object?5Name?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@FEHG@?$CIoi?$CJ?5Can?8t?5start?5network?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@GCPD@?$CIoi?$CJ?5Warning?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@OGGO@?$CIoi?$CJ?5Object?5definition?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@BILP@?$CIoi?$CJ?5Entity?5name?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HPNO@?$CIoi?$CJ?5EI?5Flags?5?5?5?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FP@BNEA@Return?5code?5indicates?5that?5Commi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@OPBG@OE?5Warning?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EC@LDIB@?$CFs?5?5?$CFs?5?5?5Object?5Definition?3?5?$CFs?5?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@FIA@?$CFlf?5seconds?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@PHHP@?$CIoi?$CJ?5Total?5time?5for?5CommitMultip@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@DMOI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5Warning?5?9?9?9?9?9?9@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06EOKH@create?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IDPA@delete?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07JPDC@created?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NAPP@deleted?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0ID@FFNG@Warning?3?5Trying?5to?5commit?5an?5ent@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@PJII@Number?5of?5views?5in?5the?5cluster?3?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@IIDP@?$CInull?$CJ?5View?5not?5flagged?5as?5chang@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@FMKN@?5?5?5View?5ID?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@MHHP@?5?5?5View?5ID?5?$DN?5?$CFlx?0?5Object?5name?5?$DN?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05OGKG@?$CFs?4?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@HLDF@OD?4Entity?5with?5Create?5flag?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@BCNN@OD?4Entity?5with?5Delete?5flag?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@MNFM@OD?4Entity?5with?5create?5authority?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0KE@LDAH@Warning?3?5Trying?5to?5commit?5an?5ent@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DMJL@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@KCFL@No?5GenKey?5handler?5set?5for?5LOD?3?5?$CF@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@FKJO@OIs?5have?5different?5GenKey?5handle@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08HFJA@KZGKHWOB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JOKA@_KZGKHWOB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OHJM@EntityID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JEOF@Genkey?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@KMCA@EntityCount?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JMBN@TableName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@PLOF@Infinite?5loop?5trying?5to?5set?5FKs?$DP@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LNBB@?$EA?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@CNGJ@Couldn?8t?5find?5original?5OI?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@PFIF@?$CIoi?$CJ?5Activating?5Optimistic?5Check@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DB@NCB@?$CIoi?$CJ?5Error?5loading?5Optimistic?5ch@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@JDBO@?$CIoi?$CJ?5Optimistic?5locking?5compare?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@OMJF@mOIFLAGS?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GFPC@mOIFLAGS?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05HEAD@?$CFx?5?$CFx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GLEP@mETAG?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KKHA@mEKEY?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@IJFA@mEKEY?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NHOC@?0?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HIC@a?$CFlx?$CFs?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DCMN@?$CFs?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IACC@a?$CF?99s?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPK@a?5?$CFx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FA@OBP@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Src?5View?5E@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DN@MLKO@Error?5writing?5OI?3?5ER?5Tokens?5don?8@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GN@i?$CFlx?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KPKL@c?$CFx?50?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BFPN@c?$CFx?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08ION@?5?5?5?5?5?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@LHOF@mCONTROL?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JJOE@ZEND?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@BFCD@?$CIoi?$CJ?5Total?5time?5for?5SfWriteOI_To@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CP@GGJF@Trying?5to?5drop?5original?5OI?5but?5i@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@NIPI@?9?5ParentEntity?5?$DN?$DN?5ChildEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@NMHK@?$CIoi?$CJ?5Hangin?5key?5error?$CB?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BKHK@LOD?5?8?$CFs?8?5is?5locked?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JJPK@Entity?5?8?$CFs?8?5is?5locked?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@NLCC@YYYY?9M?9D?5HH?3MI?3SS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NCBI@?$CIoi?$CJ?5Object?5locked?5by?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@FDBN@?$CIoi?$CJ?5Object?5locked?5on?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@POBP@?$CIoi?$CJ?5Concatenated?5key?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DH@OLHA@?$DN?$DN?$DN?$DN?5Activate?5error?3?5Infinite?5re@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@JOON@Object?5Name?5?5?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LMMD@Parent?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@BHHL@Parent?5level?5?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NJHF@Child?5Entity?5?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@IHNO@Child?5level?5?5?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PCJP@Y?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICJO@CONTROL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EECP@ETAG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BDIB@EKEY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JDHD@OITAG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07IFBG@OIFLAGS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@GEOJ@?$CIWARNING?$CJ?5Couldn?8t?5find?5entity?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@FECF@?$CIWARNING?$CJ?5in?5LOD?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PJCK@?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@HIC@Error?5from?5UUDECODE_NextLineToBu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@FNGM@UUDECODE?5length?5invalid?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FA@FOLJ@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Tgt?5View?5E@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@DJNN@ER?5Tokens?5don?8t?5match?5for?5linked@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@IKLP@?$CIoi?$CJ?5Failed?5entity?5linking?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@FPOB@?$CIoi?$CJ?5Link?5Src?5?$CD?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@GFPE@?$CIoi?$CJ?5Source?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GIND@?$CIoi?$CJ?5Link?5Tgt?5?$CD?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FHME@?$CIoi?$CJ?5Target?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@MMNH@?$CIoi?$CJ?5Entity?5type?5mismatch?5during@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@HFJB@?$CIoi?$CJ?5Total?5time?5for?5SfActivateOI@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FO@KBNJ@SfActivateSysOI_FromFile?5now?5REQ@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FM@LNBI@SfActivateSysOI_FromFile?5now?5REQ@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09BPDN@Zeidon?5OE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FL@BEFB@SfActivateSysEmptyOI?5now?5REQUIRE@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FI@FKHH@SfActivateSysEmptyOI?5now?5REQUIRE@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CEOG@?4bubblesort?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@NHNF@Out?5of?5space?5for?5entities?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@LCPB@Maximum?5?$CD?5of?5order?5entities?5used@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@KEBP@Sequencing?5error?5?$DO?540?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@OIFL@fnOrderEntitiesByDefaultAttribs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@BDHH@Ordering?5attributes?5?9?9?5resetting@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@KJKO@Unset?5or?5Null?5Cursor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@GNIP@OrderEntities?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@OBEN@Ordering?5attributes?5?9?9?5Entity?5cu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@DGOD@Error?5occurs?5after?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CM@MJO@Error?5parsing?5command?4?5?5See?5trac@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09MHIP@ACTIVATE?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06ICCC@WHERE?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06KGGE@?$CKroot?$CK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CHNO@KeyList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@GDFL@IntegerValue?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_gszKeyDelimStr
_BSS	SEGMENT
_?ZeroAttribFlags@?BJ@??fnWriteOI_ToTextStream@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_gszKeyDelimStr DB '/|\', 09H, 0aH, '`~!@#$%^&*-_=+;<>?aAzZ10', 00H
_DATA	ENDS
PUBLIC	_fnInvokeOCEOperation
PUBLIC	_ActivateEmptyObjectInstance@16
PUBLIC	??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ ; `string'
PUBLIC	??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@		; `string'
PUBLIC	??_C@_0O@OFE@lpAppQualView?$AA@			; `string'
PUBLIC	_fnActivateEmptyObjectInstance
EXTRN	_fnOperationCall:NEAR
EXTRN	_fnOperationReturn:NEAR
EXTRN	_fnDeclareView@20:NEAR
EXTRN	_fnDropView@4:NEAR
EXTRN	_AnchorBlock:DWORD
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_fnIssueCoreError:NEAR
;	COMDAT ??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ DB 'More than one zL'
	DB	'EVEL_ option requested', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@
_DATA	SEGMENT
??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@ DB 'with zLEVEL_SAME', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@OFE@lpAppQualView?$AA@
_DATA	SEGMENT
??_C@_0O@OFE@lpAppQualView?$AA@ DB 'lpAppQualView', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_lControl$ = 20
_lpCurrentTask$ = -24
_lpOwningTask$ = -16
_lpViewOD$ = -4
_lpView$ = -8
_l$ = -20
_nRC$ = -12
_lpViewCsr$7661 = -28
_nState$7678 = -32
_ActivateEmptyObjectInstance@16 PROC NEAR

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 557  :    LPTASK         lpCurrentTask;
; 558  :    LPTASK         lpOwningTask;
; 559  :    LPVIEWOD       lpViewOD;
; 560  :    zVIEW          lpView;
; 561  :    zLONG          l;
; 562  :    zSHORT         nRC;
; 563  : 
; 564  :    // Init in case of early error
; 565  :    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 566  : 
; 567  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 568  :    if ( (lpCurrentTask = fnOperationCall( iActivateEmptyObjectInstance,
; 569  :                                           lpAppQualView, zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	push	50					; 00000032H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L7652

; 571  :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7645
$L7652:

; 573  : 
; 574  :    // Verify only one zLEVEL_ option requested
; 575  :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], edx

; 576  :    if ( l && (-l & l) != l )

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $L7653
	mov	eax, DWORD PTR _l$[ebp]
	neg	eax
	and	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _l$[ebp]
	je	SHORT $L7653

; 578  :       // error, More than one zLEVEL_ option requested
; 579  :       // "KZOEE023 - Invalid parameter, "
; 580  :       fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 23, 0,
; 581  :                         "More than one zLEVEL_ option requested", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ ; `string'
	push	0
	push	23					; 00000017H
	push	8
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 582  :       fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 583  :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7645
$L7653:

; 585  : 
; 586  :    // If zLEVEL_SAME is requested
; 587  :    if ( lControl & zLEVEL_SAME )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1024				; 00000400H
	test	ecx, ecx
	je	$L7670

; 589  :       if ( lpAppQualView == 0 || lpAppQualView->hSubtask )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $L7657
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $L7656
$L7657:

; 591  :          // "KZOEE100 - Invalid View, view is a Subtask View"
; 592  :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 100, 0,
; 593  :                            "lpAppQualView", "with zLEVEL_SAME" );

	push	OFFSET FLAT:??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0O@OFE@lpAppQualView?$AA@ ; `string'
	push	0
	push	100					; 00000064H
	push	8
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 594  :          fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 595  :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7645
$L7656:

; 599  :          LPVIEWCSR lpViewCsr;
; 600  : 
; 601  :          // Turn off the 'same' indicator
; 602  :          lControl ^= zLEVEL_SAME;

	mov	eax, DWORD PTR _lControl$[ebp]
	xor	eax, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], eax

; 603  :          // To determine what the level is of the qualifying view
; 604  :          //   1. Change lpAppQualView to point to the initial
; 605  :          //      view created for the object instance
; 606  :          //   2. Check for application level, if there use
; 607  :          //      zLEVEL_APPLICATION.
; 608  :          //   3. Check if the view task is the main task, if so use
; 609  :          //      zLEVEL_SYSTEM.
; 610  :          //   4. Use the task level...
; 611  :          lpViewCsr = zGETPTR( lpAppQualView->hViewCsr );

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$7661[ebp], eax
$L7664:

; 612  :          while ( lpViewCsr->hNextViewCsr )

	mov	eax, DWORD PTR _lpViewCsr$7661[ebp]
	cmp	DWORD PTR [eax+2], 0
	je	SHORT $L7665

; 613  :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpViewCsr$7661[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$7661[ebp], eax
	jmp	SHORT $L7664
$L7665:

; 614  : 
; 615  :          lpAppQualView = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$7661[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAppQualView$[ebp], eax

; 616  :          if ( lpAppQualView->bApplicationView )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L7668

; 617  :             lControl |= zLEVEL_APPLICATION;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 4
	mov	DWORD PTR _lControl$[ebp], ecx

; 618  :          else

	jmp	SHORT $L7670
$L7668:

; 619  :          if ( lpAppQualView->hTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $L7670

; 620  :             lControl |= zLEVEL_SYSTEM;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 8
	mov	DWORD PTR _lControl$[ebp], edx
$L7670:

; 623  : 
; 624  :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L7671

; 625  :       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 626  :    else

	jmp	SHORT $L7673
$L7671:

; 627  :       lpOwningTask = lpCurrentTask;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], eax
$L7673:

; 628  : 
; 629  :    if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 630  :                               lpAppQualView, cpcViewOD_Name, 0 )) != 0 )

	push	0
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L7674

; 632  :       fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 633  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L7645
$L7674:

; 635  : 
; 636  : #if 0
; 637  :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 638  :    {
; 639  :       zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 640  :                                   zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 641  :       if ( (nRC = SfTransferView( *pvReturnView, lpAppQualView,
; 642  :                                   nScope )) != 0 )
; 643  :       {
; 644  :          fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );
; 645  :          return( nRC );
; 646  :       }
; 647  :    }
; 648  : #endif
; 649  : 
; 650  :    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, *pvReturnView, lControl );

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 651  :    lpView = *pvReturnView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpView$[ebp], eax

; 652  :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 653  :    if ( lControl & zREADONLY )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $L7676

; 654  :       lpView->bReadOnly = TRUE;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+30], edx
$L7676:

; 655  : 
; 656  : // TraceLine( "ActivateEmptyObjectInstance: 0x%08x   LOD: %s",
; 657  : //            lpView, lpViewOD->szName );
; 658  : 
; 659  : #ifdef __ACTIVATE_CONSTRAINTS__
; 660  :    if ( lpViewOD->bActivateEmptyConstraint && nRC == 0 )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L7680
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $L7680

; 662  :       zSHORT   nState;
; 663  : 
; 664  :       nState = (lControl & zLEVEL_SYSTEM) ? zOCE_STATE_SYSTEM : 0;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 8
	neg	ecx
	sbb	ecx, ecx
	and	ecx, 4
	mov	WORD PTR _nState$7678[ebp], cx

; 665  :          if ( lControl & zMULTIPLE )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 256				; 00000100H
	test	edx, edx
	je	SHORT $L7679

; 666  :             nState |= zOCE_STATE_MULTIPLE;

	mov	ax, WORD PTR _nState$7678[ebp]
	or	al, 16					; 00000010H
	mov	WORD PTR _nState$7678[ebp], ax
$L7679:

; 667  : 
; 668  :       nRC = fnInvokeOCEOperation( lpView, lpCurrentTask,
; 669  :                                   zOCE_ACTIVATE_EMPTY, nState );

	mov	cx, WORD PTR _nState$7678[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 670  :       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L7680

; 672  :          fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDropView@4

; 673  :          *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0
$L7680:

; 676  : #endif
; 677  : 
; 678  :    fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 679  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L7645:

; 680  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_ActivateEmptyObjectInstance@16 ENDP
_TEXT	ENDS
PUBLIC	_fnResolveQualOI
PUBLIC	??_C@_0L@EIGE@EntitySpec?$AA@			; `string'
PUBLIC	??_C@_0P@FPPG@SourceViewName?$AA@		; `string'
PUBLIC	??_C@_0N@NIIK@SourceViewID?$AA@			; `string'
PUBLIC	??_C@_0BB@CPOO@SourceEntityName?$AA@		; `string'
PUBLIC	??_C@_0BE@ICOG@SourceAttributeName?$AA@		; `string'
PUBLIC	??_C@_04FKDH@Oper?$AA@				; `string'
PUBLIC	??_C@_02PKFC@IS?$AA@				; `string'
PUBLIC	??_C@_01GFI@?$CI?$AA@				; `string'
PUBLIC	??_C@_03LACO@AND?$AA@				; `string'
PUBLIC	??_C@_0L@LOJF@EntityName?$AA@			; `string'
PUBLIC	??_C@_0O@JICG@AttributeName?$AA@		; `string'
PUBLIC	??_C@_01KPOD@?$DN?$AA@				; `string'
PUBLIC	??_C@_05KBGO@Value?$AA@				; `string'
PUBLIC	??_C@_01KMMP@?$CJ?$AA@				; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
EXTRN	_SetAttributeFromInteger@16:NEAR
EXTRN	_SetAttributeFromAttribute@24:NEAR
EXTRN	_MiGetViewEntityForView@8:NEAR
EXTRN	_CreateViewFromViewForTask@12:NEAR
EXTRN	_GetViewByName@16:NEAR
EXTRN	_GetAddrForAttribute@16:NEAR
EXTRN	_DropView@4:NEAR
EXTRN	_CreateEntity@12:NEAR
EXTRN	_DeleteEntity@12:NEAR
EXTRN	__imp___stricmp:NEAR
EXTRN	_SetCursorNextEntity@12:NEAR
EXTRN	_SetCursorFirstEntity@12:NEAR
EXTRN	_SetAttributeFromString@16:NEAR
EXTRN	_GetIntegerFromAttribute@16:NEAR
;	COMDAT ??_C@_00A@?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_C@_0L@EIGE@EntitySpec?$AA@
_DATA	SEGMENT
??_C@_0L@EIGE@EntitySpec?$AA@ DB 'EntitySpec', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@FPPG@SourceViewName?$AA@
_DATA	SEGMENT
??_C@_0P@FPPG@SourceViewName?$AA@ DB 'SourceViewName', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NIIK@SourceViewID?$AA@
_DATA	SEGMENT
??_C@_0N@NIIK@SourceViewID?$AA@ DB 'SourceViewID', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CPOO@SourceEntityName?$AA@
_DATA	SEGMENT
??_C@_0BB@CPOO@SourceEntityName?$AA@ DB 'SourceEntityName', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@ICOG@SourceAttributeName?$AA@
_DATA	SEGMENT
??_C@_0BE@ICOG@SourceAttributeName?$AA@ DB 'SourceAttributeName', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04FKDH@Oper?$AA@
_DATA	SEGMENT
??_C@_04FKDH@Oper?$AA@ DB 'Oper', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02PKFC@IS?$AA@
_DATA	SEGMENT
??_C@_02PKFC@IS?$AA@ DB 'IS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01GFI@?$CI?$AA@
_DATA	SEGMENT
??_C@_01GFI@?$CI?$AA@ DB '(', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03LACO@AND?$AA@
_DATA	SEGMENT
??_C@_03LACO@AND?$AA@ DB 'AND', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@LOJF@EntityName?$AA@
_DATA	SEGMENT
??_C@_0L@LOJF@EntityName?$AA@ DB 'EntityName', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@JICG@AttributeName?$AA@
_DATA	SEGMENT
??_C@_0O@JICG@AttributeName?$AA@ DB 'AttributeName', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01KPOD@?$DN?$AA@
_DATA	SEGMENT
??_C@_01KPOD@?$DN?$AA@ DB '=', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KBGO@Value?$AA@
_DATA	SEGMENT
??_C@_05KBGO@Value?$AA@ DB 'Value', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01KMMP@?$CJ?$AA@
_DATA	SEGMENT
??_C@_01KMMP@?$CJ?$AA@ DB ')', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vView$ = 8
_pchQualEntity$ = 12
_nRC$ = -4
_vSourceView$7695 = -12
_pchSourceViewName$7696 = -8
_pchSourceEntityName$7697 = -24
_pchSourceAttributeName$7698 = -20
_pchOper$7699 = -16
_lpViewEntity$7711 = -32
_lpViewAttrib$7712 = -36
_vTemp$7713 = -40
_bFirstKey$7714 = -28
_fnResolveQualOI PROC NEAR

; 688  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 689  :    zSHORT nRC;
; 690  : 
; 691  :    for ( nRC = SetCursorFirstEntity( vView, "EntitySpec", 0 );
; 692  :          nRC == zCURSOR_SET;
; 693  :          nRC = SetCursorNextEntity( vView, "EntitySpec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L7688
$L7689:
	push	0
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L7688:
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$L7690

; 695  :       for ( nRC = SetCursorFirstEntity( vView, pchQualEntity, "EntitySpec" );
; 696  :             nRC == zCURSOR_SET;
; 697  :             nRC = SetCursorNextEntity( vView, pchQualEntity, "EntitySpec" ) )

	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L7692
$L7693:
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L7692:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$L7694

; 699  :          zVIEW  vSourceView;
; 700  :          zPCHAR pchSourceViewName;
; 701  :          zPCHAR pchSourceEntityName;
; 702  :          zPCHAR pchSourceAttributeName;
; 703  :          zPCHAR pchOper;
; 704  : 
; 705  :          // See if QualAttrib references another view.
; 706  :          GetAddrForAttribute( &pchSourceViewName, vView, pchQualEntity,
; 707  :                               "SourceViewName" );

	push	OFFSET FLAT:??_C@_0P@FPPG@SourceViewName?$AA@ ; `string'
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchSourceViewName$7696[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 708  :          if ( *pchSourceViewName )

	mov	edx, DWORD PTR _pchSourceViewName$7696[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L7701

; 709  :             GetViewByName( &vSourceView, pchSourceViewName, vView, zLEVEL_TASK );

	push	2
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchSourceViewName$7696[ebp]
	push	edx
	lea	eax, DWORD PTR _vSourceView$7695[ebp]
	push	eax
	call	_GetViewByName@16

; 710  :          else

	jmp	SHORT $L7702
$L7701:

; 711  :             GetIntegerFromAttribute( (zPLONG) &vSourceView, vView,
; 712  :                                      pchQualEntity, "SourceViewID" );

	push	OFFSET FLAT:??_C@_0N@NIIK@SourceViewID?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vSourceView$7695[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
$L7702:

; 713  : 
; 714  :          // If vSourceView is 0, then the current QualAttrib doesn't reference
; 715  :          // another view, so continue with the next QualAttrib.
; 716  :          if ( vSourceView == 0 )

	cmp	DWORD PTR _vSourceView$7695[ebp], 0
	jne	SHORT $L7705

; 717  :             continue;

	jmp	SHORT $L7693
$L7705:

; 718  : 
; 719  :          // Get the source entity and attribute names.
; 720  :          GetAddrForAttribute( &pchSourceEntityName, vView, pchQualEntity,
; 721  :                               "SourceEntityName" );

	push	OFFSET FLAT:??_C@_0BB@CPOO@SourceEntityName?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchSourceEntityName$7697[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 722  :          GetAddrForAttribute( &pchSourceAttributeName, vView, pchQualEntity,
; 723  :                               "SourceAttributeName" );

	push	OFFSET FLAT:??_C@_0BE@ICOG@SourceAttributeName?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchSourceAttributeName$7698[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 724  : 
; 725  :          // Check to see if the operation is "IS".  If it is, then we have to
; 726  :          // save the key values.
; 727  :          GetAddrForAttribute( &pchOper, vView, pchQualEntity, "Oper" );

	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchOper$7699[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 728  :          if ( zstrcmpi( pchOper, "IS" ) == 0 )

	push	OFFSET FLAT:??_C@_02PKFC@IS?$AA@	; `string'
	mov	ecx, DWORD PTR _pchOper$7699[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	$L7709

; 730  :             LPVIEWENTITY lpViewEntity;
; 731  :             LPVIEWATTRIB lpViewAttrib;
; 732  :             zVIEW        vTemp;
; 733  :             zBOOL        bFirstKey = TRUE;

	mov	BYTE PTR _bFirstKey$7714[ebp], 1

; 734  : 
; 735  :             // Save a copy of the current view so we can delete the QualAttrib
; 736  :             // entity later.
; 737  :             CreateViewFromViewForTask( &vTemp, vView, 0 );

	push	0
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vTemp$7713[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 738  : 
; 739  :             CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_CreateEntity@12

; 740  :             SetAttributeFromString( vView, pchQualEntity, "Oper", "(" );

	push	OFFSET FLAT:??_C@_01GFI@?$CI?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 741  : 
; 742  :             // The oper is "IS".  This means we need to replace the current
; 743  :             // QualAttrib with QualAttribs to compare each key.
; 744  :             lpViewEntity = MiGetViewEntityForView( vSourceView,
; 745  :                                                    pchSourceEntityName );

	mov	edx, DWORD PTR _pchSourceEntityName$7697[ebp]
	push	edx
	mov	eax, DWORD PTR _vSourceView$7695[ebp]
	push	eax
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpViewEntity$7711[ebp], eax

; 746  :             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 747  :                   lpViewAttrib;
; 748  :                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$7711[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$7712[ebp], eax
	jmp	SHORT $L7719
$L7720:
	mov	eax, DWORD PTR _lpViewAttrib$7712[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$7712[ebp], eax
$L7719:
	cmp	DWORD PTR _lpViewAttrib$7712[ebp], 0
	je	$L7721

; 750  :                // We only care about keys...
; 751  :                if ( lpViewAttrib->bKey == FALSE )

	mov	edx, DWORD PTR _lpViewAttrib$7712[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $L7722

; 752  :                   continue;

	jmp	SHORT $L7720
$L7722:

; 753  : 
; 754  :                if ( bFirstKey )

	mov	ecx, DWORD PTR _bFirstKey$7714[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L7723

; 755  :                   bFirstKey = FALSE;

	mov	BYTE PTR _bFirstKey$7714[ebp], 0

; 756  :                else

	jmp	SHORT $L7724
$L7723:

; 758  :                   CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_CreateEntity@12

; 759  :                   SetAttributeFromString( vView, pchQualEntity, "Oper", "AND" );

	push	OFFSET FLAT:??_C@_03LACO@AND?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L7724:

; 761  : 
; 762  :                CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 763  :                SetAttributeFromString( vView, pchQualEntity, "EntityName",
; 764  :                                        pchSourceEntityName );

	mov	edx, DWORD PTR _pchSourceEntityName$7697[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 765  :                SetAttributeFromString( vView, pchQualEntity, "AttributeName",
; 766  :                                        lpViewAttrib->szName );

	mov	edx, DWORD PTR _lpViewAttrib$7712[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_0O@JICG@AttributeName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 767  :                SetAttributeFromString( vView, pchQualEntity, "Oper", "=" );

	push	OFFSET FLAT:??_C@_01KPOD@?$DN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 768  :                SetAttributeFromAttribute( vView, pchQualEntity, "Value",
; 769  :                                           vSourceView, pchSourceEntityName,
; 770  :                                           lpViewAttrib->szName );

	mov	ecx, DWORD PTR _lpViewAttrib$7712[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _pchSourceEntityName$7697[ebp]
	push	edx
	mov	eax, DWORD PTR _vSourceView$7695[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_05KBGO@Value?$AA@	; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromAttribute@24

; 771  :             } // for...

	jmp	$L7720
$L7721:

; 772  : 
; 773  :             CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 774  :             SetAttributeFromString( vView, pchQualEntity, "Oper", ")" );

	push	OFFSET FLAT:??_C@_01KMMP@?$CJ?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 775  : 
; 776  :             DeleteEntity( vTemp, pchQualEntity, zREPOS_NONE );

	push	0
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTemp$7713[ebp]
	push	edx
	call	_DeleteEntity@12

; 777  :             DropView( vTemp );

	mov	eax, DWORD PTR _vTemp$7713[ebp]
	push	eax
	call	_DropView@4

; 778  : 
; 779  :             // We've done all that needs to be done, so process the next
; 780  :             // qual entity.
; 781  :             continue;

	jmp	$L7693
$L7709:

; 784  : 
; 785  :          // Copy attribute value from the source view to the qual view.
; 786  :          SetAttributeFromAttribute( vView, pchQualEntity, "Value",
; 787  :                                     vSourceView, pchSourceEntityName,
; 788  :                                     pchSourceAttributeName );

	mov	ecx, DWORD PTR _pchSourceAttributeName$7698[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchSourceEntityName$7697[ebp]
	push	edx
	mov	eax, DWORD PTR _vSourceView$7695[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_05KBGO@Value?$AA@	; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromAttribute@24

; 789  : 
; 790  :          // Set the qual attrib to be null.
; 791  :          SetAttributeFromString( vView, pchQualEntity, "SourceViewName", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0P@FPPG@SourceViewName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 792  :          SetAttributeFromInteger( vView, pchQualEntity, "SourceViewID", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0N@NIIK@SourceViewID?$AA@ ; `string'
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 793  :          SetAttributeFromString( vView, pchQualEntity, "SourceEntityName", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BB@CPOO@SourceEntityName?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 794  :          SetAttributeFromString( vView, pchQualEntity, "SourceAttributeName", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BE@ICOG@SourceAttributeName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 795  : 
; 796  :       } // for each pchQualEntity...

	jmp	$L7693
$L7694:

; 797  : 
; 798  :    } // for each "EntitySpec"...

	jmp	$L7689
$L7690:

; 799  : 
; 800  : } // fnResolveQualOI

	mov	esp, ebp
	pop	ebp
	ret	0
_fnResolveQualOI ENDP
_TEXT	ENDS
PUBLIC	_fnSetLockingAttributes@36
PUBLIC	??_C@_08GDMG@LOD_Name?$AA@			; `string'
PUBLIC	??_C@_08GOHN@KeyValue?$AA@			; `string'
PUBLIC	??_C@_08BJPE@UserName?$AA@			; `string'
PUBLIC	??_C@_09KMOL@Timestamp?$AA@			; `string'
PUBLIC	??_C@_09NCPC@AllowRead?$AA@			; `string'
EXTRN	_SysGetUserID@12:NEAR
EXTRN	_fnSetAttributeFromVariable:NEAR
EXTRN	_strcmp:NEAR
EXTRN	_SysGetDateTime@4:NEAR
;	COMDAT ??_C@_08GDMG@LOD_Name?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_08GDMG@LOD_Name?$AA@ DB 'LOD_Name', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GOHN@KeyValue?$AA@
_DATA	SEGMENT
??_C@_08GOHN@KeyValue?$AA@ DB 'KeyValue', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08BJPE@UserName?$AA@
_DATA	SEGMENT
??_C@_08BJPE@UserName?$AA@ DB 'UserName', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KMOL@Timestamp?$AA@
_DATA	SEGMENT
??_C@_09KMOL@Timestamp?$AA@ DB 'Timestamp', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09NCPC@AllowRead?$AA@
_DATA	SEGMENT
??_C@_09NCPC@AllowRead?$AA@ DB 'AllowRead', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_vLock$ = 12
_lpLockEntity$ = 16
_lpLockEntityCsr$ = 20
_pchLOD_Name$ = 24
_pchKeyString$ = 28
_bSetUserName$ = 32
_bSetTimestamp$ = 36
_pchAllowRead$ = 40
_lpViewAttrib$ = -8
_nCnt$ = -4
_szUserName$7793 = -40
_szPassword$7794 = -72
_szDateTime$7807 = -104
_fnSetLockingAttributes@36 PROC NEAR

; 812  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 813  :    LPVIEWATTRIB lpViewAttrib;
; 814  :    zSHORT       nCnt = 0;

	mov	WORD PTR _nCnt$[ebp], 0

; 815  : 
; 816  :    // Loop through each of the attributes in the lock OI.  When we find
; 817  :    // one we want set it.  To keep us from looping unnecessarily we keep
; 818  :    // track of the # of attributes we set.  When we get to 5 we're done.
; 819  :    for ( lpViewAttrib = zGETPTR( lpLockEntity->hFirstOD_Attrib );
; 820  :          lpViewAttrib && nCnt < 5;
; 821  :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpLockEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L7759
$L7760:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L7759:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L7761
	movsx	ecx, WORD PTR _nCnt$[ebp]
	cmp	ecx, 5
	jge	$L7761

; 823  :       if ( zstrcmp( lpViewAttrib->szName, "LOD_Name" ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	movsx	ecx, BYTE PTR ??_C@_08GDMG@LOD_Name?$AA@
	cmp	eax, ecx
	jne	SHORT $L12727
	push	OFFSET FLAT:??_C@_08GDMG@LOD_Name?$AA@	; `string'
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -108+[ebp], eax
	jmp	SHORT $L12728
$L12727:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR ??_C@_08GDMG@LOD_Name?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -108+[ebp], eax
$L12728:
	cmp	DWORD PTR -108+[ebp], 0
	jne	SHORT $L7768

; 825  :          nCnt++;

	mov	cx, WORD PTR _nCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nCnt$[ebp], cx

; 826  : 
; 827  :          if ( pchLOD_Name &&
; 828  :               fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 829  :                                           lpViewAttrib,
; 830  :                                           (zPVOID) pchLOD_Name, 'S', 0, 0,
; 831  :                                           lpCurrentTask, 0 ) != 0 )

	cmp	DWORD PTR _pchLOD_Name$[ebp], 0
	je	SHORT $L7771
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchLOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7771

; 833  :             return( zCALL_ERROR ); // error setting attribute

	mov	ax, -16					; fffffff0H
	jmp	$L7754
$L7771:

; 836  :       else

	jmp	$L7820
$L7768:

; 837  :       if ( zstrcmp( lpViewAttrib->szName, "KeyValue" ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	movsx	ecx, BYTE PTR ??_C@_08GOHN@KeyValue?$AA@
	cmp	eax, ecx
	jne	SHORT $L12729
	push	OFFSET FLAT:??_C@_08GOHN@KeyValue?$AA@	; `string'
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -112+[ebp], eax
	jmp	SHORT $L12730
$L12729:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR ??_C@_08GOHN@KeyValue?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -112+[ebp], eax
$L12730:
	cmp	DWORD PTR -112+[ebp], 0
	jne	SHORT $L7779

; 839  :          nCnt++;

	mov	cx, WORD PTR _nCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nCnt$[ebp], cx

; 840  : 
; 841  :          if ( fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 842  :                                           lpViewAttrib,
; 843  :                                           (zPVOID) pchKeyString, 'S',
; 844  :                                           0, 0, lpCurrentTask, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchKeyString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7782

; 846  :             return( zCALL_ERROR ); // error setting attribute

	mov	ax, -16					; fffffff0H
	jmp	$L7754
$L7782:

; 849  :       else

	jmp	$L7820
$L7779:

; 850  :       if ( zstrcmp( lpViewAttrib->szName, "UserName" ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	movsx	ecx, BYTE PTR ??_C@_08BJPE@UserName?$AA@
	cmp	eax, ecx
	jne	SHORT $L12731
	push	OFFSET FLAT:??_C@_08BJPE@UserName?$AA@	; `string'
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -116+[ebp], eax
	jmp	SHORT $L12732
$L12731:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR ??_C@_08BJPE@UserName?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -116+[ebp], eax
$L12732:
	cmp	DWORD PTR -116+[ebp], 0
	jne	SHORT $L7790

; 852  :          nCnt++;

	mov	cx, WORD PTR _nCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nCnt$[ebp], cx

; 853  : 
; 854  :          if ( bSetUserName )

	mov	edx, DWORD PTR _bSetUserName$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L7796

; 856  :             zCHAR szUserName[ 30 ];
; 857  :             zCHAR szPassword[ 30 ];
; 858  : 
; 859  :             SysGetUserID( vLock, szUserName, szPassword );

	lea	eax, DWORD PTR _szPassword$7794[ebp]
	push	eax
	lea	ecx, DWORD PTR _szUserName$7793[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_SysGetUserID@12

; 860  :             if ( fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 861  :                                              lpViewAttrib,
; 862  :                                              (zPVOID) szUserName, 'S',
; 863  :                                              0, 0, lpCurrentTask, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	83					; 00000053H
	lea	ecx, DWORD PTR _szUserName$7793[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L7796

; 865  :                return( zCALL_ERROR ); // error setting attribute

	mov	ax, -16					; fffffff0H
	jmp	$L7754
$L7796:

; 869  :       else

	jmp	$L7820
$L7790:

; 870  :       if ( zstrcmp( lpViewAttrib->szName, "Timestamp" ) == 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR ??_C@_09KMOL@Timestamp?$AA@
	cmp	ecx, edx
	jne	SHORT $L12733
	push	OFFSET FLAT:??_C@_09KMOL@Timestamp?$AA@	; `string'
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -120+[ebp], eax
	jmp	SHORT $L12734
$L12733:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	movsx	eax, BYTE PTR ??_C@_09KMOL@Timestamp?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -120+[ebp], ecx
$L12734:
	cmp	DWORD PTR -120+[ebp], 0
	jne	SHORT $L7804

; 872  :          nCnt++;

	mov	dx, WORD PTR _nCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nCnt$[ebp], dx

; 873  : 
; 874  :          if ( bSetTimestamp )

	mov	eax, DWORD PTR _bSetTimestamp$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L7809

; 876  :             zCHAR szDateTime[ 30 ];
; 877  : 
; 878  :             SysGetDateTime( szDateTime );

	lea	ecx, DWORD PTR _szDateTime$7807[ebp]
	push	ecx
	call	_SysGetDateTime@4

; 879  :             if ( fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 880  :                                              lpViewAttrib,
; 881  :                                              (zPVOID) szDateTime, 'S',
; 882  :                                              0, 0, lpCurrentTask, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	lea	eax, DWORD PTR _szDateTime$7807[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7809

; 884  :                return( zCALL_ERROR ); // error setting attribute

	mov	ax, -16					; fffffff0H
	jmp	$L7754
$L7809:

; 888  :       else

	jmp	$L7820
$L7804:

; 889  :       if ( zstrcmp( lpViewAttrib->szName, "AllowRead" ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	movsx	ecx, BYTE PTR ??_C@_09NCPC@AllowRead?$AA@
	cmp	eax, ecx
	jne	SHORT $L12735
	push	OFFSET FLAT:??_C@_09NCPC@AllowRead?$AA@	; `string'
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -124+[ebp], eax
	jmp	SHORT $L12736
$L12735:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR ??_C@_09NCPC@AllowRead?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -124+[ebp], eax
$L12736:
	cmp	DWORD PTR -124+[ebp], 0
	jne	SHORT $L7820

; 891  :          nCnt++;

	mov	cx, WORD PTR _nCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nCnt$[ebp], cx

; 892  : 
; 893  :          if ( pchAllowRead &&
; 894  :               fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 895  :                                           lpViewAttrib,
; 896  :                                           (zPVOID) pchAllowRead, 'S',
; 897  :                                           0, 0, lpCurrentTask, 0 ) != 0 )

	cmp	DWORD PTR _pchAllowRead$[ebp], 0
	je	SHORT $L7820
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchAllowRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7820

; 899  :             return( zCALL_ERROR ); // error setting attribute

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L7754
$L7820:

; 902  : 
; 903  :    } // for each lpViewAttrib...

	jmp	$L7760
$L7761:

; 904  : 
; 905  :    return( 0 );

	xor	ax, ax
$L7754:

; 906  : 
; 907  : } // fnSetLockingAttributes

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_fnSetLockingAttributes@36 ENDP
_TEXT	ENDS
PUBLIC	_fnCommitObjectInstance@28
PUBLIC	_fnCreatePessimisticSemaphore@20
PUBLIC	??_C@_07KIPN@ZPLOCKO?$AA@			; `string'
PUBLIC	??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@	; `string'
PUBLIC	??_C@_03IMFF@?$CD?$CFs?$AA@			; `string'
PUBLIC	??_C@_0L@PIFJ@ZeidonLock?$AA@			; `string'
PUBLIC	??_C@_01OAK@N?$AA@				; `string'
PUBLIC	??_C@_0BC@JGEA@Locking?5semaphore?$AA@		; `string'
PUBLIC	??_C@_0DE@IKDC@Waited?5too?5long?5to?5write?5pessimi@ ; `string'
EXTRN	_fnSysMessageBox@16:NEAR
EXTRN	__imp__sprintf:NEAR
EXTRN	_fnValidViewEntity@16:NEAR
EXTRN	_SysWait@4:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_SetCursorFirstEntityByString@20:NEAR
EXTRN	_fnCreateEntity@20:NEAR
EXTRN	_fnSysLockCoreMutex@4:NEAR
EXTRN	_fnSysUnlockCoreMutex@4:NEAR
EXTRN	_szlOE_SystemError:DWORD
;	COMDAT ??_C@_07KIPN@ZPLOCKO?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_07KIPN@ZPLOCKO?$AA@ DB 'ZPLOCKO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@
_DATA	SEGMENT
??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@ DB '#Global Entity Lock', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IMFF@?$CD?$CFs?$AA@
_DATA	SEGMENT
??_C@_03IMFF@?$CD?$CFs?$AA@ DB '#%s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@PIFJ@ZeidonLock?$AA@
_DATA	SEGMENT
??_C@_0L@PIFJ@ZeidonLock?$AA@ DB 'ZeidonLock', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_01OAK@N?$AA@
_DATA	SEGMENT
??_C@_01OAK@N?$AA@ DB 'N', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@JGEA@Locking?5semaphore?$AA@
_DATA	SEGMENT
??_C@_0BC@JGEA@Locking?5semaphore?$AA@ DB 'Locking semaphore', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DE@IKDC@Waited?5too?5long?5to?5write?5pessimi@
_DATA	SEGMENT
??_C@_0DE@IKDC@Waited?5too?5long?5to?5write?5pessimi@ DB 'Waited too long'
	DB	' to write pessimistic lock semaphore', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpArray$ = 12
_nViewCount$ = 16
_pnViewErrorIdx$ = 20
_vSubtask$ = 24
_vLock$ = -20
_lpLockEntity$ = -24
_lpLockEntityCsr$ = -164
_lpEntityInstance$ = -84
_lpViewCluster$ = -88
_tViewArrayBlock$ = -152
_szLockName$ = -80
_bGlobalLockCreated$ = -8
_bArrayIsViewList$ = -12
_bMutexLocked$ = -168
_bCreateSemaphore$ = -4
_nCommit$ = -156
_k$ = -160
_nRC$ = -28
_lpViewOD$7860 = -172
_fnCreatePessimisticSemaphore@20 PROC NEAR

; 924  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	edi

; 925  :    ViewClusterRecord vLock;
; 926  :    LPVIEWENTITY      lpLockEntity;
; 927  :    LPVIEWENTITYCSR   lpLockEntityCsr;
; 928  :    LPENTITYINSTANCE  lpEntityInstance;
; 929  :    LPVIEWCLUSTER     lpViewCluster;
; 930  :    VIEWARRAYBLOCK    tViewArrayBlock = { 0 };

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	mov	ecx, 15					; 0000000fH
	xor	eax, eax
	lea	edi, DWORD PTR _tViewArrayBlock$[ebp+4]
	rep stosd

; 931  :    zCHAR             szLockName[ 50 ];
; 932  :    zBOOL             bGlobalLockCreated = FALSE;

	mov	BYTE PTR _bGlobalLockCreated$[ebp], 0

; 933  :    zBOOL             bArrayIsViewList;
; 934  :    zBOOL             bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$[ebp], 0

; 935  :    zBOOL             bCreateSemaphore;
; 936  :    zSHORT            nCommit;
; 937  :    zSHORT            k;
; 938  :    zSHORT            nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 939  : 
; 940  :    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 941  :    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 942  : 
; 943  :    if ( vSubtask == 0 )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	jne	SHORT $L7847

; 945  :       bArrayIsViewList = TRUE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 1

; 946  :       lpViewCluster = (LPVIEWCLUSTER) lpArray;

	mov	eax, DWORD PTR _lpArray$[ebp]
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 947  : 
; 948  :       // vSubtask is just the first valid view in the list.
; 949  :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L7849
$L7850:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L7849:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $L7851

; 951  :          if ( lpViewCluster[ k ].vOI )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	je	SHORT $L7852

; 953  :             vSubtask = lpViewCluster[ k ].vOI;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _vSubtask$[ebp], edx

; 954  :             break;

	jmp	SHORT $L7851
$L7852:

; 956  :       }

	jmp	SHORT $L7850
$L7851:

; 958  :    else

	jmp	SHORT $L7853
$L7847:

; 959  :       bArrayIsViewList = FALSE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 0
$L7853:

; 960  : 
; 961  :    // Create an empty lock OI.
; 962  :    if ( fnDeclareView( &vLock.vOI, lpCurrentTask, vSubtask, "ZPLOCKO", 0 ) != 0 )

	push	0
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDeclareView@20
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7854

; 963  :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7832
$L7854:

; 964  : 
; 965  :    if ( fnActivateEmptyObjectInstance( lpCurrentTask, vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7856

; 966  :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7832
$L7856:

; 967  : 
; 968  :    // It's possible that the user wants to keep the locks for all the views.
; 969  :    // Following flag is TRUE if there is a least one lock.
; 970  :    bCreateSemaphore = FALSE;

	mov	BYTE PTR _bCreateSemaphore$[ebp], 0

; 971  : 
; 972  :    // Loop through all the views and set a lock.
; 973  :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L7857
$L7858:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L7857:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$L7859

; 975  :       LPVIEWOD lpViewOD;
; 976  : 
; 977  :       if ( bArrayIsViewList )

	mov	ecx, DWORD PTR _bArrayIsViewList$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L7861

; 979  :          if ( lpViewCluster[ k ].vOI == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	jne	SHORT $L7862

; 980  :             continue;

	jmp	SHORT $L7858
$L7862:

; 981  : 
; 982  :          // If we're keeping locks on this guy then skip him.
; 983  :          if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $L7863

; 984  :             continue;

	jmp	SHORT $L7858
$L7863:

; 985  : 
; 986  :          // Get ViewOD from view.
; 987  :          lpViewOD = zGETPTR( lpViewCluster[ k ].vOI->hViewOD );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$7860[ebp], eax

; 989  :       else

	jmp	SHORT $L7865
$L7861:

; 991  :          if ( lpArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L7866

; 992  :             continue;

	jmp	$L7858
$L7866:

; 993  : 
; 994  :          lpViewOD = (LPVIEWOD) lpArray[ k ];

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _lpViewOD$7860[ebp], eax
$L7865:

; 996  : 
; 997  :       // If this ViewOD doesn't have any locking (which is possible if we're
; 998  :       // committing a cluster) then we can skip it.
; 999  :       if ( lpViewOD->nLock       < zLL_PESSIMISTIC &&
; 1000 :            lpViewOD->nEntityLock < zLL_PESSIMISTIC )

	mov	ecx, DWORD PTR _lpViewOD$7860[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 3
	jge	SHORT $L7868
	mov	eax, DWORD PTR _lpViewOD$7860[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+237]
	cmp	ecx, 3
	jge	SHORT $L7868

; 1002 :          continue;

	jmp	$L7858
$L7868:

; 1004 : 
; 1005 :       bCreateSemaphore = TRUE;

	mov	BYTE PTR _bCreateSemaphore$[ebp], 1

; 1006 : 
; 1007 :       // Set lock name.  If OD does not have pessimistic locking at the entity
; 1008 :       // level then it's safe to lock out other users trying to lock the same
; 1009 :       // OD.  This allows us to use the entity name for the locking semaphore.
; 1010 :       // If the OD has entity locking we need to use a "global" entity locking
; 1011 :       // semaphore so that no one can lock entities at the same time.
; 1012 :       if ( lpViewOD->nEntityLock )

	mov	edx, DWORD PTR _lpViewOD$7860[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+237]
	test	eax, eax
	je	SHORT $L7869

; 1014 :          // If we've already created the global lock entity just continue.
; 1015 :          if ( bGlobalLockCreated )

	mov	ecx, DWORD PTR _bGlobalLockCreated$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L7870

; 1016 :             continue;

	jmp	$L7858
$L7870:

; 1017 : 
; 1018 :          bGlobalLockCreated = TRUE;

	mov	BYTE PTR _bGlobalLockCreated$[ebp], 1

; 1019 : 
; 1020 :          // We are using entity level locking.
; 1021 :          zstrcpy( szLockName, "#Global Entity Lock" );

	push	OFFSET FLAT:??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@ ; `string'
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1023 :       else

	jmp	SHORT $L7872
$L7869:

; 1024 :          // We are not using entity level locking so we can just lock out other
; 1025 :          // users using the same LOD.  We prefix the name with a '#' to to
; 1026 :          // indicate that this is the locking semaphore.
; 1027 :          zsprintf( szLockName, "#%s", lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$7860[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_03IMFF@?$CD?$CFs?$AA@	; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L7872:

; 1028 : 
; 1029 :       // Check to make sure we're not already setting the lock for this type.
; 1030 :       if ( SetCursorFirstEntityByString( vLock.vOI, "ZeidonLock", "LOD_Name",
; 1031 :                                          szLockName, 0 ) >= zCURSOR_SET )

	push	0
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08GDMG@LOD_Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jl	SHORT $L7874

; 1033 :          continue;

	jmp	$L7858
$L7874:

; 1035 : 
; 1036 :       // Get the lpViewEntity and lpLockEntityCsr for the lock OI.
; 1037 :       lpLockEntity = fnValidViewEntity( &lpLockEntityCsr, vLock.vOI,
; 1038 :                                         "ZeidonLock", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpLockEntity$[ebp], eax

; 1039 : 
; 1040 :       if ( fnCreateEntity( vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1041 :                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnCreateEntity@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7877

; 1043 :          goto EndOfFunction;

	jmp	$EndOfFunction$7878
$L7877:

; 1045 : 
; 1046 :       // fnCreateEntity DOES NOT set the bCreated flag so set it.
; 1047 :       lpEntityInstance = zGETPTR( lpLockEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1048 :       lpEntityInstance->u.nInd.bCreated = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 2
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 1049 : 
; 1050 :       // Set entity name and key string (which is just a description).
; 1051 :       if ( fnSetLockingAttributes( lpCurrentTask,
; 1052 :                                    vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1053 :                                    szLockName, "Locking semaphore",
; 1054 :                                    TRUE, TRUE, "N" ) != 0 )

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	1
	push	1
	push	OFFSET FLAT:??_C@_0BC@JGEA@Locking?5semaphore?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnSetLockingAttributes@36
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7880

; 1055 :          goto EndOfFunction;

	jmp	$EndOfFunction$7878
$L7880:

; 1056 : 
; 1057 :    } // for ( k... )...

	jmp	$L7858
$L7859:

; 1058 : 
; 1059 :    // If we didn't find any views that needed to drop their locks then get out.
; 1060 :    if ( bCreateSemaphore == FALSE )

	mov	ecx, DWORD PTR _bCreateSemaphore$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L7883

; 1061 :       return( 1 );

	mov	ax, 1
	jmp	$L7832
$L7883:

; 1062 : 
; 1063 :    // Now lock the pessimistic semaphore.  This will hopefully single-thread
; 1064 :    // creation of the semaphore.  It doesn't really do anything if we are
; 1065 :    // running as simple client-server.
; 1066 :    zLOCK_MUTEX( zMUTEX_PESSIMISTICLOCK );

	push	9
	call	_fnSysLockCoreMutex@4

; 1067 :    bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$[ebp], 1

; 1068 : 
; 1069 :    // Now commit the lock OI.  This should set the semaphore lock.  We'll try
; 1070 :    // a few times before giving up.
; 1071 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7884

; 1072 :       goto EndOfFunction;

	jmp	$EndOfFunction$7878
$L7884:

; 1073 : 
; 1074 :    for ( k = 0; k < 10; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L7885
$L7886:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L7885:
	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 10					; 0000000aH
	jge	SHORT $L7887

; 1076 :       // Try committing the semaphore.  If the return code indicates that
; 1077 :       // we have a duplicate root then somebody else is working with the
; 1078 :       // lock object so try again.
; 1079 :       nCommit = fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0,
; 1080 :                                         lpCurrentTask, 0, &tViewArrayBlock );

	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	1
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnCommitObjectInstance@28
	mov	WORD PTR _nCommit$[ebp], ax

; 1081 :       if ( nCommit == 0 )

	movsx	ecx, WORD PTR _nCommit$[ebp]
	test	ecx, ecx
	jne	SHORT $L7888

; 1082 :          break;               // Everything OK.

	jmp	SHORT $L7887
$L7888:

; 1083 : 
; 1084 :       if ( nCommit == zDUPLICATE_ROOT )

	movsx	edx, WORD PTR _nCommit$[ebp]
	cmp	edx, -4					; fffffffcH
	jne	SHORT $L7889

; 1086 :          SysWait( 1000 );     // Wait a second.

	push	1000					; 000003e8H
	call	_SysWait@4

; 1087 :          continue;            // Try again.

	jmp	SHORT $L7886
$L7889:

; 1089 : 
; 1090 :       // Oops--there must be something wrong.  Get out.
; 1091 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$7878
$L7887:

; 1093 : 
; 1094 :    // If nCommit isn't 0 then we had problems trying to write the semaphore
; 1095 :    // record.  Show error and get out.
; 1096 :    if ( nCommit )

	movsx	eax, WORD PTR _nCommit$[ebp]
	test	eax, eax
	je	SHORT $L7890

; 1098 :       fnSysMessageBox( lpCurrentTask, szlOE_SystemError,
; 1099 :                        "Waited too long to write pessimistic lock semaphore", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0DE@IKDC@Waited?5too?5long?5to?5write?5pessimi@ ; `string'
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16

; 1100 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$7878
$L7890:

; 1102 : 
; 1103 :    // Set flag indicating that current task has written locking semaphore.
; 1104 :    lpCurrentTask->bPessimisticLockingSet = TRUE;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	or	ch, 1
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [edx+443], ecx

; 1105 : 
; 1106 :    // If we get here everything's OK.
; 1107 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$7878:

; 1108 : 
; 1109 : EndOfFunction:
; 1110 :    // If something went wrong then unlock the mutex.
; 1111 :    if ( nRC && bMutexLocked )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L7892
	mov	ecx, DWORD PTR _bMutexLocked$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L7892

; 1112 :       zUNLOCK_MUTEX( zMUTEX_PESSIMISTICLOCK );

	push	9
	call	_fnSysUnlockCoreMutex@4
$L7892:

; 1113 : 
; 1114 :    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $L7893

; 1115 :       fnDropView( vLock.vOI );

	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDropView@4
$L7893:

; 1116 : 
; 1117 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 1118 : 
; 1119 :    if ( nRC == zCALL_ERROR && pnViewErrorIdx )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $L7894
	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L7894

; 1120 :       *pnViewErrorIdx = k;

	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	ax, WORD PTR _k$[ebp]
	mov	WORD PTR [edx], ax
$L7894:

; 1121 : 
; 1122 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L7832:

; 1123 : 
; 1124 : } // fnCreatePessimisticSemaphore

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnCreatePessimisticSemaphore@20 ENDP
_TEXT	ENDS
PUBLIC	_fnDeletePessimisticSemaphore@20
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpArray$ = 12
_nViewCount$ = 16
_pnViewErrorIdx$ = 20
_vSubtask$ = 24
_vLock$ = -12
_szLockName$ = -76
_lpLockEntity$ = -16
_lpLockEntityCsr$ = -152
_lpEntityInstance$ = -24
_lpViewCluster$ = -80
_tViewArrayBlock$ = -144
_bArrayIsViewList$ = -4
_k$ = -148
_nRC$ = -20
_lpViewOD$7929 = -156
_fnDeletePessimisticSemaphore@20 PROC NEAR

; 1132 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	edi

; 1133 :    ViewClusterRecord vLock;
; 1134 :    zCHAR             szLockName[ 50 ];
; 1135 :    LPVIEWENTITY      lpLockEntity;
; 1136 :    LPVIEWENTITYCSR   lpLockEntityCsr;
; 1137 :    LPENTITYINSTANCE  lpEntityInstance;
; 1138 :    LPVIEWCLUSTER     lpViewCluster;
; 1139 :    VIEWARRAYBLOCK    tViewArrayBlock = {0};

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	mov	ecx, 15					; 0000000fH
	xor	eax, eax
	lea	edi, DWORD PTR _tViewArrayBlock$[ebp+4]
	rep stosd

; 1140 :    zBOOL             bArrayIsViewList;
; 1141 :    zSHORT            k;
; 1142 :    zSHORT            nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 1143 : 
; 1144 :    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 1145 :    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 1146 : 
; 1147 :    if ( vSubtask == 0 )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	jne	SHORT $L7917

; 1149 :       bArrayIsViewList = TRUE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 1

; 1150 :       lpViewCluster = (LPVIEWCLUSTER) lpArray;

	mov	eax, DWORD PTR _lpArray$[ebp]
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 1151 : 
; 1152 :       // vSubtask is just the first valid view in the list.
; 1153 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L7919
$L7920:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L7919:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $L7921

; 1155 :          if ( lpViewCluster[ k ].vOI )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	je	SHORT $L7922

; 1157 :             vSubtask = lpViewCluster[ k ].vOI;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _vSubtask$[ebp], edx

; 1158 :             break;

	jmp	SHORT $L7921
$L7922:

; 1160 :       }

	jmp	SHORT $L7920
$L7921:

; 1162 :    else

	jmp	SHORT $L7923
$L7917:

; 1163 :       bArrayIsViewList = FALSE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 0
$L7923:

; 1164 : 
; 1165 :    // Create an empty lock OI.
; 1166 :    if ( fnDeclareView( &vLock.vOI, lpCurrentTask, vSubtask, "ZPLOCKO", 0 ) != 0 )

	push	0
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDeclareView@20
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7924

; 1167 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7906
$L7924:

; 1168 : 
; 1169 :    if ( fnActivateEmptyObjectInstance( lpCurrentTask, vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7925

; 1170 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7906
$L7925:

; 1171 : 
; 1172 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L7926
$L7927:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L7926:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$L7928

; 1174 :       LPVIEWOD lpViewOD;
; 1175 : 
; 1176 :       if ( bArrayIsViewList )

	mov	ecx, DWORD PTR _bArrayIsViewList$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L7930

; 1178 :          if ( lpViewCluster[ k ].vOI == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	jne	SHORT $L7931

; 1179 :             continue;

	jmp	SHORT $L7927
$L7931:

; 1180 : 
; 1181 :          // If we're keeping locks on this guy then skip him.
; 1182 :          if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $L7932

; 1183 :             continue;

	jmp	SHORT $L7927
$L7932:

; 1184 : 
; 1185 :          // Get ViewOD from view.
; 1186 :          lpViewOD = zGETPTR( lpViewCluster[ k ].vOI->hViewOD );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$7929[ebp], eax

; 1188 :       else

	jmp	SHORT $L7934
$L7930:

; 1190 :          if ( lpArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L7935

; 1191 :             continue;

	jmp	$L7927
$L7935:

; 1192 : 
; 1193 :          lpViewOD = (LPVIEWOD) lpArray[ k ];

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _lpViewOD$7929[ebp], eax
$L7934:

; 1195 : 
; 1196 :       // If this ViewOD doesn't have any locking (which is possible if we're
; 1197 :       // committing a cluster) then we can skip it.
; 1198 :       if ( lpViewOD->nLock       < zLL_PESSIMISTIC &&
; 1199 :            lpViewOD->nEntityLock < zLL_PESSIMISTIC )

	mov	ecx, DWORD PTR _lpViewOD$7929[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 3
	jge	SHORT $L7937
	mov	eax, DWORD PTR _lpViewOD$7929[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+237]
	cmp	ecx, 3
	jge	SHORT $L7937

; 1201 :          continue;

	jmp	$L7927
$L7937:

; 1203 : 
; 1204 :       // Set lock name.  If OD does not have pessimistic locking at the entity
; 1205 :       // level then it's safe to lock out other users trying to lock the same
; 1206 :       // OD.  This allows us to use the entity name for the locking semaphore.
; 1207 :       // If the OD has entity locking we need to use a "global" entity locking
; 1208 :       // semaphore so that no one can lock entities at the same time.
; 1209 :       if ( lpViewOD->nEntityLock )

	mov	edx, DWORD PTR _lpViewOD$7929[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+237]
	test	eax, eax
	je	SHORT $L7938

; 1211 :          // We are using entity level locking.
; 1212 :          zstrcpy( szLockName, "#Global Entity Lock" );

	push	OFFSET FLAT:??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1214 :       else

	jmp	SHORT $L7939
$L7938:

; 1216 :          // We are not using entity level locking so we can just lock out other
; 1217 :          // users using the same LOD.  We prefix the name with a '#' to to
; 1218 :          // indicate that this is the locking semaphore.
; 1219 :          zsprintf( szLockName, "#%s", lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$7929[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_03IMFF@?$CD?$CFs?$AA@	; `string'
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L7939:

; 1221 : 
; 1222 :       // Get the lpViewEntity and lpLockEntityCsr for the lock OI.
; 1223 :       lpLockEntity = fnValidViewEntity( &lpLockEntityCsr, vLock.vOI,
; 1224 :                                         "ZeidonLock", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpLockEntity$[ebp], eax

; 1225 : 
; 1226 :       if ( fnCreateEntity( vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1227 :                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLockEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCreateEntity@20
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7941

; 1229 :          goto EndOfFunction;

	jmp	$EndOfFunction$7942
$L7941:

; 1231 : 
; 1232 :       // Set entity name and key string (which is just a description).
; 1233 :       if ( fnSetLockingAttributes( lpCurrentTask,
; 1234 :                                    vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1235 :                                    szLockName, "Locking semaphore",
; 1236 :                                    0, 0, 0 ) != 0 )

	push	0
	push	0
	push	0
	push	OFFSET FLAT:??_C@_0BC@JGEA@Locking?5semaphore?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnSetLockingAttributes@36
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7943

; 1238 :          goto EndOfFunction;

	jmp	$EndOfFunction$7942
$L7943:

; 1240 : 
; 1241 :       // Here's where we cheat -- turn off Create flag and turn on the
; 1242 :       // Delete/Hidden flags so that when we commit the OI the locking
; 1243 :       // records will be deleted.
; 1244 :       lpEntityInstance = zGETPTR( lpLockEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1245 :       lpEntityInstance->u.nInd.bCreated = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 1246 :       lpEntityInstance->u.nInd.bDeleted = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 8
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 1247 :       lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ch, 4
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 1248 :    }

	jmp	$L7927
$L7928:

; 1249 : 
; 1250 :    // Set flag indicating that current task no longer has a locking semaphore.
; 1251 :    lpCurrentTask->bPessimisticLockingSet = FALSE;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	and	ch, -2					; fffffffeH
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [edx+443], ecx

; 1252 : 
; 1253 :    // Now commit the lock OI.  This should release the semaphore lock.
; 1254 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7945

; 1255 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$7942
$L7945:

; 1256 : 
; 1257 :    if ( fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0, lpCurrentTask,
; 1258 :                                 0, &tViewArrayBlock ) != 0 )

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	1
	lea	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCommitObjectInstance@28
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7946

; 1260 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$7942
$L7946:

; 1262 : 
; 1263 :    // If we get here everything's OK.
; 1264 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$7942:

; 1265 : 
; 1266 : EndOfFunction:
; 1267 :    zUNLOCK_MUTEX( zMUTEX_PESSIMISTICLOCK );

	push	9
	call	_fnSysUnlockCoreMutex@4

; 1268 : 
; 1269 :    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $L7947

; 1270 :       fnDropView( vLock.vOI );

	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnDropView@4
$L7947:

; 1271 : 
; 1272 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 1273 : 
; 1274 :    if ( nRC == zCALL_ERROR && pnViewErrorIdx )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L7948
	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L7948

; 1275 :       *pnViewErrorIdx = k;

	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	dx, WORD PTR _k$[ebp]
	mov	WORD PTR [ecx], dx
$L7948:

; 1276 : 
; 1277 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L7906:

; 1278 : 
; 1279 : } // fnDeletePessimisticSemaphore

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnDeletePessimisticSemaphore@20 ENDP
_TEXT	ENDS
PUBLIC	_fnRelinkObjectInstance@4
EXTRN	_fnEstablishViewForInstance:NEAR
EXTRN	_fnIncludeSubobjectFromSubobject:NEAR
EXTRN	_fnInstanceKeysMatch:NEAR
EXTRN	_fnRelinkInstanceToInstance:NEAR
_TEXT	SEGMENT
_lpView$ = 8
_lpViewEntity$ = -28
_lpViewOD$ = -8
_lpViewCsr$ = -4
_lpViewOI$ = -32
_lpRootInstance$ = -24
_lpEntityInstance$ = -20
_lpSearchInstance$ = -16
_nRC$ = -12
_lpDupEntityInstance$7967 = -36
_lpSearchViewEntity$7980 = -40
_hDupRelParent$7992 = -44
_lpParentInstance$7993 = -48
_lpSearchInstance$7999 = -56
_lpSourceInstance$8000 = -52
_lpSourceEntity$8006 = -60
_lpViewEntityCsr$8007 = -64
_fnRelinkObjectInstance@4 PROC NEAR

; 1301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1302 :    LPVIEWENTITY      lpViewEntity;
; 1303 :    LPVIEWOD          lpViewOD;
; 1304 :    LPVIEWCSR         lpViewCsr;
; 1305 :    LPVIEWOI          lpViewOI;
; 1306 :    LPENTITYINSTANCE  lpRootInstance;
; 1307 :    LPENTITYINSTANCE  lpEntityInstance;
; 1308 :    LPENTITYINSTANCE  lpSearchInstance;
; 1309 :    zSHORT            nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 1310 : 
; 1311 :    lpViewOD       = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1312 :    lpViewCsr      = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1313 :    lpViewOI       = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1314 :    lpRootInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootInstance$[ebp], eax

; 1315 : 
; 1316 :    if ( lpRootInstance == 0 )

	cmp	DWORD PTR _lpRootInstance$[ebp], 0
	jne	SHORT $L7965

; 1317 :       return( 0 );

	xor	ax, ax
	jmp	$L7952
$L7965:

; 1318 : 
; 1319 :    // If the object definition has view entities marked as
; 1320 :    // has dup instance, go through and attempt to relink them
; 1321 :    // together now
; 1322 :    if ( lpViewOD->bHasDupInstance )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	and	eax, 1
	test	eax, eax
	je	$L7972

; 1324 :       LPENTITYINSTANCE lpDupEntityInstance = 0;

	mov	DWORD PTR _lpDupEntityInstance$7967[ebp], 0

; 1325 : 
; 1326 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L7968

; 1327 :          nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1
$L7968:

; 1328 : 
; 1329 :       // Look for EI's that are flagged as duplicate instances and link
; 1330 :       // together the same instances.  We will start looping with the first
; 1331 :       // EI and see if it is the same as any PREVIOUS EI's.  If we find a
; 1332 :       // match then they will be linked.
; 1333 :       for ( lpEntityInstance = lpRootInstance;
; 1334 :             lpEntityInstance;
; 1335 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpRootInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $L7970
$L7971:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L7970:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L7972

; 1337 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1338 : 
; 1339 :          // If this EI isn't a duplicate entity then skip it.
; 1340 :          if ( lpViewEntity->bDupInstance == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 25					; 00000019H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L7974

; 1341 :             continue;

	jmp	SHORT $L7971
$L7974:

; 1342 : 
; 1343 :          // To save some looping time we'll keep track of the first EI that
; 1344 :          // is flagged as a dup instance.
; 1345 :          if ( lpDupEntityInstance == 0 )

	cmp	DWORD PTR _lpDupEntityInstance$7967[ebp], 0
	jne	SHORT $L7975

; 1346 :             lpDupEntityInstance = lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpDupEntityInstance$7967[ebp], eax
$L7975:

; 1347 : 
; 1348 :          // Now try to find the first EI that matches lpEntityInstance.  If
; 1349 :          // lpSearchInstance == lpEntityInstance then we've searched all the
; 1350 :          // previous EIs so we can stop looking.
; 1351 :          for ( lpSearchInstance = lpDupEntityInstance;
; 1352 :                lpSearchInstance != lpEntityInstance;
; 1353 :                lpSearchInstance = zGETPTR( lpSearchInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpDupEntityInstance$7967[ebp]
	mov	DWORD PTR _lpSearchInstance$[ebp], ecx
	jmp	SHORT $L7977
$L7978:
	mov	edx, DWORD PTR _lpSearchInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchInstance$[ebp], eax
$L7977:
	mov	ecx, DWORD PTR _lpSearchInstance$[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L7979

; 1355 :             LPVIEWENTITY lpSearchViewEntity;
; 1356 : 
; 1357 :             lpSearchViewEntity = zGETPTR( lpSearchInstance->hViewEntity );

	mov	edx, DWORD PTR _lpSearchInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$7980[ebp], eax

; 1358 : 
; 1359 :             // If the entities are not the same ER entity then we can't link.
; 1360 :             if ( lpViewEntity->lEREntTok != lpSearchViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR _lpSearchViewEntity$7980[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	je	SHORT $L7982

; 1361 :                continue;

	jmp	SHORT $L7978
$L7982:

; 1362 : 
; 1363 :             // The search view entity must be flagged as duplicate instance.
; 1364 :             if ( lpSearchViewEntity->bDupInstance == FALSE )

	mov	ecx, DWORD PTR _lpSearchViewEntity$7980[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 25					; 00000019H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L7983

; 1365 :                continue;

	jmp	SHORT $L7978
$L7983:

; 1366 : 
; 1367 :             if ( !fnInstanceKeysMatch( lpEntityInstance, lpSearchInstance ) )

	mov	eax, DWORD PTR _lpSearchInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L7984

; 1368 :                continue;

	jmp	SHORT $L7978
$L7984:

; 1369 : 
; 1370 :             fnRelinkInstanceToInstance( lpEntityInstance, lpSearchInstance );

	mov	eax, DWORD PTR _lpSearchInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRelinkInstanceToInstance
	add	esp, 8
$L7979:

; 1377 : 
; 1378 :       } // for ( lpEntityInstance...)

	jmp	$L7971
$L7972:

; 1381 : 
; 1382 :    // if the view object has duplicate relationships, try and
; 1383 :    // spawn any necessary includes to instantiate the relationships
; 1384 :    if ( lpViewOD->bHasDupRel )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	$L7991

; 1386 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L7986

; 1387 :          nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1
$L7986:

; 1388 : 
; 1389 :       // Loop through the view entities and look for entities that are
; 1390 :       // flagged as dup relationships.
; 1391 :       for ( lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );
; 1392 :             lpViewEntity;
; 1393 :             lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $L7989
$L7990:
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$L7989:
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	$L7991

; 1395 :          LPVIEWENTITY      hDupRelParent;
; 1396 :          LPENTITYINSTANCE  lpParentInstance;
; 1397 : 
; 1398 :          if ( lpViewEntity->bDupRel == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 26					; 0000001aH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L7994

; 1399 :             continue;

	jmp	SHORT $L7990
$L7994:

; 1400 : 
; 1401 :          // Get the parent entity of the dup rel entity.  Then we will loop
; 1402 :          // through all the the EI's looking for instances of the parent.
; 1403 :          hDupRelParent = lpViewEntity->hParent;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	mov	DWORD PTR _hDupRelParent$7992[ebp], eax

; 1404 :          for ( lpParentInstance = lpRootInstance;
; 1405 :                lpParentInstance;
; 1406 :                lpParentInstance = zGETPTR( lpParentInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpRootInstance$[ebp]
	mov	DWORD PTR _lpParentInstance$7993[ebp], ecx
	jmp	SHORT $L7996
$L7997:
	mov	edx, DWORD PTR _lpParentInstance$7993[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentInstance$7993[ebp], eax
$L7996:
	cmp	DWORD PTR _lpParentInstance$7993[ebp], 0
	je	$L7998

; 1408 :             LPENTITYINSTANCE lpSearchInstance;
; 1409 :             LPENTITYINSTANCE lpSourceInstance;
; 1410 : 
; 1411 :             if ( lpParentInstance->hViewEntity != hDupRelParent )

	mov	ecx, DWORD PTR _lpParentInstance$7993[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hDupRelParent$7992[ebp]
	je	SHORT $L8001

; 1412 :                continue;

	jmp	SHORT $L7997
$L8001:

; 1413 : 
; 1414 :             // We have found an an entity instance that is the parent of the
; 1415 :             // dup rel entity.  Now we have to check to see if we should
; 1416 :             // include another entity instance under the parent.  Look to
; 1417 :             // see if there is another EI in the OI who's relationship
; 1418 :             // matches the dup rel entity.
; 1419 :             for ( lpSearchInstance = lpRootInstance;
; 1420 :                   lpSearchInstance;
; 1421 :                   lpSearchInstance = zGETPTR( lpSearchInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpRootInstance$[ebp]
	mov	DWORD PTR _lpSearchInstance$7999[ebp], eax
	jmp	SHORT $L8003
$L8004:
	mov	ecx, DWORD PTR _lpSearchInstance$7999[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchInstance$7999[ebp], eax
$L8003:
	cmp	DWORD PTR _lpSearchInstance$7999[ebp], 0
	je	$L8005

; 1423 :                LPVIEWENTITY    lpSourceEntity;
; 1424 :                LPVIEWENTITYCSR lpViewEntityCsr;
; 1425 : 
; 1426 :                lpSourceEntity = zGETPTR( lpSearchInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSearchInstance$7999[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntity$8006[ebp], eax

; 1427 : 
; 1428 :                // If the relationship token of the source instance does not
; 1429 :                // match the token of the dup rel entity then try the next one.
; 1430 :                if ( lpSourceEntity->lERRelTok != lpViewEntity->lERRelTok )

	mov	edx, DWORD PTR _lpSourceEntity$8006[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+199]
	cmp	ecx, DWORD PTR [eax+199]
	je	SHORT $L8009

; 1431 :                   continue;

	jmp	SHORT $L8004
$L8009:

; 1432 : 
; 1433 :                // Make sure the source entity is not derived or dup rel itself.
; 1434 :                if ( lpSourceEntity->bDerivedPath || lpSourceEntity->bDupRelPath )

	mov	edx, DWORD PTR _lpSourceEntity$8006[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	jne	SHORT $L8011
	mov	ecx, DWORD PTR _lpSourceEntity$8006[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	test	edx, edx
	je	SHORT $L8010
$L8011:

; 1435 :                   continue;

	jmp	SHORT $L8004
$L8010:

; 1436 : 
; 1437 :                // Check to see if the relationship of the search instance is
; 1438 :                // the same or the inverse of lpViewEntity.
; 1439 :                if ( lpSourceEntity->lEREntTok == lpViewEntity->lEREntTok )

	mov	eax, DWORD PTR _lpSourceEntity$8006[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	jne	SHORT $L8012

; 1441 :                   // If we get here then the following is an example of the
; 1442 :                   // situation:
; 1443 :                   //
; 1444 :                   //     (R)
; 1445 :                   //      |
; 1446 :                   //     (A)
; 1447 :                   //    /  \
; 1448 :                   //  (X)  (B)
; 1449 :                   //   |    |
; 1450 :                   //  (Y)  (X')
; 1451 :                   //        |
; 1452 :                   //       (Y')
; 1453 :                   //
; 1454 :                   // Y' is the dup rel entity (lpViewEntity) and X' is the
; 1455 :                   // parent (lpParent).  Y is the current lpSearchInstance and
; 1456 :                   // is the entity that we want to include under X'.  In this
; 1457 :                   // case we want to make sure that the values of the keys for
; 1458 :                   // X and X' are the same.
; 1459 :                   if ( !fnInstanceKeysMatch( lpParentInstance,
; 1460 :                                              zGETPTR( lpSearchInstance->hParent ) ) )

	mov	eax, DWORD PTR _lpSearchInstance$7999[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpParentInstance$7993[ebp]
	push	edx
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L8014

; 1462 :                      // Keys don't match so it's not a candidate.  Try again
; 1463 :                      // with the next instance.
; 1464 :                      continue;

	jmp	$L8004
$L8014:

; 1466 : 
; 1467 :                   // Source for the include is Y (lpSearchInstance).
; 1468 :                   lpSourceInstance = lpSearchInstance;

	mov	ecx, DWORD PTR _lpSearchInstance$7999[ebp]
	mov	DWORD PTR _lpSourceInstance$8000[ebp], ecx

; 1470 :                else

	jmp	SHORT $L8015
$L8012:

; 1472 :                   // If we get here then the following is an example of the
; 1473 :                   // situation:
; 1474 :                   //
; 1475 :                   //                       (R)
; 1476 :                   //                        |
; 1477 :                   //                       (A)
; 1478 :                   //                      /  \
; 1479 :                   //  X and Y are  ==>  (Y)  (B)
; 1480 :                   //  inversed           |    |
; 1481 :                   //  from above   ==>  (X)  (X')
; 1482 :                   //                          |
; 1483 :                   //                         (Y')
; 1484 :                   //
; 1485 :                   // Y' is the dup rel entity (lpViewEntity) and X' is the
; 1486 :                   // parent (lpParent).  X is the current lpSearchInstance.
; 1487 :                   // The entity that we want to include under X' is the
; 1488 :                   // parent of X -- Y.  Make sure X and X' are the same.
; 1489 :                   if ( !fnInstanceKeysMatch( lpParentInstance,
; 1490 :                                              lpSearchInstance ) )

	mov	edx, DWORD PTR _lpSearchInstance$7999[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParentInstance$7993[ebp]
	push	eax
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L8016

; 1492 :                      // Keys don't match so it's not a candidate.  Try again
; 1493 :                      // with the next instance.
; 1494 :                      continue;

	jmp	$L8004
$L8016:

; 1496 : 
; 1497 :                   // The source of the include is the parent of X.
; 1498 :                   lpSourceInstance = zGETPTR( lpSearchInstance->hParent );

	mov	edx, DWORD PTR _lpSearchInstance$7999[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceInstance$8000[ebp], eax

; 1499 :                   lpSourceEntity   = zGETPTR( lpSourceInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSourceInstance$8000[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntity$8006[ebp], eax
$L8015:

; 1501 : 
; 1502 :                // We have found a match!  First establish the cursor positions
; 1503 :                // to match our parent and source instances.
; 1504 :                lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$8007[ebp], eax

; 1505 :                lpViewEntityCsr += (lpViewEntity->nHierNbr - 1);

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	sub	eax, 1
	imul	eax, 30					; 0000001eH
	mov	ecx, DWORD PTR _lpViewEntityCsr$8007[ebp]
	add	ecx, eax
	mov	DWORD PTR _lpViewEntityCsr$8007[ebp], ecx

; 1506 :                lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpViewEntityCsr$8007[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$8007[ebp], eax

; 1507 :                fnEstablishViewForInstance( lpView, lpViewEntityCsr,
; 1508 :                                            lpParentInstance );

	mov	ecx, DWORD PTR _lpParentInstance$7993[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$8007[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1509 : 
; 1510 :                lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$8007[ebp], eax

; 1511 :                lpViewEntityCsr += (lpSourceEntity->nHierNbr - 1);

	mov	eax, DWORD PTR _lpSourceEntity$8006[ebp]
	movsx	ecx, WORD PTR [eax+217]
	sub	ecx, 1
	imul	ecx, 30					; 0000001eH
	mov	edx, DWORD PTR _lpViewEntityCsr$8007[ebp]
	add	edx, ecx
	mov	DWORD PTR _lpViewEntityCsr$8007[ebp], edx

; 1512 :                fnEstablishViewForInstance( lpView, lpViewEntityCsr,
; 1513 :                                            lpSourceInstance );

	mov	eax, DWORD PTR _lpSourceInstance$8000[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$8007[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1514 : 
; 1515 :                // Include the source instance to instantiate the dup rel entity.
; 1516 :                if ( fnIncludeSubobjectFromSubobject( lpView, lpViewEntity,
; 1517 :                                                      lpView, lpSourceEntity,
; 1518 :                                                      zPOS_FIRST, 0,
; 1519 :                                                      0 ) == zCALL_ERROR )

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _lpSourceEntity$8006[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnIncludeSubobjectFromSubobject
	add	esp, 28					; 0000001cH
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $L8023

; 1521 :                   return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L7952
$L8023:

; 1523 : 
; 1524 :                // We've found the source instance and included it so we're
; 1525 :                // done looking for a source instance to include so break.
; 1526 :                //break;
; 1527 : 
; 1528 :             } // for ( lpSearchInstance )...

	jmp	$L8004
$L8005:

; 1529 : 
; 1530 :          } // for ( lpParentInstance )...

	jmp	$L7997
$L7998:

; 1531 : 
; 1532 :       } // for ( lpViewEntity...)

	jmp	$L7990
$L7991:

; 1535 : 
; 1536 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L7952:

; 1537 : 
; 1538 : } // fnRelinkObjectInstance

	mov	esp, ebp
	pop	ebp
	ret	4
_fnRelinkObjectInstance@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DIOI@QualAttrib?$AA@			; `string'
PUBLIC	??_C@_0O@GCPH@SubQualAttrib?$AA@		; `string'
PUBLIC	??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@ ; `string'
PUBLIC	??_C@_08IDGA@KZOEOIAA?$AA@			; `string'
PUBLIC	??_C@_02KKOC@xx?$AA@				; `string'
PUBLIC	??_C@_0BL@OKGH@?$CFlf?5seconds?5for?5object?5?$CFs?5?$AA@ ; `string'
PUBLIC	??_C@_0CO@EJKO@?$CIoi?$CJ?5Total?5time?5for?5ActivateObje@ ; `string'
PUBLIC	_ActivateObjectInstance@20
PUBLIC	_ActivateOI_FromOI_ForTask@16
PUBLIC	_DropObjectInstance@4
PUBLIC	__real@8@4008fa00000000000000
PUBLIC	_SfActivateSysEmptyOI@16
PUBLIC	??_C@_0CK@FJHF@Expecting?5valid?5OI?5for?5zACTIVATE@ ; `string'
PUBLIC	??_C@_0DB@KPMG@Root?5entity?5has?5no?5default?5seque@ ; `string'
PUBLIC	??_C@_08IDPE@kzdbhqua?$AA@			; `string'
PUBLIC	??_C@_02CHDK@OR?$AA@				; `string'
PUBLIC	??_C@_01FHE@?$DM?$AA@				; `string'
PUBLIC	??_C@_01FAFK@?$DO?$AA@				; `string'
PUBLIC	_fnActivateObjectInstance
PUBLIC	??_C@_08ILBJ@KZDBHQUA?$AA@			; `string'
PUBLIC	??_C@_0BD@JJIL@__Load?9in?9progress?$AA@	; `string'
PUBLIC	??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_0CF@NCHC@?$CIoi?$CJ?5Database?5unavailable?9?9try?5a@ ; `string'
PUBLIC	??_C@_0CB@FJHI@?$CIoi?$CJ?5Database?5Deadlock?5?9?5Object?$DN@ ; `string'
PUBLIC	??_C@_0BH@DAGF@?5Activate?5Retry?5Count?$DN?$AA@ ; `string'
PUBLIC	??_C@_0CL@FIPO@?$CIoi?$CJ?5Deadlock?5Crash?5?9?5Retry?5Coun@ ; `string'
PUBLIC	??_C@_0DP@HHNF@?$CIoi?$CJ?5Database?5Memory?5Limit?5Reach@ ; `string'
EXTRN	_SysGetTickCount@0:NEAR
EXTRN	_fnGetAttrAddrFromEntityInstance:NEAR
EXTRN	_fnStoreValueInEntityInstance:NEAR
EXTRN	_TraceLineI@8:NEAR
EXTRN	_TraceLineS@8:NEAR
EXTRN	_TraceLine:NEAR
EXTRN	_fnValidView:NEAR
EXTRN	_fnValidViewObject:NEAR
EXTRN	_fnSetViewFromView:NEAR
EXTRN	_fnResetView:NEAR
EXTRN	_SetNameForView@16:NEAR
EXTRN	_DropNameForView@16:NEAR
EXTRN	__fltused:NEAR
EXTRN	_GetStringFromRecord@20:NEAR
EXTRN	_strcat:NEAR
EXTRN	_ActivateViewObject@12:NEAR
EXTRN	_SetCursorPrevEntity@12:NEAR
EXTRN	_MessageSend@24:NEAR
EXTRN	_NetStartup@12:NEAR
EXTRN	_NetActivateOI@28:NEAR
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_szlEntityName:DWORD
EXTRN	_szlEntitySpec:DWORD
EXTRN	_NetStatus@8:NEAR
EXTRN	_szlOper:DWORD
EXTRN	_szlQualAttrib:DWORD
;	COMDAT ??_C@_0CK@FJHF@Expecting?5valid?5OI?5for?5zACTIVATE@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CK@FJHF@Expecting?5valid?5OI?5for?5zACTIVATE@ DB 'Expecting valid '
	DB	'OI for zACTIVATE_CONTINUE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DB@KPMG@Root?5entity?5has?5no?5default?5seque@
_DATA	SEGMENT
??_C@_0DB@KPMG@Root?5entity?5has?5no?5default?5seque@ DB 'Root entity has'
	DB	' no default sequencing attributes', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IDPE@kzdbhqua?$AA@
_DATA	SEGMENT
??_C@_08IDPE@kzdbhqua?$AA@ DB 'kzdbhqua', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02CHDK@OR?$AA@
_DATA	SEGMENT
??_C@_02CHDK@OR?$AA@ DB 'OR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FHE@?$DM?$AA@
_DATA	SEGMENT
??_C@_01FHE@?$DM?$AA@ DB '<', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FAFK@?$DO?$AA@
_DATA	SEGMENT
??_C@_01FAFK@?$DO?$AA@ DB '>', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08ILBJ@KZDBHQUA?$AA@
_DATA	SEGMENT
??_C@_08ILBJ@KZDBHQUA?$AA@ DB 'KZDBHQUA', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@JJIL@__Load?9in?9progress?$AA@
_DATA	SEGMENT
??_C@_0BD@JJIL@__Load?9in?9progress?$AA@ DB '__Load-in-progress', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
_DATA	SEGMENT
??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '('
	DB	'oi) -------------------------------', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@NCHC@?$CIoi?$CJ?5Database?5unavailable?9?9try?5a@
_DATA	SEGMENT
??_C@_0CF@NCHC@?$CIoi?$CJ?5Database?5unavailable?9?9try?5a@ DB '(oi) Data'
	DB	'base unavailable--try again', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@FJHI@?$CIoi?$CJ?5Database?5Deadlock?5?9?5Object?$DN@
_DATA	SEGMENT
??_C@_0CB@FJHI@?$CIoi?$CJ?5Database?5Deadlock?5?9?5Object?$DN@ DB '(oi) D'
	DB	'atabase Deadlock - Object=', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@DAGF@?5Activate?5Retry?5Count?$DN?$AA@
_DATA	SEGMENT
??_C@_0BH@DAGF@?5Activate?5Retry?5Count?$DN?$AA@ DB ' Activate Retry Coun'
	DB	't=', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@FIPO@?$CIoi?$CJ?5Deadlock?5Crash?5?9?5Retry?5Coun@
_DATA	SEGMENT
??_C@_0CL@FIPO@?$CIoi?$CJ?5Deadlock?5Crash?5?9?5Retry?5Coun@ DB '(oi) Dea'
	DB	'dlock Crash - Retry Count exceeded', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DP@HHNF@?$CIoi?$CJ?5Database?5Memory?5Limit?5Reach@
_DATA	SEGMENT
??_C@_0DP@HHNF@?$CIoi?$CJ?5Database?5Memory?5Limit?5Reach@ DB '(oi) Datab'
	DB	'ase Memory Limit Reached (Task: 0x%08x) - Object: %s', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DIOI@QualAttrib?$AA@
_DATA	SEGMENT
??_C@_0L@DIOI@QualAttrib?$AA@ DB 'QualAttrib', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@GCPH@SubQualAttrib?$AA@
_DATA	SEGMENT
??_C@_0O@GCPH@SubQualAttrib?$AA@ DB 'SubQualAttrib', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@
_DATA	SEGMENT
??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@ DB 'Network cannot be '
	DB	'started.', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IDGA@KZOEOIAA?$AA@
_DATA	SEGMENT
??_C@_08IDGA@KZOEOIAA?$AA@ DB 'KZOEOIAA', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02KKOC@xx?$AA@
_DATA	SEGMENT
??_C@_02KKOC@xx?$AA@ DB 'xx', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OKGH@?$CFlf?5seconds?5for?5object?5?$CFs?5?$AA@
_DATA	SEGMENT
??_C@_0BL@OKGH@?$CFlf?5seconds?5for?5object?5?$CFs?5?$AA@ DB '%lf seconds'
	DB	' for object %s ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CO@EJKO@?$CIoi?$CJ?5Total?5time?5for?5ActivateObje@
_DATA	SEGMENT
??_C@_0CO@EJKO@?$CIoi?$CJ?5Total?5time?5for?5ActivateObje@ DB '(oi) Total'
	DB	' time for ActivateObjectInstance = ', 00H	; `string'
_DATA	ENDS
;	COMDAT __real@8@4008fa00000000000000
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
_TEXT	SEGMENT
_vQualOI$8198 = -700
_lNetControl$8205 = -704
_lpEntityInstance$8218 = -708
_lpViewAttrib$8224 = -712
_lpViewEntityCsr$8225 = -724
_lpNewEI$8226 = -716
_bNewRoot$8227 = -720
_lpPtr$8239 = -732
_uLth$8240 = -728
_nState$8247 = -740
_k$8248 = -736
_sz$8257 = -840
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_lpQualView$ = 20
_lControl$ = 24
_lpCurrentTask$ = -64
_lpOwningTask$ = -28
_lpViewOD$ = -8
_lpViewOI$ = -56
_lpViewEntity$ = -24
_lpViewCsr$ = -4
_lpOrigInstance$ = -20
_lpOrigViewEntityCsr$ = -52
_lpView$ = -12
_vTempQual$ = -36
_vOrigView$ = -44
_lTickCount$ = -60
_l$ = -48
_bDropQual$ = -40
_bLockingSemaphoreCreatedHere$ = -32
_nRC$ = -16
_lpViewAttrib$8076 = -156
_lpSeqViewAttrib$8077 = -152
_lpOrigViewCsr$8078 = -172
_lpOrigViewOI$8079 = -160
_chCurrentAttrNbr$8080 = -168
_chMaxAttrNbr$8081 = -68
_chFirstAttrNbr$8082 = -164
_k$8121 = -176
_sz$8131 = -432
_nActivateCount$8146 = -436
_szMsg$8174 = -692
_vOriginalOI$8190 = -696
_ActivateObjectInstance@20 PROC NEAR

; 1619 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 848				; 00000350H

; 1620 :    LPTASK            lpCurrentTask;
; 1621 :    LPTASK            lpOwningTask;
; 1622 :    LPVIEWOD          lpViewOD;
; 1623 :    LPVIEWOI          lpViewOI = 0;

	mov	DWORD PTR _lpViewOI$[ebp], 0

; 1624 :    LPVIEWENTITY      lpViewEntity;
; 1625 :    LPVIEWCSR         lpViewCsr;
; 1626 :    LPENTITYINSTANCE  lpOrigInstance;
; 1627 :    LPVIEWENTITYCSR   lpOrigViewEntityCsr;
; 1628 :    zVIEW             lpView = 0;

	mov	DWORD PTR _lpView$[ebp], 0

; 1629 :    zVIEW             vTempQual = 0;

	mov	DWORD PTR _vTempQual$[ebp], 0

; 1630 :    zVIEW             vOrigView = *pvReturnView;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vOrigView$[ebp], ecx

; 1631 :    zLONG             lTickCount;
; 1632 :    zLONG             l;
; 1633 :    zBOOL             bDropQual = FALSE;   // used when continuing an activate

	mov	BYTE PTR _bDropQual$[ebp], 0

; 1634 :    zBOOL             bLockingSemaphoreCreatedHere = FALSE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 0

; 1635 :    zSHORT            nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 1636 : 
; 1637 :    *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0

; 1638 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8051

; 1639 :       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$L8051:

; 1640 : 
; 1641 :    // If task not active or disabled, return zCALL_ERROR.
; 1642 :    if ( lpAppQualView )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $L8052

; 1643 :       lpView = lpAppQualView;

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	DWORD PTR _lpView$[ebp], edx
$L8052:

; 1644 : 
; 1645 :    if ( (lpCurrentTask = fnOperationCall( iActivateObjectInstance,
; 1646 :                                           lpView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	52					; 00000034H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8053

; 1648 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8034
$L8053:

; 1650 : 
; 1651 :    lpCurrentTask->bLoadAllocLimit = FALSE;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	and	dh, -65					; ffffffbfH
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [eax+443], edx

; 1652 :    if ( lpQualView && fnValidViewObject( lpCurrentTask, lpQualView ) == 0 )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	SHORT $L8054
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidViewObject
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L8054

; 1653 :       goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8054:

; 1654 : 
; 1655 :    if ( fnValidView( lpCurrentTask, lpAppQualView ) == 0 )

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidView
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L8056

; 1656 :       goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8056:

; 1657 : 
; 1658 :    lpViewOD = ActivateViewObject( lpAppQualView, cpcViewOD_Name, FALSE );

	push	0
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1659 :    if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $L8057

; 1660 :       goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8057:

; 1661 : 
; 1662 :    // Verify only one zLEVEL_ option requested.
; 1663 :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], eax

; 1664 :    if ( l && (-l & l) != l )

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $L8058
	mov	ecx, DWORD PTR _l$[ebp]
	neg	ecx
	and	ecx, DWORD PTR _l$[ebp]
	cmp	ecx, DWORD PTR _l$[ebp]
	je	SHORT $L8058

; 1666 :       // error, More than one zLEVEL_ option requested
; 1667 :       // "KZOEE023 - Invalid parameter, "
; 1668 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 23, 0,
; 1669 :                         "More than one zLEVEL_ option requested", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ ; `string'
	push	0
	push	23					; 00000017H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1670 :       goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8058:

; 1672 : 
; 1673 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 12					; 0000000cH
	test	ecx, ecx
	je	SHORT $L8059

; 1674 :       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 1675 :    else

	jmp	SHORT $L8061
$L8059:

; 1676 :       lpOwningTask = lpCurrentTask;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], ecx
$L8061:

; 1677 : 
; 1678 :    // If zLEVEL_SAME is requested.
; 1679 :    if ( lControl & zLEVEL_SAME )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1024				; 00000400H
	test	edx, edx
	je	$L8074

; 1681 :       if ( lpAppQualView == 0 || lpAppQualView->hSubtask )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $L8064
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $L8063
$L8064:

; 1683 :          // "KZOEE100 - Invalid View, view is a Subtask View"
; 1684 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 100, 0, "lpAppQualView",
; 1685 :                            "with zLEVEL_SAME" );

	push	OFFSET FLAT:??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0O@OFE@lpAppQualView?$AA@ ; `string'
	push	0
	push	100					; 00000064H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1686 :          goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8063:

; 1690 :          // LPVIEWCSR lpViewCsr;
; 1691 : 
; 1692 :          // Turn off the 'same' indicator
; 1693 :          lControl ^= zLEVEL_SAME;

	mov	eax, DWORD PTR _lControl$[ebp]
	xor	eax, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], eax

; 1694 :          // To determine what the level is of the qualifying view
; 1695 :          //   1. Change lpAppQualView to point to the initial
; 1696 :          //      view created for the object instance
; 1697 :          //   2. Check for application level, if there use
; 1698 :          //      zLEVEL_APPLICATION.
; 1699 :          //   3. Check if the view task is the main task, if so use
; 1700 :          //      zLEVEL_SYSTEM.
; 1701 :          //   4. Use the task level...
; 1702 :          lpViewCsr = zGETPTR( lpAppQualView->hViewCsr );

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
$L8068:

; 1703 :          while ( lpViewCsr->hNextViewCsr )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [eax+2], 0
	je	SHORT $L8069

; 1704 :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
	jmp	SHORT $L8068
$L8069:

; 1705 : 
; 1706 :          lpAppQualView = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAppQualView$[ebp], eax

; 1707 :          if ( lpAppQualView->bApplicationView )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L8072

; 1708 :             lControl |= zLEVEL_APPLICATION;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 4
	mov	DWORD PTR _lControl$[ebp], ecx

; 1709 :          else

	jmp	SHORT $L8074
$L8072:

; 1710 :          if ( lpAppQualView->hTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $L8074

; 1711 :             lControl |= zLEVEL_SYSTEM;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 8
	mov	DWORD PTR _lControl$[ebp], edx
$L8074:

; 1714 : 
; 1715 :    // Check to see if we are continuing a previous activate.  If we are, then
; 1716 :    // we need to activate the next group of entities from the database.  To
; 1717 :    // do this we need to add to the current qualification view information to
; 1718 :    // load only entities that come after the last entity in the current OI.
; 1719 :    // The new qualification will then logically look like:
; 1720 :    //       ACTIVATE view
; 1721 :    //       WHERE (original-qual) AND
; 1722 :    //             (view.ent.seq-attr1 > lastent.ent.seq-attr1 OR
; 1723 :    //              (view.ent.seq-attr1 = lastent.ent.seq-attr1 AND
; 1724 :    //               view.ent.seq-attr2 > lastent.ent.seq-attr2))
; 1725 :    if ( lControl & zACTIVATE_CONTINUE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	$L8120

; 1727 :       LPVIEWATTRIB     lpViewAttrib;
; 1728 :       LPVIEWATTRIB     lpSeqViewAttrib[ MAX_SEQ_ATTS + 1 ];
; 1729 :       LPVIEWCSR        lpOrigViewCsr;
; 1730 :       LPVIEWOI         lpOrigViewOI;
; 1731 :       zCHAR            chCurrentAttrNbr;
; 1732 :       zCHAR            chMaxAttrNbr;
; 1733 :       zCHAR            chFirstAttrNbr;
; 1734 : 
; 1735 :       // Since we are continuing a previous activate, they had better pass
; 1736 :       // us the old view.
; 1737 :       if ( fnValidView( lpCurrentTask, vOrigView ) == 0 )

	mov	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidView
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L8083

; 1738 :          goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8083:

; 1739 : 
; 1740 :       *pvReturnView = vOrigView;

	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	edx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [ecx], edx

; 1741 :       lpOrigViewCsr = zGETPTR( vOrigView->hViewCsr );

	mov	eax, DWORD PTR _vOrigView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigViewCsr$8078[ebp], eax

; 1742 :       lpOrigViewOI  = zGETPTR( lpOrigViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpOrigViewCsr$8078[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigViewOI$8079[ebp], eax

; 1743 :       if ( lpOrigViewOI == 0 || lpOrigViewOI->hRootEntityInstance == 0  )

	cmp	DWORD PTR _lpOrigViewOI$8079[ebp], 0
	je	SHORT $L8087
	mov	ecx, DWORD PTR _lpOrigViewOI$8079[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	SHORT $L8086
$L8087:

; 1745 :          fnSysMessageBox( lpCurrentTask, szlOE_SystemError,
; 1746 :                           "Expecting valid OI for zACTIVATE_CONTINUE", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CK@FJHF@Expecting?5valid?5OI?5for?5zACTIVATE@ ; `string'
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16

; 1747 :          goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8086:

; 1749 : 
; 1750 :       // Get the root view entity.
; 1751 :       lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1752 : 
; 1753 :       // Null out table for now.
; 1754 :       for ( chCurrentAttrNbr = 0;
; 1755 :             chCurrentAttrNbr <= MAX_SEQ_ATTS;
; 1756 :             chCurrentAttrNbr++ )

	mov	BYTE PTR _chCurrentAttrNbr$8080[ebp], 0
	jmp	SHORT $L8090
$L8091:
	mov	al, BYTE PTR _chCurrentAttrNbr$8080[ebp]
	add	al, 1
	mov	BYTE PTR _chCurrentAttrNbr$8080[ebp], al
$L8090:
	movsx	ecx, BYTE PTR _chCurrentAttrNbr$8080[ebp]
	cmp	ecx, 20					; 00000014H
	jg	SHORT $L8092

; 1758 :          lpSeqViewAttrib[ chCurrentAttrNbr ] = 0;

	movsx	edx, BYTE PTR _chCurrentAttrNbr$8080[ebp]
	mov	DWORD PTR _lpSeqViewAttrib$8077[ebp+edx*4], 0

; 1759 :       }

	jmp	SHORT $L8091
$L8092:

; 1760 : 
; 1761 :       // First find the max cSequencing numbers for persistent attributes.
; 1762 :       chMaxAttrNbr = 0;

	mov	BYTE PTR _chMaxAttrNbr$8081[ebp], 0

; 1763 :       for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 1764 :             lpViewAttrib;
; 1765 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$8076[ebp], eax
	jmp	SHORT $L8095
$L8096:
	mov	edx, DWORD PTR _lpViewAttrib$8076[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$8076[ebp], eax
$L8095:
	cmp	DWORD PTR _lpViewAttrib$8076[ebp], 0
	je	SHORT $L8097

; 1767 :          if ( lpViewAttrib->cSequencing == 0 )

	mov	ecx, DWORD PTR _lpViewAttrib$8076[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+197]
	test	edx, edx
	jne	SHORT $L8098

; 1768 :             continue;

	jmp	SHORT $L8096
$L8098:

; 1769 : 
; 1770 :          lpSeqViewAttrib[ lpViewAttrib->cSequencing ] = lpViewAttrib;

	mov	eax, DWORD PTR _lpViewAttrib$8076[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+197]
	mov	edx, DWORD PTR _lpViewAttrib$8076[ebp]
	mov	DWORD PTR _lpSeqViewAttrib$8077[ebp+ecx*4], edx

; 1771 : 
; 1772 :          if ( lpViewAttrib->cSequencing > chMaxAttrNbr )

	mov	eax, DWORD PTR _lpViewAttrib$8076[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+197]
	movsx	edx, BYTE PTR _chMaxAttrNbr$8081[ebp]
	cmp	ecx, edx
	jle	SHORT $L8099

; 1773 :             chMaxAttrNbr = lpViewAttrib->cSequencing;

	mov	eax, DWORD PTR _lpViewAttrib$8076[ebp]
	mov	cl, BYTE PTR [eax+197]
	mov	BYTE PTR _chMaxAttrNbr$8081[ebp], cl
$L8099:

; 1774 :       }

	jmp	SHORT $L8096
$L8097:

; 1775 : 
; 1776 :       if ( chMaxAttrNbr == 0 )

	movsx	edx, BYTE PTR _chMaxAttrNbr$8081[ebp]
	test	edx, edx
	jne	SHORT $L8100

; 1778 :          fnSysMessageBox( lpCurrentTask, szlOE_SystemError,
; 1779 :                           "Root entity has no default sequencing attributes",
; 1780 :                           1 );

	push	1
	push	OFFSET FLAT:??_C@_0DB@KPMG@Root?5entity?5has?5no?5default?5seque@ ; `string'
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnSysMessageBox@16

; 1781 :          goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8100:

; 1783 : 
; 1784 :       // We need to add information to the qualification object.  If they
; 1785 :       // didn't give us one, then we need to create one.  We also need to set
; 1786 :       // the flag that indcates we will need to drop the qualification object
; 1787 :       // later.
; 1788 :       bDropQual = TRUE;

	mov	BYTE PTR _bDropQual$[ebp], 1

; 1789 :       if ( lpQualView == 0 )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	jne	SHORT $L8102

; 1791 :          SfActivateSysEmptyOI( &lpQualView, "kzdbhqua",
; 1792 :                                lpAppQualView, zMULTIPLE );

	push	256					; 00000100H
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08IDPE@kzdbhqua?$AA@	; `string'
	lea	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SfActivateSysEmptyOI@16

; 1794 :       else

	jmp	SHORT $L8104
$L8102:

; 1795 :          ActivateOI_FromOI_ForTask( &lpQualView, lpQualView, 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_ActivateOI_FromOI_ForTask@16
$L8104:

; 1796 : 
; 1797 :       // We need to find the last root instance of the original OI.
; 1798 :       for ( lpOrigInstance = zGETPTR( lpOrigViewOI->hRootEntityInstance );
; 1799 :             lpOrigInstance->hNextTwin;
; 1800 :             lpOrigInstance = zGETPTR( lpOrigInstance->hNextTwin ) )

	mov	eax, DWORD PTR _lpOrigViewOI$8079[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigInstance$[ebp], eax
	jmp	SHORT $L8107
$L8108:
	mov	edx, DWORD PTR _lpOrigInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigInstance$[ebp], eax
$L8107:
	mov	ecx, DWORD PTR _lpOrigInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $L8109

; 1802 :          ;  // nothing needs to be done here
; 1803 :       }

	jmp	SHORT $L8108
$L8109:

; 1804 : 
; 1805 :       lpOrigViewEntityCsr = fnEstablishViewForInstance( vOrigView, 0,
; 1806 :                                                         lpOrigInstance );

	mov	edx, DWORD PTR _lpOrigInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _vOrigView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpOrigViewEntityCsr$[ebp], eax

; 1807 : 
; 1808 :       // Make sure that EntitySpec for the root entity exists.
; 1809 :       if ( SetCursorFirstEntityByString( lpQualView, szlEntitySpec,
; 1810 :                                          szlEntityName,
; 1811 :                                          lpViewEntity->szName,
; 1812 :                                          0 ) < zCURSOR_SET )

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _szlEntityName
	push	edx
	mov	eax, DWORD PTR _szlEntitySpec
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $L8110

; 1814 :          CreateEntity( lpQualView, szlEntitySpec, zPOS_LAST );

	push	2
	mov	eax, DWORD PTR _szlEntitySpec
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1815 :          SetAttributeFromString( lpQualView, szlEntitySpec, szlEntityName,
; 1816 :                                  lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _szlEntityName
	push	eax
	mov	ecx, DWORD PTR _szlEntitySpec
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 1818 :       else

	jmp	$L8112
$L8110:

; 1820 :          // Qual view already has qualification on the root entity, so add
; 1821 :          // QualAttrib entities to surround qualification with parens.
; 1822 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_FIRST );

	push	1
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1823 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "(" );

	push	OFFSET FLAT:??_C@_01GFI@?$CI?$AA@	; `string'
	mov	edx, DWORD PTR _szlOper
	push	edx
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 1824 : 
; 1825 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_LAST );

	push	2
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CreateEntity@12

; 1826 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, ")" );

	push	OFFSET FLAT:??_C@_01KMMP@?$CJ?$AA@	; `string'
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1827 : 
; 1828 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_LAST );

	push	2
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1829 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "AND" );

	push	OFFSET FLAT:??_C@_03LACO@AND?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 1830 : 
; 1831 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1832 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "(" );

	push	OFFSET FLAT:??_C@_01GFI@?$CI?$AA@	; `string'
	mov	edx, DWORD PTR _szlOper
	push	edx
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 1833 : 
; 1834 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_LAST );

	push	2
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CreateEntity@12

; 1835 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, ")" );

	push	OFFSET FLAT:??_C@_01KMMP@?$CJ?$AA@	; `string'
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1836 : 
; 1837 :          SetCursorPrevEntity( lpQualView, szlQualAttrib, 0 );

	push	0
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetCursorPrevEntity@12
$L8112:

; 1839 : 
; 1840 :       chFirstAttrNbr = 0;

	mov	BYTE PTR _chFirstAttrNbr$8082[ebp], 0

; 1841 : 
; 1842 :       for ( chCurrentAttrNbr = 1;
; 1843 :             chCurrentAttrNbr <= chMaxAttrNbr;
; 1844 :             chCurrentAttrNbr++ )

	mov	BYTE PTR _chCurrentAttrNbr$8080[ebp], 1
	jmp	SHORT $L8118
$L8119:
	mov	al, BYTE PTR _chCurrentAttrNbr$8080[ebp]
	add	al, 1
	mov	BYTE PTR _chCurrentAttrNbr$8080[ebp], al
$L8118:
	movsx	ecx, BYTE PTR _chCurrentAttrNbr$8080[ebp]
	movsx	edx, BYTE PTR _chMaxAttrNbr$8081[ebp]
	cmp	ecx, edx
	jg	$L8120

; 1846 :          zSHORT k;
; 1847 : 
; 1848 :          if ( lpSeqViewAttrib[ chCurrentAttrNbr ] == 0 )

	movsx	eax, BYTE PTR _chCurrentAttrNbr$8080[ebp]
	cmp	DWORD PTR _lpSeqViewAttrib$8077[ebp+eax*4], 0
	jne	SHORT $L8122

; 1849 :             continue;

	jmp	SHORT $L8119
$L8122:

; 1850 : 
; 1851 :          if ( chFirstAttrNbr == 0 )

	movsx	ecx, BYTE PTR _chFirstAttrNbr$8082[ebp]
	test	ecx, ecx
	jne	SHORT $L8123

; 1852 :             chFirstAttrNbr = chCurrentAttrNbr;

	mov	dl, BYTE PTR _chCurrentAttrNbr$8080[ebp]
	mov	BYTE PTR _chFirstAttrNbr$8082[ebp], dl
$L8123:

; 1853 : 
; 1854 :          // If chCurrentAttrNbr > chFirstAttrNbr, then we have multiple seq
; 1855 :          // attrs in the entity and we need to stick in an "OR".
; 1856 :          if ( chCurrentAttrNbr > chFirstAttrNbr )

	movsx	eax, BYTE PTR _chCurrentAttrNbr$8080[ebp]
	movsx	ecx, BYTE PTR _chFirstAttrNbr$8082[ebp]
	cmp	eax, ecx
	jle	SHORT $L8124

; 1858 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CreateEntity@12

; 1859 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "OR" );

	push	OFFSET FLAT:??_C@_02CHDK@OR?$AA@	; `string'
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1860 : 
; 1861 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1862 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "(" );

	push	OFFSET FLAT:??_C@_01GFI@?$CI?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L8124:

; 1864 : 
; 1865 :          for ( k = chFirstAttrNbr; k <= chCurrentAttrNbr; k++ )

	movsx	ax, BYTE PTR _chFirstAttrNbr$8082[ebp]
	mov	WORD PTR _k$8121[ebp], ax
	jmp	SHORT $L8128
$L8129:
	mov	cx, WORD PTR _k$8121[ebp]
	add	cx, 1
	mov	WORD PTR _k$8121[ebp], cx
$L8128:
	movsx	edx, WORD PTR _k$8121[ebp]
	movsx	eax, BYTE PTR _chCurrentAttrNbr$8080[ebp]
	cmp	edx, eax
	jg	$L8130

; 1867 :             zCHAR sz[ 256 ];
; 1868 : 
; 1869 :             if ( lpSeqViewAttrib[ k ] == 0 )

	movsx	ecx, WORD PTR _k$8121[ebp]
	cmp	DWORD PTR _lpSeqViewAttrib$8077[ebp+ecx*4], 0
	jne	SHORT $L8132

; 1870 :                continue;

	jmp	SHORT $L8129
$L8132:

; 1871 : 
; 1872 :             if ( k > chFirstAttrNbr )

	movsx	edx, WORD PTR _k$8121[ebp]
	movsx	eax, BYTE PTR _chFirstAttrNbr$8082[ebp]
	cmp	edx, eax
	jle	SHORT $L8133

; 1874 :                CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1875 :                SetAttributeFromString( lpQualView, szlQualAttrib,
; 1876 :                                        szlOper, "AND" );

	push	OFFSET FLAT:??_C@_03LACO@AND?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L8133:

; 1878 : 
; 1879 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1880 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlEntityName,
; 1881 :                                     lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _szlEntityName
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 1882 :             SetAttributeFromString( lpQualView, szlQualAttrib, "AttributeName",
; 1883 :                                     lpSeqViewAttrib[ k ]->szName );

	movsx	eax, WORD PTR _k$8121[ebp]
	mov	ecx, DWORD PTR _lpSeqViewAttrib$8077[ebp+eax*4]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0O@JICG@AttributeName?$AA@ ; `string'
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1884 : 
; 1885 :             if ( k == chCurrentAttrNbr )

	movsx	ecx, WORD PTR _k$8121[ebp]
	movsx	edx, BYTE PTR _chCurrentAttrNbr$8080[ebp]
	cmp	ecx, edx
	jne	SHORT $L8136

; 1887 :                if ( lpSeqViewAttrib[ k ]->bSequencingD )

	movsx	eax, WORD PTR _k$8121[ebp]
	mov	ecx, DWORD PTR _lpSeqViewAttrib$8077[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	test	edx, edx
	je	SHORT $L8137

; 1888 :                   SetAttributeFromString( lpQualView, szlQualAttrib,
; 1889 :                                           szlOper, "<" );

	push	OFFSET FLAT:??_C@_01FHE@?$DM?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 1890 :                else

	jmp	SHORT $L8139
$L8137:

; 1891 :                   SetAttributeFromString( lpQualView, szlQualAttrib,
; 1892 :                                           szlOper, ">" );

	push	OFFSET FLAT:??_C@_01FAFK@?$DO?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L8139:

; 1894 :             else

	jmp	SHORT $L8141
$L8136:

; 1895 :                SetAttributeFromString( lpQualView, szlQualAttrib,
; 1896 :                                        szlOper, "=" );

	push	OFFSET FLAT:??_C@_01KPOD@?$DN?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L8141:

; 1897 : 
; 1898 :             GetStringFromRecord( vOrigView, lpViewEntity,
; 1899 :                                  lpSeqViewAttrib[ k ], sz, 256 );

	push	256					; 00000100H
	lea	eax, DWORD PTR _sz$8131[ebp]
	push	eax
	movsx	ecx, WORD PTR _k$8121[ebp]
	mov	edx, DWORD PTR _lpSeqViewAttrib$8077[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	call	_GetStringFromRecord@20

; 1900 :             SetAttributeFromString( lpQualView, szlQualAttrib, "Value", sz );

	lea	edx, DWORD PTR _sz$8131[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_05KBGO@Value?$AA@	; `string'
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 1901 :          }

	jmp	$L8129
$L8130:

; 1902 : 
; 1903 :          if ( chCurrentAttrNbr > chFirstAttrNbr )

	movsx	edx, BYTE PTR _chCurrentAttrNbr$8080[ebp]
	movsx	eax, BYTE PTR _chFirstAttrNbr$8082[ebp]
	cmp	edx, eax
	jle	SHORT $L8142

; 1905 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1906 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, ")" );

	push	OFFSET FLAT:??_C@_01KMMP@?$CJ?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L8142:

; 1908 : 
; 1909 :       } // for...

	jmp	$L8119
$L8120:

; 1912 : 
; 1913 :    lpView = 0;

	mov	DWORD PTR _lpView$[ebp], 0

; 1914 :    if ( lpViewOD->szNetwork[ 0 ] == 0 || lControl & zACTIVATE_LOCAL )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+109]
	test	ecx, ecx
	je	SHORT $L8145
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1073741824				; 40000000H
	test	edx, edx
	je	$L8144
$L8145:

; 1916 :       zSHORT nActivateCount;
; 1917 : 
; 1918 :       // Make sure the LOD has data records.
; 1919 :       lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1920 :       if ( lpViewEntity->hFirstDataRecord == 0 )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+191], 0
	jne	SHORT $L8148

; 1922 :          // "KZOEE083 - LOD does not have physical information"
; 1923 :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 16, 83, 0, lpViewOD->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	0
	push	83					; 00000053H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1924 :          goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8148:

; 1926 : 
; 1927 :       // Check to see if we have pessimistic locking defined for the LOD.
; 1928 :       if ( lpViewOD->nLock       >= zLL_PESSIMISTIC ||
; 1929 :            lpViewOD->nEntityLock >= zLL_PESSIMISTIC )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+236]
	cmp	ecx, 3
	jge	SHORT $L8150
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+237]
	cmp	eax, 3
	jl	SHORT $L8155
$L8150:

; 1931 :          // Check to make sure we can load objects needed for pessimistic
; 1932 :          // locking.
; 1933 :          if ( ActivateViewObject( lpAppQualView, "ZPLOCKO", FALSE ) == 0 )

	push	0
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	call	_ActivateViewObject@12
	test	eax, eax
	jne	SHORT $L8151

; 1934 :             goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8151:

; 1935 : 
; 1936 :          // Look for the qualification object.
; 1937 :          if ( ActivateViewObject( lpAppQualView, "KZDBHQUA", TRUE ) == 0 )

	push	1
	push	OFFSET FLAT:??_C@_08ILBJ@KZDBHQUA?$AA@	; `string'
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	call	_ActivateViewObject@12
	test	eax, eax
	jne	SHORT $L8152

; 1938 :             goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8152:

; 1939 : 
; 1940 :          // If user requests locking, then we need to create the locking
; 1941 :          // semaphore so that only one user changes locking at the same time.
; 1942 :          if ( lControl & zSINGLE_FOR_UPDATE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $L8155

; 1944 :             if ( lpCurrentTask->bPessimisticLockingSet == FALSE )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 8
	and	edx, 1
	test	edx, edx
	jne	SHORT $L8155

; 1946 :                if ( fnCreatePessimisticSemaphore( lpCurrentTask,
; 1947 :                                                   (zPVOID) &lpViewOD, 1, 0,
; 1948 :                                                   lpAppQualView ) < 0 )

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	push	0
	push	1
	lea	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCreatePessimisticSemaphore@20
	movsx	eax, ax
	test	eax, eax
	jge	SHORT $L8157

; 1950 :                   goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8157:

; 1952 : 
; 1953 :                bLockingSemaphoreCreatedHere = TRUE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 1
$L8155:

; 1957 : 
; 1958 :       if ( (nRC = fnDeclareView( &lpView, lpOwningTask, lpAppQualView,
; 1959 :                                  cpcViewOD_Name, FALSE )) != 0 )

	push	0
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L8158

; 1961 :          goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8158:

; 1963 : 
; 1964 : #if 0
; 1965 :       if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 1966 :       {
; 1967 :          zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 1968 :                                      zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 1969 : 
; 1970 :          // Must be done prior to activation.
; 1971 :          SfTransferView( lpView, lpAppQualView, nScope );
; 1972 :       }
; 1973 : #endif
; 1974 : 
; 1975 :       nRC = fnActivateEmptyObjectInstance( lpCurrentTask, lpView, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 1976 :       if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L8159

; 1978 :          // fnActivateEmptyObjectInstance didn't work for some reason.
; 1979 :          // Restore the view cursor to the way is was before the call.
; 1980 :          goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8159:

; 1982 : 
; 1983 :       nActivateCount = 1;

	mov	WORD PTR _nActivateCount$8146[ebp], 1

; 1984 : 
; 1985 :       SetNameForView( lpView, "__Load-in-progress", 0, zLEVEL_TASK );

	push	2
	push	0
	push	OFFSET FLAT:??_C@_0BD@JJIL@__Load?9in?9progress?$AA@ ; `string'
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetNameForView@16

; 1986 : 
; 1987 :       // Call fnActivateObjectInstance until activate was achieved. It is
; 1988 :       // possible that there are locks in place that keep the activate from
; 1989 :       // working.
; 1990 :       // Activate object instance.  If database is in use, wait two seconds
; 1991 :       // and try again.
; 1992 :       // Create a temp qualification so the original doesn't get changed.
; 1993 :       if ( lpQualView )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	SHORT $L8161

; 1995 :          fnDeclareView( &vTempQual, lpOwningTask, lpQualView, 0, 0 );

	push	0
	push	0
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vTempQual$[ebp]
	push	ecx
	call	_fnDeclareView@20

; 1996 :          fnSetViewFromView( vTempQual, lpQualView );

	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _vTempQual$[ebp]
	push	eax
	call	_fnSetViewFromView
	add	esp, 8

; 1998 :       else

	jmp	SHORT $L8162
$L8161:

; 1999 :          vTempQual = 0;

	mov	DWORD PTR _vTempQual$[ebp], 0
$L8162:

; 2000 : 
; 2001 :       while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	$L8165

; 2003 :          nRC = fnActivateObjectInstance( lpCurrentTask, lpView,
; 2004 :                                          vTempQual, lControl );

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _vTempQual$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateObjectInstance
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 2005 : 
; 2006 :          // If fnActivateObjectInstance worked OK, drop old ViewCsr,
; 2007 :          // otherwise restore the view cursor.
; 2008 :          if ( nRC >= -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jl	SHORT $L8166

; 2010 :             // Try to relink entity instances.
; 2011 :             fnRelinkObjectInstance( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnRelinkObjectInstance@4

; 2012 :             break;

	jmp	$L8165
$L8166:

; 2014 :          else
; 2015 :          if ( nRC == zDB_UNAVAIL )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -2					; fffffffeH
	jne	SHORT $L8168

; 2017 :             // Database was unavailable (in use by another user).
; 2018 :             nActivateCount++;

	mov	ax, WORD PTR _nActivateCount$8146[ebp]
	add	ax, 1
	mov	WORD PTR _nActivateCount$8146[ebp], ax

; 2019 : 
; 2020 :             // If we've tried 8 times, exit anyway.
; 2021 :             if ( nActivateCount > 8 )

	movsx	ecx, WORD PTR _nActivateCount$8146[ebp]
	cmp	ecx, 8
	jle	SHORT $L8169

; 2023 :                fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDropView@4

; 2024 :                lpView = 0;   // Null out lpView so it won't be dropped again.

	mov	DWORD PTR _lpView$[ebp], 0

; 2025 :                goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8169:

; 2027 : 
; 2028 :             SysWait( 2000 );  // Wait for 2 seconds then try again.

	push	2000					; 000007d0H
	call	_SysWait@4

; 2029 :             TraceLineS( "(oi) -------------------------------", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	call	_TraceLineS@8

; 2030 :             TraceLineS( "(oi) Database unavailable--try again", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CF@NCHC@?$CIoi?$CJ?5Database?5unavailable?9?9try?5a@ ; `string'
	call	_TraceLineS@8

; 2031 :             TraceLineS( "(oi) -------------------------------", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	call	_TraceLineS@8

; 2033 :          else

	jmp	$L8181
$L8168:

; 2034 :          if ( nRC == zDB_DEADLOCK )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -3					; fffffffdH
	jne	$L8173

; 2036 :             // Transaction backed out because of deadlock.
; 2037 :             zCHAR  szMsg[ 256 ];
; 2038 : 
; 2039 :             zstrcpy( szMsg, "(oi) Database Deadlock - Object=" );

	push	OFFSET FLAT:??_C@_0CB@FJHI@?$CIoi?$CJ?5Database?5Deadlock?5?9?5Object?$DN@ ; `string'
	lea	ecx, DWORD PTR _szMsg$8174[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2040 :             zstrcat( szMsg, cpcViewOD_Name );

	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	lea	eax, DWORD PTR _szMsg$8174[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2041 :             zstrcat( szMsg, " Activate Retry Count=" );

	push	OFFSET FLAT:??_C@_0BH@DAGF@?5Activate?5Retry?5Count?$DN?$AA@ ; `string'
	lea	ecx, DWORD PTR _szMsg$8174[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2042 :             TraceLineI( szMsg, nActivateCount );

	movsx	edx, WORD PTR _nActivateCount$8146[ebp]
	push	edx
	lea	eax, DWORD PTR _szMsg$8174[ebp]
	push	eax
	call	_TraceLineI@8

; 2043 : 
; 2044 :             nActivateCount++;

	mov	cx, WORD PTR _nActivateCount$8146[ebp]
	add	cx, 1
	mov	WORD PTR _nActivateCount$8146[ebp], cx

; 2045 : 
; 2046 :             // If we've tried 3 times, exit anyway.
; 2047 :             if ( nActivateCount > 3 )

	movsx	edx, WORD PTR _nActivateCount$8146[ebp]
	cmp	edx, 3
	jle	SHORT $L8177

; 2049 :                fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDropView@4

; 2050 :                lpView = 0;   // Null out lpView so it won't be dropped again.

	mov	DWORD PTR _lpView$[ebp], 0

; 2051 :                TraceLineS( "(oi) Deadlock Crash - Retry Count exceeded", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CL@FIPO@?$CIoi?$CJ?5Deadlock?5Crash?5?9?5Retry?5Coun@ ; `string'
	call	_TraceLineS@8

; 2052 : 
; 2053 :                goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8177:

; 2055 : 
; 2056 :             DropObjectInstance( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_DropObjectInstance@4

; 2057 : 
; 2058 :             nRC = fnDeclareView( &lpView, lpOwningTask, lpAppQualView,
; 2059 :                                  cpcViewOD_Name, FALSE );

	push	0
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax

; 2060 :             if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L8179

; 2061 :                goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8179:

; 2062 : 
; 2063 : #if 0
; 2064 :             if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 2065 :             {
; 2066 :                zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 2067 :                                            zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 2068 :                SfTransferView( lpView, lpAppQualView, nScope );
; 2069 :             }
; 2070 : #endif
; 2071 : 
; 2072 :             if ( fnActivateEmptyObjectInstance( lpCurrentTask, lpView,
; 2073 :                                                 lControl ) != 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L8180

; 2075 :                goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8180:

; 2077 : 
; 2078 :             SetNameForView( lpView, "__Load-in-progress", 0, zLEVEL_TASK );

	push	2
	push	0
	push	OFFSET FLAT:??_C@_0BD@JJIL@__Load?9in?9progress?$AA@ ; `string'
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetNameForView@16

; 2080 :          else

	jmp	SHORT $L8181
$L8173:

; 2082 :             if ( nRC == zMEMORY_LIMIT )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -7					; fffffff9H
	jne	SHORT $L8182

; 2084 :                // Transaction backed out because of memory error.
; 2085 :                TraceLine( "(oi) Database Memory Limit Reached (Task: 0x%08x) - Object: %s",
; 2086 :                           zGETHNDL( lpCurrentTask), cpcViewOD_Name );

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET FLAT:??_C@_0DP@HHNF@?$CIoi?$CJ?5Database?5Memory?5Limit?5Reach@ ; `string'
	call	_TraceLine
	add	esp, 12					; 0000000cH
$L8182:

; 2088 : 
; 2089 :             // Some error occurred.  Bomb out.
; 2090 :             fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDropView@4

; 2091 :             lpView = 0;   // Null out lpView so it won't be dropped again.

	mov	DWORD PTR _lpView$[ebp], 0

; 2092 :             goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8181:

; 2094 :       } // while ( TRUE )...

	jmp	$L8162
$L8165:

; 2095 : 
; 2096 :       if ( nRC >= 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $L8185

; 2098 :          lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2099 :          lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax
$L8185:

; 2101 : 
; 2102 :       // If nRC is 0 or greater, then we've retrieved a valid object.  If
; 2103 :       // the Object instance has any optmistic locking, then some
; 2104 :       // processing needs to be performed.
; 2105 :       if ( nRC >= 0 && (lControl & zSINGLE_FOR_UPDATE) &&
; 2106 :            (lpViewOD->nLock == zLL_OPTIMISTIC_NOINC ||
; 2107 :             lpViewOD->nLock == zLL_OPTIMISTIC_CMPRALL) )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L8202
	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 67108864				; 04000000H
	test	ecx, ecx
	je	$L8202
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+236]
	cmp	eax, 1
	je	SHORT $L8189
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 2
	jne	$L8202
$L8189:

; 2109 :          zVIEW vOriginalOI;
; 2110 : 
; 2111 :          // The user wants optimistic locking.  All we need to do right
; 2112 :          // now is save the current OI and the qualification OI.  First
; 2113 :          // make sure we don't have any old ones lying around.
; 2114 :          if ( lpViewOI->vOriginalOI )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $L8191

; 2115 :             fnDropView( zGETPTR( lpViewOI->vOriginalOI ) );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4
$L8191:

; 2116 : 
; 2117 :          if ( lpViewOI->vQualOI )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $L8193

; 2118 :             fnDropView( zGETPTR( lpViewOI->vQualOI ) );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4
$L8193:

; 2119 : 
; 2120 :          // Copy the current OI to a safe place so that we can reference
; 2121 :          // it later.  We need to flag the original view so that if
; 2122 :          // vOriginalOI gets dropped before the main OI gets dropped we
; 2123 :          // will know about it.
; 2124 :          ActivateOI_FromOI_ForTask( &vOriginalOI, lpView, 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vOriginalOI$8190[ebp]
	push	ecx
	call	_ActivateOI_FromOI_ForTask@16

; 2125 :          vOriginalOI->bOrigView   = TRUE;

	mov	edx, DWORD PTR _vOriginalOI$8190[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, -128				; ffffff80H
	mov	ecx, DWORD PTR _vOriginalOI$8190[ebp]
	mov	DWORD PTR [ecx+30], eax

; 2126 :          vOriginalOI->bViewLocked = TRUE;

	mov	edx, DWORD PTR _vOriginalOI$8190[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _vOriginalOI$8190[ebp]
	mov	DWORD PTR [ecx+30], eax

; 2127 :          vOriginalOI->hMainOI     = zGETHNDL( lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _vOriginalOI$8190[ebp]
	mov	DWORD PTR [ecx+26], eax

; 2128 :          lpViewOI->vOriginalOI    = zGETHNDL( vOriginalOI );

	mov	edx, DWORD PTR _vOriginalOI$8190[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 2129 : 
; 2130 :          if ( lpQualView )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	$L8197

; 2132 :             zVIEW vQualOI;
; 2133 : 
; 2134 :             ActivateOI_FromOI_ForTask( &vQualOI, lpQualView, 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vQualOI$8198[ebp]
	push	eax
	call	_ActivateOI_FromOI_ForTask@16

; 2135 :             vQualOI->bQualView   = TRUE;

	mov	ecx, DWORD PTR _vQualOI$8198[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	dh, 1
	mov	eax, DWORD PTR _vQualOI$8198[ebp]
	mov	DWORD PTR [eax+30], edx

; 2136 :             vQualOI->bViewLocked = TRUE;

	mov	ecx, DWORD PTR _vQualOI$8198[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _vQualOI$8198[ebp]
	mov	DWORD PTR [eax+30], edx

; 2137 :             vQualOI->hMainOI     = vOriginalOI->hMainOI; // = zGETHNDL( lpViewOI );

	mov	ecx, DWORD PTR _vQualOI$8198[ebp]
	mov	edx, DWORD PTR _vOriginalOI$8190[ebp]
	mov	eax, DWORD PTR [edx+26]
	mov	DWORD PTR [ecx+26], eax

; 2138 : 
; 2139 :             // It is possible that the qual OI contains references to
; 2140 :             // another view.  These views might not be around (or they
; 2141 :             // might change) when we use the qual OI again.  To avoid
; 2142 :             // these errors, resolve all references to other views.
; 2143 :             fnResolveQualOI( vQualOI, "QualAttrib" );

	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	ecx, DWORD PTR _vQualOI$8198[ebp]
	push	ecx
	call	_fnResolveQualOI
	add	esp, 8

; 2144 :             fnResolveQualOI( vQualOI, "SubQualAttrib" );

	push	OFFSET FLAT:??_C@_0O@GCPH@SubQualAttrib?$AA@ ; `string'
	mov	edx, DWORD PTR _vQualOI$8198[ebp]
	push	edx
	call	_fnResolveQualOI
	add	esp, 8

; 2145 : 
; 2146 :             lpViewOI->vQualOI = zGETHNDL( vQualOI );

	mov	eax, DWORD PTR _vQualOI$8198[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 2148 :          else

	jmp	SHORT $L8202
$L8197:

; 2149 :             lpViewOI->vQualOI = 0;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+44], 0
$L8202:

; 2152 : 
; 2153 :       if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $L8203

; 2154 :          DropNameForView( lpView, "__Load-in-progress", lpView, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BD@JJIL@__Load?9in?9progress?$AA@ ; `string'
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_DropNameForView@16
$L8203:

; 2157 :    else

	jmp	$L8204
$L8144:

; 2159 :       zLONG lNetControl;
; 2160 : 
; 2161 :       // We need to activate from the network, sooo ...
; 2162 : 
; 2163 :       // First make sure the network is active.
; 2164 :       nRC = NetStatus( lpAppQualView, lpViewOD->szNetwork );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 109				; 0000006dH
	push	edx
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	call	_NetStatus@8
	mov	WORD PTR _nRC$[ebp], ax

; 2165 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L8207

; 2167 :          nRC = NetStartup( lpAppQualView, lpViewOD->szNetwork,
; 2168 :                            lpViewOD->szNetwork );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 109				; 0000006dH
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 109				; 0000006dH
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	call	_NetStartup@12
	mov	WORD PTR _nRC$[ebp], ax

; 2169 :          if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L8207

; 2171 :             MessageSend( lpAppQualView, "xx", "KZOEOIAA",
; 2172 :                         "Network cannot be started.",
; 2173 :                         zMSGQ_OBJECT_CONSTRAINT_ERROR, 1 );

	push	1
	push	300					; 0000012cH
	push	OFFSET FLAT:??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_08IDGA@KZOEOIAA?$AA@	; `string'
	push	OFFSET FLAT:??_C@_02KKOC@xx?$AA@	; `string'
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	call	_MessageSend@24

; 2174 :             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 2175 :             goto EndOfFunction;

	jmp	$EndOfFunction$8055
$L8207:

; 2178 : 
; 2179 :       // Since we are handling the CONTINUE logic on the client side, turn
; 2180 :       // off the CONTINUE flag (if it's on).
; 2181 :       lNetControl = lControl & ~zACTIVATE_CONTINUE;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, -134217729				; f7ffffffH
	mov	DWORD PTR _lNetControl$8205[ebp], ecx

; 2182 : 
; 2183 :       nRC = NetActivateOI( lpViewOD->szNetwork, 0, &lpView,
; 2184 :                            (zPCHAR) cpcViewOD_Name, lpAppQualView,
; 2185 :                            lpQualView, lNetControl );

	mov	edx, DWORD PTR _lNetControl$8205[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 109				; 0000006dH
	push	ecx
	call	_NetActivateOI@28
	mov	WORD PTR _nRC$[ebp], ax
$L8204:

; 2187 : 
; 2188 :    if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $L8212

; 2190 :       lpViewOD  = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 2191 :       lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2192 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2193 :       lpViewOI->lActivateControl = lControl;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR _lControl$[ebp]
	mov	DWORD PTR [edx+48], eax
$L8212:

; 2195 : 
; 2196 :    if ( nRC >= 0 && lControl & zREADONLY )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $L8216
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2048				; 00000800H
	test	edx, edx
	je	SHORT $L8216

; 2197 :       lpView->bReadOnly = TRUE;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx
$L8216:

; 2198 : 
; 2199 :    // If we are doing a CONTINUE activate then we need to add the entities
; 2200 :    // just loaded to the original instance.
; 2201 :    if ( lControl & zACTIVATE_CONTINUE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	$L8217

; 2203 :       LPENTITYINSTANCE lpEntityInstance;
; 2204 : 
; 2205 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 2206 :             lpEntityInstance;
; 2207 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$8218[ebp], eax
	jmp	SHORT $L8221
$L8222:
	mov	eax, DWORD PTR _lpEntityInstance$8218[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$8218[ebp], eax
$L8221:
	cmp	DWORD PTR _lpEntityInstance$8218[ebp], 0
	je	$L8223

; 2209 :       // LPDATARECORD     lpFirstDataRecord;
; 2210 :       // LPDATAFIELD      lpDataField;
; 2211 :          LPVIEWATTRIB     lpViewAttrib;
; 2212 :          LPVIEWENTITYCSR  lpViewEntityCsr;
; 2213 :          LPENTITYINSTANCE lpNewEI;
; 2214 :          zBOOL            bNewRoot;
; 2215 : 
; 2216 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$8218[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 2217 :          fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$8218[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 2218 : 
; 2219 :          fnValidViewEntity( &lpViewEntityCsr, vOrigView,
; 2220 :                             lpViewEntity->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$8225[ebp]
	push	edx
	call	_fnValidViewEntity@16

; 2221 :          if ( lpViewEntity->hParent )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $L8229

; 2222 :             bNewRoot = FALSE;

	mov	BYTE PTR _bNewRoot$8227[ebp], 0

; 2223 :          else

	jmp	SHORT $L8230
$L8229:

; 2224 :             bNewRoot = FALSE; // TRUE;

	mov	BYTE PTR _bNewRoot$8227[ebp], 0
$L8230:

; 2225 : 
; 2226 :          fnCreateEntity( vOrigView, lpViewEntity, lpViewEntityCsr, zPOS_LAST,
; 2227 :                          (zSHORT) bNewRoot );

	movzx	cx, BYTE PTR _bNewRoot$8227[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _lpViewEntityCsr$8225[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	call	_fnCreateEntity@20

; 2228 :          lpNewEI = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$8225[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewEI$8226[ebp], eax

; 2229 : 
; 2230 :          // Loop through all persistent entities and store values in object.
; 2231 :          for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 2232 :                lpViewAttrib;
; 2233 :                lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$8224[ebp], eax
	jmp	SHORT $L8236
$L8237:
	mov	eax, DWORD PTR _lpViewAttrib$8224[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$8224[ebp], eax
$L8236:
	cmp	DWORD PTR _lpViewAttrib$8224[ebp], 0
	je	SHORT $L8238

; 2235 :             zPCHAR  lpPtr;
; 2236 :             zULONG  uLth;
; 2237 : 
; 2238 :             if ( lpViewAttrib->bPersist )

	mov	edx, DWORD PTR _lpViewAttrib$8224[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	test	eax, eax
	je	SHORT $L8241

; 2240 :                fnGetAttrAddrFromEntityInstance( &lpPtr, &uLth,
; 2241 :                                                 lpEntityInstance,
; 2242 :                                                 lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$8224[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$8218[ebp]
	push	edx
	lea	eax, DWORD PTR _uLth$8240[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpPtr$8239[ebp]
	push	ecx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H

; 2243 :                fnStoreValueInEntityInstance( lpNewEI, lpViewEntity,
; 2244 :                                              lpViewAttrib, lpPtr, uLth );

	mov	edx, DWORD PTR _uLth$8240[ebp]
	push	edx
	mov	eax, DWORD PTR _lpPtr$8239[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$8224[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewEI$8226[ebp]
	push	eax
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
$L8241:

; 2246 : 
; 2247 :          } // for ( lpDataField... )...

	jmp	SHORT $L8237
$L8238:

; 2248 : 
; 2249 :       } // for ( lpEntityInstance... )...

	jmp	$L8222
$L8223:

; 2250 : 
; 2251 :       fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropView@4

; 2252 :       lpView = vOrigView;

	mov	edx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR _lpView$[ebp], edx
$L8217:

; 2255 : 
; 2256 :    if ( nRC >= 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $L8244

; 2258 :       // Reset the view to its initial state.
; 2259 :       if ( lControl & zACTIVATE_CONTINUE )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 134217728				; 08000000H
	test	ecx, ecx
	je	SHORT $L8243

; 2260 :          fnEstablishViewForInstance( lpView, 0, lpOrigInstance );

	mov	edx, DWORD PTR _lpOrigInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 2261 :       else

	jmp	SHORT $L8244
$L8243:

; 2262 :          fnResetView( lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetView
	add	esp, 8
$L8244:

; 2265 : 
; 2266 : #ifdef __ACTIVATE_CONSTRAINTS__
; 2267 : 
; 2268 :    if ( (lControl & zACTIVATE_NOCONSTRAINTS) == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 16777216				; 01000000H
	test	edx, edx
	jne	$L8250

; 2270 :       // If there is an Object Constraint for activate, see if it has
; 2271 :       // any objections about continuing.
; 2272 :       if ( nRC >= 0 && lpViewOD->bActivateConstraint )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $L8250
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	je	SHORT $L8250

; 2274 :          zSHORT   nState;
; 2275 :          zSHORT   k;
; 2276 : 
; 2277 :          nState = (lControl & zLEVEL_SYSTEM) ? zOCE_STATE_SYSTEM : 0;

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 8
	neg	eax
	sbb	eax, eax
	and	eax, 4
	mov	WORD PTR _nState$8247[ebp], ax

; 2278 :          if ( lControl & zMULTIPLE )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L8249

; 2279 :             nState |= zOCE_STATE_MULTIPLE;

	mov	dx, WORD PTR _nState$8247[ebp]
	or	dl, 16					; 00000010H
	mov	WORD PTR _nState$8247[ebp], dx
$L8249:

; 2280 : 
; 2281 :          k = fnInvokeOCEOperation( lpView, lpCurrentTask,
; 2282 :                                    zOCE_ACTIVATE, nState );

	mov	ax, WORD PTR _nState$8247[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _k$8248[ebp], ax

; 2283 :          // If object constraint says no go, drop the view and exit
; 2284 :          if ( k )

	movsx	eax, WORD PTR _k$8248[ebp]
	test	eax, eax
	je	SHORT $L8250

; 2286 :             nRC = k;

	mov	cx, WORD PTR _k$8248[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 2287 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$8055
$L8250:

; 2291 : #endif
; 2292 : 
; 2293 :    // If the view has pessimistic locking and if the zSINGLE_FOR_UPDATE flag
; 2294 :    // has not been set or if the locking level is zLL_PESSIMISTIC then the
; 2295 :    // view is read-only.
; 2296 :    if ( nRC >= -1 && lpView &&
; 2297 :         (((lControl & zSINGLE_FOR_UPDATE) == 0 &&
; 2298 :           (lpViewOD->nLock > 0 ||
; 2299 :            lpViewOD->nEntityLock > zLL_PESSIMISTIC)) ||
; 2300 :          lpViewOD->nLock == zLL_PESSIMISTIC) )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	SHORT $EndOfFunction$8055
	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $EndOfFunction$8055
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	jne	SHORT $L8253
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	test	edx, edx
	jg	SHORT $L8252
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+237]
	cmp	ecx, 3
	jg	SHORT $L8252
$L8253:
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+236]
	cmp	eax, 3
	jne	SHORT $EndOfFunction$8055
$L8252:

; 2302 :       lpView->bReadOnly   = TRUE;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+30], edx

; 2303 :       lpViewOI->bReadOnly = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 4
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$EndOfFunction$8055:

; 2305 : 
; 2306 : EndOfFunction:
; 2307 : 
; 2308 :    if ( bLockingSemaphoreCreatedHere )

	mov	ecx, DWORD PTR _bLockingSemaphoreCreatedHere$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L8254

; 2309 :       fnDeletePessimisticSemaphore( lpCurrentTask,
; 2310 :                                     (zPVOID) &lpViewOD, 1, 0, lpAppQualView );

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	0
	push	1
	lea	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnDeletePessimisticSemaphore@20
$L8254:

; 2311 : 
; 2312 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	and	eax, 1
	test	eax, eax
	je	SHORT $L8256

; 2314 :       zCHAR sz[ 100 ];
; 2315 : 
; 2316 :       zsprintf( sz, "%lf seconds for object %s ",
; 2317 :                 (double) (SysGetTickCount( ) - lTickCount) / zTICKS_PER_SECOND,
; 2318 :                 cpcViewOD_Name );

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR -848+[ebp], eax
	mov	DWORD PTR -848+[ebp+4], 0
	fild	QWORD PTR -848+[ebp]
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BL@OKGH@?$CFlf?5seconds?5for?5object?5?$CFs?5?$AA@ ; `string'
	lea	edx, DWORD PTR _sz$8257[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2319 :       TraceLineS( "(oi) Total time for ActivateObjectInstance = ", sz );

	lea	eax, DWORD PTR _sz$8257[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CO@EJKO@?$CIoi?$CJ?5Total?5time?5for?5ActivateObje@ ; `string'
	call	_TraceLineS@8
$L8256:

; 2321 : 
; 2322 :    if ( nRC < -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jge	SHORT $L8261

; 2324 :       if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $L8262

; 2325 :          fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDropView@4
$L8262:

; 2326 : 
; 2327 :       if ( (lControl & zACTIVATE_CONTINUE) == 0 )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	jne	SHORT $L8263

; 2328 :          *pvReturnView = 0;

	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [ecx], 0
$L8263:

; 2330 :    else

	jmp	SHORT $L8264
$L8261:

; 2331 :       *pvReturnView = lpView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx], eax
$L8264:

; 2332 : 
; 2333 :    if ( vTempQual )

	cmp	DWORD PTR _vTempQual$[ebp], 0
	je	SHORT $L8265

; 2334 :       fnDropView( vTempQual );

	mov	ecx, DWORD PTR _vTempQual$[ebp]
	push	ecx
	call	_fnDropView@4
$L8265:

; 2335 : 
; 2336 :    if ( bDropQual )

	mov	edx, DWORD PTR _bDropQual$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L8266

; 2337 :       fnDropView( lpQualView );

	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_fnDropView@4
$L8266:

; 2338 : 
; 2339 :    fnOperationReturn( iActivateObjectInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	52					; 00000034H
	call	_fnOperationReturn
	add	esp, 8

; 2340 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L8034:

; 2341 : 
; 2342 : }  // ActivateObjectInstance

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_ActivateObjectInstance@20 ENDP
_TEXT	ENDS
PUBLIC	_fnReadDataFromFileStream@20
EXTRN	_SysReadLine@12:NEAR
EXTRN	_SysReadLineLth@16:NEAR
_TEXT	SEGMENT
_lpView$ = 8
_pvData$ = 12
_ppchReturnBuffer$ = 16
_uLth$ = 20
_nErrorNbr$ = 24
_lpFileData$ = -4
_pchExtraData$8282 = -8
_lpTask$8284 = -12
_fnReadDataFromFileStream@20 PROC NEAR

; 2350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2351 :    LPFILEDATA lpFileData = (LPFILEDATA) pvData;

	mov	eax, DWORD PTR _pvData$[ebp]
	mov	DWORD PTR _lpFileData$[ebp], eax

; 2352 : 
; 2353 :    // If nErrorNbr is not 0, then flash the error message and get out.
; 2354 :    if ( nErrorNbr )

	movsx	ecx, WORD PTR _nErrorNbr$[ebp]
	test	ecx, ecx
	je	$L8281

; 2356 :       zPCHAR pchExtraData = (zPCHAR) ppchReturnBuffer;

	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	DWORD PTR _pchExtraData$8282[ebp], edx

; 2357 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8284[ebp], eax

; 2358 : 
; 2359 :       switch ( nErrorNbr )
; 2360 :       {

	movsx	edx, WORD PTR _nErrorNbr$[ebp]
	mov	DWORD PTR -16+[ebp], edx
	mov	eax, DWORD PTR -16+[ebp]
	sub	eax, 74					; 0000004aH
	mov	DWORD PTR -16+[ebp], eax
	cmp	DWORD PTR -16+[ebp], 30			; 0000001eH
	ja	$L8287
	mov	edx, DWORD PTR -16+[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR $L12745[edx]
	jmp	DWORD PTR $L12746[ecx*4]
$L8290:

; 2363 :             // "KZOEE074 - Invalid Entity name on line "
; 2364 :             fnIssueCoreError( lpTask, lpView, 16, 74, lpFileData->lLine,
; 2365 :                               pchExtraData, lpFileData->pchFileName );

	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pchExtraData$8282[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	74					; 0000004aH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$8284[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2366 :             break;

	jmp	SHORT $L8287
$L8291:

; 2368 : 
; 2369 :          case 75:
; 2370 :             // "KZOEE075 - Invalid Entity level on line "
; 2371 :             fnIssueCoreError( lpTask, lpView, 16, 75, lpFileData->lLine,
; 2372 :                               pchExtraData, lpFileData->pchFileName );

	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pchExtraData$8282[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	75					; 0000004bH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$8284[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2373 :             break;

	jmp	SHORT $L8287
$L8292:

; 2374 : 
; 2375 :          case 90:
; 2376 :             // "KZOEE090 - Maximum number of entites in portable file exceeded"
; 2377 :             fnIssueCoreError( lpTask, lpView, 16, 90, lpFileData->lLine,
; 2378 :                               lpFileData->pchFileName, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	edx, DWORD PTR _lpFileData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	90					; 0000005aH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$8284[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2379 :             break;

	jmp	SHORT $L8287
$L8293:

; 2380 : 
; 2381 :          case 104:
; 2382 :             // "KZOEE104 - Invalid Attribute name for Entity"
; 2383 :             fnIssueCoreError( lpTask, lpView, 16, 104, 0, pchExtraData, 0 );

	push	0
	mov	edx, DWORD PTR _pchExtraData$8282[ebp]
	push	edx
	push	0
	push	104					; 00000068H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$8284[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$L8287:

; 2387 : 
; 2388 :       return( 0 );

	xor	ax, ax
	jmp	SHORT $L8295
$L8281:

; 2391 : 
; 2392 :    lpFileData->lLine++;

	mov	edx, DWORD PTR _lpFileData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2393 : 
; 2394 :    if ( uLth )

	cmp	DWORD PTR _uLth$[ebp], 0
	je	SHORT $L8294

; 2395 :       return( SysReadLineLth( lpView, ppchReturnBuffer, lpFileData->hFile, uLth ) );

	mov	edx, DWORD PTR _uLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysReadLineLth@16
	jmp	SHORT $L8295
$L8294:

; 2396 :    else
; 2397 :       return( SysReadLine( lpView, ppchReturnBuffer, lpFileData->hFile ) );

	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ppchReturnBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysReadLine@12
$L8295:

; 2398 : 
; 2399 : } // fnReadDataFromFileStream

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L12746:
	DD	$L8290
	DD	$L8291
	DD	$L8292
	DD	$L8293
	DD	$L8287
$L12745:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnReadDataFromFileStream@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@PPBE@?$CIoi?$CJ?5opening?5?$AA@	; `string'
PUBLIC	_ActivateOI_FromFile@20
PUBLIC	_SfActivateOI_FromStream@24
EXTRN	_fnGetApplicationForSubtask@8:NEAR
EXTRN	_SysOpenFile@12:NEAR
EXTRN	__imp__strchr:NEAR
EXTRN	_cDirSep:BYTE
EXTRN	_SysAppendcDirSep@4:NEAR
EXTRN	_fnSysCloseFile@12:NEAR
EXTRN	_SysConvertEnvironmentString@8:NEAR
;	COMDAT ??_C@_0O@PPBE@?$CIoi?$CJ?5opening?5?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0O@PPBE@?$CIoi?$CJ?5opening?5?$AA@ DB '(oi) opening ', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_cpcFileName$ = 20
_lControl$ = 24
_lpCurrentTask$ = -2104
_lpTask$ = -2068
_lpViewOD$ = -2060
_lpApp$ = -2072
_ActFileData$ = -2092
_vTask$ = -2100
_l$ = -2076
_hFile$ = -2080
_szOpenFileName$ = -2056
_szWork$ = -1028
_bSystemObj$ = -2096
_nRC$ = -2064
_lpViewCsr$8327 = -2108
_lpSystemApp$8341 = -2112
_ActivateOI_FromFile@20 PROC NEAR

; 2469 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2112				; 00000840H

; 2470 :    LPTASK          lpCurrentTask;
; 2471 :    LPTASK          lpTask;
; 2472 :    LPVIEWOD        lpViewOD;
; 2473 :    LPAPP           lpApp;
; 2474 :    FileDataRecord  ActFileData;
; 2475 :    zVIEW           vTask;
; 2476 :    zLONG           l;
; 2477 :    zLONG           hFile;
; 2478 :    zCHAR           szOpenFileName[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 2479 :    zCHAR           szWork[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 2480 :    zBOOL           bSystemObj;
; 2481 :    zSHORT          nRC;
; 2482 : 
; 2483 :    // Init in case of error.
; 2484 :    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 2485 :    bSystemObj = (lControl & zACTIVATE_SYSTEM) ? TRUE : FALSE;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 536870912				; 20000000H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	BYTE PTR _bSystemObj$[ebp], cl

; 2486 : 
; 2487 :    // If task not active or disabled, return zCALL_ERROR.
; 2488 :    if ( (lpCurrentTask = fnOperationCall( iActivateOI_FromFile,
; 2489 :                                           lpAppQualView, 0 )) == 0 )

	push	0
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	54					; 00000036H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8319

; 2491 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8306
$L8319:

; 2493 : 
; 2494 :    // Unless we're activating a system object, ensure that the app qual
; 2495 :    // view is valid.
; 2496 :    if ( (lpAppQualView || !(lControl & zACTIVATE_SYSTEM)) &&
; 2497 :         fnValidView( lpCurrentTask, lpAppQualView ) == 0 )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	jne	SHORT $L8321
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	jne	SHORT $L8320
$L8321:
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidView
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L8320

; 2499 :       fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2500 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8306
$L8320:

; 2502 : 
; 2503 :    // Verify only one zLEVEL_ option requested.
; 2504 :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], edx

; 2505 :    if ( l && (-l & l) != l )

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $L8322
	mov	eax, DWORD PTR _l$[ebp]
	neg	eax
	and	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _l$[ebp]
	je	SHORT $L8322

; 2507 :       // error, More than one zLEVEL_ option requested
; 2508 :       // "KZOEE023 - Invalid parameter, "
; 2509 :       fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 23, 0,
; 2510 :                         "More than one zLEVEL_ option requested", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ ; `string'
	push	0
	push	23					; 00000017H
	push	8
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2511 :       fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2512 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8306
$L8322:

; 2514 : 
; 2515 :    // If zLEVEL_SAME is requested.
; 2516 :    if ( lControl & zLEVEL_SAME )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1024				; 00000400H
	test	ecx, ecx
	je	$L8336

; 2518 :       if ( lpAppQualView == 0 || lpAppQualView->hSubtask )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $L8325
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $L8324
$L8325:

; 2520 :          // "KZOEE100 - Invalid View, view is a Subtask View"
; 2521 :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 100, 0,
; 2522 :                            "lpAppQualView", "with zLEVEL_SAME" );

	push	OFFSET FLAT:??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0O@OFE@lpAppQualView?$AA@ ; `string'
	push	0
	push	100					; 00000064H
	push	8
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2523 :          fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2524 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8306
$L8324:

; 2528 :          LPVIEWCSR lpViewCsr;
; 2529 : 
; 2530 :          // Turn off the 'same' indicator
; 2531 :          lControl ^= zLEVEL_SAME;

	mov	eax, DWORD PTR _lControl$[ebp]
	xor	eax, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], eax

; 2532 :          // To determine what the level is of the qualifying view
; 2533 :          //   1. Change lpAppQualView to point to the initial
; 2534 :          //      view created for the object instance
; 2535 :          //   2. Check for application level, if there use
; 2536 :          //      zLEVEL_APPLICATION.
; 2537 :          //   3. Check if the view task is the main task, if so use
; 2538 :          //      zLEVEL_SYSTEM.
; 2539 :          //   4. Use the task level...
; 2540 :          lpViewCsr = zGETPTR( lpAppQualView->hViewCsr );

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$8327[ebp], eax
$L8330:

; 2541 :          while ( lpViewCsr->hNextViewCsr )

	mov	eax, DWORD PTR _lpViewCsr$8327[ebp]
	cmp	DWORD PTR [eax+2], 0
	je	SHORT $L8331

; 2542 :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpViewCsr$8327[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$8327[ebp], eax
	jmp	SHORT $L8330
$L8331:

; 2543 : 
; 2544 :          lpAppQualView = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$8327[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAppQualView$[ebp], eax

; 2545 :          if ( lpAppQualView->bApplicationView )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L8334

; 2546 :             lControl |= zLEVEL_APPLICATION;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 4
	mov	DWORD PTR _lControl$[ebp], ecx

; 2547 :          else

	jmp	SHORT $L8336
$L8334:

; 2548 :          if ( lpAppQualView->hTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $L8336

; 2549 :             lControl |= zLEVEL_SYSTEM;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 8
	mov	DWORD PTR _lControl$[ebp], edx
$L8336:

; 2552 : 
; 2553 :    // Make sure request is for valid OD.
; 2554 :    lpViewOD = ActivateViewObject( lpAppQualView, cpcViewOD_Name, bSystemObj );

	mov	al, BYTE PTR _bSystemObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 2555 :    if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $L8337

; 2557 :       fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2558 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8306
$L8337:

; 2560 : 
; 2561 :    // First off, see if we can open the filename requested,
; 2562 :    // go through characters in name and see if they need either
; 2563 :    // a directory qualification prefix or an object file suffix.
; 2564 : 
; 2565 : // Change DGC 5/27/96 -- In an attempt to make all code retrieve the
; 2566 : // application in the same way from a view, I have changed the following code.
; 2567 :    fnGetApplicationForSubtask( &lpApp, lpAppQualView );

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	call	_fnGetApplicationForSubtask@8

; 2568 : 
; 2569 : // DGC 9/23/96
; 2570 : // I changed the logic: if the file name is not qualfied, use the object dir
; 2571 : // for the application. I repeated this change in CommitOI_ToFile.
; 2572 :    if ( zstrchr( cpcFileName, cDirSep ) == 0 )

	movsx	eax, BYTE PTR _cDirSep
	push	eax
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $L8338

; 2574 :       if ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $L8339

; 2575 :          zstrcpy( szWork, lpApp->szObjectDir );

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 347				; 0000015bH
	push	edx
	lea	eax, DWORD PTR _szWork$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2576 :       else

	jmp	SHORT $L8340
$L8339:

; 2578 :          LPAPP lpSystemApp = zGETPTR( AnchorBlock->hSystemApp );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSystemApp$8341[ebp], eax

; 2579 : 
; 2580 :          zstrcpy( szWork, lpSystemApp->szObjectDir );

	mov	eax, DWORD PTR _lpSystemApp$8341[ebp]
	add	eax, 347				; 0000015bH
	push	eax
	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$L8340:

; 2582 : 
; 2583 :       SysAppendcDirSep( szWork );

	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 2585 :    else

	jmp	SHORT $L8343
$L8338:

; 2586 :       szWork[ 0 ] = 0;

	mov	BYTE PTR _szWork$[ebp], 0
$L8343:

; 2587 : 
; 2588 :    zstrcat( szWork, cpcFileName ); // w\bin\sys\tzrpsrco.lod

	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2589 :    SysConvertEnvironmentString( szOpenFileName, szWork );

	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	call	_SysConvertEnvironmentString@8

; 2590 : 
; 2591 :    if ( AnchorBlock->TraceFlags.bOpenFile )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 2
	and	edx, 1
	test	edx, edx
	je	SHORT $L8344

; 2592 :       TraceLineS( "(oi) opening ", szOpenFileName );

	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0O@PPBE@?$CIoi?$CJ?5opening?5?$AA@ ; `string'
	call	_TraceLineS@8
$L8344:

; 2593 : 
; 2594 :    // Open the file for the object instance data.
; 2595 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 12					; 0000000cH
	test	ecx, ecx
	je	SHORT $L8346

; 2597 :       lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 2600 :    else

	jmp	SHORT $L8348
$L8346:

; 2602 :       lpTask = lpCurrentTask;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpTask$[ebp], ecx
$L8348:

; 2605 : 
; 2606 :    if ( lpAppQualView && zGETPTR( lpAppQualView->hTask ) == lpTask ) // added dks 2006.09.15 to prevent looking

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $L8350
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpTask$[ebp]
	jne	SHORT $L8350

; 2607 :       vTask = lpAppQualView;                                         // at incorrect app when we just pick vTask

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	mov	DWORD PTR _vTask$[ebp], ecx

; 2608 :    else                                                              // willy-nilly (as is done on the next line)

	jmp	SHORT $L8351
$L8350:

; 2609 :       vTask = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTask$[ebp], eax
$L8351:

; 2610 : 
; 2611 :    hFile = SysOpenFile( vTask, szOpenFileName, COREFILE_READ );

	push	128					; 00000080H
	lea	ecx, DWORD PTR _szOpenFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTask$[ebp]
	push	edx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 2612 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L8355

; 2614 :       if ( lControl & zNOI_OKAY )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $L8354

; 2616 :          fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2617 :          return( -1 );

	or	ax, -1
	jmp	$L8306
$L8354:

; 2621 :          //  "KZOEE071 - Error opening instance file "
; 2622 :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 16, 71, 0,
; 2623 :                            szOpenFileName, 0 );

	push	0
	lea	edx, DWORD PTR _szOpenFileName$[ebp]
	push	edx
	push	0
	push	71					; 00000047H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2624 :          fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2625 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8306
$L8355:

; 2628 : 
; 2629 :    ActFileData.pchFileName = szOpenFileName;

	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	mov	DWORD PTR _ActFileData$[ebp], eax

; 2630 :    ActFileData.hFile = hFile;

	mov	ecx, DWORD PTR _hFile$[ebp]
	mov	DWORD PTR _ActFileData$[ebp+4], ecx

; 2631 :    ActFileData.lLine = 1;

	mov	DWORD PTR _ActFileData$[ebp+8], 1

; 2632 : 
; 2633 :    nRC = SfActivateOI_FromStream( pvReturnView, cpcViewOD_Name,
; 2634 :                                // lpAppQualView, lControl,
; 2635 :                                   vTask, lControl,
; 2636 :                                   fnReadDataFromFileStream,
; 2637 :                                   (zPVOID) &ActFileData );

	lea	edx, DWORD PTR _ActFileData$[ebp]
	push	edx
	push	OFFSET FLAT:_fnReadDataFromFileStream@20
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	push	eax
	call	_SfActivateOI_FromStream@24
	mov	WORD PTR _nRC$[ebp], ax

; 2638 : 
; 2639 : // TraceLine( "ActivateOI_FromFile: 0x%08x", *pvReturnView );
; 2640 : 
; 2641 :    // Close the file
; 2642 :    fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 2643 : 
; 2644 :    fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2645 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L8306:

; 2646 : 
; 2647 : } // ActivateOI_FromFile

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_ActivateOI_FromFile@20 ENDP
_TEXT	ENDS
PUBLIC	_ActivateOI_FromOI@12
_TEXT	SEGMENT
_pvReturnView$ = 8
_lpSrcView$ = 12
_lControl$ = 16
_ActivateOI_FromOI@12 PROC NEAR

; 2702 : {

	push	ebp
	mov	ebp, esp

; 2703 :    return( ActivateOI_FromOI_ForTask( pvReturnView, lpSrcView, 0, lControl ) );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	push	edx
	call	_ActivateOI_FromOI_ForTask@16

; 2704 : }

	pop	ebp
	ret	12					; 0000000cH
_ActivateOI_FromOI@12 ENDP
_TEXT	ENDS
EXTRN	_fnCopyAttributeRecord:NEAR
EXTRN	_fnAddEntityToDebugChange@4:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_fnAllocDataspace:NEAR
EXTRN	_fnSetEntityKey@12:NEAR
_TEXT	SEGMENT
_pvReturnView$ = 8
_lpSrcView$ = 12
_lControl$ = 20
_lpCurrentTask$ = -36
_lpOwningTask$ = -20
_lpSrcViewOI$ = -28
_lpTgtViewOI$ = -12
_lpViewCsr$ = -4
_lpTgtView$ = -8
_l$ = -24
_bMultiple$ = -32
_nRC$ = -16
_lpInstanceOwningTask$8403 = -56
_lpViewEntity$8404 = -52
_lpSrcEntityInstance$8405 = -40
_lpTgtEntityInstance$8406 = -64
_lpLastTgtEntityInstance$8407 = -80
_lpTgtParent$8408 = -44
_lpWkInstance1$8409 = -72
_lpWkInstance2$8410 = -68
_hTgtViewOI$8411 = -48
_hTgtEntityInstance$8412 = -60
_nLastLvl$8413 = -76
_lpRootViewEntityCsr$8418 = -84
_hWkInstance1$8439 = -88
_ActivateOI_FromOI_ForTask@16 PROC NEAR

; 2711 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 2712 :    LPTASK      lpCurrentTask;
; 2713 :    LPTASK      lpOwningTask;
; 2714 :    LPVIEWOI    lpSrcViewOI;
; 2715 :    LPVIEWOI    lpTgtViewOI;
; 2716 :    LPVIEWCSR   lpViewCsr;
; 2717 :    zVIEW       lpTgtView;
; 2718 :    zLONG       l;
; 2719 :    zBOOL       bMultiple;
; 2720 :    zSHORT      nRC;
; 2721 : 
; 2722 :    *pvReturnView = 0;  // init in case of error

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 2723 : 
; 2724 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2725 :    if ( (lpCurrentTask = fnOperationCall( iActivateOI_FromOI, lpSrcView,
; 2726 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	55					; 00000037H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8382

; 2728 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8372
$L8382:

; 2730 : 
; 2731 :    // Get the view oi and ensure that it has no outstanding temporal
; 2732 :    // entities or subobjects.
; 2733 :    lpViewCsr = zGETPTR( lpSrcView->hViewCsr );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2734 : 
; 2735 :    lpSrcViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOI$[ebp], eax

; 2736 :    if ( lpSrcViewOI->nVersionedInstances )

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	je	SHORT $L8385

; 2738 :       //  "KZOEE076 - Object instance contains versioned entity instances"
; 2739 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 76, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	push	8
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2740 :       fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 2741 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8372
$L8385:

; 2743 : 
; 2744 :    // Verify only one zLEVEL_ option requested.
; 2745 :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], edx

; 2746 :    if ( l && (-l & l) != l )

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $L8386
	mov	eax, DWORD PTR _l$[ebp]
	neg	eax
	and	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _l$[ebp]
	je	SHORT $L8386

; 2748 :       // error, More than one zLEVEL_ option requested
; 2749 :       // "KZOEE023 - Invalid parameter, "
; 2750 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 23, 0,
; 2751 :                         "More than one zLEVEL_ option requested", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ ; `string'
	push	0
	push	23					; 00000017H
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2752 :       fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 2753 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8372
$L8386:

; 2755 : 
; 2756 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 12					; 0000000cH
	test	ecx, ecx
	je	SHORT $L8387

; 2757 :       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 2758 :    else

	jmp	SHORT $L8389
$L8387:

; 2759 :       lpOwningTask = lpCurrentTask;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], ecx
$L8389:

; 2760 : 
; 2761 :    // Get multiple root indicator.
; 2762 :    bMultiple = 0;

	mov	BYTE PTR _bMultiple$[ebp], 0

; 2763 :    if ( lControl & zMULTIPLE )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 256				; 00000100H
	test	edx, edx
	je	SHORT $L8390

; 2764 :       bMultiple = TRUE;

	mov	BYTE PTR _bMultiple$[ebp], 1
$L8390:

; 2765 : 
; 2766 :    // If zLEVEL_SAME is requested.
; 2767 :    if ( lControl & zLEVEL_SAME )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $L8400

; 2769 :       // Turn off the 'same' indicator.
; 2770 :       lControl ^= zLEVEL_SAME;

	mov	ecx, DWORD PTR _lControl$[ebp]
	xor	ecx, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], ecx

; 2771 :       // To determine what the level is of the qualifying view
; 2772 :       //   1. Change lpSrcView to point to the initial
; 2773 :       //      view created for the object instance
; 2774 :       //   2. Check for application level, if there use
; 2775 :       //      zLEVEL_APPLICATION.
; 2776 :       //   3. Check if the view task is the main task, if so use
; 2777 :       //      zLEVEL_SYSTEM.
; 2778 :       //   4. Use the task level...
; 2779 :       lpViewCsr = zGETPTR( lpSrcView->hViewCsr );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
$L8394:

; 2780 :       while ( lpViewCsr->hNextViewCsr )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+2], 0
	je	SHORT $L8395

; 2781 :          lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
	jmp	SHORT $L8394
$L8395:

; 2782 : 
; 2783 :       lpSrcView = zGETPTR( lpViewCsr->hView );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcView$[ebp], eax

; 2784 :       if ( lpSrcView->bApplicationView )

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 3
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8398

; 2785 :          lControl |= zLEVEL_APPLICATION;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 4
	mov	DWORD PTR _lControl$[ebp], edx

; 2786 :       else

	jmp	SHORT $L8400
$L8398:

; 2787 :       if ( lpSrcView->hTask == AnchorBlock->hMainTask )

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [eax+14]
	cmp	edx, DWORD PTR [ecx+106]
	jne	SHORT $L8400

; 2788 :          lControl |= zLEVEL_SYSTEM;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	al, 8
	mov	DWORD PTR _lControl$[ebp], eax
$L8400:

; 2790 : 
; 2791 :    if ( (nRC = fnDeclareView( &lpTgtView, lpOwningTask,
; 2792 :                               lpSrcView, 0, 0 )) != 0 )

	push	0
	push	0
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L8401

; 2794 :       fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 2795 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L8372
$L8401:

; 2797 : 
; 2798 : #if 0
; 2799 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 2800 :    {
; 2801 :       zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 2802 :                                   zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 2803 :       if ( (nRC = SfTransferView( lpTgtView, lpSrcView,
; 2804 :                                   nScope )) != 0 )
; 2805 :       {
; 2806 :          fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );
; 2807 :          return( nRC );
; 2808 :       }
; 2809 :    }
; 2810 : #endif
; 2811 : 
; 2812 :    // Create an empty object instance in which to copy the object instance.
; 2813 :    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, lpTgtView, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2814 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L8467

; 2816 :       LPTASK           lpInstanceOwningTask;
; 2817 :       LPVIEWENTITY     lpViewEntity;
; 2818 :       LPENTITYINSTANCE lpSrcEntityInstance;
; 2819 :       LPENTITYINSTANCE lpTgtEntityInstance;
; 2820 :       LPENTITYINSTANCE lpLastTgtEntityInstance;
; 2821 :       LPENTITYINSTANCE lpTgtParent;
; 2822 :       LPENTITYINSTANCE lpWkInstance1;
; 2823 :       LPENTITYINSTANCE lpWkInstance2;
; 2824 :       LPVIEWOI         hTgtViewOI;
; 2825 :       zPVOID           hTgtEntityInstance;
; 2826 :       zSHORT           nLastLvl;
; 2827 : 
; 2828 :       // Here we copy the instance in memory.
; 2829 :       lpViewCsr   = zGETPTR( lpTgtView->hViewCsr );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2830 :       hTgtViewOI  = lpViewCsr->hViewOI;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hTgtViewOI$8411[ebp], ecx

; 2831 :       lpTgtViewOI = zGETPTR( hTgtViewOI );

	mov	edx, DWORD PTR _hTgtViewOI$8411[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOI$[ebp], eax

; 2832 :       lpInstanceOwningTask = zGETPTR( lpTgtViewOI->hAllocTask );

	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInstanceOwningTask$8403[ebp], eax

; 2833 :       lpTgtEntityInstance = 0;

	mov	DWORD PTR _lpTgtEntityInstance$8406[ebp], 0

; 2834 :       lpLastTgtEntityInstance = 0;

	mov	DWORD PTR _lpLastTgtEntityInstance$8407[ebp], 0

; 2835 :       lpTgtParent = 0;

	mov	DWORD PTR _lpTgtParent$8408[ebp], 0

; 2836 : 
; 2837 :       // Set the first source entity instance.  If zSINGLE was set, then the
; 2838 :       // first entity instance should be the selected root for the view.
; 2839 :       lpSrcEntityInstance = 0;

	mov	DWORD PTR _lpSrcEntityInstance$8405[ebp], 0

; 2840 : 
; 2841 :       if ( bMultiple == FALSE )

	mov	edx, DWORD PTR _bMultiple$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L8417

; 2843 :          LPVIEWENTITYCSR lpRootViewEntityCsr;
; 2844 : 
; 2845 :          lpViewCsr= zGETPTR( lpSrcView->hViewCsr );

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2846 :          lpRootViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootViewEntityCsr$8418[ebp], eax

; 2847 :          lpSrcEntityInstance = zGETPTR( lpRootViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpRootViewEntityCsr$8418[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$8405[ebp], eax
$L8417:

; 2849 : 
; 2850 :       if ( lpSrcEntityInstance == 0 || lpSrcEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpSrcEntityInstance$8405[ebp], 0
	je	SHORT $L8424
	cmp	DWORD PTR _lpSrcEntityInstance$8405[ebp], 1
	jne	SHORT $L8423
$L8424:

; 2851 :          lpSrcEntityInstance = zGETPTR( lpSrcViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$8405[ebp], eax
$L8423:

; 2852 : 
; 2853 :       // For each instance in the source, copy the instance and
; 2854 :       // link the new instance to the source instance. This link will
; 2855 :       // be removed later on after the initial copy is complete.
; 2856 :       while ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$8405[ebp], 0
	je	$L8428

; 2858 :          nLastLvl = lpSrcEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLastLvl$8413[ebp], ax

; 2859 :          lpViewEntity = zGETPTR( lpSrcEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$8404[ebp], eax

; 2860 : 
; 2861 :          hTgtEntityInstance =
; 2862 :                      fnAllocDataspace( lpInstanceOwningTask->hFirstDataHeader,
; 2863 :                                        sizeof( EntityInstanceRecord ), 0, 0,
; 2864 :                                        iEntityInstance );

	push	10024					; 00002728H
	push	0
	push	0
	push	68					; 00000044H
	mov	eax, DWORD PTR _lpInstanceOwningTask$8403[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTgtEntityInstance$8412[ebp], eax

; 2865 :          lpTgtEntityInstance = zGETPTR( hTgtEntityInstance );

	mov	edx, DWORD PTR _hTgtEntityInstance$8412[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$8406[ebp], eax

; 2866 :          if ( lpTgtEntityInstance )

	cmp	DWORD PTR _lpTgtEntityInstance$8406[ebp], 0
	je	$L8432

; 2868 :             zmemcpy( (zPVOID) lpTgtEntityInstance,
; 2869 :                      (zPVOID) lpSrcEntityInstance,
; 2870 :                      sizeof( EntityInstanceRecord ) );

	push	68					; 00000044H
	mov	eax, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2871 :             lpTgtEntityInstance->hViewOI   = hTgtViewOI;

	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	eax, DWORD PTR _hTgtViewOI$8411[ebp]
	mov	DWORD PTR [edx+10], eax

; 2872 :             lpTgtEntityInstance->hPrevHier = zGETHNDL( lpLastTgtEntityInstance );

	mov	ecx, DWORD PTR _lpLastTgtEntityInstance$8407[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR [edx+18], eax

; 2873 :             lpTgtEntityInstance->hNextHier = 0;

	mov	eax, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR [eax+14], 0

; 2874 :             lpTgtEntityInstance->hNextTwin = 0;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR [ecx+22], 0

; 2875 :             fnSetEntityKey( lpInstanceOwningTask, 0, lpTgtEntityInstance );

	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpInstanceOwningTask$8403[ebp]
	push	eax
	call	_fnSetEntityKey@12

; 2876 :             if ( lpLastTgtEntityInstance )

	cmp	DWORD PTR _lpLastTgtEntityInstance$8407[ebp], 0
	je	$L8437

; 2878 :                lpLastTgtEntityInstance->hNextHier = hTgtEntityInstance;

	mov	ecx, DWORD PTR _lpLastTgtEntityInstance$8407[ebp]
	mov	edx, DWORD PTR _hTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [ecx+14], edx

; 2879 :                if ( lpSrcEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L8438

; 2881 :                   LPENTITYINSTANCE hWkInstance1;
; 2882 : 
; 2883 :                   hWkInstance1  = lpSrcEntityInstance->hPrevHier;

	mov	ecx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	mov	edx, DWORD PTR [ecx+18]
	mov	DWORD PTR _hWkInstance1$8439[ebp], edx

; 2884 :                   lpWkInstance1 = zGETPTR( hWkInstance1 );

	mov	eax, DWORD PTR _hWkInstance1$8439[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8409[ebp], eax

; 2885 :                   lpWkInstance2 = zGETPTR( lpTgtEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance2$8410[ebp], eax
$L8443:

; 2886 :                   while ( hWkInstance1 != lpSrcEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	mov	ecx, DWORD PTR _hWkInstance1$8439[ebp]
	cmp	ecx, DWORD PTR [eax+26]
	je	SHORT $L8444

; 2888 :                      hWkInstance1  = lpWkInstance1->hPrevHier;

	mov	edx, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR _hWkInstance1$8439[ebp], eax

; 2889 :                      lpWkInstance1 = zGETPTR( hWkInstance1 );

	mov	ecx, DWORD PTR _hWkInstance1$8439[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8409[ebp], eax

; 2890 :                      lpWkInstance2 = zGETPTR( lpWkInstance2->hPrevHier );

	mov	edx, DWORD PTR _lpWkInstance2$8410[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance2$8410[ebp], eax

; 2891 :                   }

	jmp	SHORT $L8443
$L8444:

; 2892 : 
; 2893 :                   lpTgtEntityInstance->hPrevTwin = zGETHNDL( lpWkInstance2 );

	mov	ecx, DWORD PTR _lpWkInstance2$8410[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR [edx+26], eax

; 2894 :                   lpWkInstance2->hNextTwin = hTgtEntityInstance;

	mov	eax, DWORD PTR _lpWkInstance2$8410[ebp]
	mov	ecx, DWORD PTR _hTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [eax+22], ecx
$L8438:

; 2897 :             else

	jmp	SHORT $L8448
$L8437:

; 2899 :                lpTgtViewOI->hRootEntityInstance = hTgtEntityInstance;

	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	eax, DWORD PTR _hTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [edx+26], eax

; 2900 :                lpTgtEntityInstance->hPrevTwin = 0;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR [ecx+26], 0
$L8448:

; 2902 : 
; 2903 :             lpTgtEntityInstance->hParent = zGETHNDL( lpTgtParent );

	mov	edx, DWORD PTR _lpTgtParent$8408[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR [ecx+30], eax

; 2904 :          // if ( lpTgtEntityInstance->hParent == UNSET_CSR )
; 2905 :          //    SysMessageBox( 0, "ActivateOI_FromOI", "UNSET_CSR", -1 );
; 2906 : 
; 2907 :             if ( lpSrcEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $L8450

; 2908 :                lpSrcEntityInstance->hNextLinked = hTgtEntityInstance;

	mov	eax, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	mov	ecx, DWORD PTR _hTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [eax+42], ecx
$L8450:

; 2909 : 
; 2910 :             fnAddEntityToDebugChange( lpTgtEntityInstance );

	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	push	edx
	call	_fnAddEntityToDebugChange@4

; 2912 :          else

	jmp	SHORT $L8452
$L8432:

; 2913 :          if ( lpLastTgtEntityInstance )

	cmp	DWORD PTR _lpLastTgtEntityInstance$8407[ebp], 0
	je	SHORT $L8452

; 2915 :             lpLastTgtEntityInstance->hNextHier = 0;

	mov	eax, DWORD PTR _lpLastTgtEntityInstance$8407[ebp]
	mov	DWORD PTR [eax+14], 0

; 2916 :             lpLastTgtEntityInstance->hNextTwin = 0;

	mov	ecx, DWORD PTR _lpLastTgtEntityInstance$8407[ebp]
	mov	DWORD PTR [ecx+22], 0

; 2917 :             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 2918 :             break;

	jmp	$L8428
$L8452:

; 2920 : 
; 2921 :          // Get the next entity instance in memory to copy.
; 2922 :          lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$8405[ebp], eax

; 2923 :          if ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$8405[ebp], 0
	je	SHORT $L8454

; 2925 :             if ( lpSrcEntityInstance->nLevel == 1 && bMultiple == FALSE )

	mov	ecx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	edx, 1
	jne	SHORT $L8455
	mov	eax, DWORD PTR _bMultiple$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L8455

; 2927 :                nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1

; 2928 :                lpSrcEntityInstance = 0;

	mov	DWORD PTR _lpSrcEntityInstance$8405[ebp], 0

; 2930 :             else

	jmp	SHORT $L8461
$L8455:

; 2931 :             if ( lpSrcEntityInstance->nLevel > nLastLvl )

	mov	ecx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nLastLvl$8413[ebp]
	cmp	edx, eax
	jle	SHORT $L8457

; 2932 :                lpTgtParent = lpTgtEntityInstance;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR _lpTgtParent$8408[ebp], ecx

; 2933 :             else

	jmp	SHORT $L8461
$L8457:

; 2935 :                while ( lpTgtParent &&
; 2936 :                        lpTgtParent->nLevel >= lpSrcEntityInstance->nLevel )

	cmp	DWORD PTR _lpTgtParent$8408[ebp], 0
	je	SHORT $L8461
	mov	edx, DWORD PTR _lpTgtParent$8408[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	jl	SHORT $L8461

; 2938 :                   lpTgtParent = zGETPTR( lpTgtParent->hParent );

	mov	eax, DWORD PTR _lpTgtParent$8408[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtParent$8408[ebp], eax

; 2939 :                }

	jmp	SHORT $L8457
$L8461:

; 2942 :          else

	jmp	SHORT $L8463
$L8454:

; 2943 :             nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$L8463:

; 2944 : 
; 2945 :          lpLastTgtEntityInstance = lpTgtEntityInstance;

	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR _lpLastTgtEntityInstance$8407[ebp], edx

; 2946 :       }

	jmp	$L8423
$L8428:

; 2947 : 
; 2948 :       // We've copied the entity instance chain and linked all the
; 2949 :       // new instance information with the source being copied, now
; 2950 :       // isolate the copied instance by de-linking it from all
; 2951 :       // instances in other ViewOI's and copying the data-record
; 2952 :       // for each instance.
; 2953 :       hTgtEntityInstance  = lpTgtViewOI->hRootEntityInstance;

	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR _hTgtEntityInstance$8412[ebp], ecx

; 2954 :       lpTgtEntityInstance = zGETPTR( hTgtEntityInstance );

	mov	edx, DWORD PTR _hTgtEntityInstance$8412[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$8406[ebp], eax
$L8466:

; 2955 :       while ( lpTgtEntityInstance )

	cmp	DWORD PTR _lpTgtEntityInstance$8406[ebp], 0
	je	$L8467

; 2957 :          // First, see if the attribute record information needs
; 2958 :          // to be copied, if so, copy it now.
; 2959 :          lpWkInstance1 = zGETPTR( lpTgtEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8409[ebp], eax
$L8470:

; 2960 :          while ( lpWkInstance1 && lpWkInstance1 != lpTgtEntityInstance )

	cmp	DWORD PTR _lpWkInstance1$8409[ebp], 0
	je	SHORT $L8471
	mov	edx, DWORD PTR _lpWkInstance1$8409[ebp]
	cmp	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	je	SHORT $L8471

; 2962 :             if ( lpWkInstance1->hViewOI != hTgtViewOI )

	mov	eax, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	ecx, DWORD PTR [eax+10]
	cmp	ecx, DWORD PTR _hTgtViewOI$8411[ebp]
	je	SHORT $L8472

; 2963 :                break;

	jmp	SHORT $L8471
$L8472:

; 2964 : 
; 2965 :             lpWkInstance1 = zGETPTR( lpWkInstance1->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8409[ebp], eax

; 2966 :          }

	jmp	SHORT $L8470
$L8471:

; 2967 : 
; 2968 :          // Copy the non-persistent record regardless
; 2969 :          lpTgtEntityInstance->hNonPersistRecord =
; 2970 :              fnCopyAttributeRecord( lpInstanceOwningTask,
; 2971 :                 zGETPTR( lpTgtEntityInstance->hViewEntity ),
; 2972 :                 (zPCHAR) zGETPTR( lpTgtEntityInstance->hNonPersistRecord ), 0 );

	push	0
	mov	ecx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpInstanceOwningTask$8403[ebp]
	push	edx
	call	_fnCopyAttributeRecord
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR [ecx+64], eax

; 2973 : 
; 2974 :          // Copy the persistent record unless the instance is linked
; 2975 :          // only to instances in the same ViewOI (which means that
; 2976 :          // the persistent record has already been copied).
; 2977 :          if ( lpWkInstance1 != lpTgtEntityInstance )

	mov	edx, DWORD PTR _lpWkInstance1$8409[ebp]
	cmp	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	je	$L8489

; 2979 :             lpTgtEntityInstance->hPersistRecord =
; 2980 :                      fnCopyAttributeRecord( lpInstanceOwningTask,
; 2981 :                          zGETPTR( lpTgtEntityInstance->hViewEntity ),
; 2982 :                          (zPCHAR) zGETPTR( lpTgtEntityInstance->hPersistRecord ), 1 );

	push	1
	mov	eax, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpInstanceOwningTask$8403[ebp]
	push	ecx
	call	_fnCopyAttributeRecord
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR [edx+60], eax

; 2983 : 
; 2984 :             if ( lpWkInstance1 )

	cmp	DWORD PTR _lpWkInstance1$8409[ebp], 0
	je	$L8489

; 2986 :                // The instance is linked to another instance in a different
; 2987 :                // ViewOI, create two chains out of the single chain to isolate
; 2988 :                // this object instance from the other one being copied.
; 2989 :                lpSrcEntityInstance = lpWkInstance1;

	mov	eax, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	DWORD PTR _lpSrcEntityInstance$8405[ebp], eax

; 2990 :                lpWkInstance1 = zGETPTR( lpTgtEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8409[ebp], eax
$L8484:

; 2991 :                while ( lpWkInstance1->hNextLinked != hTgtEntityInstance )

	mov	eax, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	ecx, DWORD PTR [eax+42]
	cmp	ecx, DWORD PTR _hTgtEntityInstance$8412[ebp]
	je	SHORT $L8485

; 2992 :                   lpWkInstance1 = zGETPTR( lpWkInstance1->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8409[ebp], eax
	jmp	SHORT $L8484
$L8485:

; 2993 : 
; 2994 :                lpWkInstance1->hNextLinked = lpTgtEntityInstance->hNextLinked;

	mov	ecx, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax

; 2995 :                lpTgtEntityInstance->hNextLinked = 0;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR [ecx+42], 0
$L8488:

; 2998 :                   lpWkInstance1 = zGETPTR( lpSrcEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8409[ebp], eax
$L8492:

; 2999 :                   while ( lpWkInstance1 != lpSrcEntityInstance &&
; 3000 :                           lpWkInstance1->hViewOI != lpTgtEntityInstance->hViewOI )

	mov	ecx, DWORD PTR _lpWkInstance1$8409[ebp]
	cmp	ecx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	je	SHORT $L8493
	mov	edx, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	eax, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	je	SHORT $L8493

; 3002 :                      lpWkInstance1 = zGETPTR( lpWkInstance1->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8409[ebp], eax

; 3003 :                   }

	jmp	SHORT $L8492
$L8493:

; 3004 : 
; 3005 :                   if ( lpWkInstance1 == lpSrcEntityInstance )

	mov	ecx, DWORD PTR _lpWkInstance1$8409[ebp]
	cmp	ecx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	jne	SHORT $L8495

; 3006 :                      break;

	jmp	SHORT $L8489
$L8495:

; 3007 : 
; 3008 :                   // We've found another instance in the source chain which
; 3009 :                   // needs to be moved to the target chain, add the instance
; 3010 :                   // to the target chain and update its record pointer to
; 3011 :                   // be the same as the target instance.
; 3012 :                   lpWkInstance2 = lpSrcEntityInstance;

	mov	edx, DWORD PTR _lpSrcEntityInstance$8405[ebp]
	mov	DWORD PTR _lpWkInstance2$8410[ebp], edx
$L8498:

; 3013 :                   while ( lpWkInstance2->hNextLinked != zGETHNDL( lpWkInstance1 ) )

	mov	eax, DWORD PTR _lpWkInstance1$8409[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpWkInstance2$8410[ebp]
	cmp	DWORD PTR [ecx+42], eax
	je	SHORT $L8499

; 3014 :                      lpWkInstance2 = zGETPTR( lpWkInstance2->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance2$8410[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance2$8410[ebp], eax
	jmp	SHORT $L8498
$L8499:

; 3015 : 
; 3016 :                   lpWkInstance2->hNextLinked = lpWkInstance1->hNextLinked;

	mov	ecx, DWORD PTR _lpWkInstance2$8410[ebp]
	mov	edx, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax

; 3017 :                   lpWkInstance1->hPersistRecord = lpTgtEntityInstance->hPersistRecord;

	mov	ecx, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax

; 3018 :                   if ( lpTgtEntityInstance->hNextLinked == 0 )

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $L8501

; 3019 :                      lpWkInstance1->hNextLinked = hTgtEntityInstance;

	mov	edx, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	eax, DWORD PTR _hTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [edx+42], eax

; 3020 :                   else

	jmp	SHORT $L8502
$L8501:

; 3021 :                      lpWkInstance1->hNextLinked = lpTgtEntityInstance->hNextLinked;

	mov	ecx, DWORD PTR _lpWkInstance1$8409[ebp]
	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax
$L8502:

; 3022 : 
; 3023 :                   lpTgtEntityInstance->hNextLinked = zGETHNDL( lpWkInstance1 );

	mov	ecx, DWORD PTR _lpWkInstance1$8409[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	DWORD PTR [edx+42], eax

; 3024 :                }

	jmp	$L8488
$L8489:

; 3027 : 
; 3028 :          hTgtEntityInstance  = lpTgtEntityInstance->hNextHier;

	mov	eax, DWORD PTR _lpTgtEntityInstance$8406[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hTgtEntityInstance$8412[ebp], ecx

; 3029 :          lpTgtEntityInstance = zGETPTR( hTgtEntityInstance );

	mov	edx, DWORD PTR _hTgtEntityInstance$8412[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$8406[ebp], eax

; 3030 :       }

	jmp	$L8466
$L8467:

; 3032 : 
; 3033 :    if ( nRC >= 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $L8505

; 3034 :       fnResetView( lpTgtView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_fnResetView
	add	esp, 8
$L8505:

; 3035 : 
; 3036 :    // Based on the return code, see if we have to reset the view to the
; 3037 :    // prior instance or clean up the prior instance.
; 3038 :    // Note: rc = indicates multiple level1 roots are present.
; 3039 :    if ( nRC >= -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	SHORT $L8506

; 3041 :       if ( lControl & zREADONLY )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $L8507

; 3042 :          lpTgtView->bReadOnly = TRUE;

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	DWORD PTR [eax+30], edx
$L8507:

; 3043 : 
; 3044 :       lpTgtViewOI->bUpdated     = lpSrcViewOI->bUpdated;

	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shr	edx, 4
	and	edx, 1
	and	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -17				; ffffffefH
	or	ecx, edx
	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 3045 :       lpTgtViewOI->bUpdatedFile = lpSrcViewOI->bUpdatedFile;

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 5
	and	ecx, 1
	and	ecx, 1
	shl	ecx, 5
	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	al, -33					; ffffffdfH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 3046 : 
; 3047 :       *pvReturnView = lpTgtView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	DWORD PTR [edx], eax

; 3050 :    else

	jmp	SHORT $L8508
$L8506:

; 3052 :       fnDropView( lpTgtView );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_fnDropView@4

; 3053 :       *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0
$L8508:

; 3055 : 
; 3056 :    fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 3057 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L8372:

; 3058 : 
; 3059 : } // ActivateOI_FromOI_ForTask

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_ActivateOI_FromOI_ForTask@16 ENDP
_TEXT	ENDS
PUBLIC	_fnReadDataFromBuffer@20
PUBLIC	??_C@_0BE@CKOO@Out?5of?5buffer?5space?$AA@	; `string'
PUBLIC	??_C@_0BE@LIH@Internal?5Core?5Error?$AA@	; `string'
EXTRN	_SysMessageBox@16:NEAR
;	COMDAT ??_C@_0BE@CKOO@Out?5of?5buffer?5space?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BE@CKOO@Out?5of?5buffer?5space?$AA@ DB 'Out of buffer space', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@LIH@Internal?5Core?5Error?$AA@
_DATA	SEGMENT
??_C@_0BE@LIH@Internal?5Core?5Error?$AA@ DB 'Internal Core Error', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_pvData$ = 12
_ppchReturnBuffer$ = 16
_uLth$ = 20
_nErrorNbr$ = 24
_lpBufferData$ = -4
_lpTask$8524 = -12
_pchExtraData$8526 = -8
_fnReadDataFromBuffer@20 PROC NEAR

; 3071 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3072 :    LPBUFFERDATA lpBufferData = (LPBUFFERDATA) pvData;

	mov	eax, DWORD PTR _pvData$[ebp]
	mov	DWORD PTR _lpBufferData$[ebp], eax

; 3073 : 
; 3074 :    // If nErrorNbr is not 0, then flash the error message and get out.
; 3075 :    if ( nErrorNbr )

	movsx	ecx, WORD PTR _nErrorNbr$[ebp]
	test	ecx, ecx
	je	$L8523

; 3077 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8524[ebp], eax

; 3078 :       zPCHAR pchExtraData = (zPCHAR) ppchReturnBuffer;

	mov	ecx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	DWORD PTR _pchExtraData$8526[ebp], ecx

; 3079 : 
; 3080 :       switch ( nErrorNbr )
; 3081 :       {

	movsx	edx, WORD PTR _nErrorNbr$[ebp]
	mov	DWORD PTR -16+[ebp], edx
	mov	eax, DWORD PTR -16+[ebp]
	sub	eax, 74					; 0000004aH
	mov	DWORD PTR -16+[ebp], eax
	cmp	DWORD PTR -16+[ebp], 30			; 0000001eH
	ja	$L8529
	mov	edx, DWORD PTR -16+[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR $L12751[edx]
	jmp	DWORD PTR $L12752[ecx*4]
$L8532:

; 3082 :          case 74:
; 3083 :             // "KZOEE074 - Invalid Entity name on line "
; 3084 :             fnIssueCoreError( lpTask, lpView, 16, 74, 0,
; 3085 :                               pchExtraData, 0 );

	push	0
	mov	eax, DWORD PTR _pchExtraData$8526[ebp]
	push	eax
	push	0
	push	74					; 0000004aH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$8524[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3086 :             break;

	jmp	SHORT $L8529
$L8533:

; 3087 : 
; 3088 :          case 75:
; 3089 :             // "KZOEE075 - Invalid Entity level on line "
; 3090 :             fnIssueCoreError( lpTask, lpView, 16, 75, 0,
; 3091 :                               pchExtraData, 0 );

	push	0
	mov	eax, DWORD PTR _pchExtraData$8526[ebp]
	push	eax
	push	0
	push	75					; 0000004bH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$8524[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3092 :             break;

	jmp	SHORT $L8529
$L8534:

; 3093 : 
; 3094 :          case 90:
; 3095 :             // "KZOEE090 - Maximum number of entites in portable file exceeded"
; 3096 :             fnIssueCoreError( lpTask, lpView, 16, 90, 0, 0, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	0
	push	0
	push	90					; 0000005aH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$8524[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3097 :             break;

	jmp	SHORT $L8529
$L8535:

; 3098 : 
; 3099 :          case 104:
; 3100 :             // "KZOEE104 - Invalid Attribute name for Entity"
; 3101 :             fnIssueCoreError( lpTask, lpView, 16, 104, 0, pchExtraData, 0 );

	push	0
	mov	edx, DWORD PTR _pchExtraData$8526[ebp]
	push	edx
	push	0
	push	104					; 00000068H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$8524[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$L8529:

; 3105 : 
; 3106 :       return( 0 );

	xor	ax, ax
	jmp	$L8541
$L8523:

; 3109 : 
; 3110 :    if ( lpBufferData->pchCurrentByte >= lpBufferData->pchEnd )

	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jb	SHORT $L8536

; 3112 :       *ppchReturnBuffer = 0;

	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	DWORD PTR [edx], 0

; 3113 :       return( 0 ); // EOF

	xor	ax, ax
	jmp	$L8541
$L8536:

; 3115 : 
; 3116 :    if ( uLth )

	cmp	DWORD PTR _uLth$[ebp], 0
	je	SHORT $L8537

; 3118 :       if ( lpBufferData->pchCurrentByte + uLth >= lpBufferData->pchEnd )

	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _uLth$[ebp]
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	jb	SHORT $L8538

; 3120 :          SysMessageBox( lpView, "Internal Core Error", "Out of buffer space", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0BE@CKOO@Out?5of?5buffer?5space?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BE@LIH@Internal?5Core?5Error?$AA@ ; `string'
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 3121 :          return( 0 );

	xor	ax, ax
	jmp	$L8541
$L8538:

; 3123 : 
; 3124 :       *ppchReturnBuffer = lpBufferData->pchCurrentByte;

	mov	ecx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax

; 3125 :       lpBufferData->pchCurrentByte += uLth;

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3126 : 
; 3127 :       return( 1 );

	mov	ax, 1
	jmp	$L8541
$L8537:

; 3131 :       *ppchReturnBuffer = lpBufferData->pchCurrentByte;

	mov	ecx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
$L8543:

; 3132 : 
; 3133 :       // Look for the end of the line or the end of the buffer.  Note that
; 3134 :       // pchEnd points to the "EOF" char and is not part of the data.
; 3135 :       while ( lpBufferData->pchCurrentByte[ 0 ] != '\n' &&
; 3136 :               lpBufferData->pchCurrentByte[ 0 ] != '\r' &&
; 3137 :               lpBufferData->pchCurrentByte < lpBufferData->pchEnd )

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $L8544
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $L8544
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $L8544

; 3139 :          lpBufferData->pchCurrentByte++;

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3140 :       }

	jmp	SHORT $L8543
$L8544:

; 3141 : 
; 3142 :       if ( (lpBufferData->pchCurrentByte[ 0 ] == '\r' &&
; 3143 :             lpBufferData->pchCurrentByte[ 1 ] == '\n' ) ||
; 3144 :            (lpBufferData->pchCurrentByte[ 0 ] == '\n' &&
; 3145 :             lpBufferData->pchCurrentByte[ 1 ] == '\r') )

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $L8547
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 10					; 0000000aH
	je	SHORT $L8546
$L8547:
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $L8545
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $L8545
$L8546:

; 3147 :          *(lpBufferData->pchCurrentByte++) = 0;  // Null end of line and skip \r or \n

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [edx+4], ecx
$L8545:

; 3149 : 
; 3150 :       *(lpBufferData->pchCurrentByte++) = 0;  // Null end of line and skip \r or \n

	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 3151 : 
; 3152 :       return( 1 );

	mov	ax, 1
$L8541:

; 3154 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L12752:
	DD	$L8532
	DD	$L8533
	DD	$L8534
	DD	$L8535
	DD	$L8529
$L12751:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnReadDataFromBuffer@20 ENDP
_TEXT	ENDS
PUBLIC	_fnActivateOI_FromBuffer@24
EXTRN	__imp__free:NEAR
EXTRN	__imp__malloc:NEAR
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_pchBuffer$ = 20
_uLth$ = 24
_lControl$ = 28
_ActBuffData$ = -20
_pchData$ = -4
_nRC$ = -8
_fnActivateOI_FromBuffer@24 PROC NEAR

; 3169 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3170 :    BufferDataRecord ActBuffData;
; 3171 :    zPCHAR pchData;
; 3172 :    zSHORT nRC;
; 3173 : 
; 3174 :    // SfActivate needs to be able to change the data in the buffer.  Because of
; 3175 :    // this we will copy the buffer into a temporary buffer.  SfActivate also
; 3176 :    // expects an extra character at the end of the buffer to indicate the EOF.
; 3177 :    // So we need to allocate an extra byte.
; 3178 :    pchData = malloc( uLth + 1 );

	mov	eax, DWORD PTR _uLth$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _pchData$[ebp], eax

; 3179 :    zmemcpy( pchData, pchBuffer, uLth );

	mov	ecx, DWORD PTR _uLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchData$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3180 :    pchData[ uLth ] = 0;  // set the last byte to NULL

	mov	ecx, DWORD PTR _pchData$[ebp]
	add	ecx, DWORD PTR _uLth$[ebp]
	mov	BYTE PTR [ecx], 0

; 3181 : 
; 3182 :    // Set up data to be passed through to fnReadDataFromBuffer( ).
; 3183 :    ActBuffData.pchBuffer      = pchData;

	mov	edx, DWORD PTR _pchData$[ebp]
	mov	DWORD PTR _ActBuffData$[ebp], edx

; 3184 :    ActBuffData.pchCurrentByte = pchData;

	mov	eax, DWORD PTR _pchData$[ebp]
	mov	DWORD PTR _ActBuffData$[ebp+4], eax

; 3185 :    ActBuffData.pchEnd         = pchData + uLth;

	mov	ecx, DWORD PTR _pchData$[ebp]
	add	ecx, DWORD PTR _uLth$[ebp]
	mov	DWORD PTR _ActBuffData$[ebp+8], ecx

; 3186 : 
; 3187 :    nRC = SfActivateOI_FromStream( pvReturnView, cpcViewOD_Name,
; 3188 :                                   lpAppQualView, lControl,
; 3189 :                                   fnReadDataFromBuffer,
; 3190 :                                   (zPVOID) &ActBuffData );

	lea	edx, DWORD PTR _ActBuffData$[ebp]
	push	edx
	push	OFFSET FLAT:_fnReadDataFromBuffer@20
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	push	eax
	call	_SfActivateOI_FromStream@24
	mov	WORD PTR _nRC$[ebp], ax

; 3191 :    free( pchData );

	mov	ecx, DWORD PTR _pchData$[ebp]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4

; 3192 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 3193 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnActivateOI_FromBuffer@24 ENDP
_TEXT	ENDS
PUBLIC	_fnGetDBHandlerOper@12
PUBLIC	??_C@_02CJCI@KZ?$AA@				; `string'
PUBLIC	??_C@_0M@KGHM@DBH_MsgProc?$AA@			; `string'
PUBLIC	??_C@_0N@GMLG@_DBH_MsgProc?$AA@			; `string'
EXTRN	_SysGetProc@8:NEAR
EXTRN	_SysGetProcessID@4:NEAR
EXTRN	_SysLoadLibrary@8:NEAR
EXTRN	__imp___strnicmp:NEAR
;	COMDAT ??_C@_02CJCI@KZ?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_02CJCI@KZ?$AA@ DB 'KZ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@KGHM@DBH_MsgProc?$AA@
_DATA	SEGMENT
??_C@_0M@KGHM@DBH_MsgProc?$AA@ DB 'DBH_MsgProc', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@GMLG@_DBH_MsgProc?$AA@
_DATA	SEGMENT
??_C@_0N@GMLG@_DBH_MsgProc?$AA@ DB '_DBH_MsgProc', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_lpView$ = 12
_pOperReturn$ = 16
_hDBHandler$ = -24
_lpDBHandler$ = -36
_lpTaskDBHandler$ = -32
_lpViewOD$ = -12
_hLibrary$ = -8
_lpPtr$ = -20
_pOper$ = -28
_nRC$ = -16
_lProcessID$ = -4
_hTaskDBHandler$8594 = -72
_szFuncName$8595 = -68
_szLibName$8598 = -172
_fnGetDBHandlerOper@12 PROC NEAR

; 3316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH

; 3317 :    LPDBHANDLER      hDBHandler;
; 3318 :    LPDBHANDLER      lpDBHandler;
; 3319 :    LPTASKDBHANDLER  lpTaskDBHandler;
; 3320 :    LPVIEWOD         lpViewOD;
; 3321 :    LPLIBRARY        hLibrary;
; 3322 :    zPVOID           lpPtr;
; 3323 :    zPDBHOPER        pOper;
; 3324 :    zSHORT           nRC;
; 3325 :    zLONG            lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 3326 : 
; 3327 :    *pOperReturn = 0;  // initialize

	mov	eax, DWORD PTR _pOperReturn$[ebp]
	mov	DWORD PTR [eax], 0

; 3328 : 
; 3329 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 3330 :    hDBHandler = lpViewOD->hDBHandler;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	mov	DWORD PTR _hDBHandler$[ebp], ecx

; 3331 :    lpDBHandler = zGETPTR( hDBHandler );

	mov	edx, DWORD PTR _hDBHandler$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDBHandler$[ebp], eax

; 3332 : // lpDBHandler = fnGetDBHandler( hTask, lpViewOD->szDBHandler );
; 3333 : 
; 3334 :    // Make sure DBHandler can be found.
; 3335 :    if ( lpDBHandler == 0 )

	cmp	DWORD PTR _lpDBHandler$[ebp], 0
	jne	SHORT $L8584

; 3337 :       // "KZOEE080 - Object Definition does not have a Database handler
; 3338 :       // specified"
; 3339 :       fnIssueCoreError( lpTask, lpView, 8, 80, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	80					; 00000050H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3340 :       return( 0 );

	xor	eax, eax
	jmp	$L8572
$L8584:

; 3342 : 
; 3343 :    // See if DBHandler has already been invoked for this task.
; 3344 :    for ( lpTaskDBHandler = zGETPTR( lpTask->hFirstTaskDBHandler );
; 3345 :          lpTaskDBHandler;
; 3346 :          lpTaskDBHandler = zGETPTR( lpTaskDBHandler->hNextTaskDBHandler ) )

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+134]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax
	jmp	SHORT $L8587
$L8588:
	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax
$L8587:
	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	je	SHORT $L8589

; 3348 :       if ( lpTaskDBHandler->hDBHandler != hDBHandler )

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	cmp	ecx, DWORD PTR _hDBHandler$[ebp]
	je	SHORT $L8590

; 3349 :          continue;

	jmp	SHORT $L8588
$L8590:

; 3350 : 
; 3351 :       if ( lpTaskDBHandler->lProcessID != lProcessID )

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+22]
	cmp	eax, DWORD PTR _lProcessID$[ebp]
	je	SHORT $L8591

; 3352 :          continue;

	jmp	SHORT $L8588
$L8591:
$L8589:

; 3357 : 
; 3358 :    // If TaskDBHandler wasn't found, then this is the first time the
; 3359 :    // DBHandler has been called for this task.
; 3360 :    if ( lpTaskDBHandler )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	je	SHORT $L8592

; 3362 :       // The task DBHandler was found--return pointer to DBHandler routine.
; 3363 :       pOper = lpTaskDBHandler->pfDBHandlerOper;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _pOper$[ebp], edx

; 3365 :    else

	jmp	$L8593
$L8592:

; 3367 :       zPVOID hTaskDBHandler;
; 3368 :       zCHAR  szFuncName[ 30 ];
; 3369 : 
; 3370 :       // Load the DBHandler library.  If it can't be found, return with error.
; 3371 :       if ( zstrncmpi( lpDBHandler->szName, "KZ", 2 ) == 0 )

	push	2
	push	OFFSET FLAT:??_C@_02CJCI@KZ?$AA@	; `string'
	mov	eax, DWORD PTR _lpDBHandler$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L8596

; 3373 :          // If handler name starts with KZ, then load handler from Zeidon
; 3374 :          // bin directory.
; 3375 :          zCHAR szLibName[ 100 ];
; 3376 : 
; 3377 :          zstrcpy( szLibName, AnchorBlock->szZeidonBin );

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 395				; 0000018bH
	push	ecx
	lea	edx, DWORD PTR _szLibName$8598[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3378 :          zstrcat( szLibName, lpDBHandler->szName );

	mov	eax, DWORD PTR _lpDBHandler$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	lea	ecx, DWORD PTR _szLibName$8598[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3379 :          hLibrary = SysLoadLibrary( lpView, szLibName );

	lea	edx, DWORD PTR _szLibName$8598[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 3381 :       else

	jmp	SHORT $L8599
$L8596:

; 3382 :          hLibrary = SysLoadLibrary( lpView, lpDBHandler->szName );

	mov	ecx, DWORD PTR _lpDBHandler$[ebp]
	add	ecx, 11					; 0000000bH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax
$L8599:

; 3383 : 
; 3384 :       if ( hLibrary == 0 )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	jne	SHORT $L8600

; 3385 :          return( 0 );

	xor	eax, eax
	jmp	$L8572
$L8600:

; 3386 : 
; 3387 :       // Define entry function name.  First try the default name.
; 3388 :       pOper = (zPDBHOPER) SysGetProc( hLibrary, "DBH_MsgProc" );

	push	OFFSET FLAT:??_C@_0M@KGHM@DBH_MsgProc?$AA@ ; `string'
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	DWORD PTR _pOper$[ebp], eax

; 3389 :       if ( pOper == 0 )

	cmp	DWORD PTR _pOper$[ebp], 0
	jne	SHORT $L8608

; 3391 :          // Couldn't find the default name.  Try the old-style name.
; 3392 :          zstrcpy( (zPCHAR) szFuncName, lpDBHandler->szName );

	mov	ecx, DWORD PTR _lpDBHandler$[ebp]
	add	ecx, 11					; 0000000bH
	push	ecx
	lea	edx, DWORD PTR _szFuncName$8595[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3393 :          zstrcat( (zPCHAR) szFuncName, "_DBH_MsgProc" );

	push	OFFSET FLAT:??_C@_0N@GMLG@_DBH_MsgProc?$AA@ ; `string'
	lea	eax, DWORD PTR _szFuncName$8595[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3394 : 
; 3395 :          // Find the address of entry func.  If it can't be found, return with
; 3396 :          // an error.
; 3397 :          pOper = (zPDBHOPER) SysGetProc( hLibrary, szFuncName );

	lea	ecx, DWORD PTR _szFuncName$8595[ebp]
	push	ecx
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR _pOper$[ebp], eax

; 3398 :          if ( pOper == 0 )

	cmp	DWORD PTR _pOper$[ebp], 0
	jne	SHORT $L8608

; 3399 :             return( 0 );

	xor	eax, eax
	jmp	$L8572
$L8608:

; 3401 : 
; 3402 :       // Call DBHandler routine to issue start of transaction.  Bomb out if
; 3403 :       // it doesn't work.
; 3404 :       lpPtr = 0;

	mov	DWORD PTR _lpPtr$[ebp], 0

; 3405 :       nRC = (*pOper)( (zLONG) zGETHNDL( lpTask ), DBH_Init, 0,
; 3406 :                       lpViewOD, 0, lpView, 0, (zPVOID) &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	4096					; 00001000H
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 3407 :       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L8612

; 3408 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $L8572
$L8612:

; 3409 : 
; 3410 :       // Create TaskDBHandler object and attach to Task.
; 3411 :       hTaskDBHandler = fnAllocDataspace( lpTask->hFirstDataHeader,
; 3412 :                                          sizeof( TaskDBHandlerRecord ), 1, 0,
; 3413 :                                          iTaskDBHandler );

	push	10009					; 00002719H
	push	0
	push	1
	push	30					; 0000001eH
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskDBHandler$8594[ebp], eax

; 3414 :       lpTaskDBHandler = zGETPTR( hTaskDBHandler );

	mov	ecx, DWORD PTR _hTaskDBHandler$8594[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax

; 3415 :       if ( lpTaskDBHandler == 0 )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	jne	SHORT $L8615

; 3416 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $L8572
$L8615:

; 3417 : 
; 3418 :       lpTaskDBHandler->hLibrary        = hLibrary;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR [edx+10], eax

; 3419 :       lpTaskDBHandler->pfDBHandlerOper = pOper;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR _pOper$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 3420 :       lpTaskDBHandler->hDBHandler      = hDBHandler;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR _hDBHandler$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 3421 :       lpTaskDBHandler->lProcessID      = lProcessID;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [edx+22], eax

; 3422 : 
; 3423 :       // Insert lpTaskDBHandler into lpTask chain.
; 3424 :       lpTaskDBHandler->hNextTaskDBHandler = lpTask->hFirstTaskDBHandler;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+134]
	mov	DWORD PTR [ecx+2], eax

; 3425 :       lpTask->hFirstTaskDBHandler = hTaskDBHandler;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _hTaskDBHandler$8594[ebp]
	mov	DWORD PTR [ecx+134], edx
$L8593:

; 3427 : 
; 3428 :    *pOperReturn = pOper;

	mov	eax, DWORD PTR _pOperReturn$[ebp]
	mov	ecx, DWORD PTR _pOper$[ebp]
	mov	DWORD PTR [eax], ecx

; 3429 : 
; 3430 : // TraceLine( "fnGetDBHandlerOper in Process: %d   looking for DBHandler: 0x%08x for Task: %d (0x%08x)   Name: %s",
; 3431 : //            lProcessID, zGETHNDL( lpDBHandler ), hTask, hTask, lpTaskDBHandler->szName );
; 3432 : 
; 3433 :    return( lpTaskDBHandler );

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
$L8572:

; 3434 : 
; 3435 : } // fnGetDBHandlerOper

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnGetDBHandlerOper@12 ENDP
_TEXT	ENDS
PUBLIC	_fnGetGKHandlerOper
PUBLIC	??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@ ; `string'
PUBLIC	??_C@_0M@GIDM@GKH_MsgProc?$AA@			; `string'
PUBLIC	??_C@_0N@KCPG@_GKH_MsgProc?$AA@			; `string'
EXTRN	__imp__strncmp:NEAR
;	COMDAT ??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@ DB '(oi) Atte'
	DB	'mpting to load GK-handler as ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@GIDM@GKH_MsgProc?$AA@
_DATA	SEGMENT
??_C@_0M@GIDM@GKH_MsgProc?$AA@ DB 'GKH_MsgProc', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@KCPG@_GKH_MsgProc?$AA@
_DATA	SEGMENT
??_C@_0N@KCPG@_GKH_MsgProc?$AA@ DB '_GKH_MsgProc', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vSubtask$ = 8
_lpTask$ = 12
_hGKHandler$ = 16
_pOperReturn$ = 20
_lpGKHandler$ = -20
_lpTaskGKHandler$ = -8
_hLibrary$ = -12
_pGKOper$ = -24
_nRC$ = -16
_lProcessID$ = -4
_szFuncName$8642 = -60
_hTaskGKHandler$8643 = -28
_szLibName$8645 = -160
_fnGetGKHandlerOper PROC NEAR

; 3460 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H

; 3461 :    LPGKHANDLER      lpGKHandler;
; 3462 :    LPTASKGKHANDLER  lpTaskGKHandler;
; 3463 :    LPLIBRARY        hLibrary;
; 3464 :    zPGKHOPER        pGKOper;
; 3465 :    zSHORT           nRC;
; 3466 :    zLONG            lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 3467 : 
; 3468 :    lpGKHandler = zGETPTR( hGKHandler );

	mov	eax, DWORD PTR _hGKHandler$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGKHandler$[ebp], eax

; 3469 : 
; 3470 :    // Make sure DBHandler can be found.
; 3471 :    if ( lpGKHandler == 0 )

	cmp	DWORD PTR _lpGKHandler$[ebp], 0
	jne	SHORT $L8632

; 3473 :       // "KZOEE081 - Object Definition does not have a Genkey handler
; 3474 :       // specified"
; 3475 :       fnIssueCoreError( lpTask, vSubtask, 8, 81, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	81					; 00000051H
	push	8
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3476 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8624
$L8632:

; 3478 : 
; 3479 :    // See if GKHandler has already been invoked for this task.
; 3480 :    for ( lpTaskGKHandler = zGETPTR( lpTask->hFirstTaskGKHandler );
; 3481 :          lpTaskGKHandler;
; 3482 :          lpTaskGKHandler = zGETPTR( lpTaskGKHandler->hNextTaskGKHandler ) )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+138]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskGKHandler$[ebp], eax
	jmp	SHORT $L8635
$L8636:
	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskGKHandler$[ebp], eax
$L8635:
	cmp	DWORD PTR _lpTaskGKHandler$[ebp], 0
	je	SHORT $L8637

; 3484 :       if ( lpTaskGKHandler->lProcessID != lProcessID )

	mov	ecx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	je	SHORT $L8638

; 3485 :          continue;

	jmp	SHORT $L8636
$L8638:

; 3486 : 
; 3487 :       if ( lpTaskGKHandler->hGKHandler != hGKHandler )

	mov	eax, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	cmp	ecx, DWORD PTR _hGKHandler$[ebp]
	je	SHORT $L8639

; 3488 :          continue;

	jmp	SHORT $L8636
$L8639:
$L8637:

; 3493 : 
; 3494 :    // If TaskGKHandler wasn't found, then this is the first time the
; 3495 :    // GKHandler has been called for this task.
; 3496 :    if ( lpTaskGKHandler )

	cmp	DWORD PTR _lpTaskGKHandler$[ebp], 0
	je	SHORT $L8640

; 3498 :       // The task DBHandler was found--return pointer to DBHandler routine.
; 3499 :       pGKOper = lpTaskGKHandler->pfGKHandlerOper;

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _pGKOper$[ebp], eax

; 3501 :    else

	jmp	$L8641
$L8640:

; 3503 :       zCHAR  szFuncName[ 30 ];
; 3504 :       zPVOID hTaskGKHandler;
; 3505 : 
; 3506 :       // Load the DBHandler library.  If it can't be found, return with error.
; 3507 :       if ( zstrncmp( lpGKHandler->szName, "KZ", 2 ) == 0 )

	push	2
	push	OFFSET FLAT:??_C@_02CJCI@KZ?$AA@	; `string'
	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L8644

; 3509 :          // If handler name starts with KZ, then load handler from Zeidon
; 3510 :          // bin directory.
; 3511 :          zCHAR szLibName[ 100 ];
; 3512 : 
; 3513 :          zstrcpy( szLibName, AnchorBlock->szZeidonBin );

	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 395				; 0000018bH
	push	edx
	lea	eax, DWORD PTR _szLibName$8645[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 3514 :          zstrcat( szLibName, lpGKHandler->szName );

	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _szLibName$8645[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3515 : 
; 3516 :          TraceLineS( "(oi) Attempting to load GK-handler as ", szLibName );

	lea	eax, DWORD PTR _szLibName$8645[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@ ; `string'
	call	_TraceLineS@8

; 3517 :          hLibrary = SysLoadLibrary( vSubtask, szLibName );

	lea	ecx, DWORD PTR _szLibName$8645[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 3519 :       else

	jmp	SHORT $L8647
$L8644:

; 3521 :          TraceLineS( "(oi) Attempting to load GK-handler as ",
; 3522 :                      lpGKHandler->szName );

	mov	eax, DWORD PTR _lpGKHandler$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@ ; `string'
	call	_TraceLineS@8

; 3523 :          hLibrary = SysLoadLibrary( vSubtask, lpGKHandler->szName );

	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax
$L8647:

; 3525 : 
; 3526 :       if ( hLibrary == 0 )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	jne	SHORT $L8648

; 3527 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8624
$L8648:

; 3528 : 
; 3529 :       pGKOper = (zPGKHOPER) SysGetProc( hLibrary, "GKH_MsgProc" );

	push	OFFSET FLAT:??_C@_0M@GIDM@GKH_MsgProc?$AA@ ; `string'
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	DWORD PTR _pGKOper$[ebp], eax

; 3530 :       if ( pGKOper == 0 )

	cmp	DWORD PTR _pGKOper$[ebp], 0
	jne	SHORT $L8656

; 3532 :          // Try the old style name.
; 3533 :          zstrcpy( (zPCHAR) szFuncName, lpGKHandler->szName );

	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _szFuncName$8642[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3534 :          zstrcat( (zPCHAR) szFuncName, "_GKH_MsgProc" );

	push	OFFSET FLAT:??_C@_0N@KCPG@_GKH_MsgProc?$AA@ ; `string'
	lea	eax, DWORD PTR _szFuncName$8642[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3535 : 
; 3536 :          // Find the address of entry func.  If it can't be found, return with
; 3537 :          // an error.
; 3538 :          pGKOper = (zPGKHOPER) SysGetProc( hLibrary, szFuncName );

	lea	ecx, DWORD PTR _szFuncName$8642[ebp]
	push	ecx
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR _pGKOper$[ebp], eax

; 3539 :          if ( pGKOper == 0 )

	cmp	DWORD PTR _pGKOper$[ebp], 0
	jne	SHORT $L8656

; 3540 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8624
$L8656:

; 3542 : 
; 3543 :       // Call gkhandler routine to issue start of transaction.  Bomb out if
; 3544 :       // it doesn't work.
; 3545 :       nRC = (*pGKOper)( DBH_Init, vSubtask, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	4096					; 00001000H
	call	DWORD PTR _pGKOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 3546 :       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L8657

; 3547 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8624
$L8657:

; 3548 : 
; 3549 :       // Create TaskGKHandler object and attatch to Task.
; 3550 :       hTaskGKHandler = fnAllocDataspace( lpTask->hFirstDataHeader,
; 3551 :                                          sizeof( TaskGKHandlerRecord ), 1, 0,
; 3552 :                                          iTaskGKHandler );

	push	10036					; 00002734H
	push	0
	push	1
	push	26					; 0000001aH
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskGKHandler$8643[ebp], eax

; 3553 :       lpTaskGKHandler = zGETPTR( hTaskGKHandler );

	mov	ecx, DWORD PTR _hTaskGKHandler$8643[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskGKHandler$[ebp], eax

; 3554 :       if ( lpTaskGKHandler == 0 )

	cmp	DWORD PTR _lpTaskGKHandler$[ebp], 0
	jne	SHORT $L8660

; 3555 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8624
$L8660:

; 3556 : 
; 3557 :       lpTaskGKHandler->hLibrary        = hLibrary;

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR [edx+10], eax

; 3558 :       lpTaskGKHandler->pfGKHandlerOper = pGKOper;

	mov	ecx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	edx, DWORD PTR _pGKOper$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 3559 :       lpTaskGKHandler->hGKHandler      = hGKHandler;

	mov	eax, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	ecx, DWORD PTR _hGKHandler$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 3560 :       lpTaskGKHandler->lProcessID      = lProcessID;

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [edx+22], eax

; 3561 : 
; 3562 :       // Insert lpTaskGKHandler into lpTask chain.
; 3563 :       lpTaskGKHandler->hNextTaskGKHandler = lpTask->hFirstTaskGKHandler;

	mov	ecx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+138]
	mov	DWORD PTR [ecx+2], eax

; 3564 :       lpTask->hFirstTaskGKHandler = hTaskGKHandler;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _hTaskGKHandler$8643[ebp]
	mov	DWORD PTR [ecx+138], edx
$L8641:

; 3567 : 
; 3568 :    *pOperReturn = pGKOper;

	mov	eax, DWORD PTR _pOperReturn$[ebp]
	mov	ecx, DWORD PTR _pGKOper$[ebp]
	mov	DWORD PTR [eax], ecx

; 3569 : 
; 3570 :    return( 0 );

	xor	ax, ax
$L8624:

; 3571 : 
; 3572 : } // fnGetGKHandlerOper

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetGKHandlerOper ENDP
_TEXT	ENDS
PUBLIC	_CommitObjectInstance@4
PUBLIC	_CommitMultipleOIs@16
_TEXT	SEGMENT
_lpView$ = 8
_ViewCluster$ = -12
_lpCurrentTask$ = -16
_nRC$ = -4
_CommitObjectInstance@4 PROC NEAR

; 3771 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3772 :    ViewClusterRecord ViewCluster;
; 3773 :    LPTASK            lpCurrentTask;
; 3774 :    zSHORT            nRC;
; 3775 : 
; 3776 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3777 :    if ( (lpCurrentTask = fnOperationCall( iCommitObjectInstance, lpView,
; 3778 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	60					; 0000003cH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8667

; 3780 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8663
$L8667:

; 3782 : 
; 3783 :    ViewCluster.vOI      = lpView;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _ViewCluster$[ebp], ecx

; 3784 :    ViewCluster.lControl = 0;

	mov	DWORD PTR _ViewCluster$[ebp+4], 0

; 3785 : 
; 3786 :    // Call commit multiple.  We use "-1" to tell commit multiple that it is
; 3787 :    // being called from CommitObjectInstance.
; 3788 :    nRC = CommitMultipleOIs( &ViewCluster, 1, (zPSHORT) -1, 0 );

	push	0
	push	-1
	push	1
	lea	edx, DWORD PTR _ViewCluster$[ebp]
	push	edx
	call	_CommitMultipleOIs@16
	mov	WORD PTR _nRC$[ebp], ax

; 3789 :    fnOperationReturn( iCommitObjectInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	60					; 0000003cH
	call	_fnOperationReturn
	add	esp, 8

; 3790 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L8663:

; 3791 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_CommitObjectInstance@4 ENDP
_TEXT	ENDS
PUBLIC	_CreateViewCluster@8
_TEXT	SEGMENT
_vTaskView$ = 8
_lpArray$ = 12
_pv$ = -12
_lpTask$ = -4
_h$ = -8
_lCnt$ = -16
_CreateViewCluster@8 PROC NEAR

; 3812 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3813 :    LPVIEWCLUSTER pv;
; 3814 :    LPTASK        lpTask = zGETPTR( vTaskView->hTask );

	mov	eax, DWORD PTR _vTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 3815 :    zPVOID        h;
; 3816 :    zLONG         lCnt;
; 3817 : 
; 3818 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L8679

; 3819 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8673
$L8679:

; 3820 : 
; 3821 :    lCnt = zCLUSTER_VIEW_COUNT;

	mov	DWORD PTR _lCnt$[ebp], 2000		; 000007d0H

; 3822 : 
; 3823 :    // Allocate space and set it to all 0s.  Allocate enough space for all the
; 3824 :    // views + 1.  This will allow AddViewToViewArray( ) to know when it's
; 3825 :    // reached the end of the list.
; 3826 :    h = fnAllocDataspace( lpTask->hFirstDataHeader,
; 3827 :                          sizeof( ViewClusterRecord ) * (zULONG) (lCnt + 1),
; 3828 :                          TRUE, 0, iCluster );

	push	10104					; 00002778H
	push	0
	push	1
	mov	edx, DWORD PTR _lCnt$[ebp]
	lea	eax, DWORD PTR [edx*8+8]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _h$[ebp], eax

; 3829 :    pv = (LPVIEWCLUSTER) zGETPTR( h );

	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pv$[ebp], eax

; 3830 : 
; 3831 :    if ( pv )

	cmp	DWORD PTR _pv$[ebp], 0
	je	SHORT $L8684

; 3833 :       // At the end of the array set the last view to -1.
; 3834 :       pv[ lCnt ].vOI = (zVIEW) -1;

	mov	ecx, DWORD PTR _lCnt$[ebp]
	mov	edx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [edx+ecx*8], -1
$L8684:

; 3836 : 
; 3837 :    *lpArray = (zLONG) pv;

	mov	eax, DWORD PTR _lpArray$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [eax], ecx

; 3838 : 
; 3839 :    return( 0 );

	xor	ax, ax
$L8673:

; 3840 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CreateViewCluster@8 ENDP
_TEXT	ENDS
PUBLIC	_AddToViewCluster@12
PUBLIC	??_C@_0BI@HCHL@View?5doesn?8t?5have?5an?5OI?$AA@ ; `string'
;	COMDAT ??_C@_0BI@HCHL@View?5doesn?8t?5have?5an?5OI?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BI@HCHL@View?5doesn?8t?5have?5an?5OI?$AA@ DB 'View doesn''t have a'
	DB	'n OI', 00H					; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lArray$ = 8
_lpView$ = 12
_lControl$ = 16
_lpCurrentTask$ = -20
_pv$ = -16
_lpViewCsr$ = -4
_hViewOI$ = -12
_nIdx$ = -8
_AddToViewCluster@12 PROC NEAR

; 3861 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3862 :    LPTASK        lpCurrentTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 3863 :    LPVIEWCLUSTER pv = (LPVIEWCLUSTER) lArray;

	mov	edx, DWORD PTR _lArray$[ebp]
	mov	DWORD PTR _pv$[ebp], edx

; 3864 :    LPVIEWCSR     lpViewCsr;
; 3865 :    LPVIEWOI      hViewOI;
; 3866 :    zSHORT        nIdx;
; 3867 : 
; 3868 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3869 :    if ( (lpCurrentTask = fnOperationCall( iAddToViewCluster, lpView,
; 3870 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	64					; 00000040H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8701

; 3872 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8693
$L8701:

; 3874 : 
; 3875 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3876 :    if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	jne	SHORT $L8703

; 3878 :       SysMessageBox( lpView, szlOE_SystemError, "View doesn't have an OI", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BI@HCHL@View?5doesn?8t?5have?5an?5OI?$AA@ ; `string'
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 3879 :       fnOperationReturn( iAddToViewCluster, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	64					; 00000040H
	call	_fnOperationReturn
	add	esp, 8

; 3880 :       return( -1 );

	or	ax, -1
	jmp	$L8693
$L8703:

; 3882 : 
; 3883 :    hViewOI = lpViewCsr->hViewOI;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hViewOI$[ebp], ecx

; 3884 : 
; 3885 :    // Look for the first 0 (e.g. empty) cell in the array. If we find one
; 3886 :    // that is -1, then we've reached the end of the list so end with error.
; 3887 :    for ( nIdx = 0; pv[ nIdx ].vOI; nIdx++ )

	mov	WORD PTR _nIdx$[ebp], 0
	jmp	SHORT $L8705
$L8706:
	mov	dx, WORD PTR _nIdx$[ebp]
	add	dx, 1
	mov	WORD PTR _nIdx$[ebp], dx
$L8705:
	movsx	eax, WORD PTR _nIdx$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $L8707

; 3889 :       if ( pv[ nIdx ].vOI == (zVIEW) -1 )

	movsx	edx, WORD PTR _nIdx$[ebp]
	mov	eax, DWORD PTR _pv$[ebp]
	cmp	DWORD PTR [eax+edx*8], -1
	jne	SHORT $L8709

; 3891 :          // "KZOEE087 - Too many views in View array"
; 3892 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 87, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	87					; 00000057H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3893 :          fnOperationReturn( iAddToViewCluster, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	64					; 00000040H
	call	_fnOperationReturn
	add	esp, 8

; 3894 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8693
$L8709:

; 3896 :    }

	jmp	SHORT $L8706
$L8707:

; 3897 : 
; 3898 :    pv[ nIdx ].vOI      = lpView;

	movsx	ecx, WORD PTR _nIdx$[ebp]
	mov	edx, DWORD PTR _pv$[ebp]
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+ecx*8], eax

; 3899 :    pv[ nIdx ].lControl = lControl;

	movsx	ecx, WORD PTR _nIdx$[ebp]
	mov	edx, DWORD PTR _pv$[ebp]
	mov	eax, DWORD PTR _lControl$[ebp]
	mov	DWORD PTR [edx+ecx*8+4], eax

; 3900 : 
; 3901 :    fnOperationReturn( iAddToViewCluster, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	64					; 00000040H
	call	_fnOperationReturn
	add	esp, 8

; 3902 :    return( nIdx );

	mov	ax, WORD PTR _nIdx$[ebp]
$L8693:

; 3903 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_AddToViewCluster@12 ENDP
_TEXT	ENDS
PUBLIC	_AppendViewCluster@8
EXTRN	_fnFreeDataspace:NEAR
_TEXT	SEGMENT
_lTargetArray$ = 8
_lSourceArray$ = 12
_pvTarget$ = -4
_pvSource$ = -12
_k$ = -16
_n$ = -20
_nRC$ = -8
_AppendViewCluster@8 PROC NEAR

; 3927 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3928 :    LPVIEWCLUSTER pvTarget = (LPVIEWCLUSTER) lTargetArray;

	mov	eax, DWORD PTR _lTargetArray$[ebp]
	mov	DWORD PTR _pvTarget$[ebp], eax

; 3929 :    LPVIEWCLUSTER pvSource = (LPVIEWCLUSTER) lSourceArray;

	mov	ecx, DWORD PTR _lSourceArray$[ebp]
	mov	DWORD PTR _pvSource$[ebp], ecx

; 3930 :    zLONG  k;
; 3931 :    zSHORT n;
; 3932 :    zSHORT nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 3933 : 
; 3934 :    for ( k = 0; pvSource[ k ].vOI; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L8722
$L8723:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$L8722:
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pvSource$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $L8724

; 3936 :       if ( pvSource[ k ].vOI == (zVIEW) -1 )

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pvSource$[ebp]
	cmp	DWORD PTR [eax+edx*8], -1
	jne	SHORT $L8726

; 3937 :          break; // this is the end of the array

	jmp	SHORT $L8724
$L8726:

; 3938 : 
; 3939 :       n = AddToViewCluster( lTargetArray,
; 3940 :                             pvSource[ k ].vOI, pvSource[ k ].lControl );

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pvSource$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pvSource$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _lTargetArray$[ebp]
	push	ecx
	call	_AddToViewCluster@12
	mov	WORD PTR _n$[ebp], ax

; 3941 :       if ( n < 0 )

	movsx	edx, WORD PTR _n$[ebp]
	test	edx, edx
	jge	SHORT $L8727

; 3942 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8714
$L8727:

; 3943 : 
; 3944 :       if ( k == 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jne	SHORT $L8728

; 3945 :          nRC = n; // first index is the Offset of appended cluster

	mov	ax, WORD PTR _n$[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$L8728:

; 3946 :    }

	jmp	SHORT $L8723
$L8724:

; 3947 : 
; 3948 :    fnFreeDataspace( pvSource );

	mov	ecx, DWORD PTR _pvSource$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 3949 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L8714:

; 3950 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_AppendViewCluster@8 ENDP
_TEXT	ENDS
PUBLIC	_AddViewToViewCluster@8
_TEXT	SEGMENT
_lArray$ = 8
_lpView$ = 12
_AddViewToViewCluster@8 PROC NEAR

; 3971 : {

	push	ebp
	mov	ebp, esp

; 3972 :    return( AddToViewCluster( lArray, lpView, 0 ) );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lArray$[ebp]
	push	ecx
	call	_AddToViewCluster@12

; 3973 : }

	pop	ebp
	ret	8
_AddViewToViewCluster@8 ENDP
_TEXT	ENDS
PUBLIC	_DropViewCluster@4
_TEXT	SEGMENT
_lArray$ = 8
_lpCurrentTask$ = -12
_lpViewCluster$ = -8
_idx$ = -4
_DropViewCluster@4 PROC NEAR

; 3992 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3993 :    LPTASK        lpCurrentTask = 0;

	mov	DWORD PTR _lpCurrentTask$[ebp], 0

; 3994 :    LPVIEWCLUSTER lpViewCluster = (LPVIEWCLUSTER) lArray;

	mov	eax, DWORD PTR _lArray$[ebp]
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 3995 :    zSHORT        idx;
; 3996 : 
; 3997 :    // Loop through each of the OI's in the cluster.  If the vOI value is
; 3998 :    // -1 then we've reached the end of the view cluster.
; 3999 :    for ( idx = 0; lpViewCluster[ idx ].vOI != (zVIEW) -1; idx++ )

	mov	WORD PTR _idx$[ebp], 0
	jmp	SHORT $L8742
$L8743:
	mov	cx, WORD PTR _idx$[ebp]
	add	cx, 1
	mov	WORD PTR _idx$[ebp], cx
$L8742:
	movsx	edx, WORD PTR _idx$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], -1
	je	$L8744

; 4001 :       if ( lpViewCluster[ idx ].vOI == 0 )

	movsx	ecx, WORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	jne	SHORT $L8745

; 4002 :          continue;

	jmp	SHORT $L8743
$L8745:

; 4003 : 
; 4004 :       // Retrieve the task if we haven't done it already.
; 4005 :       if ( lpCurrentTask == 0 &&
; 4006 :            (lpCurrentTask = fnOperationCall( iDropViewCluster,
; 4007 :                                              lpViewCluster[ idx ].vOI, 0 )) == 0 )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8746
	push	0
	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	push	63					; 0000003fH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8746

; 4009 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8736
$L8746:

; 4011 : 
; 4012 :       if ( lpViewCluster[ idx ].lControl & zCOMMIT_DROPOBJECTINSTANCE )

	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	and	edx, 16384				; 00004000H
	test	edx, edx
	je	SHORT $L8747

; 4013 :          DropObjectInstance( lpViewCluster[ idx ].vOI );

	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	call	_DropObjectInstance@4

; 4014 :       else

	jmp	SHORT $L8749
$L8747:

; 4015 :       if ( lpViewCluster[ idx ].lControl & zCOMMIT_DROPVIEW )

	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	and	edx, 8192				; 00002000H
	test	edx, edx
	je	SHORT $L8749

; 4016 :          DropView( lpViewCluster[ idx ].vOI );

	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	call	_DropView@4
$L8749:

; 4017 :    }

	jmp	$L8743
$L8744:

; 4018 : 
; 4019 :    fnFreeDataspace( lpViewCluster );

	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 4020 : 
; 4021 :    if ( lpCurrentTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $L8750

; 4022 :       fnOperationReturn( iDropViewCluster, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	63					; 0000003fH
	call	_fnOperationReturn
	add	esp, 8
$L8750:

; 4023 : 
; 4024 :    return( 0 );

	xor	ax, ax
$L8736:

; 4025 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DropViewCluster@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@ECGE@Object?5Name?5?$DN?5?$AA@		; `string'
PUBLIC	??_C@_0BM@FEHG@?$CIoi?$CJ?5Can?8t?5start?5network?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0CK@GCPD@?$CIoi?$CJ?5Warning?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0BK@OGGO@?$CIoi?$CJ?5Object?5definition?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BE@BILP@?$CIoi?$CJ?5Entity?5name?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BE@HPNO@?$CIoi?$CJ?5EI?5Flags?5?5?5?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0FP@BNEA@Return?5code?5indicates?5that?5Commi@ ; `string'
PUBLIC	??_C@_0L@OPBG@OE?5Warning?$AA@			; `string'
PUBLIC	??_C@_0EC@LDIB@?$CFs?5?5?$CFs?5?5?5Object?5Definition?3?5?$CFs?5?5@ ; `string'
PUBLIC	??_C@_0M@FIA@?$CFlf?5seconds?$AA@		; `string'
PUBLIC	??_C@_0CJ@PHHP@?$CIoi?$CJ?5Total?5time?5for?5CommitMultip@ ; `string'
EXTRN	_TraceLineX@8:NEAR
EXTRN	_fnValidViewCsr:NEAR
EXTRN	_NetCommitOI@28:NEAR
EXTRN	_SysDiagnosticMessage@16:NEAR
;	COMDAT ??_C@_0P@ECGE@Object?5Name?5?$DN?5?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0P@ECGE@Object?5Name?5?$DN?5?$AA@ DB 'Object Name = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@FEHG@?$CIoi?$CJ?5Can?8t?5start?5network?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BM@FEHG@?$CIoi?$CJ?5Can?8t?5start?5network?5?$DN?5?$AA@ DB '(oi) C'
	DB	'an''t start network = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@GCPD@?$CIoi?$CJ?5Warning?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
_DATA	SEGMENT
??_C@_0CK@GCPD@?$CIoi?$CJ?5Warning?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '('
	DB	'oi) Warning ============================', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@OGGO@?$CIoi?$CJ?5Object?5definition?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BK@OGGO@?$CIoi?$CJ?5Object?5definition?5?$DN?5?$AA@ DB '(oi) Objec'
	DB	't definition = ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@BILP@?$CIoi?$CJ?5Entity?5name?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BE@BILP@?$CIoi?$CJ?5Entity?5name?5?$DN?5?$AA@ DB '(oi) Entity name'
	DB	' = ', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HPNO@?$CIoi?$CJ?5EI?5Flags?5?5?5?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BE@HPNO@?$CIoi?$CJ?5EI?5Flags?5?5?5?5?$DN?5?$AA@ DB '(oi) EI Flags'
	DB	'    = ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FP@BNEA@Return?5code?5indicates?5that?5Commi@
_DATA	SEGMENT
??_C@_0FP@BNEA@Return?5code?5indicates?5that?5Commi@ DB 'Return code indi'
	DB	'cates that Commit was successful but OI still has instances m'
	DB	'arked as changed.', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@OPBG@OE?5Warning?$AA@
_DATA	SEGMENT
??_C@_0L@OPBG@OE?5Warning?$AA@ DB 'OE Warning', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EC@LDIB@?$CFs?5?5?$CFs?5?5?5Object?5Definition?3?5?$CFs?5?5@
_DATA	SEGMENT
??_C@_0EC@LDIB@?$CFs?5?5?$CFs?5?5?5Object?5Definition?3?5?$CFs?5?5@ DB '%'
	DB	's  %s   Object Definition: %s   EntityName: %s   EI Flags 0x%'
	DB	'08x', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@FIA@?$CFlf?5seconds?$AA@
_DATA	SEGMENT
??_C@_0M@FIA@?$CFlf?5seconds?$AA@ DB '%lf seconds', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@PHHP@?$CIoi?$CJ?5Total?5time?5for?5CommitMultip@
_DATA	SEGMENT
??_C@_0CJ@PHHP@?$CIoi?$CJ?5Total?5time?5for?5CommitMultip@ DB '(oi) Total'
	DB	' time for CommitMultipleOIs = ', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpOrigViewCluster$ = 8
_nViewCount$ = 12
_pnViewErrorIdx$ = 16
_lControl$ = 20
_lpViewCluster$ = -24
_tViewArrayBlock$ = -104
_lpCurrentTask$ = -128
_lpViewCsr$ = -8
_lpViewOI$ = -120
_lpViewOD$ = -12
_pchNetworkName$ = -40
_vReferenceView$ = -108
_lpViewArray$ = -36
_lTickCount$ = -124
_bNetworkCommit$ = -32
_bLockingSemaphoreCreatedHere$ = -28
_bDropPessimisticLocks$ = -16
_iOpID$ = -116
_k$ = -112
_nRC$ = -20
_nReturn$ = -4
_lpViewCsr$8802 = -132
_hViewOI$8803 = -136
_j$8804 = -140
_lpTask$8835 = -144
_lpTask$8840 = -148
_nState$8856 = -152
_lpEntityInstance$8872 = -156
_lpViewEntity$8873 = -160
_szMsg$8888 = -1184
_sz$8910 = -1216
_CommitMultipleOIs@16 PROC NEAR

; 4075 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1224				; 000004c8H
	push	esi
	push	edi

; 4076 :    LPVIEWCLUSTER     lpViewCluster = 0;

	mov	DWORD PTR _lpViewCluster$[ebp], 0

; 4077 :    VIEWARRAYBLOCK    tViewArrayBlock = { 0 };

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	mov	ecx, 15					; 0000000fH
	xor	eax, eax
	lea	edi, DWORD PTR _tViewArrayBlock$[ebp+4]
	rep stosd

; 4078 :    LPTASK            lpCurrentTask;
; 4079 :    LPVIEWCSR         lpViewCsr;
; 4080 :    LPVIEWOI          lpViewOI;
; 4081 :    LPVIEWOD          lpViewOD;
; 4082 :    zPCHAR            pchNetworkName = 0;

	mov	DWORD PTR _pchNetworkName$[ebp], 0

; 4083 :    zVIEW             vReferenceView;
; 4084 :    zVIEW             *lpViewArray = 0;

	mov	DWORD PTR _lpViewArray$[ebp], 0

; 4085 :    zLONG             lTickCount;
; 4086 :    zBOOL             bNetworkCommit = FALSE;

	mov	BYTE PTR _bNetworkCommit$[ebp], 0

; 4087 :    zBOOL             bLockingSemaphoreCreatedHere = FALSE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 0

; 4088 :    zBOOL             bDropPessimisticLocks = FALSE;

	mov	BYTE PTR _bDropPessimisticLocks$[ebp], 0

; 4089 :    zSHORT            iOpID;
; 4090 :    zSHORT            k;
; 4091 :    zSHORT            nRC;
; 4092 :    zSHORT            nReturn = zCALL_ERROR;

	mov	WORD PTR _nReturn$[ebp], -16		; fffffff0H

; 4093 : 
; 4094 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8777

; 4095 :       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$L8777:

; 4096 : 
; 4097 :    // If nViewCount is 0 then determine number of views by counting non-zero
; 4098 :    // views.
; 4099 :    if ( nViewCount == 0 )

	movsx	edx, WORD PTR _nViewCount$[ebp]
	test	edx, edx
	jne	SHORT $L8785
$L8780:

; 4101 :       // The list can be terminated by either a 0 or -1.  The -1 might be
; 4102 :       // set by CreateEmptyViewCluster( ) above.
; 4103 :       while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L8781

; 4105 :          if ( lpOrigViewCluster[ nViewCount ].vOI == 0 )

	movsx	ecx, WORD PTR _nViewCount$[ebp]
	mov	edx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	jne	SHORT $L8782

; 4106 :             break;

	jmp	SHORT $L8781
$L8782:

; 4107 : 
; 4108 :          if ( lpOrigViewCluster[ nViewCount ].vOI == (zVIEW) -1 )

	movsx	eax, WORD PTR _nViewCount$[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], -1
	jne	SHORT $L8784

; 4109 :             break;

	jmp	SHORT $L8781
$L8784:

; 4110 : 
; 4111 :          nViewCount++;

	mov	dx, WORD PTR _nViewCount$[ebp]
	add	dx, 1
	mov	WORD PTR _nViewCount$[ebp], dx

; 4112 :       }

	jmp	SHORT $L8780
$L8781:

; 4113 : 
; 4114 :       // If nViewCount is *still* 0 then just get out.
; 4115 :       if ( nViewCount == 0 )

	movsx	eax, WORD PTR _nViewCount$[ebp]
	test	eax, eax
	jne	SHORT $L8785

; 4117 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L8786

; 4118 :             *pnViewErrorIdx = -1;

	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	WORD PTR [ecx], -1
$L8786:

; 4119 : 
; 4120 :          return( 0 );

	xor	ax, ax
	jmp	$L8759
$L8785:

; 4123 : 
; 4124 :    if ( pnViewErrorIdx == (zPSHORT) -1 )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], -1
	jne	SHORT $L8788

; 4126 :       iOpID = iCommitObjectInstance;

	mov	WORD PTR _iOpID$[ebp], 60		; 0000003cH

; 4127 :       pnViewErrorIdx = 0;

	mov	DWORD PTR _pnViewErrorIdx$[ebp], 0

; 4128 :       lpCurrentTask = zGETPTR( lpOrigViewCluster[ 0 ].vOI->hTask );

	mov	edx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 4130 :    else

	jmp	SHORT $L8795
$L8788:

; 4132 :       iOpID = iCommitMultipleOIs;

	mov	WORD PTR _iOpID$[ebp], 62		; 0000003eH

; 4133 : 
; 4134 :       // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 4135 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8791
$L8792:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L8791:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L8793

; 4137 :          if ( lpOrigViewCluster[ k ].vOI )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	je	SHORT $L8794

; 4138 :             break;

	jmp	SHORT $L8793
$L8794:

; 4139 :       }

	jmp	SHORT $L8792
$L8793:

; 4140 : 
; 4141 :       if ( (lpCurrentTask = fnOperationCall( iOpID,
; 4142 :                                              lpOrigViewCluster[ k ].vOI, 0 )) == 0 )

	push	0
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	cx, WORD PTR _iOpID$[ebp]
	push	ecx
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8795

; 4144 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8759
$L8795:

; 4147 : 
; 4148 : // TraceLineI( "CommitMultipleOIs: ENTRY OperationID: ", iOpID );
; 4149 : 
; 4150 :    lpViewCluster = fnAllocDataspace( lpCurrentTask->hFirstDataHeader,
; 4151 :                                      sizeof( ViewClusterRecord ) * (zULONG) nViewCount,
; 4152 :                                      TRUE, 0, iCluster );

	push	10104					; 00002778H
	push	0
	push	1
	movsx	edx, WORD PTR _nViewCount$[ebp]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 4153 :    lpViewCluster = zGETPTR( lpViewCluster );

	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 4154 : 
; 4155 :    // Create temporary views so core can muck with the cursors.
; 4156 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8799
$L8800:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L8799:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$L8801

; 4158 :       LPVIEWCSR  lpViewCsr;
; 4159 :       LPVIEWOI   hViewOI;
; 4160 :       zLONG      j;
; 4161 : 
; 4162 :       if ( lpOrigViewCluster[ k ].vOI == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $L8805

; 4163 :          continue;

	jmp	SHORT $L8800
$L8805:

; 4164 : 
; 4165 :       lpViewCsr = zGETPTR( lpOrigViewCluster[ k ].vOI->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$8802[ebp], eax

; 4166 :       if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$8802[ebp], 0
	jne	SHORT $L8807

; 4167 :          continue; // should never occur

	jmp	SHORT $L8800
$L8807:

; 4168 : 
; 4169 :       hViewOI = lpViewCsr->hViewOI;

	mov	eax, DWORD PTR _lpViewCsr$8802[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hViewOI$8803[ebp], ecx

; 4170 : 
; 4171 :       // Make sure the OI isn't already part of the cluster.
; 4172 :       for ( j = 0; j < k; j++ )

	mov	DWORD PTR _j$8804[ebp], 0
	jmp	SHORT $L8808
$L8809:
	mov	edx, DWORD PTR _j$8804[ebp]
	add	edx, 1
	mov	DWORD PTR _j$8804[ebp], edx
$L8808:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	DWORD PTR _j$8804[ebp], eax
	jge	SHORT $L8810

; 4174 :          if ( lpOrigViewCluster[ j ].vOI == 0 )

	mov	ecx, DWORD PTR _j$8804[ebp]
	mov	edx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	jne	SHORT $L8811

; 4175 :             continue;

	jmp	SHORT $L8809
$L8811:

; 4176 : 
; 4177 :          lpViewCsr = zGETPTR( lpOrigViewCluster[ j ].vOI->hViewCsr );

	mov	eax, DWORD PTR _j$8804[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$8802[ebp], eax

; 4178 :          if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$8802[ebp], 0
	jne	SHORT $L8813

; 4179 :             continue; // should never occur

	jmp	SHORT $L8809
$L8813:

; 4180 : 
; 4181 :          if ( lpViewCsr->hViewOI == hViewOI )

	mov	ecx, DWORD PTR _lpViewCsr$8802[ebp]
	mov	edx, DWORD PTR [ecx+10]
	cmp	edx, DWORD PTR _hViewOI$8803[ebp]
	jne	SHORT $L8814

; 4183 :             // it is already in cluster, so skip it for commit
; 4184 :             hViewOI = 0; // just to indicate skipping

	mov	DWORD PTR _hViewOI$8803[ebp], 0

; 4185 :             break;

	jmp	SHORT $L8810
$L8814:

; 4187 :       }

	jmp	SHORT $L8809
$L8810:

; 4188 : 
; 4189 :       if ( hViewOI == 0 )

	cmp	DWORD PTR _hViewOI$8803[ebp], 0
	jne	SHORT $L8815

; 4190 :          continue; // skip, because OI already found in cluster

	jmp	$L8800
$L8815:

; 4191 : 
; 4192 :       CreateViewFromViewForTask( &lpViewCluster[ k ].vOI,
; 4193 :                                  lpOrigViewCluster[ k ].vOI, 0 );

	push	0
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	call	_CreateViewFromViewForTask@12

; 4194 :    }

	jmp	$L8800
$L8801:

; 4195 : 
; 4196 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, nViewCount ) != 0 )

	movsx	eax, WORD PTR _nViewCount$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tViewArrayBlock$[ebp]
	push	ecx
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L8816

; 4198 :       if ( iOpID == iCommitMultipleOIs )

	movsx	eax, WORD PTR _iOpID$[ebp]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $L8817

; 4199 :          fnOperationReturn( iOpID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	dx, WORD PTR _iOpID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8
$L8817:

; 4200 : 
; 4201 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8759
$L8816:

; 4203 : 
; 4204 :    lpViewArray = tViewArrayBlock.pvArray;

	mov	eax, DWORD PTR _tViewArrayBlock$[ebp+4]
	mov	DWORD PTR _lpViewArray$[ebp], eax

; 4205 : 
; 4206 :    // Verify that all the views are OK.
; 4207 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8818
$L8819:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L8818:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$L8820

; 4209 :       // We allow NULL views.  This is mostly because fnNetProcessCommit might
; 4210 :       // send us an array containing null views.
; 4211 :       if ( lpViewCluster[ k ].vOI == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	jne	SHORT $L8821

; 4212 :          continue;

	jmp	SHORT $L8819
$L8821:

; 4213 : 
; 4214 :       if ( fnValidViewCsr( lpCurrentTask, lpViewCluster[ k ].vOI ) == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidViewCsr
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L8822

; 4216 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L8823

; 4217 :             *pnViewErrorIdx = k;

	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	ax, WORD PTR _k$[ebp]
	mov	WORD PTR [edx], ax
$L8823:

; 4218 : 
; 4219 :          goto EndOfFunction;

	jmp	$EndOfFunction$8824
$L8822:

; 4221 : 
; 4222 :       lpViewArray[ k ] = lpViewCluster[ k ].vOI;

	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	esi, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*8]
	mov	DWORD PTR [eax+edx*4], ecx

; 4223 : 
; 4224 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4225 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4226 :       lpViewOD  = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 4227 : 
; 4228 :       // Check to see if this is a network commit.
; 4229 :       if ( lpViewOD->szNetwork &&
; 4230 :            (lpViewOI->lActivateControl & zACTIVATE_LOCAL) == 0 )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 109				; 0000006dH
	test	eax, eax
	je	SHORT $L8828
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	and	edx, 1073741824				; 40000000H
	test	edx, edx
	jne	SHORT $L8828

; 4232 :          pchNetworkName = lpViewOD->szNetwork;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 109				; 0000006dH
	mov	DWORD PTR _pchNetworkName$[ebp], eax
$L8828:

; 4234 : 
; 4235 :       // If lControl for commit is zCOMMIT_DROPLOCKSONLY then turn on the flag
; 4236 :       // for each of the views.
; 4237 :       if ( lControl & zCOMMIT_DROPLOCKSONLY )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 2048				; 00000800H
	test	ecx, ecx
	je	SHORT $L8829

; 4238 :          lpViewCluster[ k ].lControl |= zCOMMIT_DROPLOCKSONLY;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	or	ch, 8
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx
$L8829:

; 4239 : 
; 4240 :       // If we're only committing the objects to drop the locks then we don't
; 4241 :       // want to commit this OI so set lpViewArray to 0.
; 4242 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_DROPLOCKSONLY )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $L8830

; 4244 :          // If a network has been specified for this cluster then we *don't*
; 4245 :          // want to zero out the view because we want to send it the server.
; 4246 :          if ( pchNetworkName == 0 || *pchNetworkName == 0 )

	cmp	DWORD PTR _pchNetworkName$[ebp], 0
	je	SHORT $L8832
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L8831
$L8832:

; 4247 :             lpViewArray[ k ] = 0;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 4248 :          else

	jmp	SHORT $L8833
$L8831:

; 4249 :             vReferenceView = lpViewArray[ k ];  // dks donc jb  2004.11.02

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _vReferenceView$[ebp], ecx
$L8833:

; 4250 : 
; 4251 :          continue;

	jmp	$L8819
$L8830:

; 4253 : 
; 4254 :       // If OI is read-only then forget it.
; 4255 :       if ( lpViewOI->bReadOnly )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $L8834

; 4257 :          LPTASK lpTask = zGETPTR( lpViewArray[ k ]->hTask );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8835[ebp], eax

; 4258 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L8837

; 4259 :             *pnViewErrorIdx = k;

	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	ax, WORD PTR _k$[ebp]
	mov	WORD PTR [edx], ax
$L8837:

; 4260 : 
; 4261 :          // "KZOEE079 - Trying to commit a read-only view".
; 4262 :          fnIssueCoreError( lpTask, lpViewArray[ k ], 8, 79, 0,
; 4263 :                            "Object Name = ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0P@ECGE@Object?5Name?5?$DN?5?$AA@ ; `string'
	push	0
	push	79					; 0000004fH
	push	8
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _lpTask$8835[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4264 :          goto EndOfFunction;

	jmp	$EndOfFunction$8824
$L8834:

; 4266 : 
; 4267 :       // Make sure OI does not contain versioned instances
; 4268 :       if ( lpViewOI->nVersionedInstances )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	je	SHORT $L8839

; 4270 :          LPTASK lpTask = zGETPTR( lpViewArray[ k ]->hTask );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8840[ebp], eax

; 4271 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L8842

; 4272 :             *pnViewErrorIdx = k;

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR [eax], cx
$L8842:

; 4273 : 
; 4274 :          //  "KZOEE076 - Object instance contains versioned entity instances"
; 4275 :          fnIssueCoreError( lpTask, lpViewArray[ k ], 8, 76, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	push	8
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _lpTask$8840[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4276 :          goto EndOfFunction;

	jmp	$EndOfFunction$8824
$L8839:

; 4278 : 
; 4279 :       // Make sure that the view has an object instance.
; 4280 :       if ( lpViewOI->hRootEntityInstance == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $L8843

; 4282 :          // Set array value to 0 to indicate that we don't need to commit
; 4283 :          // this view.
; 4284 :          lpViewArray[ k ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	DWORD PTR [edx+ecx*4], 0

; 4285 :          continue;

	jmp	$L8819
$L8843:

; 4287 : 
; 4288 :       // If OI hasn't been updated then forget about it UNLESS...
; 4289 :       // there is pessimistic locking.  Then we need to continue so that any
; 4290 :       // pessimistic locks are dropped.
; 4291 :       if ( lpViewOI->bUpdated == FALSE &&
; 4292 :            (lpViewOI->lActivateControl & zACTIVATE_WITH_LOCKING) == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L8844
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	jne	SHORT $L8844

; 4294 :          // Set array value to 0 to indicate that we don't need to commit
; 4295 :          // this view.
; 4296 :          lpViewArray[ k ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	DWORD PTR [edx+ecx*4], 0

; 4297 :          continue;

	jmp	$L8819
$L8844:

; 4299 : 
; 4300 :       // Check to see if we need pessimistic locks on this view.
; 4301 :       if ( lpViewOI->bIsLocked && (lControl & zCOMMIT_KEEPLOCKS) == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 7
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8845
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 4096				; 00001000H
	test	edx, edx
	jne	SHORT $L8845

; 4302 :          bDropPessimisticLocks = TRUE;

	mov	BYTE PTR _bDropPessimisticLocks$[ebp], 1
$L8845:

; 4303 : 
; 4304 :       vReferenceView = lpViewArray[ k ];

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _vReferenceView$[ebp], edx

; 4305 :    }

	jmp	$L8819
$L8820:

; 4306 : 
; 4307 :    // Make sure that at least one view is being committed.
; 4308 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8846
$L8847:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L8846:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $L8848

; 4310 :       if ( lpViewArray[ k ] )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L8849

; 4311 :          break;

	jmp	SHORT $L8848
$L8849:

; 4312 : 
; 4313 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_DROPLOCKSONLY )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	and	ecx, 2048				; 00000800H
	test	ecx, ecx
	je	SHORT $L8850

; 4314 :          break;

	jmp	SHORT $L8848
$L8850:

; 4315 :    }

	jmp	SHORT $L8847
$L8848:

; 4316 : 
; 4317 :    if ( k == nViewCount )

	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jne	SHORT $L8851

; 4319 :       // No non-zero views found so forget it.
; 4320 :       nReturn = 0;

	mov	WORD PTR _nReturn$[ebp], 0

; 4321 :       goto EndOfFunction;

	jmp	$EndOfFunction$8824
$L8851:

; 4323 : 
; 4324 : #ifdef __ACTIVATE_CONSTRAINTS__
; 4325 :    if ( (lControl & zCOMMIT_NOCONSTRAINTS) == 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 16777216				; 01000000H
	test	ecx, ecx
	jne	$L8855

; 4327 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8853
$L8854:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L8853:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$L8855

; 4329 :          zSHORT nState;
; 4330 : 
; 4331 :          // Don't worry about null views.
; 4332 :          if ( lpViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L8857

; 4333 :             continue;

	jmp	SHORT $L8854
$L8857:

; 4334 : 
; 4335 :          // If this view is only dropping the pessimistic locks then don't
; 4336 :          // call the constraint.
; 4337 :          if ( lpViewCluster[ k ].lControl & zCOMMIT_DROPLOCKSONLY )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $L8858

; 4338 :             continue;

	jmp	SHORT $L8854
$L8858:

; 4339 : 
; 4340 :          lpViewOD = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 4341 : 
; 4342 :          // If object has commit constraint active, check for objections.
; 4343 :          // If any exit...
; 4344 :          if ( lpViewOD->bCommitConstraint == FALSE )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	jne	SHORT $L8860

; 4345 :             continue;

	jmp	SHORT $L8854
$L8860:

; 4346 : 
; 4347 :          nState = 0;

	mov	WORD PTR _nState$8856[ebp], 0

; 4348 :          if ( lpCurrentTask->bShutdown )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	je	SHORT $L8861

; 4349 :             nState += zOCE_STATE_SHUTDOWN;

	mov	ax, WORD PTR _nState$8856[ebp]
	add	ax, 2
	mov	WORD PTR _nState$8856[ebp], ax
$L8861:

; 4350 : 
; 4351 :          nRC = fnInvokeOCEOperation( lpViewArray[ k ], lpCurrentTask,
; 4352 :                                      zOCE_COMMIT, nState );

	mov	cx, WORD PTR _nState$8856[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 4353 :          if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L8862

; 4355 :             if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L8863

; 4356 :                *pnViewErrorIdx = k;

	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	dx, WORD PTR _k$[ebp]
	mov	WORD PTR [ecx], dx
$L8863:

; 4357 : 
; 4358 :             nReturn = nRC;

	mov	ax, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturn$[ebp], ax

; 4359 :             goto EndOfFunction;

	jmp	$EndOfFunction$8824
$L8862:

; 4361 :       }

	jmp	$L8854
$L8855:

; 4363 : #endif
; 4364 : 
; 4365 :    if ( pchNetworkName && *pchNetworkName )

	cmp	DWORD PTR _pchNetworkName$[ebp], 0
	je	$L8864
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$L8864

; 4367 :       // Network Commit
; 4368 : 
; 4369 :       // First make sure the network is active.
; 4370 :       if ( NetStatus( vReferenceView, pchNetworkName ) == 0 )

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vReferenceView$[ebp]
	push	ecx
	call	_NetStatus@8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L8866

; 4372 :          if ( NetStartup( vReferenceView, pchNetworkName, pchNetworkName ) != 0 )

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vReferenceView$[ebp]
	push	edx
	call	_NetStartup@12
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L8866

; 4374 :             TraceLineS( "(oi) Can't start network = ", pchNetworkName );

	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BM@FEHG@?$CIoi?$CJ?5Can?8t?5start?5network?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 4375 :             MessageSend( vReferenceView, "xx", "KZOEOIAA",
; 4376 :                         "Network cannot be started.",
; 4377 :                         zMSGQ_OBJECT_CONSTRAINT_ERROR, 1 );

	push	1
	push	300					; 0000012cH
	push	OFFSET FLAT:??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_08IDGA@KZOEOIAA?$AA@	; `string'
	push	OFFSET FLAT:??_C@_02KKOC@xx?$AA@	; `string'
	mov	edx, DWORD PTR _vReferenceView$[ebp]
	push	edx
	call	_MessageSend@24

; 4378 : 
; 4379 :             goto EndOfFunction;

	jmp	$EndOfFunction$8824
$L8866:

; 4382 : 
; 4383 :       nRC = NetCommitOI( pchNetworkName, 0, lpViewCluster,
; 4384 :                          lpViewArray, nViewCount, pnViewErrorIdx, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	ecx
	mov	dx, WORD PTR _nViewCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	call	_NetCommitOI@28
	mov	WORD PTR _nRC$[ebp], ax

; 4385 : 
; 4386 : #ifdef DEBUG
; 4387 :       if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L8871

; 4389 :          for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8869
$L8870:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L8869:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$L8871

; 4391 :             LPENTITYINSTANCE lpEntityInstance;
; 4392 :             LPVIEWENTITY     lpViewEntity;
; 4393 : 
; 4394 :             if ( lpViewArray[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $L8874

; 4395 :                continue;

	jmp	SHORT $L8870
$L8874:

; 4396 : 
; 4397 :             lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4398 :             lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4399 : 
; 4400 :             for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 4401 :                   lpEntityInstance;
; 4402 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$8872[ebp], eax
	jmp	SHORT $L8879
$L8880:
	mov	edx, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$8872[ebp], eax
$L8879:
	cmp	DWORD PTR _lpEntityInstance$8872[ebp], 0
	je	$L8881

; 4404 :                lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$8873[ebp], eax

; 4405 : 
; 4406 :                if ( lpViewEntity->bDerivedPath == FALSE &&
; 4407 :                     ((lpEntityInstance->u.nInd.bCreated  &&
; 4408 :                       lpEntityInstance->u.nInd.bDeleted == FALSE &&
; 4409 :                       lpViewEntity->bCreate)                  ||
; 4410 :                      (lpEntityInstance->u.nInd.bUpdated  &&
; 4411 :                       lpEntityInstance->u.nInd.bDeleted == FALSE &&
; 4412 :                       lpViewEntity->bUpdate)                  ||
; 4413 :                      (lpEntityInstance->u.nInd.bDeleted  &&
; 4414 :                       lpEntityInstance->u.nInd.bCreated == FALSE &&
; 4415 :                       lpViewEntity->bDelete))
; 4416 : /*
; 4417 :                ||   (lpEntityInstance->u.nInd.bIncluded &&
; 4418 :                      lpViewEntity->bInclude)                 ||
; 4419 :                     (lpEntityInstance->u.nInd.bExcluded &&
; 4420 :                      lpViewEntity->bExclude)
; 4421 : */
; 4422 :                    )

	mov	eax, DWORD PTR _lpViewEntity$8873[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	jne	$L8897
	mov	edx, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $L8885
	mov	ecx, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L8885
	mov	eax, DWORD PTR _lpViewEntity$8873[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, 1
	test	ecx, ecx
	jne	$L8884
$L8885:
	mov	edx, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $L8886
	mov	ecx, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L8886
	mov	eax, DWORD PTR _lpViewEntity$8873[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 2
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L8884
$L8886:
	mov	edx, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	$L8897
	mov	ecx, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	jne	$L8897
	mov	eax, DWORD PTR _lpViewEntity$8873[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	je	$L8897
$L8884:

; 4424 :                   if ( (lControl & zCOMMIT_DROPLOCKSONLY) == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2048				; 00000800H
	test	edx, edx
	jne	$L8887

; 4426 :                      zCHAR szMsg[ 1024 ];
; 4427 : 
; 4428 :                      lpViewOD = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 4429 : 
; 4430 :                      TraceLineS( "(oi) Warning ============================", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CK@GCPD@?$CIoi?$CJ?5Warning?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
	call	_TraceLineS@8

; 4431 :                      TraceLineS( "(oi) Object definition = ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0BK@OGGO@?$CIoi?$CJ?5Object?5definition?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 4432 :                      TraceLineS( "(oi) Entity name = ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$8873[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET FLAT:??_C@_0BE@BILP@?$CIoi?$CJ?5Entity?5name?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 4433 :                      TraceLineX( "(oi) EI Flags    = ", lpEntityInstance->u.nIndicators );

	mov	eax, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	push	OFFSET FLAT:??_C@_0BE@HPNO@?$CIoi?$CJ?5EI?5Flags?5?5?5?5?$DN?5?$AA@ ; `string'
	call	_TraceLineX@8

; 4434 :                      zsprintf( szMsg, "%s  %s   Object Definition: %s   "
; 4435 :                                  "EntityName: %s   EI Flags 0x%08x",
; 4436 :                                "OE Warning", "Return code indicates that "
; 4437 :                                  "Commit was successful but OI still has "
; 4438 :                                  "instances marked as changed.",
; 4439 :                                lpViewOD->szName,
; 4440 :                                lpViewEntity->szName,
; 4441 :                                lpEntityInstance->u.nIndicators );

	mov	edx, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$8873[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_0FP@BNEA@Return?5code?5indicates?5that?5Commi@ ; `string'
	push	OFFSET FLAT:??_C@_0L@OPBG@OE?5Warning?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0EC@LDIB@?$CFs?5?5?$CFs?5?5?5Object?5Definition?3?5?$CFs?5?5@ ; `string'
	lea	eax, DWORD PTR _szMsg$8888[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 28					; 0000001cH

; 4442 :                      SysDiagnosticMessage( lpViewArray[ k ], "OE Warning",
; 4443 :                                            szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$8888[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0L@OPBG@OE?5Warning?$AA@ ; `string'
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_SysDiagnosticMessage@16
$L8887:

; 4445 : 
; 4446 :                   if ( lpViewEntity->bCreate )

	mov	edx, DWORD PTR _lpViewEntity$8873[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	test	eax, eax
	je	SHORT $L8897

; 4447 :                      lpEntityInstance->u.nInd.bCreated = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _lpEntityInstance$8872[ebp]
	mov	DWORD PTR [eax+6], edx
$L8897:

; 4451 :             } // for...

	jmp	$L8880
$L8881:

; 4452 : 
; 4453 :          } // for k...

	jmp	$L8870
$L8871:

; 4455 : #endif
; 4456 : 
; 4457 :       nReturn = nRC;

	mov	cx, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturn$[ebp], cx

; 4458 :       goto EndOfFunction;

	jmp	$EndOfFunction$8824
$L8864:

; 4460 : 
; 4461 :    // Check to see if any OIs where activated using pessimistic locking.  If
; 4462 :    // so then we need to create the pessimistic lock semaphore record for the
; 4463 :    // current task (unless it's already been created).
; 4464 :    if ( bDropPessimisticLocks &&
; 4465 :         lpCurrentTask->bPessimisticLockingSet == FALSE )

	mov	edx, DWORD PTR _bDropPessimisticLocks$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L8901
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 8
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L8901

; 4467 :       // Returns: 0 - everything OK;  1 - Semaphore not needed.
; 4468 :       nRC = fnCreatePessimisticSemaphore( lpCurrentTask,
; 4469 :                                           (zPVOID) lpViewCluster,
; 4470 :                                           nViewCount, pnViewErrorIdx, 0 );

	push	0
	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	edx
	mov	ax, WORD PTR _nViewCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCreatePessimisticSemaphore@20
	mov	WORD PTR _nRC$[ebp], ax

; 4471 :       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $L8900

; 4472 :          goto EndOfFunction;  // oops...error.

	jmp	SHORT $EndOfFunction$8824
$L8900:

; 4473 : 
; 4474 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L8901

; 4475 :          bLockingSemaphoreCreatedHere = TRUE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 1
$L8901:

; 4477 : 
; 4478 :    // Commit all the object instances in the array.
; 4479 :    nReturn = fnCommitObjectInstance( lpViewCluster, lpViewArray, nViewCount,
; 4480 :                                      pnViewErrorIdx, lpCurrentTask,
; 4481 :                                      lControl, &tViewArrayBlock );

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	edx
	mov	ax, WORD PTR _nViewCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	push	edx
	call	_fnCommitObjectInstance@28
	mov	WORD PTR _nReturn$[ebp], ax

; 4482 : 
; 4483 :    if ( bLockingSemaphoreCreatedHere )

	mov	eax, DWORD PTR _bLockingSemaphoreCreatedHere$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $EndOfFunction$8824

; 4484 :       fnDeletePessimisticSemaphore( lpCurrentTask, (zPVOID) lpViewCluster,
; 4485 :                                     nViewCount, pnViewErrorIdx, 0 );

	push	0
	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	ecx
	mov	dx, WORD PTR _nViewCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnDeletePessimisticSemaphore@20
$EndOfFunction$8824:

; 4486 : 
; 4487 : EndOfFunction:
; 4488 :    if ( lpViewCluster )

	cmp	DWORD PTR _lpViewCluster$[ebp], 0
	je	SHORT $L8904

; 4490 :       // Drop the temporary views.
; 4491 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8905
$L8906:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L8905:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L8907

; 4493 :          if ( lpViewCluster[ k ].vOI )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	je	SHORT $L8908

; 4494 :             fnDropView( lpViewCluster[ k ].vOI );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	_fnDropView@4
$L8908:

; 4495 :       }

	jmp	SHORT $L8906
$L8907:

; 4496 : 
; 4497 :       fnFreeDataspace( lpViewCluster );

	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4
$L8904:

; 4499 : 
; 4500 :    // free the VIEWARRAYBLOCK areas
; 4501 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 4502 : 
; 4503 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8909

; 4505 :       zCHAR sz[ 30 ];
; 4506 : 
; 4507 :       zsprintf( sz, "%lf seconds",
; 4508 :                 (double) (SysGetTickCount( ) - lTickCount) / zTICKS_PER_SECOND );

	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR -1224+[ebp], eax
	mov	DWORD PTR -1224+[ebp+4], 0
	fild	QWORD PTR -1224+[ebp]
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0M@FIA@?$CFlf?5seconds?$AA@ ; `string'
	lea	edx, DWORD PTR _sz$8910[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4509 :       TraceLineS( "(oi) Total time for CommitMultipleOIs = ", sz );

	lea	eax, DWORD PTR _sz$8910[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CJ@PHHP@?$CIoi?$CJ?5Total?5time?5for?5CommitMultip@ ; `string'
	call	_TraceLineS@8
$L8909:

; 4511 : 
; 4512 :    if ( iOpID == iCommitMultipleOIs )

	movsx	ecx, WORD PTR _iOpID$[ebp]
	cmp	ecx, 62					; 0000003eH
	jne	SHORT $L8914

; 4513 :       fnOperationReturn( iOpID, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	ax, WORD PTR _iOpID$[ebp]
	push	eax
	call	_fnOperationReturn
	add	esp, 8
$L8914:

; 4514 : 
; 4515 : // TraceLineI( "CommitMultipleOIs: EXIT OperationID: ", iOpID );
; 4516 :    return( nReturn );

	mov	ax, WORD PTR _nReturn$[ebp]
$L8759:

; 4517 : 
; 4518 : } // CommitMultipleOIs

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CommitMultipleOIs@16 ENDP
_TEXT	ENDS
PUBLIC	_CommitMultipleObjectInstances@8
_TEXT	SEGMENT
_lpArray$ = 8
_lpErrorIndex$ = 12
_nIndex$ = -8
_nRC$ = -4
_CommitMultipleObjectInstances@8 PROC NEAR

; 4538 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4539 :    zSHORT nIndex;
; 4540 :    zSHORT nRC;
; 4541 : 
; 4542 :    nRC = CommitMultipleOIs( (LPVIEWCLUSTER) lpArray, 0, &nIndex, 0 );

	push	0
	lea	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpArray$[ebp]
	push	ecx
	call	_CommitMultipleOIs@16
	mov	WORD PTR _nRC$[ebp], ax

; 4543 :    *lpErrorIndex = (zLONG) nIndex;

	movsx	edx, WORD PTR _nIndex$[ebp]
	mov	eax, DWORD PTR _lpErrorIndex$[ebp]
	mov	DWORD PTR [eax], edx

; 4544 : 
; 4545 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 4546 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CommitMultipleObjectInstances@8 ENDP
_TEXT	ENDS
PUBLIC	_fnSetForeignKeysForInstance@4
EXTRN	_lNullInteger:DWORD
EXTRN	_stNullDateTime:FWORD
EXTRN	_SysAssignDecimalFromNull@4:NEAR
_TEXT	SEGMENT
_lpEntityInstance$ = 8
_lpViewEntity$ = -4
_lpDataRecord$ = -24
_lpRelRecord$ = -20
_lpRelField$ = -12
_lpViewOI$ = -16
_lpTask$ = -8
_lpSrcViewAttrib$8947 = -28
_lpRelViewAttrib$8948 = -36
_lpRelViewEntity$8949 = -48
_lpSrcViewEntity$8950 = -52
_lpRelInstance$8951 = -40
_lpSrcInstance$8952 = -32
_lpWkDataField$8953 = -44
_lpWkRelViewEntity$8966 = -56
_lpWkSrcViewEntity$8975 = -60
_uLth$8981 = -68
_lpValue$8982 = -64
_d$8986 = -116
_s$8987 = -76
_p$8988 = -72
_fnSetForeignKeysForInstance@4 PROC NEAR

; 4568 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H

; 4569 :    LPVIEWENTITY   lpViewEntity;
; 4570 :    LPDATARECORD   lpDataRecord;
; 4571 :    LPRELRECORD    lpRelRecord;
; 4572 :    LPRELFIELD     lpRelField;
; 4573 :    LPVIEWOI       lpViewOI;
; 4574 :    LPTASK         lpTask;
; 4575 : 
; 4576 :    lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4577 : 
; 4578 :    // Get Task owning the view object instance
; 4579 :    lpTask = zGETPTR( lpViewOI->hAllocTask );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 4580 : 
; 4581 :    lpEntityInstance->u.nInd.bForeignKeys = 0;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -4194305				; ffbfffffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 4582 : 
; 4583 :    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4584 :    if ( lpViewEntity->hParent == 0 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $L8937

; 4585 :       return( 0 );

	xor	ax, ax
	jmp	$L8927
$L8937:

; 4586 : 
; 4587 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 4588 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 4589 :    if ( lpRelRecord == 0 )

	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	jne	SHORT $L8940

; 4590 :       return( 0 );

	xor	ax, ax
	jmp	$L8927
$L8940:

; 4591 : 
; 4592 :    lpRelField   = zGETPTR( lpRelRecord->hFirstRelField );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax

; 4593 :    if ( lpRelField == 0 )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	jne	SHORT $L8942

; 4594 :       return( 0 );

	xor	ax, ax
	jmp	$L8927
$L8942:

; 4595 : 
; 4596 :    // For each rel field, check to see if the current entity
; 4597 :    // instance has a foreign key.  If it does, then the value
; 4598 :    // needs to be copied
; 4599 :    for ( ;
; 4600 :          lpRelField;
; 4601 :          lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	jmp	SHORT $L8944
$L8945:
	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax
$L8944:
	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$L8946

; 4603 :       LPVIEWATTRIB      lpSrcViewAttrib;
; 4604 :       LPVIEWATTRIB      lpRelViewAttrib;
; 4605 :       LPVIEWENTITY      lpRelViewEntity;
; 4606 :       LPVIEWENTITY      lpSrcViewEntity;
; 4607 :       LPENTITYINSTANCE  lpRelInstance;
; 4608 :       LPENTITYINSTANCE  lpSrcInstance;
; 4609 :       LPDATAFIELD       lpWkDataField;
; 4610 : 
; 4611 :       // If the rel field doesn't have a data field, then skip it.
; 4612 :       if ( lpRelField->hRelDataField == 0 )

	mov	eax, DWORD PTR _lpRelField$[ebp]
	cmp	DWORD PTR [eax+14], 0
	jne	SHORT $L8954

; 4613 :          continue;

	jmp	SHORT $L8945
$L8954:

; 4614 : 
; 4615 :       lpWkDataField   = zGETPTR( lpRelField->hSrcDataField );

	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkDataField$8953[ebp], eax

; 4616 :       lpSrcViewAttrib = zGETPTR( lpWkDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpWkDataField$8953[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewAttrib$8947[ebp], eax

; 4617 :       lpWkDataField   = zGETPTR( lpRelField->hRelDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkDataField$8953[ebp], eax

; 4618 :       lpRelViewAttrib = zGETPTR( lpWkDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpWkDataField$8953[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelViewAttrib$8948[ebp], eax

; 4619 :       lpSrcViewEntity = zGETPTR( lpSrcViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpSrcViewAttrib$8947[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$8950[ebp], eax

; 4620 :       lpRelViewEntity = zGETPTR( lpRelViewAttrib->hViewEntity );

	mov	edx, DWORD PTR _lpRelViewAttrib$8948[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelViewEntity$8949[ebp], eax

; 4621 : 
; 4622 :       // We now have the attributes--the source and relationship (i.e. target)
; 4623 :       // attributes.  One is part of the current entity (lpViewEntity) and
; 4624 :       // the other is a parent of the current entity.  Find the entity
; 4625 :       // instance of the parent entity.
; 4626 : 
; 4627 :       if ( lpRelViewEntity != lpViewEntity )

	mov	ecx, DWORD PTR _lpRelViewEntity$8949[ebp]
	cmp	ecx, DWORD PTR _lpViewEntity$[ebp]
	je	$L8961

; 4629 :          // The relationship entity is different from the current entity.
; 4630 :          // Find the relationship entity instance.
; 4631 :          lpSrcInstance = lpEntityInstance;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpSrcInstance$8952[ebp], edx

; 4632 :          lpRelInstance = zGETPTR( lpEntityInstance->hParent );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelInstance$8951[ebp], eax
$L8964:

; 4633 :          while ( lpRelInstance->hViewEntity != lpRelViewAttrib->hViewEntity )

	mov	edx, DWORD PTR _lpRelInstance$8951[ebp]
	mov	eax, DWORD PTR _lpRelViewAttrib$8948[ebp]
	mov	ecx, DWORD PTR [edx+2]
	cmp	ecx, DWORD PTR [eax+6]
	je	SHORT $L8965

; 4635 :             LPVIEWENTITY lpWkRelViewEntity =
; 4636 :                                     zGETPTR( lpRelInstance->hViewEntity );

	mov	edx, DWORD PTR _lpRelInstance$8951[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkRelViewEntity$8966[ebp], eax

; 4637 : 
; 4638 :             // DGC 4/8/97
; 4639 :             // If the parent entity we are looking for is a recursive parent,
; 4640 :             // then it's possible that the entity instance we are looking for
; 4641 :             // has an lpViewEntity that is the recursive child entity.
; 4642 :             if ( lpRelViewEntity->bRecursivePar &&
; 4643 :                  lpWkRelViewEntity->bRecursive &&
; 4644 :                  lpWkRelViewEntity->lEREntTok == lpRelViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpRelViewEntity$8949[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 29					; 0000001dH
	and	edx, 1
	test	edx, edx
	je	SHORT $L8968
	mov	eax, DWORD PTR _lpWkRelViewEntity$8966[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8968
	mov	edx, DWORD PTR _lpWkRelViewEntity$8966[ebp]
	mov	eax, DWORD PTR _lpRelViewEntity$8949[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	jne	SHORT $L8968

; 4646 :                break;

	jmp	SHORT $L8965
$L8968:

; 4648 : 
; 4649 :             lpRelInstance = zGETPTR( lpRelInstance->hParent );

	mov	edx, DWORD PTR _lpRelInstance$8951[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelInstance$8951[ebp], eax

; 4650 :          }

	jmp	SHORT $L8964
$L8965:

; 4652 :       else

	jmp	$L8974
$L8961:

; 4654 :          // The source entity is different from the current entity.
; 4655 :          // Find the source entity instance.
; 4656 :          lpRelInstance = lpEntityInstance;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpRelInstance$8951[ebp], ecx

; 4657 :          lpSrcInstance = zGETPTR( lpEntityInstance->hParent );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$8952[ebp], eax
$L8973:

; 4658 :          while ( lpSrcInstance->hViewEntity != lpSrcViewAttrib->hViewEntity )

	mov	ecx, DWORD PTR _lpSrcInstance$8952[ebp]
	mov	edx, DWORD PTR _lpSrcViewAttrib$8947[ebp]
	mov	eax, DWORD PTR [ecx+2]
	cmp	eax, DWORD PTR [edx+6]
	je	SHORT $L8974

; 4660 :             LPVIEWENTITY lpWkSrcViewEntity =
; 4661 :                                     zGETPTR( lpSrcInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSrcInstance$8952[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkSrcViewEntity$8975[ebp], eax

; 4662 : 
; 4663 :             // DGC 4/8/97
; 4664 :             // If the parent entity we are looking for is a recursive parent,
; 4665 :             // then it's possible that the entity instance we are looking for
; 4666 :             // has an lpViewEntity that is the recursive child entity.
; 4667 :             if ( lpSrcViewEntity->bRecursivePar &&
; 4668 :                  lpWkSrcViewEntity->bRecursive &&
; 4669 :                  lpWkSrcViewEntity->lEREntTok == lpSrcViewEntity->lEREntTok )

	mov	eax, DWORD PTR _lpSrcViewEntity$8950[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 29					; 0000001dH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8977
	mov	edx, DWORD PTR _lpWkSrcViewEntity$8975[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	test	eax, eax
	je	SHORT $L8977
	mov	ecx, DWORD PTR _lpWkSrcViewEntity$8975[ebp]
	mov	edx, DWORD PTR _lpSrcViewEntity$8950[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	jne	SHORT $L8977

; 4671 :                break;

	jmp	SHORT $L8974
$L8977:

; 4673 : 
; 4674 :             lpSrcInstance = zGETPTR( lpSrcInstance->hParent );

	mov	ecx, DWORD PTR _lpSrcInstance$8952[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$8952[ebp], eax

; 4675 :          }

	jmp	SHORT $L8973
$L8974:

; 4677 : 
; 4678 :       if ( lpEntityInstance->u.nInd.bCreated ||
; 4679 :            lpEntityInstance->u.nInd.bIncluded )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L8980
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	je	SHORT $L8979
$L8980:

; 4681 :          zULONG  uLth;
; 4682 :          zPVOID  lpValue;
; 4683 : 
; 4684 :          // If the source instance hasn't had *IT'S* FKs set then skip this
; 4685 :          // one and try again later.
; 4686 :          if ( lpSrcInstance->u.nInd.bForeignKeys )

	mov	ecx, DWORD PTR _lpSrcInstance$8952[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 22					; 00000016H
	and	edx, 1
	test	edx, edx
	je	SHORT $L8983

; 4688 :             // Turn the flag back on for this instance.
; 4689 :             lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 4194304				; 00400000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 4690 :             return( 1 );

	mov	ax, 1
	jmp	$L8927
$L8983:

; 4692 : 
; 4693 :          fnGetAttrAddrFromEntityInstance( (zCOREMEM) &lpValue,
; 4694 :                                           &uLth,
; 4695 :                                           lpSrcInstance,
; 4696 :                                           lpSrcViewAttrib );

	mov	eax, DWORD PTR _lpSrcViewAttrib$8947[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcInstance$8952[ebp]
	push	ecx
	lea	edx, DWORD PTR _uLth$8981[ebp]
	push	edx
	lea	eax, DWORD PTR _lpValue$8982[ebp]
	push	eax
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H

; 4697 :          fnStoreValueInEntityInstance( lpRelInstance,
; 4698 :                                        lpRelViewEntity,
; 4699 :                                        lpRelViewAttrib,
; 4700 :                                        lpValue, uLth );

	mov	ecx, DWORD PTR _uLth$8981[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpValue$8982[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelViewAttrib$8948[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelViewEntity$8949[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRelInstance$8951[ebp]
	push	edx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H

; 4702 :       else

	jmp	$L9001
$L8979:

; 4704 :          zDECIMAL d;
; 4705 :          zCHAR    s[ 3 ] = "";

	mov	al, BYTE PTR ??_C@_00A@?$AA@		; `string'
	mov	BYTE PTR _s$8987[ebp], al
	xor	ecx, ecx
	mov	WORD PTR _s$8987[ebp+1], cx

; 4706 :          zPVOID   p;
; 4707 : 
; 4708 :          // Set foreign key to null.
; 4709 :          switch ( lpRelViewAttrib->cType )
; 4710 :          {

	mov	edx, DWORD PTR _lpRelViewAttrib$8948[ebp]
	movsx	eax, BYTE PTR [edx+202]
	mov	DWORD PTR -120+[ebp], eax
	mov	ecx, DWORD PTR -120+[ebp]
	sub	ecx, 68					; 00000044H
	mov	DWORD PTR -120+[ebp], ecx
	cmp	DWORD PTR -120+[ebp], 16		; 00000010H
	ja	SHORT $L8990
	mov	eax, DWORD PTR -120+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L12765[eax]
	jmp	DWORD PTR $L12766[edx*4]
$L8993:

; 4711 :             case zTYPE_DECIMAL:
; 4712 :                SysAssignDecimalFromNull( &d );

	lea	ecx, DWORD PTR _d$8986[ebp]
	push	ecx
	call	_SysAssignDecimalFromNull@4

; 4713 :                p = (zPVOID) &d;

	lea	edx, DWORD PTR _d$8986[ebp]
	mov	DWORD PTR _p$8988[ebp], edx

; 4714 :                break;

	jmp	SHORT $L8990
$L8995:

; 4715 : 
; 4716 :             case zTYPE_INTEGER:
; 4717 :                p = (zPVOID) &lNullInteger;

	mov	DWORD PTR _p$8988[ebp], OFFSET FLAT:_lNullInteger

; 4718 :                break;

	jmp	SHORT $L8990
$L8997:

; 4719 : 
; 4720 :             case zTYPE_STRING:
; 4721 :                p = (zPVOID) s;

	lea	eax, DWORD PTR _s$8987[ebp]
	mov	DWORD PTR _p$8988[ebp], eax

; 4722 :                break;

	jmp	SHORT $L8990
$L8999:

; 4723 : 
; 4724 :             case zTYPE_DATE:
; 4725 :             case zTYPE_DATETIME:
; 4726 :                p = (zPVOID) &stNullDateTime;

	mov	DWORD PTR _p$8988[ebp], OFFSET FLAT:_stNullDateTime
$L8990:

; 4729 : 
; 4730 :          // Gig, 10/4/93
; 4731 :          // If the foreign key is a key to the target entity, then
; 4732 :          // we cannot null the key because we would lose the
; 4733 :          // capability of updating the entity (in this case it
; 4734 :          // better be deleted!!!)
; 4735 :          if ( lpRelViewAttrib->bKey == FALSE )

	mov	ecx, DWORD PTR _lpRelViewAttrib$8948[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9001

; 4737 :             // HH: p points to correct datatype (set in 'switch' above).
; 4738 :             fnStoreValueInEntityInstance( lpRelInstance,
; 4739 :                                           lpRelViewEntity,
; 4740 :                                           lpRelViewAttrib,
; 4741 :                                           (zPVOID) p, 0 );

	push	0
	mov	eax, DWORD PTR _p$8988[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelViewAttrib$8948[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRelViewEntity$8949[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelInstance$8951[ebp]
	push	eax
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
$L9001:

; 4744 : 
; 4745 :       // Turn off the dbh flag to make sure that the DBHandler updates
; 4746 :       // the instance.
; 4747 :       lpRelInstance->u.nInd.bDBHUpdated = FALSE;

	mov	ecx, DWORD PTR _lpRelInstance$8951[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -131073				; fffdffffH
	mov	eax, DWORD PTR _lpRelInstance$8951[ebp]
	mov	DWORD PTR [eax+6], edx

; 4748 : 
; 4749 :    } // for ( lpRelField )...

	jmp	$L8945
$L8946:

; 4750 : 
; 4751 :    return( 0 );

	xor	ax, ax
$L8927:

; 4752 : 
; 4753 : } // fnSetForeignKeysForInstance

	mov	esp, ebp
	pop	ebp
	ret	4
$L12766:
	DD	$L8999
	DD	$L8995
	DD	$L8993
	DD	$L8997
	DD	$L8990
$L12765:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	0
_fnSetForeignKeysForInstance@4 ENDP
_TEXT	ENDS
PUBLIC	_fnCheckCreateDeleteFlags@24
PUBLIC	??_C@_0CL@DMOI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5Warning?5?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_06EOKH@create?$AA@			; `string'
PUBLIC	??_C@_06IDPA@delete?$AA@			; `string'
PUBLIC	??_C@_07JPDC@created?$AA@			; `string'
PUBLIC	??_C@_07NAPP@deleted?$AA@			; `string'
PUBLIC	??_C@_0ID@FFNG@Warning?3?5Trying?5to?5commit?5an?5ent@ ; `string'
PUBLIC	??_C@_0CB@PJII@Number?5of?5views?5in?5the?5cluster?3?5@ ; `string'
PUBLIC	??_C@_0CD@IIDP@?$CInull?$CJ?5View?5not?5flagged?5as?5chang@ ; `string'
PUBLIC	??_C@_0O@FMKN@?5?5?5View?5ID?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_0CD@MHHP@?5?5?5View?5ID?5?$DN?5?$CFlx?0?5Object?5name?5?$DN?5@ ; `string'
PUBLIC	??_C@_05OGKG@?$CFs?4?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BO@HLDF@OD?4Entity?5with?5Create?5flag?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BO@BCNN@OD?4Entity?5with?5Delete?5flag?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@		; `string'
PUBLIC	??_C@_0CD@MNFM@OD?4Entity?5with?5create?5authority?5@ ; `string'
PUBLIC	??_C@_0KE@LDAH@Warning?3?5Trying?5to?5commit?5an?5ent@ ; `string'
PUBLIC	??_C@_0BE@DMJL@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AA@ ; `string'
EXTRN	_DisplayEntityInstancePath@8:NEAR
;	COMDAT ??_C@_0CL@DMOI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5Warning?5?9?9?9?9?9?9@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CL@DMOI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5Warning?5?9?9?9?9?9?9@ DB '-'
	DB	'---------------- Warning ----------------', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_06EOKH@create?$AA@
_DATA	SEGMENT
??_C@_06EOKH@create?$AA@ DB 'create', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IDPA@delete?$AA@
_DATA	SEGMENT
??_C@_06IDPA@delete?$AA@ DB 'delete', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07JPDC@created?$AA@
_DATA	SEGMENT
??_C@_07JPDC@created?$AA@ DB 'created', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NAPP@deleted?$AA@
_DATA	SEGMENT
??_C@_07NAPP@deleted?$AA@ DB 'deleted', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0ID@FFNG@Warning?3?5Trying?5to?5commit?5an?5ent@
_DATA	SEGMENT
??_C@_0ID@FFNG@Warning?3?5Trying?5to?5commit?5an?5ent@ DB 'Warning: Tryin'
	DB	'g to commit an entity that has been %s but does not have %s a'
	DB	'uthority in the current cluster.  OD.EntityName = %s.%s', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@PJII@Number?5of?5views?5in?5the?5cluster?3?5@
_DATA	SEGMENT
??_C@_0CB@PJII@Number?5of?5views?5in?5the?5cluster?3?5@ DB 'Number of vie'
	DB	'ws in the cluster: ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@IIDP@?$CInull?$CJ?5View?5not?5flagged?5as?5chang@
_DATA	SEGMENT
??_C@_0CD@IIDP@?$CInull?$CJ?5View?5not?5flagged?5as?5chang@ DB '(null) Vi'
	DB	'ew not flagged as changed', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@FMKN@?5?5?5View?5ID?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0O@FMKN@?5?5?5View?5ID?5?$DN?5?$AA@ DB '   View ID = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@MHHP@?5?5?5View?5ID?5?$DN?5?$CFlx?0?5Object?5name?5?$DN?5@
_DATA	SEGMENT
??_C@_0CD@MHHP@?5?5?5View?5ID?5?$DN?5?$CFlx?0?5Object?5name?5?$DN?5@ DB ' '
	DB	'  View ID = %lx, Object name = %s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05OGKG@?$CFs?4?$CFs?$AA@
_DATA	SEGMENT
??_C@_05OGKG@?$CFs?4?$CFs?$AA@ DB '%s.%s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@HLDF@OD?4Entity?5with?5Create?5flag?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BO@HLDF@OD?4Entity?5with?5Create?5flag?5?$DN?5?$AA@ DB 'OD.Entity '
	DB	'with Create flag = ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@BCNN@OD?4Entity?5with?5Delete?5flag?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BO@BCNN@OD?4Entity?5with?5Delete?5flag?5?$DN?5?$AA@ DB 'OD.Entity '
	DB	'with Delete flag = ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@ DB 'OI ID = ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@MNFM@OD?4Entity?5with?5create?5authority?5@
_DATA	SEGMENT
??_C@_0CD@MNFM@OD?4Entity?5with?5create?5authority?5@ DB 'OD.Entity with '
	DB	'create authority = ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0KE@LDAH@Warning?3?5Trying?5to?5commit?5an?5ent@
_DATA	SEGMENT
??_C@_0KE@LDAH@Warning?3?5Trying?5to?5commit?5an?5ent@ DB 'Warning: Tryin'
	DB	'g to commit an entity that has been %s but does not have %s a'
	DB	'uthority in the current cluster.  OD.EntityName = %s.%s. See '
	DB	'trace for more information.', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DMJL@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AA@
_DATA	SEGMENT
??_C@_0BE@DMJL@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AA@ DB '----------'
	DB	'---------', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpEntityInstance$ = 8
_lpViewArray$ = 12
_lpViewOD_Array$ = 16
_lpViewOI_Array$ = 20
_nViewCount$ = 24
_bCheckCreate$ = 28
_lpViewEntity$ = -8
_lpCandidateViewEntity$ = -24
_lpCandidateViewOD$ = -12
_lpCandidateViewOI$ = -16
_lpViewOI$ = -28
_bShowMsg$ = -4
_k$ = -20
_lpLinked$9026 = -32
_lpLinkedViewEntity$9032 = -36
_szMsg$9048 = -1044
_lpView$9049 = -44
_lpViewOI$9050 = -1048
_lpViewOD$9052 = -40
_lpViewCsr$9057 = -1052
_fnCheckCreateDeleteFlags@24 PROC NEAR

; 4765 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1068				; 0000042cH

; 4766 :    LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4767 :    LPVIEWENTITY lpCandidateViewEntity = 0;

	mov	DWORD PTR _lpCandidateViewEntity$[ebp], 0

; 4768 :    LPVIEWOD     lpCandidateViewOD = 0;

	mov	DWORD PTR _lpCandidateViewOD$[ebp], 0

; 4769 :    LPVIEWOI     lpCandidateViewOI = 0;

	mov	DWORD PTR _lpCandidateViewOI$[ebp], 0

; 4770 :    LPVIEWOI     lpViewOI;
; 4771 :    zBOOL        bShowMsg = TRUE;  // We'll assume a problem.

	mov	BYTE PTR _bShowMsg$[ebp], 1

; 4772 :    zSHORT       k;
; 4773 : 
; 4774 :    // Look for a linked entity instance that has create authority.
; 4775 :    if ( lpEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	$L9031

; 4777 :       LPENTITYINSTANCE lpLinked;
; 4778 : 
; 4779 :       for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 4780 :             lpLinked != lpEntityInstance;
; 4781 :             lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9026[ebp], eax
	jmp	SHORT $L9029
$L9030:
	mov	edx, DWORD PTR _lpLinked$9026[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9026[ebp], eax
$L9029:
	mov	ecx, DWORD PTR _lpLinked$9026[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	$L9031

; 4783 :          LPVIEWENTITY lpLinkedViewEntity;
; 4784 : 
; 4785 :          // If the EI doesn't have create authority then skip it.
; 4786 :          lpLinkedViewEntity = zGETPTR( lpLinked->hViewEntity );

	mov	edx, DWORD PTR _lpLinked$9026[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedViewEntity$9032[ebp], eax

; 4787 :          if ( bCheckCreate )

	mov	ecx, DWORD PTR _bCheckCreate$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9034

; 4789 :             if ( lpLinkedViewEntity->bCreate == FALSE )

	mov	edx, DWORD PTR _lpLinkedViewEntity$9032[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9035

; 4790 :                continue;

	jmp	SHORT $L9030
$L9035:

; 4792 :          else

	jmp	SHORT $L9037
$L9034:

; 4794 :             if ( lpLinkedViewEntity->bDelete == FALSE )

	mov	ecx, DWORD PTR _lpLinkedViewEntity$9032[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9037

; 4795 :                continue;

	jmp	SHORT $L9030
$L9037:

; 4797 : 
; 4798 :          lpViewOI = zGETPTR( lpLinked->hViewOI );

	mov	eax, DWORD PTR _lpLinked$9026[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4799 : 
; 4800 :          // Check to see if the linked EI belongs to one of the
; 4801 :          // OIs in the current cluster.
; 4802 :          for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9039
$L9040:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9039:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L9041

; 4804 :             if ( lpViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L9042

; 4805 :                continue;

	jmp	SHORT $L9040
$L9042:

; 4806 : 
; 4807 :             if ( lpViewOI == lpViewOI_Array[ k ] )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	eax, DWORD PTR [edx+ecx*4]
	jne	SHORT $L9043

; 4809 :                // We found a linked EI in the current cluster with
; 4810 :                // create authority.  Everything's OK.
; 4811 :                bShowMsg = FALSE;

	mov	BYTE PTR _bShowMsg$[ebp], 0

; 4812 :                break;

	jmp	SHORT $L9041
$L9043:

; 4814 :          }

	jmp	SHORT $L9040
$L9041:

; 4815 : 
; 4816 :          if ( bShowMsg == FALSE )

	mov	ecx, DWORD PTR _bShowMsg$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L9044

; 4817 :             break;

	jmp	SHORT $L9031
$L9044:

; 4818 : 
; 4819 :          // If we get here then we've found an EI that has create/delete
; 4820 :          // authority but is not part of an OI in the cluster.
; 4821 :          // This is a candidate for adding to the cluster.
; 4822 :          lpCandidateViewEntity = zGETPTR( lpLinked->hViewEntity );

	mov	edx, DWORD PTR _lpLinked$9026[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCandidateViewEntity$[ebp], eax

; 4823 :          lpCandidateViewOD     = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCandidateViewOD$[ebp], eax

; 4824 :          lpCandidateViewOI     = lpViewOI;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR _lpCandidateViewOI$[ebp], eax

; 4825 :       } // for ( lpLinked...)...

	jmp	$L9030
$L9031:

; 4827 : 
; 4828 :    // If bShowMsg is TRUE then we didn't find an EI with create
; 4829 :    // authority in the current cluster.  Show diagnostic message.
; 4830 :    if ( bShowMsg )

	mov	ecx, DWORD PTR _bShowMsg$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	$L9047

; 4832 :       zCHAR    szMsg[ 1000 ];
; 4833 :       zVIEW    lpView = 0;

	mov	DWORD PTR _lpView$9049[ebp], 0

; 4834 :       LPVIEWOI lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$9050[ebp], eax

; 4835 :       LPVIEWOD lpViewOD = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$9050[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$9052[ebp], eax

; 4836 : 
; 4837 :       // Find the view that references lpViewOI.
; 4838 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9054
$L9055:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9054:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $L9056

; 4840 :          LPVIEWCSR lpViewCsr;
; 4841 : 
; 4842 :          if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L9058

; 4843 :             continue;

	jmp	SHORT $L9055
$L9058:

; 4844 : 
; 4845 :          lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$9057[ebp], eax

; 4846 :          if ( lpViewCsr->hViewOI == lpEntityInstance->hViewOI )

	mov	eax, DWORD PTR _lpViewCsr$9057[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [eax+10]
	cmp	edx, DWORD PTR [ecx+10]
	jne	SHORT $L9060

; 4848 :             // We found it.
; 4849 :             lpView = lpViewArray[ k ];

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _lpView$9049[ebp], edx

; 4850 :             break;

	jmp	SHORT $L9056
$L9060:

; 4852 :       }

	jmp	SHORT $L9055
$L9056:

; 4853 : 
; 4854 :       TraceLineS( "----------------- Warning ----------------", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CL@DMOI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5Warning?5?9?9?9?9?9?9@ ; `string'
	call	_TraceLineS@8

; 4855 :       zsprintf( szMsg, "Warning: Trying to commit an entity that "
; 4856 :                 "has been %s but does not have %s "
; 4857 :                 "authority in the current cluster.  OD.EntityName = %s.%s",
; 4858 :                 bCheckCreate ? "created" : "deleted",
; 4859 :                 bCheckCreate ? "create" : "delete",
; 4860 :                 lpViewOD->szName, lpViewEntity->szName );

	mov	eax, DWORD PTR _bCheckCreate$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L12768
	mov	DWORD PTR -1056+[ebp], OFFSET FLAT:??_C@_06EOKH@create?$AA@ ; `string'
	jmp	SHORT $L12769
$L12768:
	mov	DWORD PTR -1056+[ebp], OFFSET FLAT:??_C@_06IDPA@delete?$AA@ ; `string'
$L12769:
	mov	ecx, DWORD PTR _bCheckCreate$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L12770
	mov	DWORD PTR -1060+[ebp], OFFSET FLAT:??_C@_07JPDC@created?$AA@ ; `string'
	jmp	SHORT $L12771
$L12770:
	mov	DWORD PTR -1060+[ebp], OFFSET FLAT:??_C@_07NAPP@deleted?$AA@ ; `string'
$L12771:
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpViewOD$9052[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR -1056+[ebp]
	push	ecx
	mov	edx, DWORD PTR -1060+[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0ID@FFNG@Warning?3?5Trying?5to?5commit?5an?5ent@ ; `string'
	lea	eax, DWORD PTR _szMsg$9048[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 4861 :       TraceLineS( szMsg, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szMsg$9048[ebp]
	push	ecx
	call	_TraceLineS@8

; 4862 :       TraceLineS( "", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	call	_TraceLineS@8

; 4863 : 
; 4864 :       // List the views in the cluster.
; 4865 :       TraceLineI( "Number of views in the cluster: ", nViewCount );

	movsx	edx, WORD PTR _nViewCount$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CB@PJII@Number?5of?5views?5in?5the?5cluster?3?5@ ; `string'
	call	_TraceLineI@8

; 4866 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9068
$L9069:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9068:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $L9070

; 4868 :          if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L9071

; 4870 :             TraceLineS( "   View ID = ", "(null) View not flagged as changed" );

	push	OFFSET FLAT:??_C@_0CD@IIDP@?$CInull?$CJ?5View?5not?5flagged?5as?5chang@ ; `string'
	push	OFFSET FLAT:??_C@_0O@FMKN@?5?5?5View?5ID?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 4871 :             continue;

	jmp	SHORT $L9069
$L9071:

; 4873 : 
; 4874 :          zsprintf( szMsg, "   View ID = %lx, Object name = %s",
; 4875 :                    lpViewArray[ k ], lpViewOD_Array[ k ]->szName );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewOD_Array$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, 10					; 0000000aH
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET FLAT:??_C@_0CD@MHHP@?5?5?5View?5ID?5?$DN?5?$CFlx?0?5Object?5name?5?$DN?5@ ; `string'
	lea	edx, DWORD PTR _szMsg$9048[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4876 :          TraceLineS( szMsg, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _szMsg$9048[ebp]
	push	eax
	call	_TraceLineS@8

; 4877 :       }

	jmp	SHORT $L9069
$L9070:

; 4878 : 
; 4879 : 
; 4880 :       zsprintf( szMsg, "%s.%s", lpViewOD->szName, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$9052[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_05OGKG@?$CFs?4?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szMsg$9048[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4881 :       if ( bCheckCreate )

	mov	ecx, DWORD PTR _bCheckCreate$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9076

; 4882 :          TraceLineS( "OD.Entity with Create flag = ", szMsg );

	lea	edx, DWORD PTR _szMsg$9048[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BO@HLDF@OD?4Entity?5with?5Create?5flag?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 4883 :       else

	jmp	SHORT $L9078
$L9076:

; 4884 :          TraceLineS( "OD.Entity with Delete flag = ", szMsg );

	lea	eax, DWORD PTR _szMsg$9048[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BO@BCNN@OD?4Entity?5with?5Delete?5flag?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8
$L9078:

; 4885 :       TraceLineX( "OI ID = ", (zLONG) lpViewOI );

	mov	ecx, DWORD PTR _lpViewOI$9050[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@ ; `string'
	call	_TraceLineX@8

; 4886 : 
; 4887 :       if ( lpCandidateViewEntity )

	cmp	DWORD PTR _lpCandidateViewEntity$[ebp], 0
	je	SHORT $L9082

; 4889 :          zsprintf( szMsg, "%s.%s", lpCandidateViewOD->szName,
; 4890 :                    lpCandidateViewEntity->szName );

	mov	edx, DWORD PTR _lpCandidateViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpCandidateViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_05OGKG@?$CFs?4?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szMsg$9048[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4891 :          TraceLineS( "OD.Entity with create authority = ", szMsg );

	lea	edx, DWORD PTR _szMsg$9048[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CD@MNFM@OD?4Entity?5with?5create?5authority?5@ ; `string'
	call	_TraceLineS@8

; 4892 :          TraceLineX( "OI ID = ", (zLONG) lpCandidateViewOI );

	mov	eax, DWORD PTR _lpCandidateViewOI$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@ ; `string'
	call	_TraceLineX@8
$L9082:

; 4894 : 
; 4895 :       TraceLineS( "", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	call	_TraceLineS@8

; 4896 :       CreateViewFromViewForTask( &lpView, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$9049[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpView$9049[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 4897 :       fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$9049[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 4898 :       DisplayEntityInstancePath( lpView, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$9049[ebp]
	push	eax
	call	_DisplayEntityInstancePath@8

; 4899 :       zsprintf( szMsg, "Warning: Trying to commit an entity that "
; 4900 :                 "has been %s but does not have %s "
; 4901 :                 "authority in the current cluster.  OD.EntityName = %s.%s. "
; 4902 :                 "See trace for more information.",
; 4903 :                 bCheckCreate ? "created" : "deleted",
; 4904 :                 bCheckCreate ? "create" : "delete",
; 4905 :                 lpViewOD->szName, lpViewEntity->szName );

	mov	ecx, DWORD PTR _bCheckCreate$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L12772
	mov	DWORD PTR -1064+[ebp], OFFSET FLAT:??_C@_06EOKH@create?$AA@ ; `string'
	jmp	SHORT $L12773
$L12772:
	mov	DWORD PTR -1064+[ebp], OFFSET FLAT:??_C@_06IDPA@delete?$AA@ ; `string'
$L12773:
	mov	edx, DWORD PTR _bCheckCreate$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L12774
	mov	DWORD PTR -1068+[ebp], OFFSET FLAT:??_C@_07JPDC@created?$AA@ ; `string'
	jmp	SHORT $L12775
$L12774:
	mov	DWORD PTR -1068+[ebp], OFFSET FLAT:??_C@_07NAPP@deleted?$AA@ ; `string'
$L12775:
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$9052[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR -1064+[ebp]
	push	edx
	mov	eax, DWORD PTR -1068+[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0KE@LDAH@Warning?3?5Trying?5to?5commit?5an?5ent@ ; `string'
	lea	ecx, DWORD PTR _szMsg$9048[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 4906 :       SysDiagnosticMessage( lpView, szlOE_SystemError, szMsg, 1 );

	push	1
	lea	edx, DWORD PTR _szMsg$9048[ebp]
	push	edx
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpView$9049[ebp]
	push	ecx
	call	_SysDiagnosticMessage@16

; 4907 :       TraceLineS( "-------------------", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BE@DMJL@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AA@ ; `string'
	call	_TraceLineS@8

; 4908 :       fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$9049[ebp]
	push	edx
	call	_fnDropView@4
$L9047:

; 4910 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnCheckCreateDeleteFlags@24 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@PLOF@Infinite?5loop?5trying?5to?5set?5FKs?$DP@ ; `string'
PUBLIC	_fnInitializeGenKeys@28
PUBLIC	??_C@_0CC@KCFL@No?5GenKey?5handler?5set?5for?5LOD?3?5?$CF@ ; `string'
PUBLIC	??_C@_0CD@FKJO@OIs?5have?5different?5GenKey?5handle@ ; `string'
PUBLIC	??_C@_08HFJA@KZGKHWOB?$AA@			; `string'
PUBLIC	??_C@_09JOKA@_KZGKHWOB?$AA@			; `string'
PUBLIC	??_C@_08OHJM@EntityID?$AA@			; `string'
PUBLIC	??_C@_06JEOF@Genkey?$AA@			; `string'
PUBLIC	??_C@_0M@KMCA@EntityCount?$AA@			; `string'
PUBLIC	??_C@_09JMBN@TableName?$AA@			; `string'
EXTRN	_AddToAttributeFromInteger@16:NEAR
EXTRN	_SetCursorFirstEntityByInteger@20:NEAR
;	COMDAT ??_C@_0CC@KCFL@No?5GenKey?5handler?5set?5for?5LOD?3?5?$CF@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CC@KCFL@No?5GenKey?5handler?5set?5for?5LOD?3?5?$CF@ DB 'No GenKey '
	DB	'handler set for LOD: %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@FKJO@OIs?5have?5different?5GenKey?5handle@
_DATA	SEGMENT
??_C@_0CD@FKJO@OIs?5have?5different?5GenKey?5handle@ DB 'OIs have differe'
	DB	'nt GenKey handlers', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08HFJA@KZGKHWOB?$AA@
_DATA	SEGMENT
??_C@_08HFJA@KZGKHWOB?$AA@ DB 'KZGKHWOB', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JOKA@_KZGKHWOB?$AA@
_DATA	SEGMENT
??_C@_09JOKA@_KZGKHWOB?$AA@ DB '_KZGKHWOB', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08OHJM@EntityID?$AA@
_DATA	SEGMENT
??_C@_08OHJM@EntityID?$AA@ DB 'EntityID', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JEOF@Genkey?$AA@
_DATA	SEGMENT
??_C@_06JEOF@Genkey?$AA@ DB 'Genkey', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@KMCA@EntityCount?$AA@
_DATA	SEGMENT
??_C@_0M@KMCA@EntityCount?$AA@ DB 'EntityCount', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JMBN@TableName?$AA@
_DATA	SEGMENT
??_C@_09JMBN@TableName?$AA@ DB 'TableName', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@PLOF@Infinite?5loop?5trying?5to?5set?5FKs?$DP@
_DATA	SEGMENT
??_C@_0CB@PLOF@Infinite?5loop?5trying?5to?5set?5FKs?$DP@ DB 'Infinite loo'
	DB	'p trying to set FKs?', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpViewEntity$9216 = -356
_lpViewAttrib$9217 = -360
_pDummy$9218 = -348
_uLth$9219 = -352
_lpViewEntity$9245 = -364
_lpViewArray$ = 8
_nViewCount$ = 12
_lpCurrentTask$ = 20
_lpKZGKHWOB$ = 24
_ppGKOper$ = 28
_pViewArrayBlock$ = 32
_hGKHandler$ = -32
_lpViewOI_Array$ = -52
_lpViewOD_Array$ = -56
_lpLastInsertedViewEntity$ = -4
_lpEntityInstance$ = -16
_hTask$ = -36
_vSubtask$ = -48
_bHiddenOnly$ = -24
_bSettingFKs$ = -44
_bGenkeyNeededArray$ = -8
_bFK_NeededArray$ = -20
_nDebugCnt$ = -28
_k$ = -40
_nRC$ = -12
_lpViewCsr$9120 = -60
_szMsg$9136 = -316
_lpViewEntity$9146 = -328
_lpViewAttrib$9147 = -332
_pDummy$9148 = -320
_uLth$9149 = -324
_lpDataRecord$9189 = -336
_lpLinked$9195 = -340
_lpTask$9204 = -344
_fnInitializeGenKeys@28 PROC NEAR

; 4920 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH

; 4921 :    LPGKHANDLER      hGKHandler = 0;

	mov	DWORD PTR _hGKHandler$[ebp], 0

; 4922 :    LPVIEWOI         *lpViewOI_Array = pViewArrayBlock->pViewOI_Array;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lpViewOI_Array$[ebp], ecx

; 4923 :    LPVIEWOD         *lpViewOD_Array = pViewArrayBlock->pViewOD_Array;

	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpViewOD_Array$[ebp], eax

; 4924 :    LPVIEWENTITY     lpLastInsertedViewEntity = 0;

	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], 0

; 4925 :    LPENTITYINSTANCE lpEntityInstance;
; 4926 :    LPTASK           hTask;
; 4927 :    zVIEW            vSubtask;
; 4928 :    zBOOL            bHiddenOnly;
; 4929 :    zBOOL            bSettingFKs;
; 4930 :    zBOOL            *bGenkeyNeededArray = pViewArrayBlock->pbGenkeyNeededArray;

	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _bGenkeyNeededArray$[ebp], edx

; 4931 :    zBOOL            *bFK_NeededArray = pViewArrayBlock->pbFK_NeededArray;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _bFK_NeededArray$[ebp], ecx

; 4932 :    zSHORT           nDebugCnt;
; 4933 :    zSHORT           k;
; 4934 :    zSHORT           nRC;
; 4935 : 
; 4936 :    // Set up support arrays.
; 4937 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9117
$L9118:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9117:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L9119

; 4939 :       LPVIEWCSR lpViewCsr;
; 4940 : 
; 4941 :       if ( lpViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L9121

; 4942 :          continue;

	jmp	SHORT $L9118
$L9121:

; 4943 : 
; 4944 :       lpViewOD_Array[ k ] = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	movsx	edx, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 4945 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$9120[ebp], eax

; 4946 :       lpViewOI_Array[ k ] = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$9120[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	movsx	edx, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 4947 :    }

	jmp	SHORT $L9118
$L9119:

; 4948 : 
; 4949 :    // We'll use one of the views as a subtask view.
; 4950 :    // vSubtask is just the first valid view in the list.
; 4951 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9125
$L9126:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9125:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L9127

; 4953 :       if ( lpViewArray[ k ] )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L9128

; 4955 :          vSubtask = lpViewArray[ k ];

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _vSubtask$[ebp], eax

; 4956 :          break;

	jmp	SHORT $L9127
$L9128:

; 4958 :    }

	jmp	SHORT $L9126
$L9127:

; 4959 : 
; 4960 :    hTask = vSubtask->hTask;

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _hTask$[ebp], edx

; 4961 : 
; 4962 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9129
$L9130:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9129:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$L9131

; 4964 :       bGenkeyNeededArray[ k ] = FALSE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bGenkeyNeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 4965 :       bFK_NeededArray[ k ] = FALSE;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 4966 : 
; 4967 :       if ( lpViewArray[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $L9132

; 4968 :          continue;

	jmp	SHORT $L9130
$L9132:

; 4969 : 
; 4970 :       // Check to see if the View has genkeys.  If it does then make sure the
; 4971 :       // genkey handler has been loaded.
; 4972 :       if ( lpViewOD_Array[ k ]->bGenkey )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 9
	and	eax, 1
	test	eax, eax
	je	$L9139

; 4974 :          if ( hGKHandler == 0 )

	cmp	DWORD PTR _hGKHandler$[ebp], 0
	jne	SHORT $L9134

; 4976 :             hGKHandler = lpViewOD_Array[ k ]->hGKHandler;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR _hGKHandler$[ebp], ecx

; 4977 : 
; 4978 :             // Make sure that the GKHandler has been set.
; 4979 :             if ( hGKHandler == 0 )

	cmp	DWORD PTR _hGKHandler$[ebp], 0
	jne	SHORT $L9135

; 4981 :                zCHAR    szMsg[ 256 ];
; 4982 : 
; 4983 :                zsprintf( szMsg, "No GenKey handler set for LOD: %s",
; 4984 :                          lpViewOD_Array[ k ]->szName );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewOD_Array$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0CC@KCFL@No?5GenKey?5handler?5set?5for?5LOD?3?5?$CF@ ; `string'
	lea	edx, DWORD PTR _szMsg$9136[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 4985 :                SysMessageBox( vSubtask, szlOE_SystemError, szMsg, 1 );

	push	1
	lea	eax, DWORD PTR _szMsg$9136[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 4986 :                return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9102
$L9135:

; 4989 :          else

	jmp	SHORT $L9139
$L9134:

; 4991 :             // Make sure that all the views have the same GKHandler.
; 4992 :             if ( lpViewOD_Array[ k ]->hGKHandler != hGKHandler )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+212]
	cmp	eax, DWORD PTR _hGKHandler$[ebp]
	je	SHORT $L9139

; 4994 :                SysMessageBox( vSubtask, szlOE_SystemError,
; 4995 :                               "OIs have different GenKey handlers", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CD@FKJO@OIs?5have?5different?5GenKey?5handle@ ; `string'
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 4996 :                return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9102
$L9139:

; 5000 : 
; 5001 :       // Go through entity instance looking for entities that need genkeys.
; 5002 :       // Also check to see if the EI needs to set a foreign key.
; 5003 :       for ( lpEntityInstance = zGETPTR( lpViewOI_Array[ k ]->hRootEntityInstance );
; 5004 :             lpEntityInstance;
; 5005 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9143
$L9144:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9143:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9145

; 5007 :          LPVIEWENTITY lpViewEntity;
; 5008 :          LPVIEWATTRIB lpViewAttrib;
; 5009 :          zPVOID       pDummy;
; 5010 :          zULONG       uLth;
; 5011 : 
; 5012 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$9146[ebp], eax

; 5013 : 
; 5014 :          // Entities on a derived path don't get a genkey or a foreign key.
; 5015 :          if ( lpViewEntity->bDerivedPath )

	mov	edx, DWORD PTR _lpViewEntity$9146[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9151
$L9153:

; 5017 :             // If an EI is down a derived path then all children are also a
; 5018 :             // derived path.  We can try to save a little time by ignoring
; 5019 :             // all the children.
; 5020 :             while ( lpEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $L9154

; 5021 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9153
$L9154:

; 5022 : 
; 5023 :             continue;

	jmp	SHORT $L9144
$L9151:

; 5025 : 
; 5026 :          // Check to see if the EI needs to set some foreign keys.
; 5027 :          // NOTE!
; 5028 :          // NOTE! The logic here matches the logic that is in
; 5029 :          // NOTE! fnCommitPreLoops( ). Any changes here should be reflected
; 5030 :          // NOTE! there.
; 5031 :          // NOTE!
; 5032 :          if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	$L9156

; 5034 :             // DGC 99.07.02
; 5035 :             // If the EI is flagged as created and the entity doesn't have
; 5036 :             // create authority then make sure that there is a linked EI in
; 5037 :             // the current cluster that does have create authority.
; 5038 :             if ( lpEntityInstance->u.nInd.bCreated &&
; 5039 :                  lpViewEntity->bCreate == FALSE &&
; 5040 :                  lpViewEntity->bDupInstance == FALSE ) //BL, 2000.01.04 Bugfix Repository

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9157
	mov	edx, DWORD PTR _lpViewEntity$9146[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9157
	mov	ecx, DWORD PTR _lpViewEntity$9146[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 25					; 00000019H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9157

; 5042 :                fnCheckCreateDeleteFlags( lpEntityInstance, lpViewArray,
; 5043 :                                          lpViewOD_Array, lpViewOI_Array,
; 5044 :                                          nViewCount, TRUE );

	push	1
	mov	ax, WORD PTR _nViewCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI_Array$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD_Array$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnCheckCreateDeleteFlags@24
$L9157:

; 5046 : 
; 5047 :             if ( lpEntityInstance->u.nInd.bCreated
; 5048 : #if ( VIEWENT_RULES )
; 5049 :                   && lpViewEntity->bCreate
; 5050 : #endif
; 5051 :                )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $L9158
	mov	ecx, DWORD PTR _lpViewEntity$9146[ebp]
	mov	edx, DWORD PTR [ecx+235]
	and	edx, 1
	test	edx, edx
	je	SHORT $L9158

; 5053 :                // Foreign keys need to be set later.
; 5054 :                bFK_NeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5055 :                lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5057 :             else

	jmp	SHORT $L9160
$L9158:

; 5059 :                if ( lpEntityInstance->u.nInd.bIncluded &&
; 5060 :                     lpEntityInstance->hParent          &&
; 5061 : #if ( VIEWENT_RULES )
; 5062 :                     lpViewEntity->bInclude &&
; 5063 : #endif
; 5064 :                     ( lpEntityInstance->u.nInd.bCreated == FALSE
; 5065 : #if ( VIEWENT_RULES )
; 5066 :                       || lpViewEntity->bCreate == FALSE
; 5067 : #endif
; 5068 :                   ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	je	SHORT $L9160
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $L9160
	mov	edx, DWORD PTR _lpViewEntity$9146[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L9160
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	je	SHORT $L9161
	mov	eax, DWORD PTR _lpViewEntity$9146[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9160
$L9161:

; 5070 :                   // Foreign keys need to be set later.
; 5071 :                   bFK_NeededArray[ k ] = TRUE;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [eax+edx], 1

; 5072 :                   lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 4194304				; 00400000H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$L9160:

; 5076 :          else

	jmp	$L9166
$L9156:

; 5078 :             if ( lpEntityInstance->u.nInd.bCreated == FALSE &&
; 5079 :                  lpEntityInstance->u.nInd.bIncluded == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	jne	$L9166
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	jne	$L9166

; 5081 :                if ( lpEntityInstance->u.nInd.bExcluded
; 5082 : #if ( VIEWENT_RULES )
; 5083 :                     && lpViewEntity->bExclude
; 5084 : #endif
; 5085 :                   )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	SHORT $L9164
	mov	ecx, DWORD PTR _lpViewEntity$9146[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L9164

; 5087 :                   bFK_NeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5088 :                   lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5090 :                else

	jmp	SHORT $L9166
$L9164:

; 5091 :                if ( lpEntityInstance->u.nInd.bDeleted
; 5092 : #if ( VIEWENT_RULES )
; 5093 :                     && lpViewEntity->bDelete
; 5094 : #endif
; 5095 :                   )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L9166
	mov	ecx, DWORD PTR _lpViewEntity$9146[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	je	SHORT $L9166

; 5097 :                   bFK_NeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5098 :                   lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9166:

; 5102 : 
; 5103 :          // At this point we've determined whether an EI needs an FK.  From
; 5104 :          // this point on we're only worried about genkeys.
; 5105 : 
; 5106 :          // If NoGenKey flag is set then we already created a genkey for
; 5107 :          // another linked instance.
; 5108 :          if ( lpEntityInstance->u.nInd.bNoGenKey )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 21					; 00000015H
	and	eax, 1
	test	eax, eax
	je	SHORT $L9167

; 5109 :             continue;

	jmp	$L9144
$L9167:

; 5110 : 
; 5111 :          // We only create genkeys for EIs that were created.  If it's
; 5112 :          // created make sure it's not also deleted.
; 5113 :          if ( lpEntityInstance->u.nInd.bCreated == FALSE ||
; 5114 :               lpEntityInstance->u.nInd.bDeleted )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	je	SHORT $L9169
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9168
$L9169:

; 5116 :             continue;

	jmp	$L9144
$L9168:

; 5118 : 
; 5119 : #if ( VIEWENT_RULES )
; 5120 :          if ( lpViewEntity->bCreate == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$9146[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9170

; 5121 :             continue;

	jmp	$L9144
$L9170:

; 5122 : #endif
; 5123 : 
; 5124 :          if ( lpViewEntity->bGenkey == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$9146[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9171

; 5125 :             continue;

	jmp	$L9144
$L9171:

; 5126 : 
; 5127 :          // Check to see if the attribute is NULL.  If it is not then
; 5128 :          // we'll ignore it.
; 5129 :          for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 5130 :                lpViewAttrib->bGenkey == FALSE;
; 5131 :                lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$9146[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9147[ebp], eax
	jmp	SHORT $L9174
$L9175:
	mov	edx, DWORD PTR _lpViewAttrib$9147[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9147[ebp], eax
$L9174:
	mov	ecx, DWORD PTR _lpViewAttrib$9147[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9176

; 5133 :             ; // nothing needs to be done here
; 5134 :          }

	jmp	SHORT $L9175
$L9176:

; 5135 : 
; 5136 :          if ( fnGetAttrAddrFromEntityInstance( (zCOREMEM) &pDummy,
; 5137 :                                                &uLth, lpEntityInstance,
; 5138 :                                                lpViewAttrib ) != -1 )

	mov	eax, DWORD PTR _lpViewAttrib$9147[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _uLth$9149[ebp]
	push	edx
	lea	eax, DWORD PTR _pDummy$9148[ebp]
	push	eax
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $L9178

; 5140 :             continue;   // Attrib is not null so ignore it.

	jmp	$L9144
$L9178:

; 5142 : 
; 5143 :          // If genkey work object hasn't been activated, then activate it.
; 5144 :          if ( *lpKZGKHWOB == 0 )

	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L9179

; 5146 :             SfActivateSysEmptyOI( lpKZGKHWOB, "KZGKHWOB", vSubtask, zSINGLE );

	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08HFJA@KZGKHWOB?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16

; 5147 :             CreateEntity( *lpKZGKHWOB, "KZGKHWOB", zPOS_FIRST );

	push	1
	push	OFFSET FLAT:??_C@_08HFJA@KZGKHWOB?$AA@	; `string'
	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_CreateEntity@12

; 5148 :             SetNameForView( *lpKZGKHWOB, "_KZGKHWOB", 0, zLEVEL_TASK );

	push	2
	push	0
	push	OFFSET FLAT:??_C@_09JOKA@_KZGKHWOB?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetNameForView@16
$L9179:

; 5150 : 
; 5151 :          // lpKZGKHWOB is a work object that contains an entity for each
; 5152 :          // entity instance in the OI being committed and the number of
; 5153 :          // entity instances that need genkeys.
; 5154 :          //
; 5155 :          // If the lpViewEntity of the current entity instance is the same
; 5156 :          // as the previous entity instance, then increment the count in
; 5157 :          // lpKZGKHWOB by 1.  If they are different, then we need to find
; 5158 :          // the entity instance in lpKZGKHWOB that corresponds with the
; 5159 :          // current lpEntityInstance.  If one is not found, then it needs
; 5160 :          // to be created.
; 5161 :          if ( lpViewEntity != lpLastInsertedViewEntity )

	mov	eax, DWORD PTR _lpViewEntity$9146[ebp]
	cmp	eax, DWORD PTR _lpLastInsertedViewEntity$[ebp]
	je	$L9183

; 5163 :             // lpViewEntity for current lpEntityInstance does not match
; 5164 :             // last lpEntityInstance.  Try to find the entity in lpKZGKHWOB
; 5165 :             // that corresponds with the lpViewEntity.
; 5166 :             nRC = SetCursorFirstEntityByInteger( *lpKZGKHWOB, "Genkey",
; 5167 :                                                  "EntityID",
; 5168 :                                                  lpViewEntity->lEREntTok, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _lpViewEntity$9146[ebp]
	mov	edx, DWORD PTR [ecx+195]
	push	edx
	push	OFFSET FLAT:??_C@_08OHJM@EntityID?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SetCursorFirstEntityByInteger@20
	mov	WORD PTR _nRC$[ebp], ax

; 5169 :             if ( nRC == zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $L9186

; 5171 :                // Entity was found--increment genkey count by 1.
; 5172 :                AddToAttributeFromInteger( *lpKZGKHWOB, "Genkey",
; 5173 :                                           "EntityCount", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0M@KMCA@EntityCount?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_AddToAttributeFromInteger@16

; 5175 :             else

	jmp	$L9188
$L9186:

; 5177 :                LPDATARECORD lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$9146[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$9189[ebp], eax

; 5178 : 
; 5179 :                // Entity not found--create entity and initialize.
; 5180 :                CreateEntity( *lpKZGKHWOB, "Genkey", zPOS_FIRST );

	push	1
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_CreateEntity@12

; 5181 :                SetAttributeFromInteger( *lpKZGKHWOB, "Genkey",
; 5182 :                                         "EntityID", lpViewEntity->lEREntTok );

	mov	eax, DWORD PTR _lpViewEntity$9146[ebp]
	mov	ecx, DWORD PTR [eax+195]
	push	ecx
	push	OFFSET FLAT:??_C@_08OHJM@EntityID?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SetAttributeFromInteger@16

; 5183 :                SetAttributeFromInteger( *lpKZGKHWOB, "Genkey",
; 5184 :                                         "EntityCount", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0M@KMCA@EntityCount?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetAttributeFromInteger@16

; 5185 :                SetAttributeFromString( *lpKZGKHWOB, "Genkey",
; 5186 :                                        "TableName", lpDataRecord->szRecordName );

	mov	eax, DWORD PTR _lpDataRecord$9189[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET FLAT:??_C@_09JMBN@TableName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetAttributeFromString@16

; 5187 :                SetAttributeFromString( *lpKZGKHWOB, "Genkey",
; 5188 :                                        "EntityName", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$9146[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetAttributeFromString@16
$L9188:

; 5190 : 
; 5191 :             lpLastInsertedViewEntity = lpViewEntity;

	mov	eax, DWORD PTR _lpViewEntity$9146[ebp]
	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], eax

; 5193 :          else

	jmp	SHORT $L9193
$L9183:

; 5194 :             AddToAttributeFromInteger( *lpKZGKHWOB, "Genkey", "EntityCount", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0M@KMCA@EntityCount?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_AddToAttributeFromInteger@16
$L9193:

; 5195 : 
; 5196 :          bGenkeyNeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bGenkeyNeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5197 :          lpEntityInstance->u.nInd.bGenKeyNeeded = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 1048576				; 00100000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5198 : 
; 5199 :          // Set a flag for all linked instances to keep another genkey from
; 5200 :          // being created.
; 5201 :          if ( lpEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $L9200

; 5203 :             LPENTITYINSTANCE lpLinked;
; 5204 : 
; 5205 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 5206 :                   lpLinked != lpEntityInstance;
; 5207 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9195[ebp], eax
	jmp	SHORT $L9198
$L9199:
	mov	edx, DWORD PTR _lpLinked$9195[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9195[ebp], eax
$L9198:
	mov	ecx, DWORD PTR _lpLinked$9195[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9200

; 5209 :                lpLinked->u.nInd.bNoGenKey = TRUE;

	mov	edx, DWORD PTR _lpLinked$9195[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 2097152				; 00200000H
	mov	ecx, DWORD PTR _lpLinked$9195[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5210 :             }

	jmp	SHORT $L9199
$L9200:

; 5212 : 
; 5213 :       } // for ( lpEntityInstance )...

	jmp	$L9144
$L9145:

; 5214 :    } // for ( k = 0; k < nViewCount; k++ )

	jmp	$L9130
$L9131:

; 5215 : 
; 5216 :    // If the Genkey handler work object has been defined, then call the
; 5217 :    // genkey handler to start transactions.
; 5218 :    if ( *lpKZGKHWOB )

	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$L9209

; 5220 :       if ( fnGetGKHandlerOper( *lpKZGKHWOB, lpCurrentTask, hGKHandler,
; 5221 :                                (zlpPGKHOPER) ppGKOper ) == zCALL_ERROR )

	mov	eax, DWORD PTR _ppGKOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hGKHandler$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fnGetGKHandlerOper
	add	esp, 16					; 00000010H
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $L9203

; 5223 :          LPTASK lpTask = zGETPTR( vSubtask->hTask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$9204[ebp], eax

; 5224 :          // "KZOEE082 - Error starting Genkey handler"
; 5225 :          fnIssueCoreError( lpTask, vSubtask, 16, 82, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	82					; 00000052H
	push	16					; 00000010H
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$9204[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5226 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9102
$L9203:

; 5228 : 
; 5229 :       // Call DBHandler routine to issue start of transaction.
; 5230 :       nRC = (**ppGKOper)( DBH_StartGenkey, vSubtask, 0, 0, *lpKZGKHWOB );

	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	64					; 00000040H
	mov	ecx, DWORD PTR _ppGKOper$[ebp]
	call	DWORD PTR [ecx]
	mov	WORD PTR _nRC$[ebp], ax

; 5231 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9206

; 5232 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L9102
$L9206:

; 5233 : 
; 5234 :       // Now set the gen keys.
; 5235 :       lpLastInsertedViewEntity = 0;

	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], 0

; 5236 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9207
$L9208:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9207:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$L9209

; 5238 :          // If we didn't find any genkeys for this view then skip it.
; 5239 :          if ( bGenkeyNeededArray[ k ] == FALSE )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bGenkeyNeededArray$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $L9210

; 5240 :             continue;

	jmp	SHORT $L9208
$L9210:

; 5241 : 
; 5242 :          // Go through entity instance looking for entities that need genkeys.
; 5243 :          for ( lpEntityInstance = zGETPTR( lpViewOI_Array[ k ]->hRootEntityInstance );
; 5244 :                lpEntityInstance;
; 5245 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9213
$L9214:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9213:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9215

; 5247 :             LPVIEWENTITY lpViewEntity;
; 5248 :             LPVIEWATTRIB lpViewAttrib;
; 5249 :             zPVOID       pDummy;
; 5250 :             zULONG       uLth;
; 5251 : 
; 5252 :             // Look for an EI that needs a genkey.
; 5253 :             if ( lpEntityInstance->u.nInd.bGenKeyNeeded == FALSE )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 20					; 00000014H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9220

; 5254 :                continue;

	jmp	SHORT $L9214
$L9220:

; 5255 : 
; 5256 :             lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$9216[ebp], eax

; 5257 : 
; 5258 :             // Check to see if the attribute is NULL.  If it is not then
; 5259 :             // we'll ignore it.
; 5260 :             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 5261 :                   lpViewAttrib->bGenkey == FALSE;
; 5262 :                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$9216[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9217[ebp], eax
	jmp	SHORT $L9224
$L9225:
	mov	eax, DWORD PTR _lpViewAttrib$9217[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9217[ebp], eax
$L9224:
	mov	edx, DWORD PTR _lpViewAttrib$9217[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9226

; 5264 :                ; // nothing needs to be done here
; 5265 :             }

	jmp	SHORT $L9225
$L9226:

; 5266 : 
; 5267 :             if ( fnGetAttrAddrFromEntityInstance( (zCOREMEM) &pDummy,
; 5268 :                                                   &uLth, lpEntityInstance,
; 5269 :                                                   lpViewAttrib ) != -1 )

	mov	ecx, DWORD PTR _lpViewAttrib$9217[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	lea	eax, DWORD PTR _uLth$9219[ebp]
	push	eax
	lea	ecx, DWORD PTR _pDummy$9218[ebp]
	push	ecx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	movsx	edx, ax
	cmp	edx, -1
	je	SHORT $L9228

; 5271 :                continue;   // attrib is not null so ignore it

	jmp	$L9214
$L9228:

; 5273 : 
; 5274 :             if ( lpViewEntity != lpLastInsertedViewEntity )

	mov	eax, DWORD PTR _lpViewEntity$9216[ebp]
	cmp	eax, DWORD PTR _lpLastInsertedViewEntity$[ebp]
	je	SHORT $L9229

; 5276 :                // lpViewEntity for current lpEntityInstance does not match
; 5277 :                // last lpEntityInstance.  Try to find the entity in lpKZGKHWOB
; 5278 :                // that corresponds with the lpViewEntity.
; 5279 :                nRC = SetCursorFirstEntityByInteger( *lpKZGKHWOB, "Genkey",
; 5280 :                                                     "EntityID",
; 5281 :                                                     lpViewEntity->lEREntTok, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _lpViewEntity$9216[ebp]
	mov	edx, DWORD PTR [ecx+195]
	push	edx
	push	OFFSET FLAT:??_C@_08OHJM@EntityID?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SetCursorFirstEntityByInteger@20
	mov	WORD PTR _nRC$[ebp], ax

; 5282 : 
; 5283 :                lpLastInsertedViewEntity = lpViewEntity;

	mov	edx, DWORD PTR _lpViewEntity$9216[ebp]
	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], edx
$L9229:

; 5285 : 
; 5286 :             fnEstablishViewForInstance( lpViewArray[ k ], 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 5287 : 
; 5288 :             // Tell genkey handler to set attribute value.
; 5289 :             nRC = (**ppGKOper)( DBH_GetGenkey, lpViewArray[ k ],
; 5290 :                                 lpViewOD_Array[ k ],
; 5291 :                                 lpViewEntity, *lpKZGKHWOB );

	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$9216[ebp]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	128					; 00000080H
	mov	ecx, DWORD PTR _ppGKOper$[ebp]
	call	DWORD PTR [ecx]
	mov	WORD PTR _nRC$[ebp], ax

; 5292 :             if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9230

; 5293 :                return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9102
$L9230:

; 5294 : 
; 5295 :          } // for ( lpEntityInstance )...

	jmp	$L9214
$L9215:

; 5296 : 
; 5297 :       } // for ( k = 0; k < nViewCount; k++ )

	jmp	$L9208
$L9209:

; 5300 : 
; 5301 :    //
; 5302 :    // Now copy FKs.  We have to loop possibly many times to set the FKs.  It's
; 5303 :    // possible that the source for a FK is a FK from yet another EI.  We don't
; 5304 :    // want to copy a FK until we know that the source for a FK has been
; 5305 :    // properly set.  We also want to make sure we set the FK's for the EIs that
; 5306 :    // have been excluded/deleted before we copy FKs for the included/created.
; 5307 :    //
; 5308 :    bHiddenOnly = TRUE;  // We'll start by setting FKs for hidden EIs only.

	mov	BYTE PTR _bHiddenOnly$[ebp], 1

; 5309 :    nDebugCnt   = 0;     // We'll keep a counter in case we get an infinite loop.

	mov	WORD PTR _nDebugCnt$[ebp], 0

; 5310 :    bSettingFKs = TRUE;

	mov	BYTE PTR _bSettingFKs$[ebp], 1
$L9232:

; 5311 :    while ( bSettingFKs )

	mov	eax, DWORD PTR _bSettingFKs$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L9233

; 5313 :       // We'll hope that we're done setting FKs after this iteration.  If we
; 5314 :       // find we need to set more FKs then we'll turn it back on.
; 5315 :       bSettingFKs = FALSE;

	mov	BYTE PTR _bSettingFKs$[ebp], 0

; 5316 : 
; 5317 :       if ( nDebugCnt++ > 100 )

	movsx	ecx, WORD PTR _nDebugCnt$[ebp]
	mov	dx, WORD PTR _nDebugCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nDebugCnt$[ebp], dx
	cmp	ecx, 100				; 00000064H
	jle	SHORT $L9234

; 5319 :          SysMessageBox( vSubtask, szlOE_SystemError,
; 5320 :                         "Infinite loop trying to set FKs?", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CB@PLOF@Infinite?5loop?5trying?5to?5set?5FKs?$DP@ ; `string'
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 5321 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9102
$L9234:

; 5323 : 
; 5324 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9236
$L9237:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9236:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$L9238

; 5326 :          // If we didn't find any FKs for this view then skip it.
; 5327 :          if ( bFK_NeededArray[ k ] == FALSE )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $L9239

; 5328 :             continue;

	jmp	SHORT $L9237
$L9239:

; 5329 : 
; 5330 :          // Let's hope that this view doesn't need FKs set after this
; 5331 :          // iteration.  If it does then we'll turn the flag back on.
; 5332 :          bFK_NeededArray[ k ] = FALSE;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 5333 : 
; 5334 :          // Go through entity instance looking for entities that need genkeys.
; 5335 :          // Also check to see if the EI needs to set a foreign key.
; 5336 :          for ( lpEntityInstance = zGETPTR( lpViewOI_Array[ k ]->hRootEntityInstance );
; 5337 :                lpEntityInstance;
; 5338 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9242
$L9243:
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9242:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9244

; 5340 :             LPVIEWENTITY lpViewEntity;
; 5341 : 
; 5342 :             // If the EI isn't flagged as needing a FK then skip it.
; 5343 :             if ( lpEntityInstance->u.nInd.bForeignKeys == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 22					; 00000016H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9246

; 5344 :                continue;

	jmp	SHORT $L9243
$L9246:

; 5345 : 
; 5346 :             // Entities on a derived path don't get a FK set..
; 5347 :             lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$9245[ebp], eax

; 5348 :             if ( lpViewEntity->bDerivedPath )

	mov	edx, DWORD PTR _lpViewEntity$9245[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9248
$L9250:

; 5350 :                // If an EI is down a derived path then all children are also a
; 5351 :                // derived path.  We can try to save a little time by ignoring
; 5352 :                // all the children.
; 5353 :                while ( lpEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $L9251

; 5354 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9250
$L9251:

; 5355 : 
; 5356 :                continue;

	jmp	SHORT $L9243
$L9248:

; 5358 : 
; 5359 :             // If the EI is not hidden and we're setting FKs for hidden EIs
; 5360 :             // only then set flags for another try.
; 5361 :             if ( lpEntityInstance->u.nInd.bHidden == FALSE && bHiddenOnly )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9253
	mov	eax, DWORD PTR _bHiddenOnly$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L9253

; 5363 :                bFK_NeededArray[ k ] = TRUE;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [edx+ecx], 1

; 5364 :                bSettingFKs = TRUE;

	mov	BYTE PTR _bSettingFKs$[ebp], 1

; 5365 :                continue;

	jmp	$L9243
$L9253:

; 5367 : 
; 5368 :             // Call a function to set the FK.  If the return code is 1 then
; 5369 :             // we couldn't set the FK because a source value hasn't been set
; 5370 :             // yet and we'll have to try again later.
; 5371 :             if ( fnSetForeignKeysForInstance( lpEntityInstance ) == 1 )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnSetForeignKeysForInstance@4
	movsx	ecx, ax
	cmp	ecx, 1
	jne	SHORT $L9254

; 5373 :                bFK_NeededArray[ k ] = TRUE;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [eax+edx], 1

; 5374 :                bSettingFKs = TRUE;

	mov	BYTE PTR _bSettingFKs$[ebp], 1
$L9254:

; 5376 : 
; 5377 :          } // for ( lpEntityInstance )...

	jmp	$L9243
$L9244:

; 5378 : 
; 5379 :       } // for ( k = 0; k < nViewCount; k++ )

	jmp	$L9237
$L9238:

; 5380 : 
; 5381 :       // After one iteration we can set non-hidden FKs.
; 5382 :       bHiddenOnly = FALSE;

	mov	BYTE PTR _bHiddenOnly$[ebp], 0

; 5383 : 
; 5384 :    } // while ( bSettingFKs )...

	jmp	$L9232
$L9233:

; 5385 : 
; 5386 :    return( 0 );

	xor	ax, ax
$L9102:

; 5387 : 
; 5388 : } // fnInitializeGenKeys

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_fnInitializeGenKeys@28 ENDP
_TEXT	ENDS
PUBLIC	_fnMarkDuplicateRelationship@8
_TEXT	SEGMENT
_lpEntityInstance$ = 8
_bIncludeFlag$ = 12
_lpViewOI$ = -20
_lpViewEntity$ = -8
_lpLnkViewEntity$ = -16
_lpParent$ = -4
_lpLnkParent$ = -12
_lpLnkEntityInstance$ = -24
_lpWrkEntityInstance$9278 = -28
_lpGrandParent$9304 = -32
_fnMarkDuplicateRelationship@8 PROC NEAR

; 5396 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 5397 :    LPVIEWOI         lpViewOI;
; 5398 :    LPVIEWENTITY     lpViewEntity;
; 5399 :    LPVIEWENTITY     lpLnkViewEntity;
; 5400 :    LPENTITYINSTANCE lpParent;
; 5401 :    LPENTITYINSTANCE lpLnkParent;
; 5402 :    LPENTITYINSTANCE lpLnkEntityInstance;
; 5403 : 
; 5404 :    // Return 0 if instance passed is not linked
; 5405 :    if ( lpEntityInstance->hNextLinked == 0 )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	jne	SHORT $L9267

; 5406 :       return( 0 );

	xor	ax, ax
	jmp	$L9260
$L9267:

; 5407 : 
; 5408 :    // Get Object instance for entity instance
; 5409 :    lpViewOI     = zGETPTR( lpEntityInstance->hViewOI );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 5410 :    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5411 :    lpParent     = zGETPTR( lpEntityInstance->hParent );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$[ebp], eax

; 5412 : 
; 5413 :    // If the parent isn't linked then there are no duplicate relationships.
; 5414 :    if ( lpParent == 0 || lpParent->hNextLinked == 0 )

	cmp	DWORD PTR _lpParent$[ebp], 0
	je	SHORT $L9272
	mov	ecx, DWORD PTR _lpParent$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $L9271
$L9272:

; 5415 :       return( 0 );

	xor	ax, ax
	jmp	$L9260
$L9271:

; 5416 : 
; 5417 :    // Duplicate relationship searching phase I, see if a linked instance to
; 5418 :    // the target instance in the same object instance represents the
; 5419 :    // same relationship type AND has the same parent
; 5420 :    for ( lpLnkEntityInstance = zGETPTR( lpEntityInstance->hNextLinked );
; 5421 :          lpLnkEntityInstance != lpEntityInstance;
; 5422 :          lpLnkEntityInstance = zGETPTR( lpLnkEntityInstance->hNextLinked ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
	jmp	SHORT $L9275
$L9276:
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
$L9275:
	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	$L9277

; 5424 :       LPENTITYINSTANCE lpWrkEntityInstance;
; 5425 : 
; 5426 :       // Check to make sure linked EI has a parent--it is possible for a root
; 5427 :       // to be flagged as included and we don't care about roots.
; 5428 :       if ( lpLnkEntityInstance->u.nInd.bDeleted  ||
; 5429 :            lpLnkEntityInstance->hParent == 0 )

	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9280
	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	DWORD PTR [eax+30], 0
	jne	SHORT $L9279
$L9280:

; 5431 :          continue;

	jmp	SHORT $L9276
$L9279:

; 5433 : 
; 5434 :       // Check for appropriate include/exclude flag.
; 5435 :       if ( bIncludeFlag )

	mov	ecx, DWORD PTR _bIncludeFlag$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9281

; 5437 :          if ( lpLnkEntityInstance->u.nInd.bIncluded == FALSE ||
; 5438 :               lpLnkEntityInstance->u.nInd.bExcluded )

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	je	SHORT $L9283
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L9282
$L9283:

; 5440 :             continue;

	jmp	SHORT $L9276
$L9282:

; 5443 :       else

	jmp	SHORT $L9285
$L9281:

; 5445 :          if ( lpLnkEntityInstance->u.nInd.bIncluded ||
; 5446 :               lpLnkEntityInstance->u.nInd.bExcluded == FALSE )

	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9286
	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9285
$L9286:

; 5448 :             continue;

	jmp	$L9276
$L9285:

; 5451 : 
; 5452 :       lpLnkViewEntity = zGETPTR( lpLnkEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkViewEntity$[ebp], eax

; 5453 : 
; 5454 :       // Linked EI must have the same relationship and it can't be derived.
; 5455 :       if ( lpLnkViewEntity->lERRelTok != lpViewEntity->lERRelTok ||
; 5456 :            lpLnkViewEntity->bDerivedPath )

	mov	eax, DWORD PTR _lpLnkViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	jne	SHORT $L9289
	mov	eax, DWORD PTR _lpLnkViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9288
$L9289:

; 5458 :          continue;

	jmp	$L9276
$L9288:

; 5460 : 
; 5461 :       // Now check to see if the parent of the linked EI is linked to the
; 5462 :       // parent of the original EI.  If it is then the linked EI and the
; 5463 :       // original EI have the same relationship.
; 5464 : 
; 5465 :       lpLnkParent = zGETPTR( lpLnkEntityInstance->hParent );

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkParent$[ebp], eax

; 5466 : 
; 5467 :       for ( lpWrkEntityInstance = zGETPTR( lpLnkParent->hNextLinked );
; 5468 :             lpWrkEntityInstance && lpWrkEntityInstance != lpLnkParent;
; 5469 :             lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hNextLinked ) )

	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$9278[ebp], eax
	jmp	SHORT $L9293
$L9294:
	mov	eax, DWORD PTR _lpWrkEntityInstance$9278[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$9278[ebp], eax
$L9293:
	cmp	DWORD PTR _lpWrkEntityInstance$9278[ebp], 0
	je	SHORT $L9295
	mov	edx, DWORD PTR _lpWrkEntityInstance$9278[ebp]
	cmp	edx, DWORD PTR _lpLnkParent$[ebp]
	je	SHORT $L9295

; 5471 :          if ( lpWrkEntityInstance == lpParent )

	mov	eax, DWORD PTR _lpWrkEntityInstance$9278[ebp]
	cmp	eax, DWORD PTR _lpParent$[ebp]
	jne	SHORT $L9296

; 5473 :             // The parents of the two linked EIs are also linked.  Set flag
; 5474 :             // and break loop.
; 5475 :             if ( bIncludeFlag )

	mov	ecx, DWORD PTR _bIncludeFlag$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9297

; 5476 :                lpLnkEntityInstance->u.nInd.bDBHIncluded = TRUE;

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, -128				; ffffff80H
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5477 :             else

	jmp	SHORT $L9298
$L9297:

; 5478 :                lpLnkEntityInstance->u.nInd.bDBHExcluded = TRUE;

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9298:

; 5479 : 
; 5480 :             break;

	jmp	SHORT $L9295
$L9296:

; 5482 :       }

	jmp	SHORT $L9294
$L9295:

; 5483 :    }

	jmp	$L9276
$L9277:

; 5484 : 
; 5485 :    // Duplicate relationship searching, phase II, see if the parent of
; 5486 :    // the instance has a linked instance representing the same relationship
; 5487 :    // type which is also a child of one of the targets linked instances.
; 5488 :    // (i.e. the same relationship instance inverted).
; 5489 :    for ( lpLnkParent = zGETPTR( lpParent->hNextLinked );
; 5490 :          lpLnkParent != lpParent;
; 5491 :          lpLnkParent = zGETPTR( lpLnkParent->hNextLinked ) )

	mov	edx, DWORD PTR _lpParent$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkParent$[ebp], eax
	jmp	SHORT $L9301
$L9302:
	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkParent$[ebp], eax
$L9301:
	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	cmp	eax, DWORD PTR _lpParent$[ebp]
	je	$L9303

; 5493 :       LPENTITYINSTANCE lpGrandParent;
; 5494 : 
; 5495 :       // Check for appropriate include/exclude flag.
; 5496 :       if ( bIncludeFlag )

	mov	ecx, DWORD PTR _bIncludeFlag$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9305

; 5498 :          if ( lpLnkParent->u.nInd.bIncluded == FALSE ||
; 5499 :               lpLnkParent->u.nInd.bExcluded )

	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	je	SHORT $L9307
	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L9306
$L9307:

; 5501 :             continue;

	jmp	SHORT $L9302
$L9306:

; 5504 :       else

	jmp	SHORT $L9309
$L9305:

; 5506 :          if ( lpLnkParent->u.nInd.bIncluded || lpLnkParent->u.nInd.bExcluded == FALSE )

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9310
	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9309
$L9310:

; 5507 :             continue;

	jmp	SHORT $L9302
$L9309:

; 5509 : 
; 5510 :       lpLnkViewEntity = zGETPTR( lpLnkParent->hViewEntity );

	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkViewEntity$[ebp], eax

; 5511 : 
; 5512 :       // Check to see if the relationship for the EI linked to the parent is
; 5513 :       // the same as the relationship of the original EI.
; 5514 :       if ( lpLnkViewEntity->lERRelTok != lpViewEntity->lERRelTok )

	mov	eax, DWORD PTR _lpLnkViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	je	SHORT $L9312

; 5515 :          continue;  // Nope.

	jmp	$L9302
$L9312:

; 5516 : 
; 5517 :       // OK, we have an EI (lpLnkParent) that has the same relationship as
; 5518 :       // lpEntityInstance.  Check to see if the parent of lpLnkParent (lpGrandParent)
; 5519 :       // is linked with lpEntityInstance.  If they are linked then lpLnkParent
; 5520 :       // has the same physical relationship as lpEntityInstance.
; 5521 :       lpGrandParent = zGETPTR( lpLnkParent->hParent );

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGrandParent$9304[ebp], eax

; 5522 :       for ( lpLnkEntityInstance = zGETPTR( lpEntityInstance->hNextLinked );
; 5523 :             lpLnkEntityInstance != lpEntityInstance;
; 5524 :             lpLnkEntityInstance = zGETPTR( lpLnkEntityInstance->hNextLinked ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
	jmp	SHORT $L9316
$L9317:
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
$L9316:
	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9318

; 5526 :          if ( lpLnkEntityInstance == lpGrandParent )

	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpGrandParent$9304[ebp]
	jne	SHORT $L9319

; 5528 :             // If we've found an inverted structure in the same
; 5529 :             // object instance which is the same relationship type, set flag.
; 5530 :             if ( bIncludeFlag )

	mov	edx, DWORD PTR _bIncludeFlag$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L9320

; 5531 :                lpLnkParent->u.nInd.bDBHIncluded = TRUE;

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ch, -128				; ffffff80H
	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 5532 :             else

	jmp	SHORT $L9321
$L9320:

; 5533 :                lpLnkParent->u.nInd.bDBHExcluded = TRUE;

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L9321:

; 5534 : 
; 5535 :             break;

	jmp	SHORT $L9318
$L9319:

; 5537 :       }

	jmp	SHORT $L9317
$L9318:

; 5538 :    }

	jmp	$L9302
$L9303:

; 5539 : 
; 5540 :    return( 0 );

	xor	ax, ax
$L9260:

; 5541 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnMarkDuplicateRelationship@8 ENDP
_TEXT	ENDS
PUBLIC	_fnCommitPreLoops
EXTRN	_fnCreateAttributeRecord:NEAR
EXTRN	_fnEntityInstanceIsDead@4:NEAR
EXTRN	_fnGetAttribFlagsPtr@8:NEAR
_TEXT	SEGMENT
_lpView$ = 12
_plpLastEntityInstance$ = 16
_plHiddenCnt$ = 20
_lpViewOD$ = -16
_lpViewOI$ = -36
_lpViewCsr$ = -8
_lpViewEntity$ = -28
_lpLastInsertedViewEntity$ = -4
_lpEntityInstance$ = -24
_lpRootEntityInstance$ = -12
_lpDataRecord$ = -44
_lpViewAttrib$ = -32
_lpRelRecord$ = -40
_nRC$ = -20
_uLth$9357 = -48
_lSeq$9358 = -60
_lpSeqPtr$9359 = -52
_lpTwin$9360 = -56
_lpAttribFlags$9374 = -64
_fnCommitPreLoops PROC NEAR

; 5572 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 5573 :    LPVIEWOD             lpViewOD;
; 5574 :    LPVIEWOI             lpViewOI;
; 5575 :    LPVIEWCSR            lpViewCsr;
; 5576 :    LPVIEWENTITY         lpViewEntity;
; 5577 :    LPVIEWENTITY         lpLastInsertedViewEntity;
; 5578 :    LPENTITYINSTANCE     lpEntityInstance;
; 5579 :    LPENTITYINSTANCE     lpRootEntityInstance;
; 5580 :    LPDATARECORD         lpDataRecord;
; 5581 :    LPVIEWATTRIB         lpViewAttrib;
; 5582 :    LPRELRECORD          lpRelRecord;
; 5583 :    zSHORT               nRC;
; 5584 : 
; 5585 :    lpLastInsertedViewEntity = 0;

	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], 0

; 5586 : 
; 5587 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 5588 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 5589 :    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 5590 :    lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax

; 5591 : 
; 5592 :    // Change the "hidden" indicator to false if the entity instance was
; 5593 :    // deleted.  This will allow the db-handler to access the entity instance.
; 5594 :    *plHiddenCnt = 0;

	mov	edx, DWORD PTR _plHiddenCnt$[ebp]
	mov	DWORD PTR [edx], 0

; 5595 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 5596 :    for ( lpEntityInstance = lpRootEntityInstance;
; 5597 :          lpEntityInstance;
; 5598 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9348
$L9349:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9348:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9350

; 5600 :       // Keep track of the last valid EI.
; 5601 :       *plpLastEntityInstance = lpEntityInstance;

	mov	eax, DWORD PTR _plpLastEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax], ecx

; 5602 : 
; 5603 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5604 : 
; 5605 :       // If it is a derived path, skip it
; 5606 :       if ( lpViewEntity->bDerivedPath )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	test	edx, edx
	je	SHORT $L9352

; 5607 :          continue;

	jmp	SHORT $L9349
$L9352:

; 5608 : 
; 5609 :       lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 5610 : 
; 5611 :       // If it has no data record, skip it
; 5612 :       if ( lpDataRecord == 0 )

	cmp	DWORD PTR _lpDataRecord$[ebp], 0
	jne	SHORT $L9354

; 5613 :          continue;

	jmp	SHORT $L9349
$L9354:

; 5614 : 
; 5615 :       lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 5616 : 
; 5617 :       // If the entity for the current entity instance has an automatic
; 5618 :       // sequence attribute AND it is the first twin under its parent,
; 5619 :       // ensure that the sequence numbers for all the twins are correct.
; 5620 :       if ( lpViewEntity->bAutoSeq &&
; 5621 :            lpEntityInstance->hPrevTwin == 0 &&  // Must be first twin.
; 5622 :            lpEntityInstance->hNextTwin )   // Don't bother if only 1 twin.

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 20					; 00000014H
	and	edx, 1
	test	edx, edx
	je	$L9368
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	$L9368
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	$L9368

; 5624 :          zULONG           uLth;
; 5625 :          zLONG            lSeq;
; 5626 :          zPLONG           lpSeqPtr;
; 5627 :          LPENTITYINSTANCE lpTwin;
; 5628 : 
; 5629 :          // First, find the autoseq view attrib.
; 5630 :          lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L9363:

; 5631 :          while ( lpViewAttrib->bAutoSeq == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9364

; 5632 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L9363
$L9364:

; 5633 : 
; 5634 :          // For each of the twins, set the seq attribute.
; 5635 :          lSeq = 1;

	mov	DWORD PTR _lSeq$9358[ebp], 1

; 5636 :          lpTwin = lpEntityInstance;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpTwin$9360[ebp], edx
$L9367:

; 5637 :          while ( lpTwin )

	cmp	DWORD PTR _lpTwin$9360[ebp], 0
	je	$L9368

; 5639 :             // If the twin wasn't deleted, then set it's sequence number.
; 5640 :             if ( lpTwin->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpTwin$9360[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	jne	$L9369

; 5642 :                // Make sure the entity instance has a data record.
; 5643 :                if ( lpTwin->hPersistRecord == 0 )

	mov	edx, DWORD PTR _lpTwin$9360[ebp]
	cmp	DWORD PTR [edx+60], 0
	jne	SHORT $L9370

; 5644 :                   fnCreateAttributeRecord( zGETPTR( lpViewOI->hAllocTask ),
; 5645 :                                            lpViewEntity, lpTwin );

	mov	eax, DWORD PTR _lpTwin$9360[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH
$L9370:

; 5646 : 
; 5647 :                fnGetAttrAddrFromEntityInstance( (zCOREMEM) &lpSeqPtr, &uLth,
; 5648 :                                                 lpTwin, lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTwin$9360[ebp]
	push	edx
	lea	eax, DWORD PTR _uLth$9357[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSeqPtr$9359[ebp]
	push	ecx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H

; 5649 : 
; 5650 :                // Only update sequence attribute if the value of the seqence
; 5651 :                // attribute in the entity is different from the local counter.
; 5652 :                if ( *lpSeqPtr != lSeq )

	mov	edx, DWORD PTR _lpSeqPtr$9359[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lSeq$9358[ebp]
	je	SHORT $L9373

; 5654 :                   LPATTRIBFLAGS lpAttribFlags;
; 5655 : 
; 5656 :                   *lpSeqPtr = lSeq;

	mov	ecx, DWORD PTR _lpSeqPtr$9359[ebp]
	mov	edx, DWORD PTR _lSeq$9358[ebp]
	mov	DWORD PTR [ecx], edx

; 5657 :                   lpTwin->u.nInd.bSequenceUpdt = TRUE;

	mov	eax, DWORD PTR _lpTwin$9360[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 524288				; 00080000H
	mov	edx, DWORD PTR _lpTwin$9360[ebp]
	mov	DWORD PTR [edx+6], ecx

; 5658 : 
; 5659 :                   // Since changing the attribute value via a pointer doesn't
; 5660 :                   // change the attrib flag do so now.
; 5661 :                   lpAttribFlags = fnGetAttribFlagsPtr( lpTwin, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTwin$9360[ebp]
	push	ecx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$9374[ebp], eax

; 5662 :                   lpAttribFlags->u.bFlags.bUpdated = TRUE;

	mov	edx, DWORD PTR _lpAttribFlags$9374[ebp]
	mov	eax, DWORD PTR [edx]
	or	al, 2
	mov	ecx, DWORD PTR _lpAttribFlags$9374[ebp]
	mov	DWORD PTR [ecx], eax

; 5663 : 
; 5664 :                   // Turn off the bDBHUpdated flag (if it's on) so that we
; 5665 :                   // make sure the entity is updated.  If the entity instance
; 5666 :                   // is linked with someone else it's possible that the
; 5667 :                   // entity was updated through the other link.
; 5668 :                   lpEntityInstance->u.nInd.bDBHUpdated = FALSE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -131073				; fffdffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9373:

; 5670 : 
; 5671 :                lSeq++;

	mov	edx, DWORD PTR _lSeq$9358[ebp]
	add	edx, 1
	mov	DWORD PTR _lSeq$9358[ebp], edx
$L9369:

; 5673 : 
; 5674 :             lpTwin = zGETPTR( lpTwin->hNextTwin );

	mov	eax, DWORD PTR _lpTwin$9360[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTwin$9360[ebp], eax

; 5675 :          }

	jmp	$L9367
$L9368:

; 5677 : 
; 5678 :       if ( lpEntityInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9377

; 5680 :          // Increment Hidden counter
; 5681 :          (*plHiddenCnt)++;

	mov	ecx, DWORD PTR _plHiddenCnt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _plHiddenCnt$[ebp]
	mov	DWORD PTR [eax], edx

; 5682 : 
; 5683 :          // Unhide the instance so the DBHandler can access it unless it is
; 5684 :          // "dead".  If it's "dead" the the DBHandler shouldn't care about it.
; 5685 :          if ( !fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnEntityInstanceIsDead@4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L9377

; 5686 :             lpEntityInstance->u.nInd.bHidden = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ch, -5					; fffffffbH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L9377:

; 5688 : 
; 5689 :    }  // for ( lpEntityInstance )...

	jmp	$L9349
$L9350:

; 5690 : 
; 5691 :    return( 0 );

	xor	ax, ax

; 5692 : 
; 5693 : } // fnCommitPreLoops

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCommitPreLoops ENDP
_TEXT	ENDS
PUBLIC	_fnCleanupInstance
PUBLIC	_fnDropViewCsr
EXTRN	_fnResetCursorForViewChildren:NEAR
EXTRN	_fnReclaimHiddenInstances@4:NEAR
EXTRN	_fnInstanceLinkedToInstance:NEAR
_TEXT	SEGMENT
_lpView$ = 8
_lHiddenCnt$ = 12
_lpViewCsr$ = -4
_lpViewOI$ = -28
_lpViewEntity$ = -16
_lpRootEntityInstance$ = -8
_lpEntityInstance$ = -12
_lpNextLinked$ = -24
_lpWrkViewCsr$ = -20
_lpNextViewCsr$9397 = -32
_lpViewEntityCsr$9402 = -40
_uIdx$9403 = -36
_lpViewAttrib$9417 = -48
_lpParent$9418 = -44
_lpAttribFlags$9427 = -52
_lpLinkedViewEntity$9435 = -56
_lpLinkedViewEntity$9455 = -60
_fnCleanupInstance PROC NEAR

; 5715 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 5716 :    LPVIEWCSR         lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 5717 :    LPVIEWOI          lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 5718 :    LPVIEWENTITY      lpViewEntity;
; 5719 :    LPENTITYINSTANCE  lpRootEntityInstance;
; 5720 :    LPENTITYINSTANCE  lpEntityInstance;
; 5721 :    LPENTITYINSTANCE  lpNextLinked;
; 5722 :    LPVIEWCSR         lpWrkViewCsr;
; 5723 : 
; 5724 :    // Clean up any view cursors which point to a hidden entity
; 5725 :    // If the root was deleted, delete all view cursors except the one
; 5726 :    // used in this call - REMOVED 1/22/93...Causes reclamation problems and
; 5727 :    // also does not account for multiple roots in the instance, the
; 5728 :    // reclamation code below will clean up the instance except for
; 5729 :    // the deleted root, This is enough cleanup under the circumstances
; 5730 :    // 1/22/93 ... Gig
; 5731 :    lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax

; 5732 :    lpWrkViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewCsr$[ebp], eax
$L9395:

; 5733 :    while ( lpWrkViewCsr )

	cmp	DWORD PTR _lpWrkViewCsr$[ebp], 0
	je	$L9396

; 5735 :       LPVIEWCSR lpNextViewCsr;
; 5736 : 
; 5737 :       lpNextViewCsr = zGETPTR( lpWrkViewCsr->hNextViewCsr );

	mov	edx, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewCsr$9397[ebp], eax

; 5738 : 
; 5739 :       // Get rid of any view cursors whose parent entity instance has been
; 5740 :       // deleted
; 5741 :       lpEntityInstance = zGETPTR( lpWrkViewCsr->hViewParentEntityInstance );

	mov	ecx, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 5742 :       if ( lpEntityInstance && lpEntityInstance->u.nInd.bHidden )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L9400
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9400

; 5743 :          fnDropViewCsr( lpWrkViewCsr );

	mov	edx, DWORD PTR _lpWrkViewCsr$[ebp]
	push	edx
	call	_fnDropViewCsr
	add	esp, 4

; 5744 :       else

	jmp	$L9407
$L9400:

; 5746 :          // Go through all view entity cursors (except the root) and set all
; 5747 :          // cursors pointing to a hidden instance to unset.
; 5748 :          LPVIEWENTITYCSR lpViewEntityCsr;
; 5749 :          zUSHORT         uIdx;
; 5750 : 
; 5751 :          // Turn Off Hierarchical stuff in ViewCsr
; 5752 :          lpViewCsr->hHierRootEntityInstance = 0;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [eax+22], 0

; 5753 :          lpViewCsr->hHierEntityInstance = 0;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [ecx+26], 0

; 5754 : 
; 5755 :          lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$9402[ebp], eax

; 5756 :          lpViewEntityCsr++;  // Skip the root.

	mov	ecx, DWORD PTR _lpViewEntityCsr$9402[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpViewEntityCsr$9402[ebp], ecx

; 5757 :          for ( uIdx = 2; uIdx <= lpViewCsr->uEntities; uIdx++ )

	mov	WORD PTR _uIdx$9403[ebp], 2
	jmp	SHORT $L9405
$L9406:
	mov	dx, WORD PTR _uIdx$9403[ebp]
	add	dx, 1
	mov	WORD PTR _uIdx$9403[ebp], dx
$L9405:
	mov	eax, DWORD PTR _uIdx$9403[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+34]
	cmp	eax, edx
	jg	SHORT $L9407

; 5759 :             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$9402[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 5760 :             if ( lpEntityInstance && lpEntityInstance != UNSET_CSR &&
; 5761 :                  lpEntityInstance->u.nInd.bHidden )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L9410
	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	je	SHORT $L9410
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9410

; 5763 :                if ( lpEntityInstance != lpRootEntityInstance )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpRootEntityInstance$[ebp]
	je	SHORT $L9411

; 5765 :                   lpViewEntityCsr->hEntityInstance = UNSET_CSR;

	mov	edx, DWORD PTR _lpViewEntityCsr$9402[ebp]
	mov	DWORD PTR [edx+26], 1
$L9411:

; 5769 : 
; 5770 :                fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$9402[ebp]
	push	eax
	call	_fnResetCursorForViewChildren
	add	esp, 4
$L9410:

; 5772 : 
; 5773 :             lpViewEntityCsr++;

	mov	ecx, DWORD PTR _lpViewEntityCsr$9402[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpViewEntityCsr$9402[ebp], ecx

; 5774 :          }

	jmp	SHORT $L9406
$L9407:

; 5776 : 
; 5777 :       lpWrkViewCsr = lpNextViewCsr;

	mov	edx, DWORD PTR _lpNextViewCsr$9397[ebp]
	mov	DWORD PTR _lpWrkViewCsr$[ebp], edx

; 5778 :    }

	jmp	$L9395
$L9396:

; 5779 : 
; 5780 :    // Now un-mark all created, updated and included instances and
; 5781 :    // remove any deleted instances
; 5782 :    for ( lpEntityInstance = lpRootEntityInstance;
; 5783 :          lpEntityInstance;
; 5784 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9414
$L9415:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9414:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9416

; 5786 :       LPVIEWATTRIB     lpViewAttrib;
; 5787 :       LPENTITYINSTANCE lpParent;
; 5788 : 
; 5789 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5790 : 
; 5791 :       // Skip the entity if the DBH didn't do anything
; 5792 :       if ( lpEntityInstance->u.nInd.bDBHCreated == FALSE &&
; 5793 :            lpEntityInstance->u.nInd.bDBHIncluded == FALSE &&
; 5794 :            lpEntityInstance->u.nInd.bDBHDeleted == FALSE &&
; 5795 :            lpEntityInstance->u.nInd.bDBHExcluded == FALSE &&
; 5796 :            lpEntityInstance->u.nInd.bDBHUpdated == FALSE )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9420
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9420
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9420
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 16					; 00000010H
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9420
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 17					; 00000011H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9420

; 5798 :          continue;

	jmp	SHORT $L9415
$L9420:

; 5800 : 
; 5801 :       lpEntityInstance->u.nInd.bCreated =
; 5802 :          lpEntityInstance->u.nInd.bUpdated =
; 5803 :          lpEntityInstance->u.nInd.bDeleted =
; 5804 :          lpEntityInstance->u.nInd.bIncluded =
; 5805 :          lpEntityInstance->u.nInd.bExcluded = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 5806 : 
; 5807 :       // If the EI was not updated, deleted, or created then we are done with
; 5808 :       // this entity.
; 5809 :       if ( lpEntityInstance->u.nInd.bDBHCreated == FALSE &&
; 5810 :            lpEntityInstance->u.nInd.bDBHDeleted == FALSE &&
; 5811 :            lpEntityInstance->u.nInd.bDBHUpdated == FALSE )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9421
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9421
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 17					; 00000011H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9421

; 5813 :          continue;

	jmp	$L9415
$L9421:

; 5815 : 
; 5816 :       // Turn off the updated flag for each of the attributes.
; 5817 :       for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 5818 :             lpViewAttrib;
; 5819 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9417[ebp], eax
	jmp	SHORT $L9424
$L9425:
	mov	edx, DWORD PTR _lpViewAttrib$9417[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9417[ebp], eax
$L9424:
	cmp	DWORD PTR _lpViewAttrib$9417[ebp], 0
	je	SHORT $L9426

; 5821 :          LPATTRIBFLAGS lpAttribFlags;
; 5822 : 
; 5823 :          // Skip non-persistent attributes.
; 5824 :          if ( lpViewAttrib->bPersist == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$9417[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9428

; 5825 :             continue;

	jmp	SHORT $L9425
$L9428:

; 5826 : 
; 5827 :          lpAttribFlags = fnGetAttribFlagsPtr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$9417[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$9427[ebp], eax

; 5828 :          lpAttribFlags->u.bFlags.bUpdated = FALSE;

	mov	edx, DWORD PTR _lpAttribFlags$9427[ebp]
	mov	eax, DWORD PTR [edx]
	and	al, -3					; fffffffdH
	mov	ecx, DWORD PTR _lpAttribFlags$9427[ebp]
	mov	DWORD PTR [ecx], eax

; 5829 :       }

	jmp	SHORT $L9425
$L9426:

; 5830 : 
; 5831 :       // Set flags for other linked instances.  If this instance isn't linked
; 5832 :       // then go on to next one.
; 5833 :       if ( lpEntityInstance->hNextLinked == 0 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	jne	SHORT $L9429

; 5834 :          continue;

	jmp	$L9415
$L9429:

; 5835 : 
; 5836 :       for ( lpNextLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 5837 :             lpNextLinked != lpEntityInstance;
; 5838 :             lpNextLinked = zGETPTR( lpNextLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
	jmp	SHORT $L9432
$L9433:
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
$L9432:
	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	$L9434

; 5840 :          LPVIEWENTITY lpLinkedViewEntity = zGETPTR( lpNextLinked->hViewEntity );

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedViewEntity$9435[ebp], eax

; 5841 : 
; 5842 :          // Turn off flags in linked entities depending on what the DBHandler
; 5843 :          // did to the current EI.
; 5844 :          if ( lpEntityInstance->u.nInd.bDBHCreated )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	test	edx, edx
	je	SHORT $L9437

; 5845 :             lpNextLinked->u.nInd.bCreated = FALSE;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L9437:

; 5846 : 
; 5847 :          if ( lpEntityInstance->u.nInd.bDBHUpdated )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 17					; 00000011H
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9438

; 5848 :             lpNextLinked->u.nInd.bUpdated = FALSE;

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -5					; fffffffbH
	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9438:

; 5849 : 
; 5850 :          if ( lpEntityInstance->u.nInd.bDBHDeleted )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9439

; 5851 :             lpNextLinked->u.nInd.bDeleted = FALSE;

	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -9					; fffffff7H
	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [eax+6], edx
$L9439:

; 5852 : 
; 5853 :          // Do some more processing if the EI is included/excluded.  If not
; 5854 :          // inc/exc then skip it.
; 5855 :          if ( lpEntityInstance->u.nInd.bDBHIncluded == FALSE &&
; 5856 :               lpEntityInstance->u.nInd.bDBHExcluded == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9440
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 16					; 00000010H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9440

; 5858 :             continue;

	jmp	$L9433
$L9440:

; 5860 : 
; 5861 :          // If lpEntityInstance and lpNextLinked have the same relationship
; 5862 :          // with their respective parents then we don't want to inc/exc the
; 5863 :          // lpNextLinked because it's already been done.  If the two EIs are
; 5864 :          // in the same OI then they must have the same linked parents.
; 5865 :          if ( lpNextLinked->hViewOI == lpEntityInstance->hViewOI ||
; 5866 :               ( lpLinkedViewEntity->lERRelTok == lpViewEntity->lERRelTok &&
; 5867 :                 fnInstanceLinkedToInstance( zGETPTR( lpNextLinked->hParent ),
; 5868 :                                             zGETPTR( lpEntityInstance->hParent ) ) ) )

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	je	SHORT $L9444
	mov	edx, DWORD PTR _lpLinkedViewEntity$9435[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+199]
	cmp	ecx, DWORD PTR [eax+199]
	jne	SHORT $L9446
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInstanceLinkedToInstance
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L9446
$L9444:

; 5870 :             if ( lpEntityInstance->u.nInd.bDBHIncluded )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 15					; 0000000fH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9445

; 5871 :                lpNextLinked->u.nInd.bIncluded = FALSE;

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9445:

; 5872 : 
; 5873 :             if ( lpEntityInstance->u.nInd.bDBHExcluded )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 16					; 00000010H
	and	eax, 1
	test	eax, eax
	je	SHORT $L9446

; 5874 :                lpNextLinked->u.nInd.bExcluded = FALSE;

	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [eax+6], edx
$L9446:

; 5876 :       }

	jmp	$L9433
$L9434:

; 5877 : 
; 5878 :       // if the instance has a parent and the parent is linked, see
; 5879 :       // if one of the linked parents is an inverted representation
; 5880 :       // of the same relationship
; 5881 :       lpParent = zGETPTR( lpEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$9418[ebp], eax

; 5882 :       if ( lpParent == 0 || lpParent->hNextLinked == 0 )

	cmp	DWORD PTR _lpParent$9418[ebp], 0
	je	SHORT $L9449
	mov	eax, DWORD PTR _lpParent$9418[ebp]
	cmp	DWORD PTR [eax+42], 0
	jne	SHORT $L9448
$L9449:

; 5883 :          continue;

	jmp	$L9415
$L9448:

; 5884 : 
; 5885 :       for ( lpNextLinked = zGETPTR( lpParent->hNextLinked );
; 5886 :             lpNextLinked != lpParent;
; 5887 :             lpNextLinked = zGETPTR( lpNextLinked->hNextLinked ) )

	mov	ecx, DWORD PTR _lpParent$9418[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
	jmp	SHORT $L9452
$L9453:
	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
$L9452:
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	cmp	edx, DWORD PTR _lpParent$9418[ebp]
	je	SHORT $L9454

; 5889 :          LPVIEWENTITY lpLinkedViewEntity = zGETPTR( lpNextLinked->hViewEntity );

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedViewEntity$9455[ebp], eax

; 5890 : 
; 5891 :          if ( lpNextLinked->hParent &&
; 5892 :               lpLinkedViewEntity->lERRelTok == lpViewEntity->lERRelTok &&
; 5893 :               fnInstanceLinkedToInstance( zGETPTR( lpNextLinked->hParent ),
; 5894 :                                           lpEntityInstance ) )

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	SHORT $L9458
	mov	eax, DWORD PTR _lpLinkedViewEntity$9455[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	jne	SHORT $L9458
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInstanceLinkedToInstance
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L9458

; 5896 :             lpNextLinked->u.nInd.bIncluded = FALSE;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 5897 :             lpNextLinked->u.nInd.bExcluded = FALSE;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L9458:

; 5899 :       }

	jmp	$L9453
$L9454:

; 5900 : 
; 5901 :    } // for each lpEntityInstance...

	jmp	$L9415
$L9416:

; 5902 : 
; 5903 :    // Call fnReclaim to clean up deleted instances
; 5904 :    if ( lHiddenCnt )

	cmp	DWORD PTR _lHiddenCnt$[ebp], 0
	je	SHORT $L9459

; 5905 :       fnReclaimHiddenInstances( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnReclaimHiddenInstances@4
$L9459:

; 5906 : 
; 5907 : } // fnCleanupInstance

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCleanupInstance ENDP
_TEXT	ENDS
PUBLIC	_fnDeleteLocksOnTwins@24
PUBLIC	??_C@_03LNBB@?$EA?$CFs?$AA@			; `string'
PUBLIC	_fnCreateConcatKey@16
;	COMDAT ??_C@_03LNBB@?$EA?$CFs?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_03LNBB@?$EA?$CFs?$AA@ DB '@%s', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_vLock$ = 12
_lpFirstEntityInstance$ = 16
_lpView$ = 20
_bLOD_Lock$ = 24
_lpLockEntity$ = -8
_lpViewEntity$ = -56
_lpViewAttrib$ = -64
_lpKeyViewAttrib$ = -224
_lpEntityInstance$ = -52
_lpLockEntityCsr$ = -432
_lpViewOD$ = -4
_szKeyString$ = -428
_szLockName$ = -48
_nKeyCnt$ = -60
_nRC$ = -12
_lpLockEntityInstance$9500 = -436
_fnDeleteLocksOnTwins@24 PROC NEAR

; 5918 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 436				; 000001b4H

; 5919 :    LPVIEWENTITY      lpLockEntity;
; 5920 :    LPVIEWENTITY      lpViewEntity;
; 5921 :    LPVIEWATTRIB      lpViewAttrib;
; 5922 :    LPVIEWATTRIB      lpKeyViewAttrib[ zMAX_KEYS_FOR_LOCK ];
; 5923 :    LPENTITYINSTANCE  lpEntityInstance;
; 5924 :    LPVIEWENTITYCSR   lpLockEntityCsr;
; 5925 :    LPVIEWOD          lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 5926 :    zCHAR             szKeyString[ zMAX_KEYLTH_FOR_LOCK + 1 ];
; 5927 :    zCHAR             szLockName[ 35 ];
; 5928 :    zSHORT            nKeyCnt;
; 5929 :    zSHORT            nRC = zCALL_ERROR;       // Assume error.

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 5930 : 
; 5931 :    lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5932 : 
; 5933 :    // To save time later find all the keys in the LOD and store them in a table.
; 5934 :    nKeyCnt = 0;

	mov	WORD PTR _nKeyCnt$[ebp], 0

; 5935 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 5936 :          lpViewAttrib;
; 5937 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L9489
$L9490:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L9489:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L9491

; 5939 :       if ( lpViewAttrib->bKey )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $L9492

; 5940 :          lpKeyViewAttrib[ nKeyCnt++ ] = lpViewAttrib;

	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeyViewAttrib$[ebp+ecx*4], edx
	mov	ax, WORD PTR _nKeyCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nKeyCnt$[ebp], ax
$L9492:

; 5941 :    }

	jmp	SHORT $L9490
$L9491:

; 5942 : 
; 5943 :    // Get the lpViewEntity and lpLockEntityCsr for the lock OI.
; 5944 :    lpLockEntity = fnValidViewEntity( &lpLockEntityCsr, vLock, "ZeidonLock", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpLockEntity$[ebp], eax

; 5945 : 
; 5946 :    if ( bLOD_Lock )

	mov	eax, DWORD PTR _bLOD_Lock$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L9493

; 5948 :       // We are checking a LOD level lock so we set LockName to the name of
; 5949 :       // the LOD.
; 5950 :       zstrcpy( szLockName, lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 5952 :    else

	jmp	SHORT $L9494
$L9493:

; 5954 :       // We are checking a lock at the entity level so use the name of the
; 5955 :       // entity for the LockName.  In addition, to handle the rare case where
; 5956 :       // a LOD and entity name are the same we prefix all entity names with
; 5957 :       // a '@' because it's an invalid character for entity names.  This
; 5958 :       // insures that the LockName for the entity does not match a LOD name.
; 5959 :       zsprintf( szLockName, "@%s", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET FLAT:??_C@_03LNBB@?$EA?$CFs?$AA@	; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9494:

; 5961 : 
; 5962 :    // Loop through each of the twin entities and create a locking record.  We
; 5963 :    // are going to cheat by then turning off the Create flag and turning on
; 5964 :    // the Delete and Hidden flags.  This will allow us to delete the lock
; 5965 :    // records off the DB without activating them first.
; 5966 :    for ( lpEntityInstance = lpFirstEntityInstance;
; 5967 :          lpEntityInstance;
; 5968 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $L9497
$L9498:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9497:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9499

; 5970 :       LPENTITYINSTANCE lpLockEntityInstance;
; 5971 : 
; 5972 :       // We don't care about instances that have been created.  Created
; 5973 :       // entities won't have a locking record because they where just created.
; 5974 :       // Same for included entities.
; 5975 :       if ( lpEntityInstance->u.nInd.bCreated ||
; 5976 :            lpEntityInstance->u.nInd.bIncluded )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9502
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	je	SHORT $L9501
$L9502:

; 5977 :          continue;

	jmp	SHORT $L9498
$L9501:

; 5978 : 
; 5979 :       // Create the concat key string.
; 5980 :       fnCreateConcatKey( szKeyString, lpEntityInstance,
; 5981 :                          lpKeyViewAttrib, nKeyCnt );

	mov	ax, WORD PTR _nKeyCnt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpKeyViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	lea	eax, DWORD PTR _szKeyString$[ebp]
	push	eax
	call	_fnCreateConcatKey@16

; 5982 : 
; 5983 :       if ( fnCreateEntity( vLock, lpLockEntity, lpLockEntityCsr,
; 5984 :                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnCreateEntity@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9504

; 5985 :          goto EndOfFunction;

	jmp	$EndOfFunction$9505
$L9504:

; 5986 : 
; 5987 :       if ( fnSetLockingAttributes( lpCurrentTask,
; 5988 :                                    vLock, lpLockEntity, lpLockEntityCsr,
; 5989 :                                    szLockName, szKeyString, 0, 0, 0 ) != 0 )

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _szKeyString$[ebp]
	push	edx
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnSetLockingAttributes@36
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9506

; 5990 :          goto EndOfFunction;

	jmp	SHORT $EndOfFunction$9505
$L9506:

; 5991 : 
; 5992 :       // Here's where we cheat -- turn off Create flag and turn on the
; 5993 :       // Delete/Hidden flags so that when we commit the OI the locking
; 5994 :       // records will be deleted.
; 5995 :       lpLockEntityInstance = zGETPTR( lpLockEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLockEntityInstance$9500[ebp], eax

; 5996 :       lpLockEntityInstance->u.nInd.bCreated = FALSE;

	mov	edx, DWORD PTR _lpLockEntityInstance$9500[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -3					; fffffffdH
	mov	ecx, DWORD PTR _lpLockEntityInstance$9500[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5997 :       lpLockEntityInstance->u.nInd.bDeleted = lpLockEntityInstance->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpLockEntityInstance$9500[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 4
	mov	ecx, DWORD PTR _lpLockEntityInstance$9500[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpLockEntityInstance$9500[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	al, 8
	mov	ecx, DWORD PTR _lpLockEntityInstance$9500[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5998 : 
; 5999 :    } // for ( lpEntityInstance...)

	jmp	$L9498
$L9499:

; 6000 : 
; 6001 :    // If we get here then everything is OK.
; 6002 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$9505:

; 6003 : 
; 6004 : EndOfFunction:
; 6005 : 
; 6006 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 6007 : 
; 6008 : } // fnDeleteLocksOnTwins

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnDeleteLocksOnTwins@24 ENDP
_TEXT	ENDS
PUBLIC	_fnRemoveLocksOnOIs@16
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpViewCluster$ = 12
_nViewCount$ = 16
_vLock$ = -8
_tViewArrayBlock$ = -80
_vSubtask$ = -88
_bDropLocks$ = -16
_k$ = -84
_nRC$ = -12
_lpViewOD$9531 = -96
_lpViewCsr$9532 = -92
_lpViewOI$9533 = -100
_lpEntityInstance$9548 = -104
_lpViewEntity$9554 = -108
_lpViewCsr$9565 = -112
_lpViewOI$9566 = -116
_fnRemoveLocksOnOIs@16 PROC NEAR

; 6016 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	edi

; 6017 :    ViewClusterRecord vLock;
; 6018 :    VIEWARRAYBLOCK    tViewArrayBlock = {0};

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	mov	ecx, 15					; 0000000fH
	xor	eax, eax
	lea	edi, DWORD PTR _tViewArrayBlock$[ebp+4]
	rep stosd

; 6019 :    zVIEW             vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 6020 :    zBOOL             bDropLocks;
; 6021 :    zSHORT            k;
; 6022 :    zSHORT            nRC = zCALL_ERROR;       // Assume error.

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 6023 : 
; 6024 :    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 6025 :    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 6026 : 
; 6027 :    // vSubtask is just the first valid view in the list.
; 6028 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9524
$L9525:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9524:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $L9526

; 6030 :       if ( lpViewCluster[ k ].vOI )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $L9527

; 6032 :          vSubtask = lpViewCluster[ k ].vOI;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _vSubtask$[ebp], ecx

; 6033 :          break;

	jmp	SHORT $L9526
$L9527:

; 6035 :    }

	jmp	SHORT $L9525
$L9526:

; 6036 : 
; 6037 :    bDropLocks = FALSE;

	mov	BYTE PTR _bDropLocks$[ebp], 0

; 6038 : 
; 6039 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9528
$L9529:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9528:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$L9530

; 6041 :       LPVIEWOD  lpViewOD;
; 6042 :       LPVIEWCSR lpViewCsr;
; 6043 :       LPVIEWOI  lpViewOI;
; 6044 : 
; 6045 :       if ( lpViewCluster[ k ].vOI == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	jne	SHORT $L9534

; 6046 :          continue;

	jmp	SHORT $L9529
$L9534:

; 6047 : 
; 6048 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $L9535

; 6049 :          continue;

	jmp	SHORT $L9529
$L9535:

; 6050 : 
; 6051 :       lpViewOD  = zGETPTR( lpViewCluster[ k ].vOI->hViewOD );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$9531[ebp], eax

; 6052 :       lpViewCsr = zGETPTR( lpViewCluster[ k ].vOI->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$9532[ebp], eax

; 6053 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$9532[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$9533[ebp], eax

; 6054 : 
; 6055 :       // If view wasn't activated with locking forget about it.
; 6056 :       if ( lpViewOI->bIsLocked == FALSE )

	mov	edx, DWORD PTR _lpViewOI$9533[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 7
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9539

; 6057 :          continue;

	jmp	$L9529
$L9539:

; 6058 : 
; 6059 :       // If bDropLocks is FALSE then we haven't created the vLock object yet.
; 6060 :       if ( bDropLocks == FALSE )

	mov	ecx, DWORD PTR _bDropLocks$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L9540

; 6062 :          // Create an empty lock OI.
; 6063 :          if ( fnDeclareView( &vLock.vOI, lpCurrentTask, vSubtask,
; 6064 :                              "ZPLOCKO", FALSE ) != 0 )

	push	0
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnDeclareView@20
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9541

; 6066 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9517
$L9541:

; 6068 : 
; 6069 :          if ( fnActivateEmptyObjectInstance( lpCurrentTask,
; 6070 :                                              vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9542

; 6072 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9517
$L9542:

; 6074 : 
; 6075 :          // Set flag to indicate:
; 6076 :          //    o The lock OI has been created.
; 6077 :          //    o We need to commit the lock object so that locks are removed.
; 6078 :          bDropLocks = TRUE;

	mov	BYTE PTR _bDropLocks$[ebp], 1
$L9540:

; 6080 : 
; 6081 :       // If the view has LOD-level locking release the LOD-level lock.
; 6082 :       if ( lpViewOD->nLock > zLL_PESSIMISTIC )

	mov	eax, DWORD PTR _lpViewOD$9531[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+236]
	cmp	ecx, 3
	jle	SHORT $L9545

; 6084 :          if ( fnDeleteLocksOnTwins( lpCurrentTask, vLock.vOI,
; 6085 :                                     zGETPTR( lpViewOI->hRootEntityInstance ),
; 6086 :                                     lpViewCluster[ k ].vOI,
; 6087 :                                     TRUE, lpViewOI ) != 0 )

	mov	edx, DWORD PTR _lpViewOI$9533[ebp]
	push	edx
	push	1
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$9533[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnDeleteLocksOnTwins@24
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9545

; 6089 :             goto EndOfFunction;

	jmp	$EndOfFunction$9546
$L9545:

; 6092 : 
; 6093 :       // If the view has entity-level locking release the entity-level lock.
; 6094 :       if ( lpViewOD->nEntityLock > zLL_PESSIMISTIC )

	mov	edx, DWORD PTR _lpViewOD$9531[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+237]
	cmp	eax, 3
	jle	$L9553

; 6096 :          LPENTITYINSTANCE lpEntityInstance;
; 6097 : 
; 6098 :          for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 6099 :                lpEntityInstance;
; 6100 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewOI$9533[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$9548[ebp], eax
	jmp	SHORT $L9551
$L9552:
	mov	eax, DWORD PTR _lpEntityInstance$9548[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$9548[ebp], eax
$L9551:
	cmp	DWORD PTR _lpEntityInstance$9548[ebp], 0
	je	SHORT $L9553

; 6102 :             LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$9548[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$9554[ebp], eax

; 6103 : 
; 6104 :             // If entity has no locking skip it.
; 6105 :             if ( lpViewEntity->nLock == 0 )

	mov	ecx, DWORD PTR _lpViewEntity$9554[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+230]
	test	edx, edx
	jne	SHORT $L9556

; 6106 :                continue;

	jmp	SHORT $L9552
$L9556:

; 6107 : 
; 6108 :             // If the instance is not the first twin then skip it.
; 6109 :             if ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$9548[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L9557

; 6110 :                continue;

	jmp	SHORT $L9552
$L9557:

; 6111 : 
; 6112 :             if ( fnDeleteLocksOnTwins( lpCurrentTask, vLock.vOI,
; 6113 :                                        lpEntityInstance,
; 6114 :                                        lpViewCluster[ k ].vOI, FALSE,
; 6115 :                                        lpViewOI ) != 0 )

	mov	ecx, DWORD PTR _lpViewOI$9533[ebp]
	push	ecx
	push	0
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$9548[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnDeleteLocksOnTwins@24
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9558

; 6117 :                nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 6118 :                break;

	jmp	SHORT $L9553
$L9558:

; 6120 : 
; 6121 :          } // for ( lpEntityInstance )...

	jmp	SHORT $L9552
$L9553:

; 6123 : 
; 6124 :    } // for ( k = 0... )...

	jmp	$L9529
$L9530:

; 6125 : 
; 6126 :    // If we didn't find any views that should be locked then get out.
; 6127 :    if ( bDropLocks == FALSE )

	mov	eax, DWORD PTR _bDropLocks$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L9559

; 6129 :       nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 6130 :       goto EndOfFunction;

	jmp	$EndOfFunction$9546
$L9559:

; 6132 : 
; 6133 :    // Now commit the lock OI.  This should delete the locks.
; 6134 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	ecx, DWORD PTR _tViewArrayBlock$[ebp]
	push	ecx
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9560

; 6135 :       goto EndOfFunction;

	jmp	$EndOfFunction$9546
$L9560:

; 6136 : 
; 6137 :    if ( fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0, lpCurrentTask,
; 6138 :                                 0, &tViewArrayBlock ) != 0 )

	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	1
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnCommitObjectInstance@28
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9561

; 6140 :       goto EndOfFunction;

	jmp	$EndOfFunction$9546
$L9561:

; 6142 : 
; 6143 :    // Flag all the OI's as no longer locked.
; 6144 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9562
$L9563:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9562:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L9564

; 6146 :       LPVIEWCSR lpViewCsr;
; 6147 :       LPVIEWOI  lpViewOI;
; 6148 : 
; 6149 :       if ( lpViewCluster[ k ].vOI == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	jne	SHORT $L9567

; 6150 :          continue;

	jmp	SHORT $L9563
$L9567:

; 6151 : 
; 6152 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $L9568

; 6153 :          continue;

	jmp	SHORT $L9563
$L9568:

; 6154 : 
; 6155 :       lpViewCsr = zGETPTR( lpViewCluster[ k ].vOI->hViewCsr );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$9565[ebp], eax

; 6156 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$9565[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$9566[ebp], eax

; 6157 : 
; 6158 :       lpViewOI->bIsLocked = FALSE;

	mov	ecx, DWORD PTR _lpViewOI$9566[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	dl, 127					; 0000007fH
	mov	eax, DWORD PTR _lpViewOI$9566[ebp]
	mov	DWORD PTR [eax+36], edx

; 6159 : 
; 6160 :    } // for ( k = 0... )...

	jmp	SHORT $L9563
$L9564:

; 6161 : 
; 6162 :    // If we get here then everything's OK.
; 6163 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$9546:

; 6164 : 
; 6165 : EndOfFunction:
; 6166 :    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $L9571

; 6167 :       fnDropView( vLock.vOI );

	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnDropView@4
$L9571:

; 6168 : 
; 6169 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 6170 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L9517:

; 6171 : 
; 6172 : } // fnRemoveLocksOnOIs

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnRemoveLocksOnOIs@16 ENDP
_TEXT	ENDS
PUBLIC	_fnCommitSingleOI@16
PUBLIC	??_C@_0BL@CNGJ@Couldn?8t?5find?5original?5OI?$CB?$AA@ ; `string'
PUBLIC	??_C@_0CG@PFIF@?$CIoi?$CJ?5Activating?5Optimistic?5Check@ ; `string'
PUBLIC	??_C@_0DB@NCB@?$CIoi?$CJ?5Error?5loading?5Optimistic?5ch@ ; `string'
PUBLIC	??_C@_0CG@JDBO@?$CIoi?$CJ?5Optimistic?5locking?5compare?5@ ; `string'
EXTRN	_fnCompareOI_ToOI:NEAR
EXTRN	_fnResetViewFromSubobject:NEAR
;	COMDAT ??_C@_0BL@CNGJ@Couldn?8t?5find?5original?5OI?$CB?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BL@CNGJ@Couldn?8t?5find?5original?5OI?$CB?$AA@ DB 'Couldn''t find '
	DB	'original OI!', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@PFIF@?$CIoi?$CJ?5Activating?5Optimistic?5Check@
_DATA	SEGMENT
??_C@_0CG@PFIF@?$CIoi?$CJ?5Activating?5Optimistic?5Check@ DB '(oi) Activa'
	DB	'ting Optimistic Check view', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DB@NCB@?$CIoi?$CJ?5Error?5loading?5Optimistic?5ch@
_DATA	SEGMENT
??_C@_0DB@NCB@?$CIoi?$CJ?5Error?5loading?5Optimistic?5ch@ DB '(oi) Error '
	DB	'loading Optimistic check view.  RC = ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@JDBO@?$CIoi?$CJ?5Optimistic?5locking?5compare?5@
_DATA	SEGMENT
??_C@_0CG@JDBO@?$CIoi?$CJ?5Optimistic?5locking?5compare?5@ DB '(oi) Optim'
	DB	'istic locking compare RC = ', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_lpCurrentTask$ = 16
_lpTaskDBHandler$ = 20
_lpViewOD$ = -20
_lpViewOI$ = -48
_lpViewCsr$ = -4
_lpViewEntity$ = -36
_lpEntityInstance$ = -32
_lpLastEntityInstance$ = -40
_lpRootEntityInstance$ = -16
_lpLinked$ = -12
_pOper$ = -44
_lpPtr$ = -28
_lHiddenCnt$ = -52
_nRC$ = -24
_bRelational$ = -8
_lpTask$9600 = -56
_vCheckView$9604 = -64
_lCmprCntrl$9605 = -60
_lpTask$9611 = -68
_lpTask$9619 = -72
_bDelete$9650 = -76
_lpVE_Parent$9652 = -80
_lpVE_NextHier$9653 = -88
_lpEI_Parent$9654 = -84
_fnCommitSingleOI@16 PROC NEAR

; 6200 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 6201 :    LPVIEWOD             lpViewOD;
; 6202 :    LPVIEWOI             lpViewOI;
; 6203 :    LPVIEWCSR            lpViewCsr;
; 6204 :    LPVIEWENTITY         lpViewEntity;
; 6205 :    LPENTITYINSTANCE     lpEntityInstance;
; 6206 :    LPENTITYINSTANCE     lpLastEntityInstance;
; 6207 :    LPENTITYINSTANCE     lpRootEntityInstance;
; 6208 :    LPENTITYINSTANCE     lpLinked;
; 6209 :    zPDBHOPER            pOper = lpTaskDBHandler->pfDBHandlerOper;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _pOper$[ebp], ecx

; 6210 :    zPVOID               lpPtr = lpTaskDBHandler->lpConnection;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR _lpPtr$[ebp], eax

; 6211 :    zLONG                lHiddenCnt;
; 6212 :    zSHORT               nRC;
; 6213 : 
; 6214 :    // DGC 1998/11/17
; 6215 :    // We have code that is special just for relational DBs.  At the moment we
; 6216 :    // only support relational DBs so I'm setting the following variable to
; 6217 :    // be always TRUE.  When we support other DB types we'll have to do
; 6218 :    // something different.
; 6219 :    zBOOL                bRelational = TRUE;

	mov	BYTE PTR _bRelational$[ebp], 1

; 6220 : 
; 6221 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6222 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6223 :    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 6224 : 
; 6225 :    nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Object | DBH_NewObject, 0,
; 6226 :                    lpViewOD, 0, lpView, 0, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	16392					; 00004008H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6227 : 
; 6228 :    // Make sure OI does not contain versioned instances.
; 6229 :    if ( lpViewOI->nVersionedInstances )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	je	SHORT $L9599

; 6231 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$9600[ebp], eax

; 6232 :       //  "KZOEE076 - Object instance contains versioned entity instances"
; 6233 :       fnIssueCoreError( lpTask, lpView, 8, 76, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$9600[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6234 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9581
$L9599:

; 6236 : 
; 6237 :    // Check to see if the OI was activated using optmistic locking.
; 6238 :    if ( lpViewOI->lActivateControl & zACTIVATE_WITH_LOCKING &&
; 6239 :         (lpViewOD->nLock == zLL_OPTIMISTIC_NOINC ||
; 6240 :          lpViewOD->nLock == zLL_OPTIMISTIC_CMPRALL) )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, 67108864				; 04000000H
	test	ecx, ecx
	je	$L9618
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+236]
	cmp	eax, 1
	je	SHORT $L9603
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 2
	jne	$L9618
$L9603:

; 6242 :       zVIEW vCheckView;
; 6243 :       zLONG lCmprCntrl;
; 6244 : 
; 6245 :       // Since we have optimistic locking, we should have a copy of the
; 6246 :       // original OI (the OI after it was loaded).  Make sure we got it.
; 6247 :       if ( lpViewOI->vOriginalOI == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L9606

; 6249 :          // This should never happen (if it does it's a core error) so we'll
; 6250 :          // just use SysMessageBox.
; 6251 :          SysMessageBox( lpView, "Internal Core Error",
; 6252 :                         "Couldn't find original OI!", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0BL@CNGJ@Couldn?8t?5find?5original?5OI?$CB?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BE@LIH@Internal?5Core?5Error?$AA@ ; `string'
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 6253 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9581
$L9606:

; 6255 : 
; 6256 :       // Now activate the OI again using the qualification object but
; 6257 :       // WITHOUT optimistic locking.
; 6258 :       TraceLineS( "(oi) Activating Optimistic Check view", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CG@PFIF@?$CIoi?$CJ?5Activating?5Optimistic?5Check@ ; `string'
	call	_TraceLineS@8

; 6259 :       nRC = ActivateObjectInstance( &vCheckView, lpViewOD->szName,
; 6260 :                                     lpView, zGETPTR( lpViewOI->vQualOI ),
; 6261 :                                     (lpViewOI->lActivateControl &
; 6262 :                                                ~(zACTIVATE_WITH_LOCKING)) );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, -67108865				; fbffffffH
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _vCheckView$9604[ebp]
	push	edx
	call	_ActivateObjectInstance@20
	mov	WORD PTR _nRC$[ebp], ax

; 6263 :       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $L9610

; 6265 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$9611[ebp], eax

; 6266 :          // We've got an error loading the optimistic check view, so get out.
; 6267 :          if ( vCheckView )

	cmp	DWORD PTR _vCheckView$9604[ebp], 0
	je	SHORT $L9613

; 6268 :             DropView( vCheckView );

	mov	eax, DWORD PTR _vCheckView$9604[ebp]
	push	eax
	call	_DropView@4
$L9613:

; 6269 : 
; 6270 :          TraceLineI( "(oi) Error loading Optimistic check view.  RC = ", nRC );

	movsx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DB@NCB@?$CIoi?$CJ?5Error?5loading?5Optimistic?5ch@ ; `string'
	call	_TraceLineI@8

; 6271 : 
; 6272 :          // "KZOEE092 - Couldn't re-activate OI for optimistic lock check",
; 6273 :          fnIssueCoreError( lpTask, lpView, 8, 92, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	92					; 0000005cH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$9611[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6274 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9581
$L9610:

; 6276 : 
; 6277 :       // We're about to compare the OIs but first check to see if we should
; 6278 :       // ignore non-key values for include-only entities.
; 6279 :       lCmprCntrl = zCOMPAREOI_PERSISTONLY | zCOMPAREOI_RETURN;

	mov	DWORD PTR _lCmprCntrl$9605[ebp], 2

; 6280 :       if ( lpViewOD->nLock == zLL_OPTIMISTIC_NOINC )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 1
	jne	SHORT $L9615

; 6281 :          lCmprCntrl |= zCOMPAREOI_IGNOREINC;

	mov	eax, DWORD PTR _lCmprCntrl$9605[ebp]
	or	al, 1
	mov	DWORD PTR _lCmprCntrl$9605[ebp], eax
$L9615:

; 6282 : 
; 6283 :       // We now have a copy of the original OI and the current one.  Compare
; 6284 :       // the two and see if they are the same.  If they are not, then there
; 6285 :       // is an error.
; 6286 :       nRC = fnCompareOI_ToOI( zGETPTR( lpViewOI->vOriginalOI ), vCheckView,
; 6287 :                               lCmprCntrl );

	mov	ecx, DWORD PTR _lCmprCntrl$9605[ebp]
	push	ecx
	mov	edx, DWORD PTR _vCheckView$9604[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnCompareOI_ToOI
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 6288 :       TraceLineI( "(oi) Optimistic locking compare RC = ", nRC );

	movsx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CG@JDBO@?$CIoi?$CJ?5Optimistic?5locking?5compare?5@ ; `string'
	call	_TraceLineI@8

; 6289 :       DropView( vCheckView );  // We no longer need this...

	mov	eax, DWORD PTR _vCheckView$9604[ebp]
	push	eax
	call	_DropView@4

; 6290 :       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L9618

; 6292 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$9619[ebp], eax

; 6293 :          // "KZOEE093 - Optimistic locking error -- OI has changed since it was activated",
; 6294 :          fnIssueCoreError( lpTask, lpView, 8, 93, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	93					; 0000005dH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$9619[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6295 :          return( zOPTIMISTIC_LOCK_ERROR );

	mov	ax, -5					; fffffffbH
	jmp	$L9581
$L9618:

; 6299 : 
; 6300 :    // Perform some pre-commit stuff.  fnCommitPreLoops does:
; 6301 :    //    o  Sets any auto-sequence attributes.
; 6302 :    //    o  Turns off "hidden" flag so db-handler can access all data.
; 6303 :    nRC = fnCommitPreLoops( lpCurrentTask, lpView, &lpLastEntityInstance,
; 6304 :                            &lHiddenCnt );

	lea	eax, DWORD PTR _lHiddenCnt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpLastEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCommitPreLoops
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 6305 :    if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L9621

; 6306 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L9581
$L9621:

; 6307 : 
; 6308 :    lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax

; 6309 : 
; 6310 :    // Now we pass the chain once each to do relationship deletes, deletes,
; 6311 :    // relationship inserts, and updates. The delete passes are done in reverse
; 6312 :    // hierarchical order so deletes occur from the bottom up.
; 6313 : 
; 6314 :    //==============================================================
; 6315 :    // PASS Number 1, do excludes (relationship deletes).
; 6316 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$L9627

; 6318 :       for ( lpEntityInstance = lpLastEntityInstance;
; 6319 :             lpEntityInstance && nRC == 0;
; 6320 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier ) )

	mov	edx, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $L9625
$L9626:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9625:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9627
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$L9627

; 6322 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6323 : 
; 6324 :          // EIs down a derived path don't get committed to the database.
; 6325 :          // Since all children of a derived EI are also derived we can skip
; 6326 :          // the twins of the current EI.
; 6327 :          if ( lpViewEntity->bDerivedPath )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9629
$L9631:

; 6329 :             while ( lpEntityInstance->hPrevTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $L9632

; 6330 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9631
$L9632:

; 6331 : 
; 6332 :             continue;

	jmp	SHORT $L9626
$L9629:

; 6334 : 
; 6335 : #if ( VIEWENT_RULES )
; 6336 :          // Skip the EI if we don't allow excluding this entity.
; 6337 :          if ( lpViewEntity->bExclude == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9634

; 6338 :             continue;

	jmp	SHORT $L9626
$L9634:

; 6339 : #endif
; 6340 : 
; 6341 :          // Exclude entity if the entity...
; 6342 :          if ( lpEntityInstance->u.nInd.bExcluded             && // was excluded...
; 6343 :               lpEntityInstance->u.nInd.bDBHExcluded == FALSE && // wasn't committed...
; 6344 :               lpEntityInstance->u.nInd.bIncluded == FALSE    && // wasn't inc'd and...
; 6345 :               lpEntityInstance->u.nInd.bCreated == FALSE )      // wasn't created

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	je	$L9635
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 16					; 00000010H
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9635
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9635
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9635

; 6347 :             // Set entity cursor to point to lpEntityInstance.
; 6348 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6349 : 
; 6350 :             // Call DBHandler routine.
; 6351 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_DeleteRel, 0,
; 6352 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	0
	push	32776					; 00008008H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6353 : 
; 6354 :             lpEntityInstance->u.nInd.bDBHExcluded = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 65536				; 00010000H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6355 : 
; 6356 :             // Set the bDBHExcluded flag for all linked EIs that have the
; 6357 :             // exact same relationship.
; 6358 :             fnMarkDuplicateRelationship( lpEntityInstance, FALSE );

	push	0
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnMarkDuplicateRelationship@8
$L9635:

; 6360 : 
; 6361 :       }  // for ( lpEntityInstance ...)...

	jmp	$L9626
$L9627:

; 6364 : 
; 6365 :    //==============================================================
; 6366 :    // PASS Number 2, do deletes.
; 6367 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$L9641

; 6369 :       for ( lpEntityInstance = lpLastEntityInstance;
; 6370 :             lpEntityInstance && nRC == 0;
; 6371 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier ) )

	mov	eax, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9639
$L9640:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9639:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9641
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L9641

; 6373 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6374 : 
; 6375 :          // EIs down a derived path don't get committed to the database.
; 6376 :          // Since all children of a derived EI are also derived we can skip
; 6377 :          // the twins of the current EI.
; 6378 :          if ( lpViewEntity->bDerivedPath )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9643
$L9645:

; 6380 :             while ( lpEntityInstance->hPrevTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $L9646

; 6381 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9645
$L9646:

; 6382 : 
; 6383 :             continue;

	jmp	SHORT $L9640
$L9643:

; 6385 : 
; 6386 : #if ( VIEWENT_RULES )
; 6387 :          // If we don't allow deletes then skip it.
; 6388 :          if ( lpViewEntity->bDelete == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9648

; 6389 :             continue;

	jmp	SHORT $L9640
$L9648:

; 6390 : #endif
; 6391 : 
; 6392 :          // Delete entity if prev dbcall was OK and the entity...
; 6393 :          if ( lpEntityInstance->u.nInd.bDeleted             && // was deleted and...
; 6394 :               lpEntityInstance->u.nInd.bDBHDeleted == FALSE && // wasn't committed and...
; 6395 :               lpEntityInstance->u.nInd.bCreated == FALSE    && // wasn't created and...
; 6396 :               lpEntityInstance->u.nInd.bIncluded == FALSE )    // wasn't included

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	je	$L9673
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	jne	$L9673
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	$L9673
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	jne	$L9673

; 6398 :             zBOOL bDelete = FALSE;  // process each entity normally

	mov	BYTE PTR _bDelete$9650[ebp], 0

; 6399 : 
; 6400 :             // Set entity cursor to point to lpEntityInstance.
; 6401 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6402 : 
; 6403 :             // Start dks ... 2006.01.25
; 6404 :             if ( lpEntityInstance->hParent )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	$L9659

; 6406 :                LPVIEWENTITY      lpVE_Parent;
; 6407 :                LPVIEWENTITY      lpVE_NextHier;
; 6408 :                LPENTITYINSTANCE  lpEI_Parent;
; 6409 : 
; 6410 :                lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6411 :                lpVE_NextHier = zGETPTR( lpViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVE_NextHier$9653[ebp], eax

; 6412 :                lpVE_Parent = zGETPTR( lpViewEntity->hParent );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVE_Parent$9652[ebp], eax

; 6413 :                lpEI_Parent = zGETPTR( lpEntityInstance->hParent );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI_Parent$9654[ebp], eax

; 6414 :                if ( lpEI_Parent->u.nInd.bDeleted &&    // parent was deleted and...
; 6415 :                     lpViewEntity->bPDelete &&          // entity has ParentDelete behavior and...
; 6416 :                     lpVE_Parent->bSingleKey &&         // parent entity is single key and...
; 6417 :                     lpEntityInstance->hPrevTwin &&     // more than one instance to delete and...
; 6418 :                     lpViewEntity->bDerivedPath == FALSE && // cannot be derived
; 6419 :                     (lpVE_NextHier == 0 ||
; 6420 :                      lpVE_NextHier->hParent != lpEntityInstance->hViewEntity) )  // cannot have child entities

	mov	edx, DWORD PTR _lpEI_Parent$9654[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L9659
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 7
	and	edx, 1
	test	edx, edx
	je	SHORT $L9659
	mov	eax, DWORD PTR _lpVE_Parent$9652[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 16					; 00000010H
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9659
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $L9659
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9659
	cmp	DWORD PTR _lpVE_NextHier$9653[ebp], 0
	je	SHORT $L9660
	mov	edx, DWORD PTR _lpVE_NextHier$9653[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+2]
	je	SHORT $L9659
$L9660:

; 6422 :                   // This should be the condition we are looking for ... dks ... 2006.01.25
; 6423 :                   bDelete = TRUE;       // call DBHandler once in the loop below

	mov	BYTE PTR _bDelete$9650[ebp], 1
$L9659:

; 6426 :             // End dks ... 2006.01.25
; 6427 : 
; 6428 :             // Call DBHandler routine.
; 6429 :             if ( bDelete )  // dks ... 2006.01.25

	mov	edx, DWORD PTR _bDelete$9650[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L9661

; 6431 :                lpEntityInstance->u.nInd.bDBHDeleteAll = TRUE;  // call delete special case

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 262144				; 00040000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6432 :                nRC = (*pOper)( (zLONG) lpView->hTask,
; 6433 :                                DBH_Entity | DBH_Delete | DBH_DeleteAll, 0,
; 6434 :                                lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	33796					; 00008404H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$L9664:

; 6435 : 
; 6436 :                // Flag each twin that message has been sent to handler.
; 6437 :                while ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L9665

; 6439 :                   lpEntityInstance->u.nInd.bDBHDeleted = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	dh, 64					; 00000040H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6440 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 6441 :                }

	jmp	SHORT $L9664
$L9665:

; 6443 :             else

	jmp	SHORT $L9667
$L9661:

; 6445 :                // This is the only original code prior to 2006.01.25
; 6446 :                nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_Delete, 0,
; 6447 :                                lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	32772					; 00008004H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$L9667:

; 6449 : 
; 6450 :             // Flag that message has been sent to handler.
; 6451 :             lpEntityInstance->u.nInd.bDBHDeleted = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ch, 64					; 00000040H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6452 : 
; 6453 :             // Turn on the DBHDeleted flag for all linked instances.  This
; 6454 :             // will keep them from being deleted again.
; 6455 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 6456 :                   lpLinked && lpLinked != lpEntityInstance;
; 6457 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
	jmp	SHORT $L9671
$L9672:
	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
$L9671:
	cmp	DWORD PTR _lpLinked$[ebp], 0
	je	SHORT $L9673
	mov	ecx, DWORD PTR _lpLinked$[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9673

; 6459 :                lpLinked->u.nInd.bDBHDeleted = TRUE;

	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 64					; 00000040H
	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 6460 :             }

	jmp	SHORT $L9672
$L9673:

; 6462 : 
; 6463 :       }  // while ( lpEntityInstance && nRC == 0 )...

	jmp	$L9640
$L9641:

; 6466 : 
; 6467 :    //==============================================================
; 6468 :    // PASS Number 3, do creates.
; 6469 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$L9678

; 6471 :       for ( lpEntityInstance = lpRootEntityInstance;
; 6472 :             lpEntityInstance && nRC == 0;
; 6473 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9676
$L9677:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9676:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9678
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L9678

; 6475 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6476 : 
; 6477 :          // EIs down a derived path don't get committed to the database.
; 6478 :          // Since all children of a derived EI are also derived we can skip
; 6479 :          // the twins of the current EI.
; 6480 :          if ( lpViewEntity->bDerivedPath )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9680
$L9682:

; 6482 :             while ( lpEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $L9683

; 6483 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9682
$L9683:

; 6484 : 
; 6485 :             continue;

	jmp	SHORT $L9677
$L9680:

; 6487 : 
; 6488 : #if ( VIEWENT_RULES )
; 6489 :          // If we don't allow creates then skip it.
; 6490 :          if ( lpViewEntity->bCreate == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9685

; 6491 :             continue;

	jmp	SHORT $L9677
$L9685:

; 6492 : #endif
; 6493 : 
; 6494 :          // Create the entity if the entity...
; 6495 :          if ( lpEntityInstance->u.nInd.bDBHCreated == FALSE && // not committed and...
; 6496 :               lpEntityInstance->u.nInd.bCreated             && // was created and...
; 6497 :               lpEntityInstance->u.nInd.bDeleted == FALSE    && // wasn't deleted and...
; 6498 :               lpEntityInstance->u.nInd.bHidden == FALSE )      // is not hidden

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	test	edx, edx
	jne	$L9692
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	je	$L9692
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	$L9692
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	$L9692

; 6500 :             // Set entity cursor to point to lpEntityInstance.
; 6501 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6502 : 
; 6503 :             // Call DBHandler routine.
; 6504 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_Insert, 0,
; 6505 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	32769					; 00008001H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6506 : 
; 6507 :             // Flag that message sent to handler
; 6508 :             lpEntityInstance->u.nInd.bDBHCreated = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 32					; 00000020H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 6509 : 
; 6510 :             // Turn on the dbh flag for all linked instances.  This will
; 6511 :             // keep them from being created again.
; 6512 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 6513 :                   lpLinked && lpLinked != lpEntityInstance;
; 6514 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
	jmp	SHORT $L9690
$L9691:
	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
$L9690:
	cmp	DWORD PTR _lpLinked$[ebp], 0
	je	SHORT $L9692
	mov	eax, DWORD PTR _lpLinked$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9692

; 6516 :                lpLinked->u.nInd.bDBHCreated = TRUE;

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	dh, 32					; 00000020H
	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6517 : 
; 6518 :                // If the linked instance is flagged as created then we need
; 6519 :                // to set it's included flag on so that the *relationship*
; 6520 :                // is still created.
; 6521 :                if ( lpLinked->u.nInd.bCreated )

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	je	SHORT $L9693

; 6522 :                   lpLinked->u.nInd.bIncluded = TRUE;

	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L9693:

; 6523 :             }

	jmp	SHORT $L9691
$L9692:

; 6525 :       } // for ( lpEntityInstance && nRC == 0 )

	jmp	$L9677
$L9678:

; 6528 : 
; 6529 :    //==============================================================
; 6530 :    // PASS Number 4, do insert relationships
; 6531 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L9698

; 6533 :       for ( lpEntityInstance = lpRootEntityInstance;
; 6534 :             lpEntityInstance && nRC == 0;
; 6535 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx
	jmp	SHORT $L9696
$L9697:
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9696:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9698
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$L9698

; 6537 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6538 : 
; 6539 :          // EIs down a derived path don't get committed to the database.
; 6540 :          // Since all children of a derived EI are also derived we can skip
; 6541 :          // the twins of the current EI.
; 6542 :          if ( lpViewEntity->bDerivedPath )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	test	edx, edx
	je	SHORT $L9700
$L9702:

; 6544 :             while ( lpEntityInstance->hNextTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $L9703

; 6545 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9702
$L9703:

; 6546 : 
; 6547 :             continue;

	jmp	SHORT $L9697
$L9700:

; 6549 : 
; 6550 : #if ( VIEWENT_RULES )
; 6551 :          // If we don't allow includes then skip it.
; 6552 :          if ( lpViewEntity->bInclude == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 3
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9705

; 6553 :             continue;

	jmp	SHORT $L9697
$L9705:

; 6554 : #endif
; 6555 : 
; 6556 :          // If the entity doesn't have a parent (i.e. it's the root) then
; 6557 :          // we don't want to include it...there's nothing to include.  So
; 6558 :          // just flag it as already included.
; 6559 :          if ( lpEntityInstance->hParent == 0 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+30], 0
	jne	SHORT $L9706

; 6561 :             lpEntityInstance->u.nInd.bDBHIncluded = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ch, -128				; ffffff80H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6562 :             continue;

	jmp	$L9697
$L9706:

; 6564 : 
; 6565 :          // Include relationship if prev dbcall was OK and the entity...
; 6566 :          if ( lpEntityInstance->u.nInd.bIncluded             && // was included and...
; 6567 :               lpEntityInstance->u.nInd.bExcluded == FALSE    && // wasn't committed and...
; 6568 :               lpEntityInstance->u.nInd.bDBHIncluded == FALSE && // wasn't committed and...
; 6569 :               lpEntityInstance->u.nInd.bHidden == FALSE )       // is not hidden.

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	je	$L9707
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9707
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9707
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9707

; 6571 :             // Set entity cursor to point to lpEntityInstance.
; 6572 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6573 : 
; 6574 :             // Call DBHandler routine.
; 6575 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_InsertRel, 0,
; 6576 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	0
	push	32770					; 00008002H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6577 : 
; 6578 :             lpEntityInstance->u.nInd.bDBHIncluded = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	dh, -128				; ffffff80H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6579 : 
; 6580 :             // Set the bDBHIncluded flag for all linked EIs that have the
; 6581 :             // exact same relationship as lpEntityInstance.
; 6582 :             fnMarkDuplicateRelationship( lpEntityInstance, TRUE );

	push	1
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnMarkDuplicateRelationship@8
$L9707:

; 6584 :       } // for ( lpEntityInstance != lpStopInstance && nRC == 0 )

	jmp	$L9697
$L9698:

; 6586 : 
; 6587 :    //==============================================================
; 6588 :    // PASS Number 5, do entity updates
; 6589 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$L9713

; 6591 :       for ( lpEntityInstance = lpRootEntityInstance;
; 6592 :             lpEntityInstance && nRC == 0;
; 6593 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9711
$L9712:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9711:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9713
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L9713

; 6595 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6596 : 
; 6597 :          // EIs down a derived path don't get committed to the database.
; 6598 :          // Since all children of a derived EI are also derived we can skip
; 6599 :          // the twins of the current EI.
; 6600 :          if ( lpViewEntity->bDerivedPath )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9715
$L9717:

; 6602 :             while ( lpEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $L9718

; 6603 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9717
$L9718:

; 6604 : 
; 6605 :             continue;

	jmp	SHORT $L9712
$L9715:

; 6607 : 
; 6608 : #if ( VIEWENT_RULES )
; 6609 :          if ( lpViewEntity->bUpdate == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9721

; 6611 :             // the DB is relational and we need to update because of an
; 6612 :             // included or excluded entity.
; 6613 :             if ( bRelational == FALSE ||
; 6614 :                  (lpEntityInstance->u.nInd.bIncluded == FALSE &&
; 6615 :                   lpEntityInstance->u.nInd.bExcluded == FALSE) )

	mov	ecx, DWORD PTR _bRelational$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9722
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9721
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9721
$L9722:

; 6617 :                continue;

	jmp	$L9712
$L9721:

; 6620 : #endif
; 6621 : 
; 6622 :          // Update entity if the entity...
; 6623 :          if ( lpEntityInstance->u.nInd.bDBHUpdated == FALSE && // not already updated...
; 6624 :               lpEntityInstance->u.nInd.bUpdated == TRUE     && // was updated and...
; 6625 :               lpEntityInstance->u.nInd.bHidden == FALSE     && // isn't hidden and...
; 6626 :               lpEntityInstance->u.nInd.bCreated == FALSE    && // wasn't created and...
; 6627 :               lpEntityInstance->u.nInd.bDeleted == FALSE )     // wasn't deleted and...

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 17					; 00000011H
	and	ecx, 1
	test	ecx, ecx
	jne	$L9723
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	cmp	eax, 1
	jne	$L9723
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	$L9723
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	$L9723
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	$L9723

; 6629 :             // Set entity cursor to point to lpEntityInstance.
; 6630 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6631 : 
; 6632 :             // Call DBHandler routine.
; 6633 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_Update, 0,
; 6634 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	32784					; 00008010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6635 : 
; 6636 :             // Flag that message sent to handler
; 6637 :             lpEntityInstance->u.nInd.bDBHUpdated = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 131072				; 00020000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6638 : 
; 6639 :             // If the EI is flagged as excluded then we have updated the EI
; 6640 :             // to blank out an empty key so now flag it as hidden.
; 6641 :             if ( lpEntityInstance->u.nInd.bExcluded )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9725

; 6642 :                lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 4
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9725:

; 6643 : 
; 6644 :             // Turn on the dbh flag for all linked instances.  This will
; 6645 :             // keep them from being updated again.
; 6646 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 6647 :                   lpLinked && lpLinked != lpEntityInstance;
; 6648 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
	jmp	SHORT $L9728
$L9729:
	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
$L9728:
	cmp	DWORD PTR _lpLinked$[ebp], 0
	je	SHORT $L9730
	mov	eax, DWORD PTR _lpLinked$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9730

; 6650 :                lpLinked->u.nInd.bDBHUpdated = TRUE;

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 131072				; 00020000H
	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6651 :             }

	jmp	SHORT $L9729
$L9730:

; 6653 :          else

	jmp	SHORT $L9732
$L9723:

; 6654 :          if ( lpEntityInstance->u.nInd.bSequenceUpdt )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 19					; 00000013H
	and	edx, 1
	test	edx, edx
	je	SHORT $L9732

; 6656 :             // Set entity cursor to point to lpEntityInstance.
; 6657 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6658 : 
; 6659 :             // Call DBHandler routine.
; 6660 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_UpdateSeq, 0,
; 6661 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	34816					; 00008800H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6662 : 
; 6663 :             // Flag that message sent to handler
; 6664 :             lpEntityInstance->u.nInd.bDBHUpdated = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 131072				; 00020000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9732:

; 6666 :       }  // for ( lpEntityInstance && nRC == 0 )...

	jmp	$L9712
$L9713:

; 6668 : 
; 6669 :    //==============================================================
; 6670 :    // All deletes, updates, and inserts have been performed.
; 6671 : 
; 6672 :    // Turn the hidden flag back on for deleted/excluded instances.
; 6673 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 6674 :          lpEntityInstance;
; 6675 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9736
$L9737:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9736:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L9738

; 6677 :       if ( lpEntityInstance->u.nInd.bDeleted ||
; 6678 :            lpEntityInstance->u.nInd.bExcluded )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9740
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	SHORT $L9739
$L9740:

; 6680 :          lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	dh, 4
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$L9739:

; 6682 :    }

	jmp	SHORT $L9737
$L9738:

; 6683 : 
; 6684 :    // If the view is left at a subobject after processing, reset it
; 6685 :    // back to the top level
; 6686 :    while ( fnResetViewFromSubobject( lpView ) == 0 );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetViewFromSubobject
	add	esp, 4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L9743
	jmp	SHORT $L9738
$L9743:

; 6687 : 
; 6688 :    if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $L9746

; 6690 :       if ( nRC < zDUPLICATE_ROOT )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -4					; fffffffcH
	jge	SHORT $L9745

; 6691 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L9581
$L9745:

; 6692 :       else
; 6693 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L9581
$L9746:

; 6695 : 
; 6696 :    return( 0 ); // Everything OK.

	xor	ax, ax
$L9581:

; 6697 : 
; 6698 : } // fnCommitSingleOI

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnCommitSingleOI@16 ENDP
_TEXT	ENDS
PUBLIC	_fnDropObjectInstance
_TEXT	SEGMENT
_lpViewCluster$ = 8
_lpViewArray$ = 12
_nViewCount$ = 16
_pnViewErrorIdx$ = 20
_lpCurrentTask$ = 24
_lControl$ = 28
_pViewArrayBlock$ = 32
_lpViewOD$ = -8
_lpViewOI$ = -48
_lpViewCsr$ = -4
_lpTaskDBHandler$ = -32
_lpEntityInstance$ = -20
_pGKOper$ = -52
_pOper$ = -24
_lpPtr$ = -16
_lpKZGKHWOB$ = -44
_vSubtask$ = -40
_bTransactionStartedHere$ = -28
_k$ = -36
_nRC$ = -12
_vTemp$9821 = -56
_fnCommitObjectInstance@28 PROC NEAR

; 6730 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 6731 :    LPVIEWOD             lpViewOD;
; 6732 :    LPVIEWOI             lpViewOI;
; 6733 :    LPVIEWCSR            lpViewCsr;
; 6734 :    LPTASKDBHANDLER      lpTaskDBHandler;
; 6735 :    LPENTITYINSTANCE     lpEntityInstance;
; 6736 :    zPGKHOPER            pGKOper = 0;

	mov	DWORD PTR _pGKOper$[ebp], 0

; 6737 :    zPDBHOPER            pOper;
; 6738 :    zPVOID               lpPtr;
; 6739 :    zVIEW                lpKZGKHWOB;
; 6740 :    zVIEW                vSubtask;
; 6741 :    zBOOL                bTransactionStartedHere;
; 6742 :    zSHORT               k;
; 6743 :    zSHORT               nRC;
; 6744 : 
; 6745 :    // Find the first non-zero view in the list.  We'll use this to pass into
; 6746 :    // the DBHandler so that the DBH knows what DB where dealing with.
; 6747 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9775
$L9776:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9775:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $L9777

; 6749 :       if ( lpViewCluster[ k ].vOI )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $L9778

; 6751 :          vSubtask = lpViewCluster[ k ].vOI;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _vSubtask$[ebp], ecx

; 6752 :          break;

	jmp	SHORT $L9777
$L9778:

; 6754 :    }

	jmp	SHORT $L9776
$L9777:

; 6755 : 
; 6756 :    // Turn off the DBH flags for all entity instances.  This allows
; 6757 :    // us to figure out if the entity instance was processed.
; 6758 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9779
$L9780:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9779:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$L9781

; 6760 :       if ( lpViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L9782

; 6761 :          continue;

	jmp	SHORT $L9780
$L9782:

; 6762 : 
; 6763 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6764 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6765 : 
; 6766 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 6767 :             lpEntityInstance;
; 6768 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9787
$L9788:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9787:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9789

; 6770 :          lpEntityInstance->u.nInd.bDBHCreated =
; 6771 :             lpEntityInstance->u.nInd.bDBHIncluded  =
; 6772 :             lpEntityInstance->u.nInd.bDBHDeleted   =
; 6773 :             lpEntityInstance->u.nInd.bDBHExcluded  =
; 6774 :             lpEntityInstance->u.nInd.bDBHUpdated   =
; 6775 :             lpEntityInstance->u.nInd.bSequenceUpdt =
; 6776 :             lpEntityInstance->u.nInd.bGenKeyNeeded =
; 6777 :             lpEntityInstance->u.nInd.bNoGenKey     =
; 6778 :             lpEntityInstance->u.nInd.bForeignKeys  = 0;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -4194305				; ffbfffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -2097153				; ffdfffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -1048577				; ffefffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -524289				; fff7ffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -131073				; fffdffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -65537				; fffeffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -65					; ffffffbfH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, 127					; 0000007fH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 6779 :       }

	jmp	$L9788
$L9789:

; 6780 :    }

	jmp	$L9780
$L9781:

; 6781 : 
; 6782 :    // Initialize the genkey handler and create the genkeys.  This will also
; 6783 :    // determine if any EI's need to have foreign keys set.
; 6784 :    lpKZGKHWOB = 0;

	mov	DWORD PTR _lpKZGKHWOB$[ebp], 0

; 6785 :    nRC = fnInitializeGenKeys( lpViewArray, nViewCount, pnViewErrorIdx,
; 6786 :                               lpCurrentTask, &lpKZGKHWOB, &pGKOper,
; 6787 :                               pViewArrayBlock );

	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	push	edx
	lea	eax, DWORD PTR _pGKOper$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	push	eax
	mov	cx, WORD PTR _nViewCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	push	edx
	call	_fnInitializeGenKeys@28
	mov	WORD PTR _nRC$[ebp], ax

; 6788 :    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L9790

; 6789 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9761
$L9790:

; 6790 : 
; 6791 :    // Make sure that DBHandler is out there.
; 6792 :    lpTaskDBHandler = fnGetDBHandlerOper( lpCurrentTask, vSubtask, &pOper );

	lea	ecx, DWORD PTR _pOper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnGetDBHandlerOper@12
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax

; 6793 :    if ( lpTaskDBHandler == 0 )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	jne	SHORT $L9791

; 6794 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9761
$L9791:

; 6795 : 
; 6796 :    if ( lpTaskDBHandler->bTranStarted )

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	and	edx, 1
	test	edx, edx
	je	SHORT $L9792

; 6798 :       bTransactionStartedHere = FALSE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 0

; 6799 :       lpPtr = lpTaskDBHandler->lpConnection;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	mov	DWORD PTR _lpPtr$[ebp], ecx

; 6801 :    else

	jmp	SHORT $L9793
$L9792:

; 6803 :       // Call DBHandler routine to issue start of transaction.
; 6804 :       lpViewOD = zGETPTR( vSubtask->hViewOD );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 6805 :       lpPtr = 0;

	mov	DWORD PTR _lpPtr$[ebp], 0

; 6806 :       nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 6807 :                       DBH_Object | DBH_TranBegin, DBH_StoreOI, lpViewOD,
; 6808 :                       0, vSubtask, 0, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	2
	push	16385					; 00004001H
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6809 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9797

; 6810 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9761
$L9797:

; 6811 : 
; 6812 :       bTransactionStartedHere = TRUE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 1

; 6813 :       lpTaskDBHandler->bTranStarted = TRUE;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	or	ecx, 1
	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [edx+26], ecx

; 6814 :       lpTaskDBHandler->lpConnection = lpPtr;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR _lpPtr$[ebp]
	mov	DWORD PTR [eax+18], ecx
$L9793:

; 6816 : 
; 6817 :    // Commit each view separately.
; 6818 :    for ( k = 0; k < nViewCount && nRC >= 0; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9798
$L9799:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9798:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L9800
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L9800

; 6820 :       // If the view is 0 then we're not supposed to commit it (maybe it
; 6821 :       // wasn't changed?) so just skip it.
; 6822 :       if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L9801

; 6823 :          continue;

	jmp	SHORT $L9799
$L9801:

; 6824 : 
; 6825 :       nRC = fnCommitSingleOI( lpViewArray[ k ], lControl, lpCurrentTask,
; 6826 :                               lpTaskDBHandler );

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_fnCommitSingleOI@16
	mov	WORD PTR _nRC$[ebp], ax

; 6827 : 
; 6828 :       // If there was an error then stop committing.
; 6829 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9802

; 6831 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L9803

; 6832 :             *pnViewErrorIdx = k;

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR [eax], cx
$L9803:

; 6833 : 
; 6834 :          break;

	jmp	SHORT $L9800
$L9802:

; 6836 :    }

	jmp	SHORT $L9799
$L9800:

; 6837 : 
; 6838 :    // If genkey work object defined, call genkey handler to commit genkeys.
; 6839 :    if ( lpKZGKHWOB )

	cmp	DWORD PTR _lpKZGKHWOB$[ebp], 0
	je	SHORT $L9804

; 6841 :       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $L9805

; 6842 :          (*pGKOper)( DBH_Commit, vSubtask, 0, 0, lpKZGKHWOB );

	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	2
	call	DWORD PTR _pGKOper$[ebp]

; 6843 :       else

	jmp	SHORT $L9806
$L9805:

; 6844 :          (*pGKOper)( DBH_Rollback, vSubtask, 0, 0, lpKZGKHWOB );

	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	4
	call	DWORD PTR _pGKOper$[ebp]
$L9806:

; 6845 : 
; 6846 :       fnDropObjectInstance( lpKZGKHWOB );

	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	ecx
	call	_fnDropObjectInstance
	add	esp, 4
$L9804:

; 6848 : 
; 6849 :    // End the transaction if the transaction was started in this function call.
; 6850 :    if ( bTransactionStartedHere || lControl & zCOMMIT_FORCETRAN )

	mov	edx, DWORD PTR _bTransactionStartedHere$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L9808
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $L9812
$L9808:

; 6852 :       // We're about to close the transaction so set flag.
; 6853 :       lpTaskDBHandler->bTranStarted = FALSE;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [eax+26], edx

; 6854 :       lpTaskDBHandler->lpConnection = 0;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [ecx+18], 0

; 6855 : 
; 6856 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9809

; 6858 :          // Call DBHandler routine to issue rollback.
; 6859 :          (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 6860 :                    DBH_Object | DBH_Rollback, 0, lpViewOD,
; 6861 :                    0, vSubtask, 0, &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	16388					; 00004004H
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]

; 6863 :       else

	jmp	SHORT $L9812
$L9809:

; 6865 :          // Incremental update succeeded; issue commit to DBhandler.
; 6866 :          nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 6867 :                          DBH_Object | DBH_Commit, DBH_StoreOI, lpViewOD, 0,
; 6868 :                          vSubtask, 0, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	2
	push	16386					; 00004002H
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$L9812:

; 6871 : 
; 6872 :    // If view was activated with locking then delete the locks.
; 6873 :    if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L9816

; 6875 :       // A LOD has been committed using pessimistic locks.  Delete the locks
; 6876 :       // on the LODs.
; 6877 :       if ( fnRemoveLocksOnOIs( lpCurrentTask, lpViewCluster,
; 6878 :                                nViewCount, pnViewErrorIdx ) != 0 )

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	push	eax
	mov	cx, WORD PTR _nViewCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnRemoveLocksOnOIs@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9816

; 6880 :          nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H
$L9816:

; 6883 : 
; 6884 :    // If the transaction failed, return an error.
; 6885 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9817

; 6886 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L9761
$L9817:

; 6887 : 
; 6888 :    // If the commit is OK and we have optimistic locking, then drop the
; 6889 :    // "old" OI and replace it with a copy of the new OI.
; 6890 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9818
$L9819:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9818:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$L9820

; 6892 :       zVIEW vTemp;
; 6893 : 
; 6894 :       if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L9822

; 6895 :          continue;

	jmp	SHORT $L9819
$L9822:

; 6896 : 
; 6897 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6898 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6899 : 
; 6900 :       if ( lpViewOI->lActivateControl & zACTIVATE_WITH_LOCKING &&
; 6901 :            (lpViewOD->nLock == zLL_OPTIMISTIC_NOINC ||
; 6902 :             lpViewOD->nLock == zLL_OPTIMISTIC_CMPRALL) )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	$L9825
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 1
	je	SHORT $L9826
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+236]
	cmp	ecx, 2
	jne	SHORT $L9825
$L9826:

; 6904 :          fnDropView( zGETPTR( lpViewOI->vOriginalOI ) );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4

; 6905 :          ActivateOI_FromOI_ForTask( &vTemp, lpViewArray[ k ], 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	lea	ecx, DWORD PTR _vTemp$9821[ebp]
	push	ecx
	call	_ActivateOI_FromOI_ForTask@16

; 6906 :          lpViewOI->vOriginalOI = zGETHNDL( vTemp );

	mov	edx, DWORD PTR _vTemp$9821[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 6907 :          vTemp->bOrigView      = TRUE;

	mov	edx, DWORD PTR _vTemp$9821[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, -128				; ffffff80H
	mov	ecx, DWORD PTR _vTemp$9821[ebp]
	mov	DWORD PTR [ecx+30], eax

; 6908 :          vTemp->bViewLocked    = TRUE;

	mov	edx, DWORD PTR _vTemp$9821[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _vTemp$9821[ebp]
	mov	DWORD PTR [ecx+30], eax

; 6909 :          vTemp->hMainOI        = lpViewCsr->hViewOI;

	mov	edx, DWORD PTR _vTemp$9821[ebp]
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR [edx+26], ecx
$L9825:

; 6911 : 
; 6912 :       if ( (lControl & zCOMMIT_NOCLEANUP) == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 256				; 00000100H
	test	edx, edx
	jne	SHORT $L9829

; 6914 :          // Clean-up and reclaim hidden (i.e. deleted) instances.
; 6915 :          fnCleanupInstance( lpViewArray[ k ], 1 );

	push	1
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_fnCleanupInstance
	add	esp, 8
$L9829:

; 6917 : 
; 6918 :       // Mark the object instance as not updated.
; 6919 :       lpViewOI->bUpdated = lpViewOI->bUpdatedFile = 0;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 6920 :    }

	jmp	$L9819
$L9820:

; 6921 : 
; 6922 :    return( 0 );

	xor	ax, ax
$L9761:

; 6923 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_fnCommitObjectInstance@28 ENDP
_TEXT	ENDS
PUBLIC	_fnPutDataToFile@20
EXTRN	_SysWriteLine@12:NEAR
EXTRN	_SysWriteLineLth@20:NEAR
_TEXT	SEGMENT
_lpTaskView$ = 8
_lpvData$ = 12
_pchBuffer$ = 16
_ulLth$ = 20
_lpFileData$ = -4
_fnPutDataToFile@20 PROC NEAR

; 6931 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6932 :    LPFILEDATA lpFileData = (LPFILEDATA) lpvData;

	mov	eax, DWORD PTR _lpvData$[ebp]
	mov	DWORD PTR _lpFileData$[ebp], eax

; 6933 : 
; 6934 :    if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $L9844

; 6935 :       return( SysWriteLineLth( lpTaskView, lpFileData->hFile, pchBuffer, ulLth, TRUE ) );

	push	1
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_SysWriteLineLth@20
	jmp	SHORT $L9845
$L9844:

; 6936 :    else
; 6937 :       return( SysWriteLine( lpTaskView, lpFileData->hFile, pchBuffer ) );

	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysWriteLine@12
$L9845:

; 6938 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnPutDataToFile@20 ENDP
_TEXT	ENDS
PUBLIC	_UUENCODE_NextEncodedLine@16
PUBLIC	_fnWriteOI_ToTextStream
PUBLIC	??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@		; `string'
PUBLIC	??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@	; `string'
PUBLIC	??_C@_0N@OMJF@mOIFLAGS?5?$CFlx?$AA@		; `string'
PUBLIC	??_C@_0BA@GFPC@mOIFLAGS?5?5?5?5?$CFlx?$AA@	; `string'
PUBLIC	??_C@_05HEAD@?$CFx?5?$CFx?$AA@			; `string'
PUBLIC	??_C@_09GLEP@mETAG?5?$CFlx?$AA@			; `string'
PUBLIC	??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@	; `string'
PUBLIC	??_C@_09KKHA@mEKEY?5?$CFlx?$AA@			; `string'
PUBLIC	??_C@_0P@IJFA@mEKEY?5?5?5?5?5?5?$CFlx?$AA@	; `string'
PUBLIC	??_C@_04NHOC@?0?$CFlx?$AA@			; `string'
PUBLIC	??_C@_07HIC@a?$CFlx?$CFs?5?$AA@			; `string'
PUBLIC	??_C@_04DCMN@?$CFs?$CFs?$AA@			; `string'
PUBLIC	??_C@_06IACC@a?$CF?99s?5?$AA@			; `string'
PUBLIC	??_C@_04KPK@a?5?$CFx?$AA@			; `string'
PUBLIC	??_C@_0FA@OBP@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Src?5View?5E@ ; `string'
PUBLIC	??_C@_0DN@MLKO@Error?5writing?5OI?3?5ER?5Tokens?5don?8@ ; `string'
PUBLIC	??_C@_08GN@i?$CFlx?5?$CFlx?$AA@			; `string'
PUBLIC	??_C@_05KPKL@c?$CFx?50?$AA@			; `string'
PUBLIC	??_C@_07BFPN@c?$CFx?5?$CFlx?$AA@		; `string'
EXTRN	_fnGetStringFromAttribute:NEAR
EXTRN	_fnGetIntegerFromAttribute:NEAR
EXTRN	_fnGetAddrForAttribute:NEAR
EXTRN	_fnDisplayEntityInstance:NEAR
EXTRN	_fnGetAttributeLength:NEAR
EXTRN	_strlen:NEAR
EXTRN	__imp__atol:NEAR
EXTRN	__imp___ltoa:NEAR
;	COMDAT ??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@ DB 'mOITAG %lx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@ DB 'mOITAG      %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@OMJF@mOIFLAGS?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0N@OMJF@mOIFLAGS?5?$CFlx?$AA@ DB 'mOIFLAGS %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GFPC@mOIFLAGS?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0BA@GFPC@mOIFLAGS?5?5?5?5?$CFlx?$AA@ DB 'mOIFLAGS    %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_05HEAD@?$CFx?5?$CFx?$AA@
_DATA	SEGMENT
??_C@_05HEAD@?$CFx?5?$CFx?$AA@ DB '%x %x', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GLEP@mETAG?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_09GLEP@mETAG?5?$CFlx?$AA@ DB 'mETAG %lx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@ DB 'mETAG      %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KKHA@mEKEY?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_09KKHA@mEKEY?5?$CFlx?$AA@ DB 'mEKEY %lx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@IJFA@mEKEY?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0P@IJFA@mEKEY?5?5?5?5?5?5?$CFlx?$AA@ DB 'mEKEY      %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NHOC@?0?$CFlx?$AA@
_DATA	SEGMENT
??_C@_04NHOC@?0?$CFlx?$AA@ DB ',%lx', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HIC@a?$CFlx?$CFs?5?$AA@
_DATA	SEGMENT
??_C@_07HIC@a?$CFlx?$CFs?5?$AA@ DB 'a%lx%s ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DCMN@?$CFs?$CFs?$AA@
_DATA	SEGMENT
??_C@_04DCMN@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IACC@a?$CF?99s?5?$AA@
_DATA	SEGMENT
??_C@_06IACC@a?$CF?99s?5?$AA@ DB 'a%-9s ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04KPK@a?5?$CFx?$AA@
_DATA	SEGMENT
??_C@_04KPK@a?5?$CFx?$AA@ DB 'a %x', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FA@OBP@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Src?5View?5E@
_DATA	SEGMENT
??_C@_0FA@OBP@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Src?5View?5E@ DB '('
	DB	'oi) Error (OD: %s) - Src View Entity: %s Token: %d  View Enti'
	DB	'ty: %s Token = %d', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DN@MLKO@Error?5writing?5OI?3?5ER?5Tokens?5don?8@
_DATA	SEGMENT
??_C@_0DN@MLKO@Error?5writing?5OI?3?5ER?5Tokens?5don?8@ DB 'Error writing'
	DB	' OI: ER Tokens don''t match for linked entities!', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GN@i?$CFlx?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_08GN@i?$CFlx?5?$CFlx?$AA@ DB 'i%lx %lx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KPKL@c?$CFx?50?$AA@
_DATA	SEGMENT
??_C@_05KPKL@c?$CFx?50?$AA@ DB 'c%x 0', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07BFPN@c?$CFx?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_07BFPN@c?$CFx?5?$CFlx?$AA@ DB 'c%x %lx', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_lpfnStreamFunc$ = 12
_lpvData$ = 16
_bIncremental$ = 20
_lControl$ = 24
_lpApp$ = -352
_lpViewOD$ = -12
_lpViewOI$ = -404
_lpViewEntity$ = -28
_lpViewAttrib$ = -40
_lpViewCsr$ = -4
_lpEntityInstance$ = -24
_ViewEntityCsr$ = -400
_lpTask$ = -32
_lpAttribFlags$ = -364
_pchAttr$ = -20
_pchBuffer$ = -36
_szWorkString$ = -348
_lLastLinkedInstance$ = -368
_lHierCount$ = -408
_ulLth$ = -360
_uPos$ = -48
_bMsgBox$ = -44
_nLevel$ = -8
_k$ = -356
_nRC$ = -16
_uFlags$9903 = -412
_bEntityIsCompressed$9919 = -424
_pchBufferEnd$9920 = -416
_bValuesStored$9921 = -420
_lTemp$9943 = -428
_lpLinked$9969 = -432
_l$9991 = -436
_bStringContainsSpecialChars$10001 = -452
_szAttribFlags$10002 = -448
_szAttribName$10011 = -504
_pch$10015 = -508
_cStreamType$10026 = -512
_bAttribIsNull$10056 = -516
_l$10058 = -520
_szLth$10069 = -540
_lpSourceEntityInstance$10078 = -544
_lpTask$10107 = -556
_vWork$10109 = -548
_lpWorkViewEntityCsr$10110 = -552
_lpSrcViewEntity$10116 = -560
_lpViewEntityCsr$10132 = -572
_lpCurrentEI$10133 = -568
_lInstanceCount$10134 = -564
_lpSrchInstance$10148 = -576
_bNoTwins$10149 = -580
_fnWriteOI_ToTextStream PROC NEAR

; 6954 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 584				; 00000248H

; 6955 :    LPAPP                lpApp;
; 6956 :    LPVIEWOD             lpViewOD;
; 6957 :    LPVIEWOI             lpViewOI;
; 6958 :    LPVIEWENTITY         lpViewEntity;
; 6959 :    LPVIEWATTRIB         lpViewAttrib;
; 6960 :    LPVIEWCSR            lpViewCsr;
; 6961 :    LPENTITYINSTANCE     lpEntityInstance;
; 6962 :    ViewEntityCsrRecord  ViewEntityCsr;
; 6963 :    LPTASK               lpTask;
; 6964 :    LPATTRIBFLAGS        lpAttribFlags;
; 6965 :    zPCHAR               pchAttr;
; 6966 :    zPCHAR               pchBuffer = 0;

	mov	DWORD PTR _pchBuffer$[ebp], 0

; 6967 :    zCHAR                szWorkString[ 300 ];
; 6968 :    zLONG                lLastLinkedInstance;
; 6969 :    zLONG                lHierCount;
; 6970 :    zULONG               ulLth;
; 6971 :    zULONG               uPos;
; 6972 :    zBOOL                bMsgBox = TRUE;

	mov	BYTE PTR _bMsgBox$[ebp], 1

; 6973 :    zSHORT               nLevel;
; 6974 :    zSHORT               k;
; 6975 :    zSHORT               nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 6976 : 
; 6977 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6978 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6979 :    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 6980 :    lpApp     = zGETPTR( lpViewOD->hApp );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 6981 :    lpTask    = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 6982 : 
; 6983 :    // If user wants entity tags, write out the tag for the OI.
; 6984 :    if ( lControl & zENTITY_TAGS )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 524288				; 00080000H
	test	ecx, ecx
	je	SHORT $L9884

; 6986 :       if ( lControl & zCOMPRESSED )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L9885

; 6987 :          zsprintf( szWorkString, "mOITAG %lx", (zLONG) lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 6988 :       else

	jmp	SHORT $L9888
$L9885:

; 6989 :          zsprintf( szWorkString, "mOITAG      %lx", (zLONG) lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9888:

; 6990 : 
; 6991 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9891

; 6992 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9857
$L9891:

; 6994 :    else

	jmp	SHORT $L9896
$L9884:

; 6995 :    if ( lpViewOI->lTag )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $L9896

; 6997 :       // If the tag for the current OI is non-zero, then we'll write it.
; 6998 :       if ( lControl & zCOMPRESSED )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L9894

; 6999 :          zsprintf( szWorkString, "mOITAG %lx", lpViewOI->lTag );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	push	OFFSET FLAT:??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7000 :       else

	jmp	SHORT $L9895
$L9894:

; 7001 :          zsprintf( szWorkString, "mOITAG      %lx", lpViewOI->lTag );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	push	OFFSET FLAT:??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9895:

; 7002 : 
; 7003 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9896

; 7004 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9857
$L9896:

; 7006 : 
; 7007 :    // Set some flags.
; 7008 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 7009 :          lpEntityInstance;
; 7010 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9899
$L9900:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9899:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L9901

; 7012 :       lpEntityInstance->u.nInd.bWritten =
; 7013 :          lpEntityInstance->u.nInd.bRecordOwner = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ch, -17					; ffffffefH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 7014 : 
; 7015 :       lpEntityInstance->lHierCount = 0;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+54], 0

; 7016 :    }

	jmp	SHORT $L9900
$L9901:

; 7017 : 
; 7018 :    // We need to write some information about the OI.
; 7019 :    if ( lControl & zINCREMENTAL )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 65536				; 00010000H
	test	ecx, ecx
	je	$L9911

; 7021 :       zULONG uFlags = 0;

	mov	DWORD PTR _uFlags$9903[ebp], 0

; 7022 : 
; 7023 :       uFlags = 0;

	mov	DWORD PTR _uFlags$9903[ebp], 0

; 7024 :       if ( lpViewOI->bIsLocked )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 7
	and	eax, 1
	test	eax, eax
	je	SHORT $L9904

; 7025 :          uFlags |= zOI_ISLOCKED;

	mov	ecx, DWORD PTR _uFlags$9903[ebp]
	or	ecx, 1
	mov	DWORD PTR _uFlags$9903[ebp], ecx
$L9904:

; 7026 : 
; 7027 :       if ( lpView->bReadOnly )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	je	SHORT $L9905

; 7028 :          uFlags |= zOI_READONLY;

	mov	ecx, DWORD PTR _uFlags$9903[ebp]
	or	ecx, 2
	mov	DWORD PTR _uFlags$9903[ebp], ecx
$L9905:

; 7029 : 
; 7030 :       if ( uFlags )

	cmp	DWORD PTR _uFlags$9903[ebp], 0
	je	SHORT $L9911

; 7032 :          if ( lControl & zCOMPRESSED )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L9907

; 7033 :             zsprintf( szWorkString, "mOIFLAGS %lx", uFlags );

	mov	eax, DWORD PTR _uFlags$9903[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0N@OMJF@mOIFLAGS?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7034 :          else

	jmp	SHORT $L9909
$L9907:

; 7035 :             zsprintf( szWorkString, "mOIFLAGS    %lx", uFlags );

	mov	edx, DWORD PTR _uFlags$9903[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BA@GFPC@mOIFLAGS?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9909:

; 7036 : 
; 7037 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9911

; 7038 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9857
$L9911:

; 7041 : 
; 7042 :    // If we are writting the OI in a compressed format, we need a buffer.
; 7043 :    if ( lControl & zCOMPRESSED )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L9912

; 7045 :       // Allocate a buffer to contain attribute data for an entity.
; 7046 :       pchBuffer = fnAllocDataspace( lpTask->hFirstDataHeader,
; 7047 :                                     zENTITY_BUFFER_SIZE, 0, 0, iBuffer );

	push	10105					; 00002779H
	push	0
	push	0
	push	10000					; 00002710H
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pchBuffer$[ebp], eax

; 7048 :       pchBuffer = zGETPTR( pchBuffer );

	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchBuffer$[ebp], eax
$L9912:

; 7050 : 
; 7051 :    // write out the entity instances
; 7052 :    lpAttribFlags = 0;

	mov	DWORD PTR _lpAttribFlags$[ebp], 0

; 7053 :    lHierCount = 0;

	mov	DWORD PTR _lHierCount$[ebp], 0

; 7054 :    lLastLinkedInstance = -1;      // last linked relative instance counter

	mov	DWORD PTR _lLastLinkedInstance$[ebp], -1

; 7055 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 7056 :          lpEntityInstance;
; 7057 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9916
$L9917:
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9916:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9918

; 7059 :       zBOOL  bEntityIsCompressed;
; 7060 :       zPCHAR pchBufferEnd;
; 7061 :       zBOOL  bValuesStored;
; 7062 : 
; 7063 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 7064 : 
; 7065 :       // This entity can be compressed if:
; 7066 :       // o  lControl specifies compression.
; 7067 :       // o  The max size of all the attributes for the entity is smaller
; 7068 :       //    then the buffer we set up to hold all the attribute values.
; 7069 :       bEntityIsCompressed = lControl & zCOMPRESSED &&
; 7070 :                             lpViewEntity->ulMaxLth < zENTITY_BUFFER_SIZE;

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L12786
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+203], 10000		; 00002710H
	jae	SHORT $L12786
	mov	DWORD PTR -584+[ebp], 1
	jmp	SHORT $L12787
$L12786:
	mov	DWORD PTR -584+[ebp], 0
$L12787:
	mov	dl, BYTE PTR -584+[ebp]
	mov	BYTE PTR _bEntityIsCompressed$9919[ebp], dl

; 7071 : 
; 7072 : #if 0
; 7073 :       // DGC 02/25/98
; 7074 :       // Following code is called and may be (?) needed.
; 7075 :       if ( bIncremental &&
; 7076 :            lpEntityInstance->u.nInd.bExcluded &&
; 7077 :            lpEntityInstance->u.nInd.bDeleted &&
; 7078 :            lpEntityInstance->u.nInd.bCreated == FALSE &&
; 7079 :            lpEntityInstance->u.nInd.bIncluded == FALSE &&
; 7080 :            lpEntityInstance->u.nInd.bRelOwner &&
; 7081 :            lpViewEntity->bDelete == FALSE &&
; 7082 :            lpViewEntity->bExclude )
; 7083 :       {
; 7084 :          LPENTITYINSTANCE lpDupInstance;
; 7085 :          LPVIEWENTITY     lpDupViewEntity;
; 7086 : 
; 7087 :          lpDupInstance = lpEntityInstance;
; 7088 :          for ( ; ; )
; 7089 :          {
; 7090 :             lpDupInstance = fnFindDuplicateRelationship( lpDupInstance, 1, 0 );
; 7091 :             if ( lpDupInstance == 0 || lpDupInstance == lpEntityInstance )
; 7092 :                break;
; 7093 : 
; 7094 :             lpDupViewEntity = zGETPTR( lpDupInstance->hViewEntity );
; 7095 :             if ( lpDupInstance->u.nInd.bDeleted &&
; 7096 :                  lpDupViewEntity->bDerivedPath == FALSE &&
; 7097 :                  lpDupViewEntity->bDelete )
; 7098 :             {
; 7099 :                lpEntityInstance->u.nInd.bExcluded = FALSE;
; 7100 :                break;
; 7101 :             }
; 7102 :             else
; 7103 :             {
; 7104 :                lpDupInstance->u.nInd.bRelOwner = FALSE;
; 7105 :             }
; 7106 :          }
; 7107 :       }
; 7108 : #endif
; 7109 : 
; 7110 :       // Look to see if the current instance should be written out.  If
; 7111 :       // not we'll skip it and go on to the next one.  All non-hidden
; 7112 :       // instances get written so we'll look for that first.
; 7113 :       if ( lpEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	je	$L9924

; 7115 :          // The EI is hidden.  Don't write the current EI if we're not
; 7116 :          // writing incrementals or if the EI is dead.
; 7117 :          if ( bIncremental == FALSE ||
; 7118 :               fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	edx, DWORD PTR _bIncremental$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L9925
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnEntityInstanceIsDead@4
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9924
$L9925:

; 7120 :             nLevel = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLevel$[ebp], ax

; 7121 : 
; 7122 :             for ( lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );
; 7123 :                   lpEntityInstance;
; 7124 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9928
$L9929:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9928:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L9930

; 7126 :                if ( lpEntityInstance->nLevel <= nLevel )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $L9931

; 7127 :                   break;

	jmp	SHORT $L9930
$L9931:

; 7128 :             }

	jmp	SHORT $L9929
$L9930:

; 7129 : 
; 7130 :             if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L9932

; 7131 :                break;

	jmp	$L9918
$L9932:

; 7132 :             else
; 7133 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 7134 : 
; 7135 :             // Continue with the next EI.
; 7136 :             continue;

	jmp	$L9917
$L9924:

; 7139 : 
; 7140 :       lpEntityInstance->lHierCount = lHierCount++;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR _lHierCount$[ebp]
	mov	DWORD PTR [ecx+54], edx
	mov	eax, DWORD PTR _lHierCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _lHierCount$[ebp], eax

; 7141 : 
; 7142 :       // Build the entity name line.
; 7143 :       szWorkString[ 0 ] = 'e';

	mov	BYTE PTR _szWorkString$[ebp], 101	; 00000065H

; 7144 :       if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L9935

; 7146 :          // Use the hierarchical number instead of the entity name.
; 7147 :          zsprintf( szWorkString + 1, "%x %x", lpViewEntity->nHierNbr,
; 7148 :                    lpEntityInstance->nLevel );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	push	edx
	push	OFFSET FLAT:??_C@_05HEAD@?$CFx?5?$CFx?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp+1]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 7149 :          k = zstrlen( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7151 :       else

	jmp	$L9937
$L9935:

; 7153 :          zstrcpy( szWorkString + 1, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp+1]
	push	eax
	call	_strcpy
	add	esp, 8

; 7154 :          k = zstrlen( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7155 : 
; 7156 :          szWorkString[ k++ ] = ' ';

	movsx	edx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 32	; 00000020H
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9939:

; 7157 :          while ( k < 11 )

	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 11					; 0000000bH
	jge	SHORT $L9940

; 7158 :             szWorkString[ k++ ] = ' ';

	movsx	edx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 32	; 00000020H
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $L9939
$L9940:

; 7159 : 
; 7160 :          zltoa( lpEntityInstance->nLevel, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7161 :          k = zstrlen( szWorkString );

	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax
$L9937:

; 7163 : 
; 7164 :       // if we are writing an incremental file, write out the indicators.
; 7165 :       if ( bIncremental )

	mov	eax, DWORD PTR _bIncremental$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L9942

; 7167 :          szWorkString[ k++ ] = ',';

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 44	; 0000002cH
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 7168 :          zbtoa( lpEntityInstance->u.nIndicators, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7169 : 
; 7170 :          if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L9942

; 7172 :             zLONG lTemp;
; 7173 : 
; 7174 :             // Convert number for decimal format to hexadecimal.
; 7175 :             lTemp = zatol( &szWorkString[ k ] );

	movsx	edx, WORD PTR _k$[ebp]
	lea	eax, DWORD PTR _szWorkString$[ebp+edx]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lTemp$9943[ebp], eax

; 7176 :             zltox( lTemp, &szWorkString[ k ] );

	push	16					; 00000010H
	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lTemp$9943[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$L9942:

; 7179 : 
; 7180 :       // Write out the entity name.
; 7181 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9944

; 7182 :          goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L9944:

; 7183 : 
; 7184 :       // If user wants entity tags, write it.
; 7185 :       if ( lControl & zENTITY_TAGS )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 524288				; 00080000H
	test	edx, edx
	je	SHORT $L9946

; 7187 :          if ( lControl & zCOMPRESSED )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L9947

; 7188 :             zsprintf( szWorkString, "mETAG %lx", (zLONG) lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_09GLEP@mETAG?5?$CFlx?$AA@ ; `string'
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7189 :          else

	jmp	SHORT $L9950
$L9947:

; 7190 :             zsprintf( szWorkString, "mETAG      %lx", (zLONG) lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9950:

; 7191 : 
; 7192 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9953

; 7193 :             goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L9953:

; 7195 :       else

	jmp	SHORT $L9958
$L9946:

; 7196 :       if ( lpEntityInstance->lTag )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+46], 0
	je	SHORT $L9958

; 7198 :          // If the tag for the current entity instance is non-zero, then we'll
; 7199 :          // write it.
; 7200 :          if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L9956

; 7201 :             zsprintf( szWorkString, "mETAG %lx", lpEntityInstance->lTag );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+46]
	push	eax
	push	OFFSET FLAT:??_C@_09GLEP@mETAG?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7202 :          else

	jmp	SHORT $L9957
$L9956:

; 7203 :             zsprintf( szWorkString, "mETAG      %lx", lpEntityInstance->lTag );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+46]
	push	eax
	push	OFFSET FLAT:??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9957:

; 7204 : 
; 7205 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9958

; 7206 :             goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L9958:

; 7208 : 
; 7209 :       if ( lControl & zENTITY_KEYS )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2097152				; 00200000H
	test	eax, eax
	je	SHORT $L9964

; 7211 :          if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L9960

; 7212 :             zsprintf( szWorkString, "mEKEY %lx", lpEntityInstance->ulKey );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+50]
	push	eax
	push	OFFSET FLAT:??_C@_09KKHA@mEKEY?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7213 :          else

	jmp	SHORT $L9962
$L9960:

; 7214 :             zsprintf( szWorkString, "mEKEY      %lx", lpEntityInstance->ulKey );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+50]
	push	eax
	push	OFFSET FLAT:??_C@_0P@IJFA@mEKEY?5?5?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9962:

; 7215 : 
; 7216 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9964

; 7217 :             goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L9964:

; 7219 : 
; 7220 :       // If the EI has already been written (this means it's linked to another
; 7221 :       // EI that has already been written) and it has no non-persist record,
; 7222 :       // then we don't need to write it's attribute values.
; 7223 :       lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 7224 :       if ( lpEntityInstance->u.nInd.bWritten )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 12					; 0000000cH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9967

; 7226 :          lLastLinkedInstance = lpEntityInstance->lHierCount;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+54]
	mov	DWORD PTR _lLastLinkedInstance$[ebp], edx

; 7227 : 
; 7228 :          if ( lpEntityInstance->u.nInd.bHidden == FALSE &&
; 7229 :               lpEntityInstance->hNonPersistRecord == FALSE )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9967
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+64], 0
	jne	SHORT $L9967

; 7231 :             bEntityIsCompressed = FALSE; // Make sure we don't write anything

	mov	BYTE PTR _bEntityIsCompressed$9919[ebp], 0

; 7232 :             lpViewAttrib = 0;

	mov	DWORD PTR _lpViewAttrib$[ebp], 0
$L9967:

; 7235 : 
; 7236 :       // Set flag to indicate that entity instance has been written to
; 7237 :       // the stream.  Let's also mark all the linked instances.
; 7238 :       if ( lpEntityInstance->u.nInd.bWritten == FALSE &&
; 7239 :            lpEntityInstance->hNextLinked )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9974
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $L9974

; 7241 :          LPENTITYINSTANCE lpLinked;
; 7242 : 
; 7243 :          // Set the record owner.  This means that this EI will not have
; 7244 :          // link lines written (e.g. "i38,102") for it.
; 7245 :          lpEntityInstance->u.nInd.bRecordOwner = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 7246 : 
; 7247 :          for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 7248 :                lpLinked != lpEntityInstance;
; 7249 :                lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9969[ebp], eax
	jmp	SHORT $L9972
$L9973:
	mov	edx, DWORD PTR _lpLinked$9969[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9969[ebp], eax
$L9972:
	mov	ecx, DWORD PTR _lpLinked$9969[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9974

; 7251 :             // For a little insurance we'll only set the flags for EIs in
; 7252 :             // the same OI.
; 7253 :             if ( lpLinked->hViewOI == lpEntityInstance->hViewOI )

	mov	edx, DWORD PTR _lpLinked$9969[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	jne	SHORT $L9975

; 7254 :                lpLinked->u.nInd.bWritten = TRUE;

	mov	edx, DWORD PTR _lpLinked$9969[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 16					; 00000010H
	mov	ecx, DWORD PTR _lpLinked$9969[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9975:

; 7255 :          }

	jmp	SHORT $L9973
$L9974:

; 7257 : 
; 7258 :       lpEntityInstance->u.nInd.bWritten = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 16					; 00000010H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 7259 : 
; 7260 :       // Some stuff needs to be done if we're storing in compressed format...
; 7261 :       if ( bEntityIsCompressed )

	mov	edx, DWORD PTR _bEntityIsCompressed$9919[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L9976

; 7263 :          // pchBufferEnd points to the first unused byte in the compression
; 7264 :          // buffer.
; 7265 :          pchBufferEnd = pchBuffer;

	mov	eax, DWORD PTR _pchBuffer$[ebp]
	mov	DWORD PTR _pchBufferEnd$9920[ebp], eax

; 7266 : 
; 7267 :          // In rare cases an entity will have all NULL attribute
; 7268 :          // values (this will usually occur when an instance is linked).
; 7269 :          // If that happens, don't bother writting the attribute values.
; 7270 :          bValuesStored = FALSE;

	mov	BYTE PTR _bValuesStored$9921[ebp], 0
$L9976:

; 7272 : 
; 7273 :       ViewEntityCsr.hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _ViewEntityCsr$[ebp+26], eax

; 7274 : 
; 7275 :       // Write the attribute values.
; 7276 :       for ( ;              // assigned above
; 7277 :             lpViewAttrib;
; 7278 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	jmp	SHORT $L9979
$L9980:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L9979:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L9981

; 7280 :          static AttribFlagsRecord ZeroAttribFlags = { 0 };
; 7281 : 
; 7282 :          // If attribute is derived, don't bother.
; 7283 :          if ( lpViewAttrib->szDerivedOper[ 0 ] &&
; 7284 :               lpViewAttrib->bPersist == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+213]
	test	edx, edx
	je	SHORT $L9984
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9984

; 7286 :             continue;

	jmp	SHORT $L9980
$L9984:

; 7288 : 
; 7289 :          // If we are only writing keys and this attr isn't a key then skip it.
; 7290 :          if ( lControl & zWRITE_KEYS_ONLY && lpViewAttrib->bKey == FALSE )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1048576				; 00100000H
	test	edx, edx
	je	SHORT $L9985
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9985

; 7291 :             continue;

	jmp	SHORT $L9980
$L9985:

; 7292 : 
; 7293 :          // Get a pointer to the attribute flags if we are writing incremental
; 7294 :          // flags.  If we're not writing incremental then we'll leave the ptr
; 7295 :          // as it is--WHICH HAD BETTER BE 0.
; 7296 :          if ( bIncremental )

	mov	edx, DWORD PTR _bIncremental$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L9987

; 7298 :             lpAttribFlags = fnGetAttribFlagsPtr( lpEntityInstance,
; 7299 :                                                  lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$[ebp], eax

; 7300 : 
; 7301 :             // If lpAttribFlags is 0 then this means that a data record
; 7302 :             // (i.e. data stick) has been created for this attrib.  Just set
; 7303 :             // lpAttribFlags to point to a 0 flag record.
; 7304 :             if ( lpAttribFlags == 0 )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	jne	SHORT $L9987

; 7305 :                lpAttribFlags = &ZeroAttribFlags;

	mov	DWORD PTR _lpAttribFlags$[ebp], OFFSET FLAT:_?ZeroAttribFlags@?BJ@??fnWriteOI_ToTextStream@@9@9
$L9987:

; 7307 : 
; 7308 :          if ( bEntityIsCompressed && lpViewAttrib->cType != zTYPE_BLOB )

	mov	edx, DWORD PTR _bEntityIsCompressed$9919[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L9988
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	je	$L9988

; 7310 :             // If the entity is linked with another, then we don't need to store
; 7311 :             // the attribute value, but we do need to store a dummy value in the
; 7312 :             // attribute buffer.
; 7313 :             if ( lpViewAttrib->bPersist &&
; 7314 :                  lpEntityInstance->lHierCount == lLastLinkedInstance )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	test	eax, eax
	je	SHORT $L9989
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+54]
	cmp	edx, DWORD PTR _lLastLinkedInstance$[ebp]
	jne	SHORT $L9989

; 7316 :                *pchBufferEnd++ = 0;

	mov	eax, DWORD PTR _pchBufferEnd$9920[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pchBufferEnd$9920[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchBufferEnd$9920[ebp], ecx

; 7317 :                continue;

	jmp	$L9980
$L9989:

; 7319 : 
; 7320 :             if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $L9990

; 7322 :                zLONG l;
; 7323 : 
; 7324 :                if ( fnGetIntegerFromAttribute( &l, lpView, &ViewEntityCsr,
; 7325 :                                                lpViewAttrib ) != 0 )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l$9991[ebp]
	push	ecx
	call	_fnGetIntegerFromAttribute
	add	esp, 16					; 00000010H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9992

; 7327 :                   // Integer is null so set null value.
; 7328 :                   *pchBufferEnd = 0;

	mov	eax, DWORD PTR _pchBufferEnd$9920[ebp]
	mov	BYTE PTR [eax], 0

; 7330 :                else

	jmp	SHORT $L9995
$L9992:

; 7331 :                if ( l >= 0 )

	cmp	DWORD PTR _l$9991[ebp], 0
	jl	SHORT $L9994

; 7332 :                   zltox( l, pchBufferEnd );

	push	16					; 00000010H
	mov	ecx, DWORD PTR _pchBufferEnd$9920[ebp]
	push	ecx
	mov	edx, DWORD PTR _l$9991[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7333 :                else

	jmp	SHORT $L9995
$L9994:

; 7335 :                   *pchBufferEnd = '-';

	mov	eax, DWORD PTR _pchBufferEnd$9920[ebp]
	mov	BYTE PTR [eax], 45			; 0000002dH

; 7336 :                   zltox( l * -1, pchBufferEnd + 1 );

	push	16					; 00000010H
	mov	ecx, DWORD PTR _pchBufferEnd$9920[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _l$9991[ebp]
	imul	edx, -1
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$L9995:

; 7339 :             else

	jmp	SHORT $L9996
$L9990:

; 7340 :                fnGetStringFromAttribute( pchBufferEnd, zENTITY_BUFFER_SIZE,
; 7341 :                                          lpView, &ViewEntityCsr,
; 7342 :                                          lpViewAttrib, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	10000					; 00002710H
	mov	eax, DWORD PTR _pchBufferEnd$9920[ebp]
	push	eax
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
$L9996:

; 7343 : 
; 7344 :             // Check to see if we have a valid (i.e. non-null) attribute
; 7345 :             // value.  If we do, then we've stored a "real" value.
; 7346 :             if ( *pchBufferEnd )

	mov	ecx, DWORD PTR _pchBufferEnd$9920[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L9997

; 7347 :                bValuesStored = TRUE;

	mov	BYTE PTR _bValuesStored$9921[ebp], 1
$L9997:

; 7348 : 
; 7349 :             pchBufferEnd += zstrlen( pchBufferEnd ) + 1;

	mov	eax, DWORD PTR _pchBufferEnd$9920[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchBufferEnd$9920[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchBufferEnd$9920[ebp], edx

; 7350 : 
; 7351 :             // If the attrib flags is not 0 then we need to write them as well.
; 7352 :             if ( lpAttribFlags )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $L9998

; 7354 :                zltox( (zLONG) lpAttribFlags->u.uFlags, pchBufferEnd );

	push	16					; 00000010H
	mov	eax, DWORD PTR _pchBufferEnd$9920[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7355 :                pchBufferEnd += zstrlen( pchBufferEnd ) + 1;

	mov	eax, DWORD PTR _pchBufferEnd$9920[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchBufferEnd$9920[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchBufferEnd$9920[ebp], edx
$L9998:

; 7359 :          else

	jmp	$L10067
$L9988:

; 7361 :             zBOOL bStringContainsSpecialChars;
; 7362 :             zCHAR szAttribFlags[ 12 ];
; 7363 : 
; 7364 :             // If the current entity instance is a linked instance then we
; 7365 :             // don't need to store the attribute values because they'll be
; 7366 :             // included from the linked instance.  This is only TRUE for
; 7367 :             // persistent attributes.  Non-persistent attrs need to be stored
; 7368 :             // with the current EI.
; 7369 :             if ( lpViewAttrib->bPersist &&
; 7370 :                  lpEntityInstance->lHierCount == lLastLinkedInstance )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10003
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+54]
	cmp	eax, DWORD PTR _lLastLinkedInstance$[ebp]
	jne	SHORT $L10003

; 7372 :                continue;

	jmp	$L9980
$L10003:

; 7374 : 
; 7375 :             // If lpAttribFlags is not 0 then we're supposed to send the
; 7376 :             // attrib flags for each attribute.  To save space we won't bother
; 7377 :             // sending the flags if they are all off.
; 7378 :             if ( lpAttribFlags && lpAttribFlags->u.uFlags == 0 )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $L10004
	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L10004

; 7379 :                lpAttribFlags = 0;   // Indicates: don't bother sending flags.

	mov	DWORD PTR _lpAttribFlags$[ebp], 0
$L10004:

; 7380 : 
; 7381 :             // If the attrib flags is not 0 then set up string.
; 7382 :             if ( lpAttribFlags )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $L10005

; 7383 :                zsprintf( szAttribFlags, ",%lx", lpAttribFlags->u.uFlags );

	mov	edx, DWORD PTR _lpAttribFlags$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHOC@?0?$CFlx?$AA@	; `string'
	lea	ecx, DWORD PTR _szAttribFlags$10002[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7384 :             else

	jmp	SHORT $L10007
$L10005:

; 7385 :                szAttribFlags[ 0 ] = 0;

	mov	BYTE PTR _szAttribFlags$10002[ebp], 0
$L10007:

; 7386 : 
; 7387 :             // If we are here and zCOMPRESSED has been specified, then
; 7388 :             // the entity can't be compressed for some reason (the attribute
; 7389 :             // might be a blob, etc.) but we can still save a few bytes by
; 7390 :             // using XVATOK instead of the name.
; 7391 :             if ( lControl & zCOMPRESSED )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L10008

; 7392 :                zsprintf( szWorkString, "a%lx%s ", lpViewAttrib->lXVAAttTok,
; 7393 :                          szAttribFlags );

	lea	eax, DWORD PTR _szAttribFlags$10002[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+181]
	push	edx
	push	OFFSET FLAT:??_C@_07HIC@a?$CFlx?$CFs?5?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 7394 :             else

	jmp	SHORT $L10010
$L10008:

; 7396 :                zCHAR szAttribName[ 50 ];
; 7397 : 
; 7398 :                zsprintf( szAttribName, "%s%s", lpViewAttrib->szName,
; 7399 :                          szAttribFlags );

	lea	ecx, DWORD PTR _szAttribFlags$10002[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_04DCMN@?$CFs?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szAttribName$10011[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 7400 :                zsprintf( szWorkString, "a%-9s ", szAttribName );

	lea	ecx, DWORD PTR _szAttribName$10011[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_06IACC@a?$CF?99s?5?$AA@ ; `string'
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L10010:

; 7402 : 
; 7403 :             k = zstrlen( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7404 : 
; 7405 :             fnGetAddrForAttribute( &pchAttr, lpView, &ViewEntityCsr, 0,
; 7406 :                                    lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _ViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchAttr$[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 7407 : 
; 7408 :             // If we are dealing with a string, check to see if
; 7409 :             // it contains any special chars (e.g. '\n'). If it does, then
; 7410 :             // we have to store the string as a blob.
; 7411 :             bStringContainsSpecialChars = FALSE;

	mov	BYTE PTR _bStringContainsSpecialChars$10001[ebp], 0

; 7412 :             if ( lpViewAttrib->cType == zTYPE_STRING )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	SHORT $L10020

; 7414 :                zPCHAR pch = pchAttr;

	mov	ecx, DWORD PTR _pchAttr$[ebp]
	mov	DWORD PTR _pch$10015[ebp], ecx

; 7415 : 
; 7416 :                // We also store the string as a blob if it has more than
; 7417 :                // 254 chars.
; 7418 :                if ( zstrlen( pch ) > 254 )

	mov	edx, DWORD PTR _pch$10015[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 254				; 000000feH
	jbe	SHORT $L10016

; 7419 :                   bStringContainsSpecialChars = TRUE;

	mov	BYTE PTR _bStringContainsSpecialChars$10001[ebp], 1

; 7420 :                else

	jmp	SHORT $L10020
$L10016:

; 7421 :                   while ( pch[ 0 ] )

	mov	eax, DWORD PTR _pch$10015[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L10020

; 7423 :                      if ( CHAR_IS_SPECIAL( pch[ 0 ] ) )

	mov	edx, DWORD PTR _pch$10015[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jae	SHORT $L10023

; 7425 :                         bStringContainsSpecialChars = TRUE;

	mov	BYTE PTR _bStringContainsSpecialChars$10001[ebp], 1

; 7426 :                         break;

	jmp	SHORT $L10020
$L10023:

; 7428 : 
; 7429 :                      pch++;

	mov	ecx, DWORD PTR _pch$10015[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$10015[ebp], ecx

; 7430 :                   }

	jmp	SHORT $L10016
$L10020:

; 7432 : 
; 7433 :             if ( lpViewAttrib->cType == zTYPE_BLOB ||
; 7434 :                  bStringContainsSpecialChars )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	je	SHORT $L10025
	mov	ecx, DWORD PTR _bStringContainsSpecialChars$10001[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	$L10024
$L10025:

; 7436 :                zCHAR cStreamType;
; 7437 : 
; 7438 :                if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $L10027

; 7440 :                   fnGetAttributeLength( &ulLth, lpView,
; 7441 :                                         zGETPTR( ViewEntityCsr.hEntityInstance ),
; 7442 :                                         lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ViewEntityCsr$[ebp+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 7443 :                   cStreamType = zTYPE_BLOB;

	mov	BYTE PTR _cStreamType$10026[ebp], 66	; 00000042H

; 7445 :                else

	jmp	SHORT $L10029
$L10027:

; 7447 :                   ulLth = zstrlen( pchAttr ) + 1;

	mov	edx, DWORD PTR _pchAttr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _ulLth$[ebp], eax

; 7448 :                   if ( ulLth == 1 )

	cmp	DWORD PTR _ulLth$[ebp], 1
	jne	SHORT $L10030

; 7449 :                      ulLth = 0;

	mov	DWORD PTR _ulLth$[ebp], 0
$L10030:

; 7450 : 
; 7451 :                   cStreamType = zTYPE_STRING;

	mov	BYTE PTR _cStreamType$10026[ebp], 83	; 00000053H
$L10029:

; 7453 : 
; 7454 :                // If the attribute has a length, then write the length and
; 7455 :                // then the value.
; 7456 :                if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	$L10031

; 7458 :                   // If we're storing a string with "special" chars, then the
; 7459 :                   // first byte before the length is the "special" flag.
; 7460 :                   if ( bStringContainsSpecialChars )

	mov	eax, DWORD PTR _bStringContainsSpecialChars$10001[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10032

; 7461 :                      szWorkString[ k++ ] = zSTRING_STORED_AS_BLOB;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 31	; 0000001fH
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 7462 :                   else

	jmp	SHORT $L10034
$L10032:

; 7463 :                   if ( lControl & zENCODE_BLOBS )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 4194304				; 00400000H
	test	eax, eax
	je	SHORT $L10034

; 7464 :                      szWorkString[ k++ ] = zBLOB_STORED_ENCODED;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 85	; 00000055H
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L10034:

; 7465 : 
; 7466 :                   zltoa( ulLth, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7467 : 
; 7468 :                   // write out the attribute name and length
; 7469 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0,
; 7470 :                                           zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10035

; 7471 :                      goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10035:

; 7472 : 
; 7473 :                   // write out the data
; 7474 :                   if ( cStreamType == zTYPE_BLOB && (lControl & zENCODE_BLOBS) )

	movsx	ecx, BYTE PTR _cStreamType$10026[ebp]
	cmp	ecx, 66					; 00000042H
	jne	$L10036
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 4194304				; 00400000H
	test	edx, edx
	je	SHORT $L10036

; 7476 :                      uPos = 0;

	mov	DWORD PTR _uPos$[ebp], 0
$L10038:

; 7477 :                      while ( UUENCODE_NextEncodedLine( szWorkString, pchAttr,
; 7478 :                                                        ulLth, &uPos ) == 1)

	lea	eax, DWORD PTR _uPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttr$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_UUENCODE_NextEncodedLine@16
	movsx	ecx, ax
	cmp	ecx, 1
	jne	SHORT $L10039

; 7480 :                         //TraceLineS( "Encoded Line: ", szWorkString);
; 7481 :                         if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, cStreamType ) )

	mov	dl, BYTE PTR _cStreamType$10026[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10040

; 7482 :                            goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10040:

; 7483 :                      }

	jmp	SHORT $L10038
$L10039:

; 7484 : 
; 7485 :                      //TraceLineS( "Encoded Line: ", szWorkString);
; 7486 :                      if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, cStreamType ) )

	mov	cl, BYTE PTR _cStreamType$10026[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10041

; 7487 :                         goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10041:

; 7489 :                   else

	jmp	$L10050
$L10036:

; 7490 :                   if ( cStreamType == zTYPE_STRING )

	movsx	eax, BYTE PTR _cStreamType$10026[ebp]
	cmp	eax, 83					; 00000053H
	jne	$L10043

; 7492 :                      // PAS 03/09/2001 - to eliminate x00 in the portable
; 7493 :                      //                  files, we temporarily change the
; 7494 :                      //                  byte to the char 0.
; 7495 :                      if ( lControl & zNO_NULL_STRING_TERM )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 8388608				; 00800000H
	test	ecx, ecx
	je	SHORT $L10044

; 7497 :                         pchAttr[ ulLth - 1 ] = '0';

	mov	edx, DWORD PTR _pchAttr$[ebp]
	add	edx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [edx-1], 48			; 00000030H

; 7498 :                         if ( (*lpfnStreamFunc)( lpView, lpvData, pchAttr,
; 7499 :                                                 ulLth, cStreamType ) )

	mov	al, BYTE PTR _cStreamType$10026[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10045

; 7501 :                            pchAttr[ ulLth - 1 ] = 0;

	mov	eax, DWORD PTR _pchAttr$[ebp]
	add	eax, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [eax-1], 0

; 7502 :                            goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10045:

; 7504 :                         else
; 7505 :                            pchAttr[ ulLth - 1 ] = 0;

	mov	ecx, DWORD PTR _pchAttr$[ebp]
	add	ecx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [ecx-1], 0

; 7510 :                      else

	jmp	SHORT $L10048
$L10044:

; 7512 :                         if ( (*lpfnStreamFunc)( lpView, lpvData, pchAttr,
; 7513 :                                                 ulLth, cStreamType ) )

	mov	dl, BYTE PTR _cStreamType$10026[ebp]
	push	edx
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchAttr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10048

; 7515 :                            goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10048:

; 7519 :                   else

	jmp	SHORT $L10050
$L10043:

; 7520 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, pchAttr,
; 7521 :                                           ulLth, cStreamType ) )

	mov	dl, BYTE PTR _cStreamType$10026[ebp]
	push	edx
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchAttr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10050

; 7523 :                      goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10050:

; 7526 :                else

	jmp	SHORT $L10054
$L10031:

; 7527 :                if ( lpAttribFlags )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $L10054

; 7529 :                   // We need to write the attrib flags so write the attribute
; 7530 :                   // value as NULL.
; 7531 :                   if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $L10053

; 7533 :                      // Add "0" to the end of the string.
; 7534 :                      szWorkString[ k++ ] = '0';

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 48	; 00000030H
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L10053:

; 7536 : 
; 7537 :                   // Null-terminate the string.
; 7538 :                   szWorkString[ k++ ] = 0;

	movsx	eax, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 0
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx

; 7539 : 
; 7540 :                   // Write it.
; 7541 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0,
; 7542 :                                           zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10054

; 7544 :                      goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10054:

; 7548 :             else

	jmp	$L10067
$L10024:

; 7550 :                zBOOL bAttribIsNull;
; 7551 : 
; 7552 :                // Check to see if we are writing compressed.  This might happen
; 7553 :                // if there are too many attributes to write in the compress
; 7554 :                // buffer.
; 7555 :                if ( lControl & zCOMPRESSED &&
; 7556 :                     lpViewAttrib->cType == zTYPE_INTEGER )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	$L10057
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 76					; 0000004cH
	jne	$L10057

; 7558 :                   zLONG l;
; 7559 : 
; 7560 :                   // We are writing a compressed file so convert the value to
; 7561 :                   // a hex number.
; 7562 :                   if ( fnGetIntegerFromAttribute( &l, lpView, &ViewEntityCsr,
; 7563 :                                                   lpViewAttrib ) == -1 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$10058[ebp]
	push	eax
	call	_fnGetIntegerFromAttribute
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $L10059

; 7565 :                      bAttribIsNull = TRUE;

	mov	BYTE PTR _bAttribIsNull$10056[ebp], 1

; 7566 : 
; 7567 :                      // Write the attribute value as a '*' to indicate that the
; 7568 :                      // integer is null.
; 7569 :                      szWorkString[ k++ ] = '*';

	movsx	edx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 42	; 0000002aH
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax

; 7570 :                      szWorkString[ k++ ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 0
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 7572 :                   else

	jmp	SHORT $L10060
$L10059:

; 7574 :                      bAttribIsNull = FALSE;

	mov	BYTE PTR _bAttribIsNull$10056[ebp], 0

; 7575 : 
; 7576 :                      if ( l < 0 )

	cmp	DWORD PTR _l$10058[ebp], 0
	jge	SHORT $L10061

; 7578 :                         szWorkString[ k++ ] = '-';

	movsx	eax, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 45	; 0000002dH
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx

; 7579 :                         l = l * -1;

	mov	edx, DWORD PTR _l$10058[ebp]
	imul	edx, -1
	mov	DWORD PTR _l$10058[ebp], edx
$L10061:

; 7581 : 
; 7582 :                      zltox( l, &szWorkString[ k ] );

	push	16					; 00000010H
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _l$10058[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$L10060:

; 7585 :                else

	jmp	SHORT $L10064
$L10057:

; 7587 :                   if ( fnGetStringFromAttribute( &szWorkString[ k ], 255,
; 7588 :                                                  lpView,
; 7589 :                                                  &ViewEntityCsr,
; 7590 :                                                  lpViewAttrib, 0 ) == -1 )

	push	0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	255					; 000000ffH
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L10063

; 7592 :                      bAttribIsNull = TRUE;

	mov	BYTE PTR _bAttribIsNull$10056[ebp], 1

; 7594 :                   else

	jmp	SHORT $L10064
$L10063:

; 7595 :                      bAttribIsNull = FALSE;

	mov	BYTE PTR _bAttribIsNull$10056[ebp], 0
$L10064:

; 7597 : 
; 7598 :                // Write the value if it's not null OR if there are attribute
; 7599 :                // flags.  If there are attrib flags then we need to
; 7600 :                // keep track of null values.
; 7601 :                if ( bAttribIsNull == FALSE || lpAttribFlags )

	mov	eax, DWORD PTR _bAttribIsNull$10056[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10066
	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $L10067
$L10066:

; 7603 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0,
; 7604 :                                           zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10067

; 7606 :                      goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10067:

; 7613 : 
; 7614 :       } // for ( lpViewAttrib... )...

	jmp	$L9980
$L9981:

; 7615 : 
; 7616 :       if ( bEntityIsCompressed && bValuesStored )

	mov	edx, DWORD PTR _bEntityIsCompressed$9919[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L10068
	mov	eax, DWORD PTR _bValuesStored$9921[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L10068

; 7618 :          zCHAR szLth[ 20 ];
; 7619 : 
; 7620 :          ulLth = (zULONG) (pchBufferEnd - pchBuffer);

	mov	ecx, DWORD PTR _pchBufferEnd$9920[ebp]
	sub	ecx, DWORD PTR _pchBuffer$[ebp]
	mov	DWORD PTR _ulLth$[ebp], ecx

; 7621 : 
; 7622 :          // Set first char to 'a' to indicate that it's attribute data.
; 7623 :          // The next char is a space to differentiate it with a normal
; 7624 :          // attribute value line.
; 7625 :          zsprintf( szLth, "a %x", ulLth );

	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04KPK@a?5?$CFx?$AA@	; `string'
	lea	eax, DWORD PTR _szLth$10069[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7626 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szLth, zstrlen( szLth ),
; 7627 :                                  zTYPE_STRING ) )

	push	83					; 00000053H
	lea	ecx, DWORD PTR _szLth$10069[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _szLth$10069[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10072

; 7629 :             goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10072:

; 7631 : 
; 7632 :          // Now send the buffer.
; 7633 :          if ( (*lpfnStreamFunc)( lpView, lpvData, pchBuffer, ulLth, zTYPE_STRING ) )

	push	83					; 00000053H
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10073

; 7634 :             goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10073:

; 7636 :       else

	jmp	SHORT $L10076
$L10068:

; 7638 :          if ( (lControl & zCOMPRESSED) == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	test	edx, edx
	jne	SHORT $L10076

; 7640 :             // Write a blank line just to make things look pretty.
; 7641 :             if ( (*lpfnStreamFunc)( lpView, lpvData, "", 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10076

; 7642 :                goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10076:

; 7645 : 
; 7646 :    } // for ( lpEntityInstance... )...

	jmp	$L9917
$L9918:

; 7647 : 
; 7648 :    // If any intra-object linked instances were found, create
; 7649 :    // link records now.
; 7650 :    if ( lLastLinkedInstance > -1 )

	cmp	DWORD PTR _lLastLinkedInstance$[ebp], -1
	jle	$L10083

; 7652 :       LPENTITYINSTANCE lpSourceEntityInstance;
; 7653 : 
; 7654 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 7655 :             lpEntityInstance;
; 7656 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L10081
$L10082:
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10081:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L10083

; 7658 :          // If we've gone past the last linked instance break.
; 7659 :          if ( lpEntityInstance->lHierCount > lLastLinkedInstance )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+54]
	cmp	edx, DWORD PTR _lLastLinkedInstance$[ebp]
	jle	SHORT $L10084

; 7660 :             break;

	jmp	$L10083
$L10084:

; 7661 : 
; 7662 :          // Look to see if the current instance should be written out.  If
; 7663 :          // not we'll skip it and go on to the next one.  All non-hidden
; 7664 :          // instances get written so we'll look for that first.
; 7665 :          if ( lpEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	je	$L10086

; 7667 :             // We'll skip hidden entities if:
; 7668 :             // o  We aren't writing incrementals
; 7669 :             //    -or-
; 7670 :             // o  The EI is "dead" e.g. created and deleted.
; 7671 :             if ( bIncremental == FALSE ||
; 7672 :                  fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	edx, DWORD PTR _bIncremental$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L10087
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnEntityInstanceIsDead@4
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10086
$L10087:

; 7674 :                // The current instance should not be written to the file.
; 7675 :                // This also means that it's children should not be written.
; 7676 :                // Skip the children.
; 7677 :                nLevel = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLevel$[ebp], ax

; 7678 :                for ( lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );
; 7679 :                      lpEntityInstance;
; 7680 :                      lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L10090
$L10091:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10090:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L10092

; 7682 :                   if ( lpEntityInstance->nLevel <= nLevel )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $L10093

; 7683 :                      break;

	jmp	SHORT $L10092
$L10093:

; 7684 :                }

	jmp	SHORT $L10091
$L10092:

; 7685 : 
; 7686 :                // If no more instance break loop.
; 7687 :                if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L10094

; 7688 :                   break;

	jmp	$L10083
$L10094:

; 7689 : 
; 7690 :                // Do the following so that when the 'for' loop gets the next
; 7691 :                // entity instance it will be the one we want.
; 7692 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 7693 : 
; 7694 :                // Skip the hidden instance.
; 7695 :                continue;

	jmp	$L10082
$L10086:

; 7698 : 
; 7699 :          // If the entity is not linked to another entity then there are no
; 7700 :          // link cards to write, so skip it.
; 7701 :          if ( lpEntityInstance->hNextLinked == 0 )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $L10096

; 7702 :             continue;

	jmp	$L10082
$L10096:

; 7703 : 
; 7704 :          // If the entity is the record owner then we don't write link cards.
; 7705 :          // Link cards are written for the non-record owner.
; 7706 :          if ( lpEntityInstance->u.nInd.bRecordOwner )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	je	SHORT $L10097

; 7707 :             continue;

	jmp	$L10082
$L10097:

; 7708 : 
; 7709 :          // Look for the record owner in the same OI.
; 7710 :          lpSourceEntityInstance = zGETPTR( lpEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntityInstance$10078[ebp], eax
$L10100:

; 7711 :          while ( lpSourceEntityInstance->hViewOI != lpEntityInstance->hViewOI ||
; 7712 :                  lpSourceEntityInstance->u.nInd.bRecordOwner == FALSE )

	mov	eax, DWORD PTR _lpSourceEntityInstance$10078[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [eax+10]
	cmp	edx, DWORD PTR [ecx+10]
	jne	SHORT $L10102
	mov	eax, DWORD PTR _lpSourceEntityInstance$10078[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 6
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L10101
$L10102:

; 7714 :             lpSourceEntityInstance =
; 7715 :                                  zGETPTR( lpSourceEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpSourceEntityInstance$10078[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntityInstance$10078[ebp], eax

; 7716 :             if ( lpSourceEntityInstance == lpEntityInstance )

	mov	ecx, DWORD PTR _lpSourceEntityInstance$10078[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	jne	SHORT $L10104

; 7717 :                break;

	jmp	SHORT $L10101
$L10104:

; 7718 :          }

	jmp	SHORT $L10100
$L10101:

; 7719 : 
; 7720 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 7721 : 
; 7722 :          // If lpSourceEntityInstance == lpEntityInstance then no other
; 7723 :          // linked instances where found in the loop above.
; 7724 :          if ( lpSourceEntityInstance == lpEntityInstance )

	mov	ecx, DWORD PTR _lpSourceEntityInstance$10078[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	jne	$L10106

; 7726 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$10107[ebp], eax

; 7727 :             zVIEW           vWork;
; 7728 :             LPVIEWENTITYCSR lpWorkViewEntityCsr;
; 7729 : 
; 7730 :             CreateViewFromViewForTask( &vWork, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vWork$10109[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 7731 :             lpWorkViewEntityCsr =
; 7732 :                fnEstablishViewForInstance( vWork, 0, lpSourceEntityInstance );

	mov	eax, DWORD PTR _lpSourceEntityInstance$10078[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vWork$10109[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpWorkViewEntityCsr$10110[ebp], eax
$L10112:

; 7733 : 
; 7734 :             while ( lpWorkViewEntityCsr )

	cmp	DWORD PTR _lpWorkViewEntityCsr$10110[ebp], 0
	je	SHORT $L10113

; 7736 :                fnDisplayEntityInstance( vWork, lpWorkViewEntityCsr, 0, 0 );

	push	0
	push	0
	mov	edx, DWORD PTR _lpWorkViewEntityCsr$10110[ebp]
	push	edx
	mov	eax, DWORD PTR _vWork$10109[ebp]
	push	eax
	call	_fnDisplayEntityInstance
	add	esp, 16					; 00000010H

; 7737 :                lpWorkViewEntityCsr = zGETPTR( lpWorkViewEntityCsr->hParent );

	mov	ecx, DWORD PTR _lpWorkViewEntityCsr$10110[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEntityCsr$10110[ebp], eax

; 7738 :             }

	jmp	SHORT $L10112
$L10113:

; 7739 : 
; 7740 :             DropView( vWork );

	mov	eax, DWORD PTR _vWork$10109[ebp]
	push	eax
	call	_DropView@4

; 7741 : 
; 7742 :             // "KZOEE078 - Internal error, linked instance "
; 7743 :             // "           has no visible owner"
; 7744 :             fnIssueCoreError( lpTask, lpView, 16, 78, (zLONG) 0,
; 7745 :                               lpViewEntity->szName, 0 );

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	78					; 0000004eH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$10107[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$L10106:

; 7751 :             LPVIEWENTITY lpSrcViewEntity;
; 7752 : 
; 7753 :             lpViewEntity    = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 7754 :             lpSrcViewEntity = zGETPTR( lpSourceEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSourceEntityInstance$10078[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$10116[ebp], eax

; 7755 : 
; 7756 :             if ( lpSrcViewEntity->lEREntTok != lpViewEntity->lEREntTok )

	mov	edx, DWORD PTR _lpSrcViewEntity$10116[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	je	SHORT $L10121

; 7758 :                TraceLine( "(oi) Error (OD: %s) - Src View Entity: %s Token: %d  View Entity: %s Token = %d",
; 7759 :                           lpViewOD->szName, lpSrcViewEntity->szName, lpSrcViewEntity->lEREntTok,
; 7760 :                           lpViewEntity->szName, lpViewEntity->lEREntTok );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+195]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$10116[ebp]
	mov	eax, DWORD PTR [edx+195]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntity$10116[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_0FA@OBP@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Src?5View?5E@ ; `string'
	call	_TraceLine
	add	esp, 24					; 00000018H

; 7761 :                if ( bMsgBox )

	mov	eax, DWORD PTR _bMsgBox$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10121

; 7763 :                   bMsgBox = FALSE;

	mov	BYTE PTR _bMsgBox$[ebp], 0

; 7764 :                   SysMessageBox( lpView, szlOE_SystemError,
; 7765 :                                  "Error writing OI: ER Tokens don't match for linked entities!", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0DN@MLKO@Error?5writing?5OI?3?5ER?5Tokens?5don?8@ ; `string'
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMessageBox@16
$L10121:

; 7769 : #endif
; 7770 : 
; 7771 :          if ( lControl & zCOMPRESSED )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L10123

; 7773 :             zsprintf( szWorkString, "i%lx %lx",
; 7774 :                       lpEntityInstance->lHierCount,
; 7775 :                       lpSourceEntityInstance->lHierCount );

	mov	ecx, DWORD PTR _lpSourceEntityInstance$10078[ebp]
	mov	edx, DWORD PTR [ecx+54]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+54]
	push	ecx
	push	OFFSET FLAT:??_C@_08GN@i?$CFlx?5?$CFlx?$AA@ ; `string'
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 7777 :          else

	jmp	$L10125
$L10123:

; 7779 :             szWorkString[ 0 ] = 'i';

	mov	BYTE PTR _szWorkString$[ebp], 105	; 00000069H

; 7780 :             zltoa( lpEntityInstance->lHierCount, &szWorkString[ 1 ] );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _szWorkString$[ebp+1]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+54]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7781 :             k = zstrlen( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax
$L10126:

; 7784 :                szWorkString[ k++ ] = ' ';

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 32	; 00000020H
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 7785 :             } while ( k < 11 );

	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 11					; 0000000bH
	jl	SHORT $L10126

; 7786 : 
; 7787 :             zltoa( lpSourceEntityInstance->lHierCount, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lpSourceEntityInstance$10078[ebp]
	mov	ecx, DWORD PTR [eax+54]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$L10125:

; 7789 : 
; 7790 :          if ( lpEntityInstance->lHierCount != lpSourceEntityInstance->lHierCount )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpSourceEntityInstance$10078[ebp]
	mov	ecx, DWORD PTR [edx+54]
	cmp	ecx, DWORD PTR [eax+54]
	je	SHORT $L10130

; 7792 :             if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10130

; 7793 :                goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10130:

; 7795 : 
; 7796 :       } // for ...

	jmp	$L10082
$L10083:

; 7799 : 
; 7800 :    //
; 7801 :    // Check to see if we need to save the cursor positions.
; 7802 :    //
; 7803 :    // We save the cursor positions by storing each entity cursor as:
; 7804 :    //    cent-#, absolute-entity-instance-#
; 7805 :    // The numbers are stored as hex values.  For example, the root cursor
; 7806 :    // would be saved as:
; 7807 :    //    c1, 1
; 7808 :    // Absence of the cursor record means the cursor is null.
; 7809 :    //
; 7810 :    // Note: if lpEntityInstance->u.nInd.bWritten is 0, then the entity
; 7811 :    // instance wasn't written to the stream.
; 7812 :    //
; 7813 :    if ( lControl & zSAVE_CURSORS )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	$L10140

; 7815 :       LPVIEWENTITYCSR  lpViewEntityCsr;
; 7816 :       LPENTITYINSTANCE lpCurrentEI;
; 7817 :       zLONG            lInstanceCount;
; 7818 : 
; 7819 :       lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 7820 :       lInstanceCount = 1;

	mov	DWORD PTR _lInstanceCount$10134[ebp], 1

; 7821 : 
; 7822 :       for ( lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );
; 7823 :             lpViewEntityCsr;
; 7824 :             lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier ) )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$10132[ebp], eax
	jmp	SHORT $L10138
$L10139:
	mov	edx, DWORD PTR _lpViewEntityCsr$10132[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$10132[ebp], eax
$L10138:
	cmp	DWORD PTR _lpViewEntityCsr$10132[ebp], 0
	je	$L10140

; 7826 :          // If the entity cursor is NULL then ignore this cursor.
; 7827 :          if ( lpViewEntityCsr->hEntityInstance == 0 )

	mov	ecx, DWORD PTR _lpViewEntityCsr$10132[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	SHORT $L10141

; 7828 :             continue;

	jmp	SHORT $L10139
$L10141:

; 7829 : 
; 7830 :          if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	edx, DWORD PTR _lpViewEntityCsr$10132[ebp]
	cmp	DWORD PTR [edx+26], 1
	jne	SHORT $L10143

; 7832 :             zsprintf( szWorkString, "c%x 0", lpViewEntityCsr->nHierNbr );

	mov	eax, DWORD PTR _lpViewEntityCsr$10132[ebp]
	movsx	ecx, WORD PTR [eax+24]
	push	ecx
	push	OFFSET FLAT:??_C@_05KPKL@c?$CFx?50?$AA@	; `string'
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7833 : 
; 7834 :             if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10145

; 7835 :                goto EndOfFunction;

	jmp	$EndOfFunction$9945
$L10145:

; 7836 : 
; 7837 :             continue;

	jmp	$L10139
$L10143:

; 7839 : 
; 7840 :          lpCurrentEI = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$10132[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentEI$10133[ebp], eax

; 7841 : 
; 7842 :          if ( lpCurrentEI->u.nInd.bWritten == FALSE )

	mov	eax, DWORD PTR _lpCurrentEI$10133[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	test	ecx, ecx
	jne	$L10147

; 7844 :             LPENTITYINSTANCE lpSrchInstance;
; 7845 :             zBOOL            bNoTwins = TRUE;

	mov	BYTE PTR _bNoTwins$10149[ebp], 1

; 7846 : 
; 7847 :             // The current entity instance wasn't written to the stream.  If
; 7848 :             // none of it's twins were written to the stream then the cursor
; 7849 :             // is considered NULL.
; 7850 : 
; 7851 :             // Search previous twins.
; 7852 :             for ( lpSrchInstance = zGETPTR( lpCurrentEI->hPrevTwin );
; 7853 :                   lpSrchInstance;
; 7854 :                   lpSrchInstance = zGETPTR( lpSrchInstance->hPrevTwin ) )

	mov	edx, DWORD PTR _lpCurrentEI$10133[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$10148[ebp], eax
	jmp	SHORT $L10152
$L10153:
	mov	ecx, DWORD PTR _lpSrchInstance$10148[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$10148[ebp], eax
$L10152:
	cmp	DWORD PTR _lpSrchInstance$10148[ebp], 0
	je	SHORT $L10154

; 7856 :                if ( lpSrchInstance->u.nInd.bWritten )

	mov	eax, DWORD PTR _lpSrchInstance$10148[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10155

; 7858 :                   bNoTwins = FALSE;

	mov	BYTE PTR _bNoTwins$10149[ebp], 0

; 7859 :                   break;

	jmp	SHORT $L10154
$L10155:

; 7861 :             }

	jmp	SHORT $L10153
$L10154:

; 7862 : 
; 7863 :             // Search next twins.
; 7864 :             if ( bNoTwins )

	mov	edx, DWORD PTR _bNoTwins$10149[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L10161

; 7866 :                for ( lpSrchInstance = zGETPTR( lpCurrentEI->hNextTwin );
; 7867 :                      lpSrchInstance;
; 7868 :                      lpSrchInstance = zGETPTR( lpSrchInstance->hNextTwin ) )

	mov	eax, DWORD PTR _lpCurrentEI$10133[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$10148[ebp], eax
	jmp	SHORT $L10159
$L10160:
	mov	edx, DWORD PTR _lpSrchInstance$10148[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$10148[ebp], eax
$L10159:
	cmp	DWORD PTR _lpSrchInstance$10148[ebp], 0
	je	SHORT $L10161

; 7870 :                   if ( lpSrchInstance->u.nInd.bWritten )

	mov	ecx, DWORD PTR _lpSrchInstance$10148[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 12					; 0000000cH
	and	edx, 1
	test	edx, edx
	je	SHORT $L10162

; 7872 :                      bNoTwins = FALSE;

	mov	BYTE PTR _bNoTwins$10149[ebp], 0

; 7873 :                      break;

	jmp	SHORT $L10161
$L10162:

; 7875 :                }

	jmp	SHORT $L10160
$L10161:

; 7877 : 
; 7878 :             // If we didn't find any twins then the cursor is considered
; 7879 :             // NULL so don't write the cursor record to the stream.
; 7880 :             if ( bNoTwins )

	mov	eax, DWORD PTR _bNoTwins$10149[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10163

; 7881 :                continue;

	jmp	$L10139
$L10163:

; 7882 : 
; 7883 :             // Cursor points to invalid entity but the entity does have
; 7884 :             // valid twins, so send record indicating that the cursor is
; 7885 :             // currently not set.
; 7886 :             zsprintf( szWorkString, "c%x 0", lpViewEntityCsr->nHierNbr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$10132[ebp]
	movsx	edx, WORD PTR [ecx+24]
	push	edx
	push	OFFSET FLAT:??_C@_05KPKL@c?$CFx?50?$AA@	; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7888 :          else

	jmp	SHORT $L10164
$L10147:

; 7890 :             for ( ;
; 7891 :                   lpEntityInstance != lpCurrentEI;
; 7892 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	jmp	SHORT $L10166
$L10167:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10166:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpCurrentEI$10133[ebp]
	je	SHORT $L10168

; 7894 :                // If the entity instance wasn't written to the stream, then
; 7895 :                // don't bother counting it.
; 7896 :                if ( lpEntityInstance->u.nInd.bWritten == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 12					; 0000000cH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L10169

; 7897 :                   continue;

	jmp	SHORT $L10167
$L10169:

; 7898 : 
; 7899 :                lInstanceCount++;

	mov	eax, DWORD PTR _lInstanceCount$10134[ebp]
	add	eax, 1
	mov	DWORD PTR _lInstanceCount$10134[ebp], eax

; 7900 :             }

	jmp	SHORT $L10167
$L10168:

; 7901 : 
; 7902 :             zsprintf( szWorkString, "c%x %lx", lpViewEntityCsr->nHierNbr,
; 7903 :                       lInstanceCount );

	mov	ecx, DWORD PTR _lInstanceCount$10134[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$10132[ebp]
	movsx	eax, WORD PTR [edx+24]
	push	eax
	push	OFFSET FLAT:??_C@_07BFPN@c?$CFx?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
$L10164:

; 7905 : 
; 7906 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10171

; 7907 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$9945
$L10171:

; 7908 :       }

	jmp	$L10139
$L10140:

; 7910 : 
; 7911 :    // If we get here then everything's OK.
; 7912 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$9945:

; 7913 : 
; 7914 : EndOfFunction:
; 7915 : 
; 7916 :    if ( pchBuffer )

	cmp	DWORD PTR _pchBuffer$[ebp], 0
	je	SHORT $L10172

; 7917 :       fnFreeDataspace( pchBuffer );

	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$L10172:

; 7918 : 
; 7919 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L9857:

; 7920 : 
; 7921 : } // fnWriteOI_ToTextStream

	mov	esp, ebp
	pop	ebp
	ret	0
_fnWriteOI_ToTextStream ENDP
_TEXT	ENDS
PUBLIC	??_C@_04JJOE@ZEND?$AA@				; `string'
PUBLIC	??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@ ; `string'
PUBLIC	??_C@_0CI@BFCD@?$CIoi?$CJ?5Total?5time?5for?5SfWriteOI_To@ ; `string'
PUBLIC	_fnDateTimeFormat
PUBLIC	_SfWriteOI_ToStream@20
PUBLIC	??_C@_08ION@?5?5?5?5?5?5?5?5?$AA@		; `string'
PUBLIC	??_C@_0N@LHOF@mCONTROL?5?$CFlx?$AA@		; `string'
EXTRN	_SysTranslateString@8:NEAR
EXTRN	_memset:NEAR
EXTRN	_szlReleaseCompatible:DWORD
EXTRN	_szlReleaseCurrent:DWORD
EXTRN	_szlNewPortableHeader:DWORD
EXTRN	_szlmZeidon:DWORD
EXTRN	_MiSetOI_ReleaseForView@8:NEAR
EXTRN	_MiCompareOI_ToRelease@8:NEAR
;	COMDAT ??_C@_08ION@?5?5?5?5?5?5?5?5?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_08ION@?5?5?5?5?5?5?5?5?$AA@ DB '        ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@LHOF@mCONTROL?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0N@LHOF@mCONTROL?5?$CFlx?$AA@ DB 'mCONTROL %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JJOE@ZEND?$AA@
_DATA	SEGMENT
??_C@_04JJOE@ZEND?$AA@ DB 'ZEND', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@
_DATA	SEGMENT
??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@ DB '(%s) = %lf s'
	DB	'econds', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@BFCD@?$CIoi?$CJ?5Total?5time?5for?5SfWriteOI_To@
_DATA	SEGMENT
??_C@_0CI@BFCD@?$CIoi?$CJ?5Total?5time?5for?5SfWriteOI_To@ DB '(oi) Total'
	DB	' time for SfWriteOI_ToStream ', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_sz$10248 = -292
_lpView$ = 8
_cpcHeaderName$ = 12
_lControl$ = 16
_lpfnStreamFunc$ = 20
_lpvData$ = 24
_lpCurrentTask$ = -192
_lpViewOD$ = -108
_lpViewOI$ = -180
_lpViewCsr$ = -24
_FileHeader$ = -104
_pchLine$ = -28
_pchFileNmp$ = -188
_szDateTime$ = -20
_szTemp$ = -164
_lTickCount$ = -184
_bOptimistic$ = -168
_bIncremental$ = -176
_k$ = -172
_nRC$ = -112
_SfWriteOI_ToStream@20 PROC NEAR

; 7930 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH

; 7931 :    LPTASK               lpCurrentTask;
; 7932 :    LPVIEWOD             lpViewOD;
; 7933 :    LPVIEWOI             lpViewOI;
; 7934 :    LPVIEWCSR            lpViewCsr;
; 7935 :    FileHeaderRecord     FileHeader;
; 7936 :    zPCHAR               pchLine;
; 7937 :    zPCHAR               pchFileNmp;
; 7938 :    zCHAR                szDateTime[ 20 ];
; 7939 :    zCHAR                szTemp[ 50 ];
; 7940 :    zLONG                lTickCount;
; 7941 :    zBOOL                bOptimistic;
; 7942 :    zBOOL                bIncremental;
; 7943 :    zSHORT               k;
; 7944 :    zSHORT               nRC;
; 7945 : 
; 7946 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10198

; 7947 :       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$L10198:

; 7948 : 
; 7949 :    // If task not active or disabled, return zCALL_ERROR.
; 7950 :    lpCurrentTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 7951 : 
; 7952 :    // Validate that the view passed is valid
; 7953 :    if ( fnValidViewCsr( lpCurrentTask, lpView ) == 0 )

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidViewCsr
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L10200

; 7954 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10183
$L10200:

; 7955 : 
; 7956 :    lpViewOD  = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 7957 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 7958 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 7959 : 
; 7960 :    // Make sure OI does not contain versioned instances
; 7961 :    if ( lpViewOI->nVersionedInstances )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	je	SHORT $L10204

; 7962 : #if 0  // DGC 1999.06.04  No longer an error?  It seems like we should be able
; 7963 :        // to pass OIs even if they have versions.  We will, however, only
; 7964 :        // perform Reclaim if there are no versions (we wouldn't want to get
; 7965 :        // rid of something we want).
; 7966 :    {
; 7967 :       //  "KZOEE076 - Object instance contains versioned entity instances"
; 7968 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 76, 0, 0, 0 );
; 7969 :       return( zCALL_ERROR );
; 7970 :    }
; 7971 : 
; 7972 :    // Get rid of all deadwood instances (e.g. entities that have been created
; 7973 :    // AND deleted).
; 7974 :    fnReclaimHiddenInstances( lpViewOI );
; 7975 : 
; 7976 : #else
; 7977 :       ;
; 7978 :    else

	jmp	SHORT $L10205
$L10204:

; 7979 :       // Get rid of all deadwood instances (e.g. entities that have been created
; 7980 :       // AND deleted).
; 7981 :       fnReclaimHiddenInstances( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnReclaimHiddenInstances@4
$L10205:

; 7982 : #endif
; 7983 : 
; 7984 :    // build header record
; 7985 :    zmemset( &FileHeader.chTypeIndicator, ' ', sizeof( FileHeaderRecord ) );

	push	73					; 00000049H
	push	32					; 00000020H
	lea	ecx, DWORD PTR _FileHeader$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 7986 : 
; 7987 :    // Set bIncremental and bBinary
; 7988 :    if ( lControl & zINCREMENTAL )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 65536				; 00010000H
	test	edx, edx
	je	SHORT $L10207

; 7989 :       bIncremental = TRUE;

	mov	BYTE PTR _bIncremental$[ebp], 1

; 7990 :    else

	jmp	SHORT $L10208
$L10207:

; 7991 :       bIncremental = FALSE;

	mov	BYTE PTR _bIncremental$[ebp], 0
$L10208:

; 7992 : 
; 7993 :    // If the view has an "original OI" then the view was activated with
; 7994 :    // optimistic locking and we need to send the original OI as well.
; 7995 :    if ( lpViewOI->vOriginalOI )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $L10209

; 7996 :       bOptimistic = TRUE;

	mov	BYTE PTR _bOptimistic$[ebp], 1

; 7997 :    else

	jmp	SHORT $L10210
$L10209:

; 7998 :       bOptimistic = FALSE;

	mov	BYTE PTR _bOptimistic$[ebp], 0
$L10210:

; 7999 : 
; 8000 :    // We store information now as bit-flags.
; 8001 :    FileHeader.chTypeIndicator[ 0 ] = szlNewPortableHeader[ 0 ];

	mov	ecx, DWORD PTR _szlNewPortableHeader
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _FileHeader$[ebp], dl

; 8002 : 
; 8003 :    // DGC 1999.05.07
; 8004 :    // Used to be binary indicator.  Now it determines if the ER date is store
; 8005 :    // with with a compressed OI.  This flag can be re-used for something else
; 8006 :    // when all customers are using post-9j core.
; 8007 :    FileHeader.chTypeIndicator[ 1 ] = '1'; // This release always store date.

	mov	BYTE PTR _FileHeader$[ebp+1], 49	; 00000031H

; 8008 : 
; 8009 :    if ( bIncremental )

	mov	eax, DWORD PTR _bIncremental$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10211

; 8010 :       FileHeader.chTypeIndicator[ 2 ] = '1';

	mov	BYTE PTR _FileHeader$[ebp+2], 49	; 00000031H

; 8011 :    else

	jmp	SHORT $L10212
$L10211:

; 8012 :       FileHeader.chTypeIndicator[ 2 ] = '0';

	mov	BYTE PTR _FileHeader$[ebp+2], 48	; 00000030H
$L10212:

; 8013 : 
; 8014 :    if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L10213

; 8015 :       FileHeader.chTypeIndicator[ 3 ] = '1';

	mov	BYTE PTR _FileHeader$[ebp+3], 49	; 00000031H

; 8016 :    else

	jmp	SHORT $L10214
$L10213:

; 8017 :       FileHeader.chTypeIndicator[ 3 ] = '0';

	mov	BYTE PTR _FileHeader$[ebp+3], 48	; 00000030H
$L10214:

; 8018 : 
; 8019 :    if ( bOptimistic )

	mov	edx, DWORD PTR _bOptimistic$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L10215

; 8020 :       FileHeader.chTypeIndicator[ 4 ] = '1';

	mov	BYTE PTR _FileHeader$[ebp+4], 49	; 00000031H

; 8021 :    else

	jmp	SHORT $L10216
$L10215:

; 8022 :       FileHeader.chTypeIndicator[ 4 ] = '0';

	mov	BYTE PTR _FileHeader$[ebp+4], 48	; 00000030H
$L10216:

; 8023 : 
; 8024 : #ifdef USE_ATTRIBFLAGS
; 8025 :    // Using attribute flags logic.
; 8026 :    if ( bIncremental )
; 8027 :       FileHeader.chTypeIndicator[ 5 ] = '1';
; 8028 :    else
; 8029 :       FileHeader.chTypeIndicator[ 5 ] = '0';
; 8030 : #else
; 8031 :    // Reserved for later use...
; 8032 :    FileHeader.chTypeIndicator[ 5 ] = '-';

	mov	BYTE PTR _FileHeader$[ebp+5], 45	; 0000002dH

; 8033 : #endif
; 8034 : 
; 8035 :    zstrcpy( FileHeader.szZeidon, szlmZeidon );

	mov	eax, DWORD PTR _szlmZeidon
	push	eax
	lea	ecx, DWORD PTR _FileHeader$[ebp+6]
	push	ecx
	call	_strcpy
	add	esp, 8

; 8036 : 
; 8037 :    pchFileNmp = (zPCHAR) cpcHeaderName;

	mov	edx, DWORD PTR _cpcHeaderName$[ebp]
	mov	DWORD PTR _pchFileNmp$[ebp], edx

; 8038 :    pchLine    = (zPCHAR) cpcHeaderName;

	mov	eax, DWORD PTR _cpcHeaderName$[ebp]
	mov	DWORD PTR _pchLine$[ebp], eax
$L10220:

; 8039 :    while ( (pchLine = zstrchr( pchLine, cDirSep )) != 0 )

	movsx	ecx, BYTE PTR _cDirSep
	push	ecx
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchLine$[ebp], eax
	cmp	DWORD PTR _pchLine$[ebp], 0
	je	SHORT $L10221

; 8041 :       pchLine++;

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLine$[ebp], eax

; 8042 :       pchFileNmp = pchLine;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	mov	DWORD PTR _pchFileNmp$[ebp], ecx

; 8043 :    }

	jmp	SHORT $L10220
$L10221:

; 8044 : 
; 8045 :    // we are building the header record for this file and realize that the
; 8046 :    // file name we are copying to FileHeader.szFileName may be longer than
; 8047 :    // sizeof( FileHeader.szFileName ).  This is OK since the FileHeader
; 8048 :    // structure is large enough to accomodate an overwrite.
; 8049 :    zstrcpy( FileHeader.szFileName, pchFileNmp );

	mov	edx, DWORD PTR _pchFileNmp$[ebp]
	push	edx
	lea	eax, DWORD PTR _FileHeader$[ebp+16]
	push	eax
	call	_strcpy
	add	esp, 8

; 8050 :    pchLine = zstrchr( FileHeader.szFileName, '.' );

	push	46					; 0000002eH
	lea	ecx, DWORD PTR _FileHeader$[ebp+16]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchLine$[ebp], eax

; 8051 :    if ( pchLine )

	cmp	DWORD PTR _pchLine$[ebp], 0
	je	SHORT $L10222

; 8053 :       zstrcpy( pchLine, "        " );

	push	OFFSET FLAT:??_C@_08ION@?5?5?5?5?5?5?5?5?$AA@ ; `string'
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 8054 :       pchLine[ 0 ] = 0;

	mov	eax, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [eax], 0
$L10222:

; 8056 : 
; 8057 :    SysTranslateString( FileHeader.szFileName, 'U' );

	push	85					; 00000055H
	lea	ecx, DWORD PTR _FileHeader$[ebp+16]
	push	ecx
	call	_SysTranslateString@8

; 8058 :    zstrcpy( FileHeader.szObjectType, lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _FileHeader$[ebp+25]
	push	eax
	call	_strcpy
	add	esp, 8

; 8059 :    SysGetDateTime( szDateTime );

	lea	ecx, DWORD PTR _szDateTime$[ebp]
	push	ecx
	call	_SysGetDateTime@4

; 8060 :    fnDateTimeFormat( szDateTime, FileHeader.szDate, FileHeader.szTime );

	lea	edx, DWORD PTR _FileHeader$[ebp+45]
	push	edx
	lea	eax, DWORD PTR _FileHeader$[ebp+34]
	push	eax
	lea	ecx, DWORD PTR _szDateTime$[ebp]
	push	ecx
	call	_fnDateTimeFormat
	add	esp, 12					; 0000000cH

; 8061 :    // Even if this is not a MetaOI, we should force the release level for
; 8062 :    // all files to be at the minimal level of the software.
; 8063 :    if ( MiCompareOI_ToRelease( lpView, szlReleaseCompatible ) < 0 )

	mov	edx, DWORD PTR _szlReleaseCompatible
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_MiCompareOI_ToRelease@8
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $L10224

; 8065 :       MiSetOI_ReleaseForView( lpView, szlReleaseCompatible );

	mov	edx, DWORD PTR _szlReleaseCompatible
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_MiSetOI_ReleaseForView@8
$L10224:

; 8067 : 
; 8068 :    // if we are using new features, force to current Release
; 8069 :    if ( (lControl & zENCODE_BLOBS) || (lControl & zNO_NULL_STRING_TERM) )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 4194304				; 00400000H
	test	ecx, ecx
	jne	SHORT $L10226
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 8388608				; 00800000H
	test	edx, edx
	je	SHORT $L10225
$L10226:

; 8071 :       MiSetOI_ReleaseForView( lpView, szlReleaseCurrent );

	mov	eax, DWORD PTR _szlReleaseCurrent
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MiSetOI_ReleaseForView@8
$L10225:

; 8073 : 
; 8074 :    zstrcpy( FileHeader.szRelease, lpViewOI->szRelease );  // dks 3/5/96

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	lea	eax, DWORD PTR _FileHeader$[ebp+54]
	push	eax
	call	_strcpy
	add	esp, 8

; 8075 :    pchLine = FileHeader.chTypeIndicator;

	lea	ecx, DWORD PTR _FileHeader$[ebp]
	mov	DWORD PTR _pchLine$[ebp], ecx

; 8076 :    for ( k = 0; k < sizeof( FileHeaderRecord ); k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L10228
$L10229:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L10228:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 73					; 00000049H
	jae	SHORT $L10230

; 8078 :       if ( pchLine[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $L10231

; 8079 :          pchLine[ k ] = ' ';

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [edx+ecx], 32			; 00000020H
$L10231:

; 8080 :    }

	jmp	SHORT $L10229
$L10230:

; 8081 : 
; 8082 :    FileHeader.nEntityInstanceRecordSize = 0;

	mov	WORD PTR _FileHeader$[ebp+63], 0

; 8083 : 
; 8084 :    if ( (*lpfnStreamFunc)( lpView, lpvData, (zPCHAR) &FileHeader,
; 8085 :                            0, zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	lea	eax, DWORD PTR _FileHeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	eax, ax
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L10233

; 8087 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10183
$L10233:

; 8089 : 
; 8090 :    // Write the ER date from the OD if we have incrementals.
; 8091 :    if ( bIncremental &&
; 8092 :         (*lpfnStreamFunc)( lpView, lpvData, lpViewOD->szER_Date,
; 8093 :                            0, zTYPE_STRING ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _bIncremental$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L10234
	push	83					; 00000053H
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 248				; 000000f8H
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $L10234

; 8095 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10183
$L10234:

; 8097 : 
; 8098 :    // Write the flags used to activate the OI.
; 8099 :    if ( lpViewOI->lActivateControl )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $L10237

; 8101 :       zsprintf( szTemp, "mCONTROL %lx", lpViewOI->lActivateControl );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	push	OFFSET FLAT:??_C@_0N@LHOF@mCONTROL?5?$CFlx?$AA@ ; `string'
	lea	eax, DWORD PTR _szTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 8102 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szTemp, 0,
; 8103 :                               zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szTemp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $L10237

; 8105 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10183
$L10237:

; 8108 : 
; 8109 :    nRC = fnWriteOI_ToTextStream( lpView, lpfnStreamFunc, lpvData,
; 8110 :                                  bIncremental, lControl );

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	al, BYTE PTR _bIncremental$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpfnStreamFunc$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnWriteOI_ToTextStream
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 8111 : 
; 8112 :    // Write the original OI for optimistic locking.
; 8113 :    if ( nRC == 0 && bOptimistic )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L10238
	mov	edx, DWORD PTR _bOptimistic$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L10238

; 8115 :       if ( (*lpfnStreamFunc)( lpView, lpvData, "ZEND",
; 8116 :                               0, zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	push	OFFSET FLAT:??_C@_04JJOE@ZEND?$AA@	; `string'
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $L10239

; 8118 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10183
$L10239:

; 8120 : 
; 8121 :       // Write the OI to the text stream but don't save the cursors.
; 8122 :       nRC = fnWriteOI_ToTextStream( zGETPTR( lpViewOI->vOriginalOI ),
; 8123 :                                     lpfnStreamFunc,
; 8124 :                                     lpvData, bIncremental,
; 8125 :                                     ( lControl & ~zSAVE_CURSORS ) );

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, -262145				; fffbffffH
	push	eax
	mov	cl, BYTE PTR _bIncremental$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpfnStreamFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnWriteOI_ToTextStream
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$L10238:

; 8127 : 
; 8128 :    // Write the qualification OI for optimistic locking.
; 8129 :    if ( nRC == 0 && bOptimistic )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $L10244
	mov	ecx, DWORD PTR _bOptimistic$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L10244

; 8131 :       if ( (*lpfnStreamFunc)( lpView, lpvData, "ZEND",
; 8132 :                               0, zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	push	OFFSET FLAT:??_C@_04JJOE@ZEND?$AA@	; `string'
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $L10243

; 8134 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10183
$L10243:

; 8136 : 
; 8137 :       // Write the OI to the text stream but don't save the cursors.
; 8138 :       if ( lpViewOI->vQualOI )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $L10244

; 8139 :          nRC = fnWriteOI_ToTextStream( zGETPTR( lpViewOI->vQualOI ),
; 8140 :                                        lpfnStreamFunc,
; 8141 :                                        lpvData, bIncremental,
; 8142 :                                        ( lControl & ~zSAVE_CURSORS ) );

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, -262145				; fffbffffH
	push	eax
	mov	cl, BYTE PTR _bIncremental$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpfnStreamFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnWriteOI_ToTextStream
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$L10244:

; 8144 : 
; 8145 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $L10246

; 8146 :       lpViewOI->bUpdatedFile = 0;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L10246:

; 8147 : 
; 8148 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	and	edx, 1
	test	edx, edx
	je	SHORT $L10247

; 8150 :       zCHAR sz[ 100 ];
; 8151 : 
; 8152 :       zsprintf( sz, "(%s) = %lf seconds", lpViewOD->szName,
; 8153 :                 (double) ( SysGetTickCount( ) - lTickCount ) / zTICKS_PER_SECOND );

	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR -300+[ebp], eax
	mov	DWORD PTR -300+[ebp+4], 0
	fild	QWORD PTR -300+[ebp]
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@ ; `string'
	lea	ecx, DWORD PTR _sz$10248[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 8154 :       TraceLineS( "(oi) Total time for SfWriteOI_ToStream ", sz );

	lea	edx, DWORD PTR _sz$10248[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CI@BFCD@?$CIoi?$CJ?5Total?5time?5for?5SfWriteOI_To@ ; `string'
	call	_TraceLineS@8
$L10247:

; 8156 : 
; 8157 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10183:

; 8158 : 
; 8159 : } // SfWriteOI_ToStream

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SfWriteOI_ToStream@20 ENDP
_TEXT	ENDS
PUBLIC	_CommitOI_ToFile@12
EXTRN	_SysCloseFileWithControl@16:NEAR
_TEXT	SEGMENT
_lpView$ = 8
_cpcFileName$ = 12
_lControl$ = 16
_lpCurrentTask$ = -2084
_FileData$ = -2076
_szOpenFileName$ = -2060
_szWork$ = -1028
_hFile$ = -2080
_nTrys$ = -1032
_nRC$ = -2064
_lpApp$10268 = -2088
_CommitOI_ToFile@12 PROC NEAR

; 8184 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2088				; 00000828H

; 8185 :    LPTASK         lpCurrentTask;
; 8186 :    FileDataRecord FileData;
; 8187 :    zCHAR          szOpenFileName[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 8188 :    zCHAR          szWork[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 8189 :    zLONG          hFile;
; 8190 :    zSHORT         nTrys;
; 8191 :    zSHORT         nRC;
; 8192 : 
; 8193 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 8194 :    if ( (lpCurrentTask = fnOperationCall( iCommitOI_ToFile, lpView,
; 8195 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	61					; 0000003dH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L10266

; 8197 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10258
$L10266:

; 8199 : 
; 8200 : // DGC 9/23/96
; 8201 : // I changed the logic: if the file name is not qualfied, use the object dir
; 8202 : // for the application. I repeated this change in CommitOI_ToFile.
; 8203 :    if ( zstrchr( cpcFileName, cDirSep ) == 0 )

	movsx	ecx, BYTE PTR _cDirSep
	push	ecx
	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $L10267

; 8205 :       LPAPP lpApp;
; 8206 : 
; 8207 :       fnGetApplicationForSubtask( &lpApp, lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$10268[ebp]
	push	ecx
	call	_fnGetApplicationForSubtask@8

; 8208 :       if ( lpApp )

	cmp	DWORD PTR _lpApp$10268[ebp], 0
	je	SHORT $L10269

; 8209 :          zstrcpy( szWork, lpApp->szObjectDir );

	mov	edx, DWORD PTR _lpApp$10268[ebp]
	add	edx, 347				; 0000015bH
	push	edx
	lea	eax, DWORD PTR _szWork$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 8210 :       else

	jmp	SHORT $L10270
$L10269:

; 8212 :          lpApp = zGETPTR( AnchorBlock->hSystemApp );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$10268[ebp], eax

; 8213 :          zstrcpy( szWork, lpApp->szObjectDir );

	mov	eax, DWORD PTR _lpApp$10268[ebp]
	add	eax, 347				; 0000015bH
	push	eax
	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$L10270:

; 8215 : 
; 8216 :       SysAppendcDirSep( szWork );

	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 8218 :    else

	jmp	SHORT $L10272
$L10267:

; 8219 :       szWork[ 0 ] = 0;

	mov	BYTE PTR _szWork$[ebp], 0
$L10272:

; 8220 : 
; 8221 :    zstrcat( szWork, cpcFileName );

	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 8222 :    SysConvertEnvironmentString( szOpenFileName, szWork );

	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	call	_SysConvertEnvironmentString@8

; 8223 : 
; 8224 :    // Open the file for the object instance data ... this file really should
; 8225 :    // exist, but it may already be open.  So we will try more than once to
; 8226 :    // open it before giving up.
; 8227 :    hFile = -1;

	mov	DWORD PTR _hFile$[ebp], -1

; 8228 :    nTrys = 0;

	mov	WORD PTR _nTrys$[ebp], 0
$L10274:

; 8229 :    while ( hFile == -1 && nTrys++ < 10 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L10275
	movsx	ecx, WORD PTR _nTrys$[ebp]
	mov	dx, WORD PTR _nTrys$[ebp]
	add	dx, 1
	mov	WORD PTR _nTrys$[ebp], dx
	cmp	ecx, 10					; 0000000aH
	jge	SHORT $L10275

; 8231 :       hFile = SysOpenFile( lpView, szOpenFileName,
; 8232 :                 COREFILE_CREATE | COREFILE_WRITELINE_BUFFERED | COREFILE_BACKUP );

	push	4129					; 00001021H
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 8233 :       if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L10276

; 8234 :          SysWait( 500 );

	push	500					; 000001f4H
	call	_SysWait@4
$L10276:

; 8235 :    }

	jmp	SHORT $L10274
$L10275:

; 8236 : 
; 8237 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L10277

; 8239 :       //  "KZOEE071 - Error opening instance file "
; 8240 :       fnIssueCoreError( lpCurrentTask, lpView, 16, 71, 0, cpcFileName, 0 );

	push	0
	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	push	0
	push	71					; 00000047H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8241 :       fnOperationReturn( iCommitOI_ToFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	61					; 0000003dH
	call	_fnOperationReturn
	add	esp, 8

; 8242 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10258
$L10277:

; 8244 : 
; 8245 :    FileData.pchFileName = (zPCHAR) cpcFileName;

	mov	eax, DWORD PTR _cpcFileName$[ebp]
	mov	DWORD PTR _FileData$[ebp], eax

; 8246 :    FileData.hFile       = hFile;

	mov	ecx, DWORD PTR _hFile$[ebp]
	mov	DWORD PTR _FileData$[ebp+4], ecx

; 8247 :    FileData.lLine       = 0;

	mov	DWORD PTR _FileData$[ebp+8], 0

; 8248 : 
; 8249 :    nRC = SfWriteOI_ToStream( lpView, cpcFileName, lControl,
; 8250 :                              fnPutDataToFile, (zPVOID) &FileData );

	lea	edx, DWORD PTR _FileData$[ebp]
	push	edx
	push	OFFSET FLAT:_fnPutDataToFile@20
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SfWriteOI_ToStream@20
	mov	WORD PTR _nRC$[ebp], ax

; 8251 : 
; 8252 :    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L10280

; 8253 :       SysCloseFileWithControl( lpView, hFile, 0, CLOSEFILE_ABORT_BACKUP );

	push	1
	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysCloseFileWithControl@16

; 8254 :    else

	jmp	SHORT $L10281
$L10280:

; 8255 :       nRC = SysCloseFileWithControl( lpView, hFile, 0, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysCloseFileWithControl@16
	mov	WORD PTR _nRC$[ebp], ax
$L10281:

; 8256 : 
; 8257 :    fnOperationReturn( iCommitOI_ToFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	61					; 0000003dH
	call	_fnOperationReturn
	add	esp, 8

; 8258 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10258:

; 8259 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_CommitOI_ToFile@12 ENDP
_lpView$ = 8
_lpCurrentTask$ = -8
_nRC$ = -4
_DropObjectInstance@4 PROC NEAR

; 8282 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 8283 :    LPTASK            lpCurrentTask;
; 8284 :    zSHORT            nRC;
; 8285 : 
; 8286 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 8287 :    if ( (lpCurrentTask = fnOperationCall( iDropObjectInstance, lpView,
; 8288 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	70					; 00000046H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L10287

; 8290 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L10284
$L10287:

; 8292 : 
; 8293 :    // Call fnDropObjectInstance with current view
; 8294 :    nRC = fnDropObjectInstance( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropObjectInstance
	add	esp, 4
	mov	WORD PTR _nRC$[ebp], ax

; 8295 : 
; 8296 :    fnOperationReturn( iDropObjectInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	70					; 00000046H
	call	_fnOperationReturn
	add	esp, 8

; 8297 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10284:

; 8298 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DropObjectInstance@4 ENDP
_TEXT	ENDS
PUBLIC	_ObjectInstanceUpdated@4
_TEXT	SEGMENT
_lpView$ = 8
_lpCurrentTask$ = -16
_lpViewCsr$ = -4
_lpViewOI$ = -12
_nRC$ = -8
_ObjectInstanceUpdated@4 PROC NEAR

; 8318 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 8319 :    LPTASK            lpCurrentTask;
; 8320 :    LPVIEWCSR         lpViewCsr;
; 8321 :    LPVIEWOI          lpViewOI;
; 8322 :    zSHORT            nRC;
; 8323 : 
; 8324 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 8325 :    if ( (lpCurrentTask = fnOperationCall( iObjectInstanceUpdated, lpView,
; 8326 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	118					; 00000076H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L10295

; 8328 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L10290
$L10295:

; 8330 : 
; 8331 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8332 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8333 :    nRC = lpViewOI->bUpdated;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 4
	and	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 8334 : 
; 8335 :    fnOperationReturn( iObjectInstanceUpdated, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	118					; 00000076H
	call	_fnOperationReturn
	add	esp, 8

; 8336 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10290:

; 8337 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_ObjectInstanceUpdated@4 ENDP
_TEXT	ENDS
PUBLIC	_ObjectInstanceUpdatedFromFile@4
_TEXT	SEGMENT
_lpView$ = 8
_lpCurrentTask$ = -16
_lpViewCsr$ = -4
_lpViewOI$ = -12
_nRC$ = -8
_ObjectInstanceUpdatedFromFile@4 PROC NEAR

; 8358 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 8359 :    LPTASK            lpCurrentTask;
; 8360 :    LPVIEWCSR         lpViewCsr;
; 8361 :    LPVIEWOI          lpViewOI;
; 8362 :    zSHORT            nRC;
; 8363 : 
; 8364 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 8365 :    if ( (lpCurrentTask = fnOperationCall( iObjectInstanceUpdatedFromFile,
; 8366 :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	130					; 00000082H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L10305

; 8368 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L10300
$L10305:

; 8370 : 
; 8371 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8372 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8373 :    nRC       = lpViewOI->bUpdatedFile;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 5
	and	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 8374 : 
; 8375 :    fnOperationReturn( iObjectInstanceUpdatedFromFile, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	130					; 00000082H
	call	_fnOperationReturn
	add	esp, 8

; 8376 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10300:

; 8377 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_ObjectInstanceUpdatedFromFile@4 ENDP
_TEXT	ENDS
PUBLIC	_fnDropViewOI
_TEXT	SEGMENT
_lpViewCsr$ = 8
_lpViewOI$ = -28
_hViewCsr$ = -24
_lpViewSubobject$ = -12
_lpSelectedInstance$ = -16
_lpView$ = -4
_bMutexLocked$ = -20
_nRC$ = -8
_lpViewOD$10323 = -32
_ViewCluster$10326 = -40
_nState$10329 = -44
_lpCurrentTask$10330 = -48
_lpWorkViewCsr$10338 = -52
_fnDropViewCsr PROC NEAR

; 8399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 8400 :    LPVIEWOI           lpViewOI;
; 8401 :    LPVIEWCSR          hViewCsr = (LPVIEWCSR) zGETHNDL( lpViewCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hViewCsr$[ebp], eax

; 8402 :    LPVIEWSUBOBJECT    lpViewSubobject;
; 8403 :    LPSELECTEDINSTANCE lpSelectedInstance;
; 8404 :    zVIEW              lpView;
; 8405 :    zBOOL              bMutexLocked;
; 8406 :    zSHORT             nRC;
; 8407 : 
; 8408 :    if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	jne	SHORT $L10320

; 8409 :       return( 0 );

	xor	ax, ax
	jmp	$L10310
$L10320:

; 8410 : 
; 8411 :    lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8412 : 
; 8413 : #ifdef __ACTIVATE_CONSTRAINTS__
; 8414 :    // Check to see if we are dropping the last ViewCsr for the OI.  If we are
; 8415 :    // then we need to call the DropOI constraint.
; 8416 :    if ( lpViewOI->hFirstViewCsr == hViewCsr && lpViewCsr->hNextViewCsr == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	cmp	ecx, DWORD PTR _hViewCsr$[ebp]
	jne	$L10328
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+2], 0
	jne	$L10328

; 8418 :       LPVIEWOD lpViewOD;
; 8419 : 
; 8420 :       // We are dropping the last view csr which means we are dropping the
; 8421 :       // OI as well.
; 8422 :       lpView   = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 8423 : 
; 8424 :       // If the OI has pessimistic locking then commit the OI to drop the
; 8425 :       // locks.
; 8426 :       if ( lpViewOI->bIsLocked )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 7
	and	eax, 1
	test	eax, eax
	je	SHORT $L10325

; 8428 :          ViewClusterRecord ViewCluster;
; 8429 : 
; 8430 :          ViewCluster.vOI      = lpView;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _ViewCluster$10326[ebp], ecx

; 8431 :          ViewCluster.lControl = zCOMMIT_DROPLOCKSONLY;

	mov	DWORD PTR _ViewCluster$10326[ebp+4], 2048 ; 00000800H

; 8432 : 
; 8433 :          // We need to commit the object to release the pessimistic lock.
; 8434 :          nRC = CommitMultipleOIs( &ViewCluster, 1, 0, zCOMMIT_DROPLOCKSONLY );

	push	2048					; 00000800H
	push	0
	push	1
	lea	edx, DWORD PTR _ViewCluster$10326[ebp]
	push	edx
	call	_CommitMultipleOIs@16
	mov	WORD PTR _nRC$[ebp], ax
$L10325:

; 8436 : 
; 8437 :       // If object has drop oi constraint active, check for objections.
; 8438 :       lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$10323[ebp], eax

; 8439 :       if ( lpViewOD->bDropOIConstraint )

	mov	edx, DWORD PTR _lpViewOD$10323[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	je	SHORT $L10328

; 8441 :          zSHORT nState = 0;

	mov	WORD PTR _nState$10329[ebp], 0

; 8442 :          LPTASK lpCurrentTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$10330[ebp], eax

; 8443 : 
; 8444 :          if ( lpCurrentTask->bShutdown )

	mov	eax, DWORD PTR _lpCurrentTask$10330[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10332

; 8445 :             nState += zOCE_STATE_SHUTDOWN;

	mov	dx, WORD PTR _nState$10329[ebp]
	add	dx, 2
	mov	WORD PTR _nState$10329[ebp], dx
$L10332:

; 8446 : 
; 8447 :          fnInvokeOCEOperation( zGETPTR( lpViewCsr->hView ),
; 8448 :                                lpCurrentTask, zOCE_DROPOI, nState );

	mov	ax, WORD PTR _nState$10329[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _lpCurrentTask$10330[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H

; 8449 :          lpViewOI->bDropConstraintInvoked = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L10328:

; 8452 : #endif
; 8453 : 
; 8454 :    if ( lpViewOI->hTask == AnchorBlock->hMainTask )  // added dks

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [ecx+14]
	cmp	eax, DWORD PTR [edx+106]
	jne	SHORT $L10334

; 8456 :       bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$[ebp], 1

; 8457 :       zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 8459 :    else

	jmp	SHORT $L10335
$L10334:

; 8460 :       bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$[ebp], 0
$L10335:

; 8461 : 
; 8462 :    // Unchain ViewCsr from View OI.
; 8463 :    if ( lpViewOI->hFirstViewCsr == hViewCsr )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	cmp	edx, DWORD PTR _hViewCsr$[ebp]
	jne	SHORT $L10336

; 8464 :       lpViewOI->hFirstViewCsr = lpViewCsr->hNextViewCsr;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+10], edx

; 8465 :    else

	jmp	SHORT $L10337
$L10336:

; 8467 :       LPVIEWCSR lpWorkViewCsr;
; 8468 : 
; 8469 :       lpWorkViewCsr = zGETPTR( lpViewOI->hFirstViewCsr ); // blew on this line 2006.07.03 dks

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewCsr$10338[ebp], eax
$L10341:

; 8470 :       while ( lpWorkViewCsr->hNextViewCsr != hViewCsr )

	mov	edx, DWORD PTR _lpWorkViewCsr$10338[ebp]
	mov	eax, DWORD PTR [edx+2]
	cmp	eax, DWORD PTR _hViewCsr$[ebp]
	je	SHORT $L10342

; 8471 :          lpWorkViewCsr = zGETPTR( lpWorkViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpWorkViewCsr$10338[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewCsr$10338[ebp], eax
	jmp	SHORT $L10341
$L10342:

; 8472 : 
; 8473 :       lpWorkViewCsr->hNextViewCsr = lpViewCsr->hNextViewCsr;

	mov	eax, DWORD PTR _lpWorkViewCsr$10338[ebp]
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+2], edx
$L10337:

; 8475 : 
; 8476 :    while ( lpViewCsr->hFirstViewSubobject )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $L10346

; 8478 :       lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 8479 :       lpViewCsr->hFirstViewSubobject = lpViewSubobject->hNextViewSubobject;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+30], edx

; 8480 :       fnFreeDataspace( lpViewSubobject );

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 8481 :    }

	jmp	SHORT $L10337
$L10346:

; 8482 : 
; 8483 :    while ( lpViewCsr->hFirstSelectedInstance )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	SHORT $L10350

; 8485 :       lpSelectedInstance = zGETPTR( lpViewCsr->hFirstSelectedInstance );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSelectedInstance$[ebp], eax

; 8486 :       lpViewCsr->hFirstSelectedInstance =
; 8487 :                               lpSelectedInstance->hNextSelectedInstance;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR _lpSelectedInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+42], eax

; 8488 :       fnFreeDataspace( lpSelectedInstance );

	mov	ecx, DWORD PTR _lpSelectedInstance$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8489 :    }

	jmp	SHORT $L10346
$L10350:

; 8490 : 
; 8491 :    // If the view which used to point to us *still* points to us, then
; 8492 :    // zero out the pointer since we are going away.
; 8493 :    lpView = zGETPTR( lpViewCsr->hView );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 8494 :    if ( lpView && lpView->hViewCsr == hViewCsr )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $L10353
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	cmp	edx, DWORD PTR _hViewCsr$[ebp]
	jne	SHORT $L10353

; 8495 :       lpView->hViewCsr = 0;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+10], 0
$L10353:

; 8496 : 
; 8497 :    fnFreeDataspace( lpViewCsr );  // should this line be moved to after the following if block?? dks 2006.07.19

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8498 : 
; 8499 :    // If the ViewOI has no more cursors, drop it!
; 8500 :    if ( lpViewOI->hFirstViewCsr == 0 )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+10], 0
	jne	SHORT $L10354

; 8501 :       fnDropViewOI( lpViewOI );  // dks 2006.09.18 error while cleaning up client OE

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnDropViewOI
	add	esp, 4
$L10354:

; 8502 : 
; 8503 :    if ( bMutexLocked )

	mov	ecx, DWORD PTR _bMutexLocked$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L10355

; 8504 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$L10355:

; 8505 : 
; 8506 :    return( 0 );

	xor	ax, ax
$L10310:

; 8507 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropViewCsr ENDP
_lpView$ = 8
_lpViewOI$ = -20
_lpViewCsr$ = -4
_lpFirstViewCsr$ = -12
_lpCurrentView$ = -8
_lpLastView$ = -16
_fnDropObjectInstance PROC NEAR

; 8526 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 8527 :    LPVIEWOI          lpViewOI;
; 8528 :    LPVIEWCSR         lpViewCsr;
; 8529 :    LPVIEWCSR         lpFirstViewCsr;
; 8530 :    zVIEW             lpCurrentView;
; 8531 :    zVIEW             lpLastView;
; 8532 : 
; 8533 :    // If no ViewCsr, go home ...
; 8534 :    if ( lpView->hViewCsr == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $L10364

; 8535 :       return( 0 );

	xor	ax, ax
	jmp	$L10358
$L10364:

; 8536 : 
; 8537 :    // Get pointers to ViewOI and task owning the ViewOI.
; 8538 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8539 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax
$L10368:

; 8540 : 
; 8541 : // {
; 8542 : //    LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );
; 8543 : //    TraceLine( "DropObjectInstance: 0x%08x   LOD: %s",
; 8544 : //               lpView, lpViewOD->szName );
; 8545 : //    if ( zstrcmp( "KZMSGQOO", lpViewOD->szName ) == 0 )
; 8546 : //       SysMessageBox( lpView, "Dropping LOD", lpViewOD->szName, 0 );
; 8547 : // }
; 8548 : 
; 8549 :    // Find the last view cursor for the ViewOI.
; 8550 :    while ( lpViewCsr->hNextViewCsr )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+2], 0
	je	SHORT $L10369

; 8551 :       lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
	jmp	SHORT $L10368
$L10369:

; 8552 : 
; 8553 :    // Drop all the views.  When the last view is dropped, fnDropView will
; 8554 :    // drop the object instance.  The DropObjectInstance constraint will
; 8555 :    // be called then.
; 8556 :    lpLastView = zGETPTR( lpViewCsr->hView );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastView$[ebp], eax

; 8557 :    lpCurrentView = 0;

	mov	DWORD PTR _lpCurrentView$[ebp], 0
$L10372:

; 8560 :       lpFirstViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewCsr$[ebp], eax

; 8561 :       lpCurrentView = zGETPTR( lpFirstViewCsr->hView );

	mov	eax, DWORD PTR _lpFirstViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentView$[ebp], eax

; 8562 :       fnDropView( lpCurrentView );

	mov	edx, DWORD PTR _lpCurrentView$[ebp]
	push	edx
	call	_fnDropView@4

; 8563 : 
; 8564 :    }  while ( lpCurrentView != lpLastView );

	mov	eax, DWORD PTR _lpCurrentView$[ebp]
	cmp	eax, DWORD PTR _lpLastView$[ebp]
	jne	SHORT $L10372

; 8565 : 
; 8566 :    return( 0 );

	xor	ax, ax
$L10358:

; 8567 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropObjectInstance ENDP
_TEXT	ENDS
PUBLIC	_fnClearLinks@4
_TEXT	SEGMENT
_lpEntityInstance$ = 8
_lpNextLinked$ = -4
_lpSearchLink$ = -12
_hEntityInstance$ = -8
_fnClearLinks@4 PROC NEAR

; 8571 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 8572 :    LPENTITYINSTANCE lpNextLinked;
; 8573 :    LPENTITYINSTANCE lpSearchLink;
; 8574 :    LPENTITYINSTANCE hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hEntityInstance$[ebp], eax

; 8575 : 
; 8576 :    lpNextLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax

; 8577 : 
; 8578 :    if ( lpNextLinked->hNextLinked == hEntityInstance )

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	cmp	ecx, DWORD PTR _hEntityInstance$[ebp]
	jne	SHORT $L10386

; 8579 :       lpNextLinked->hNextLinked = 0;

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+42], 0

; 8580 :    else

	jmp	SHORT $L10387
$L10386:

; 8582 :       lpSearchLink = lpNextLinked;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$L10389:

; 8583 :       while ( lpSearchLink->hNextLinked != hEntityInstance )

	mov	ecx, DWORD PTR _lpSearchLink$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	cmp	edx, DWORD PTR _hEntityInstance$[ebp]
	je	SHORT $L10390

; 8584 :          lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
	jmp	SHORT $L10389
$L10390:

; 8585 : 
; 8586 :       lpSearchLink->hNextLinked = lpEntityInstance->hNextLinked;

	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
$L10387:

; 8588 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnClearLinks@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@GGJF@Trying?5to?5drop?5original?5OI?5but?5i@ ; `string'
EXTRN	_fnDeleteAttributeRecord:NEAR
EXTRN	_fnRemoveEntityFromDebugChange@4:NEAR
;	COMDAT ??_C@_0CP@GGJF@Trying?5to?5drop?5original?5OI?5but?5i@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CP@GGJF@Trying?5to?5drop?5original?5OI?5but?5i@ DB 'Trying to drop'
	DB	' original OI but it''s not there!', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpViewOI$ = 8
_lpEntityInstance$ = -4
_lpNextEntityInstance$ = -16
_lpLastEntityInstance$ = -12
_lpSearchLink$ = -20
_lpSearchVsn$ = -28
_lpOwningTask$ = -8
_bPrevVersion$ = -24
_vOriginalOI$10404 = -32
_lpPrevVsn$10426 = -36
_lpViewEntity$10445 = -40
_lpNextVsn$10449 = -44
_lpNextVsn$10475 = -48
_lpPrevVsn$10478 = -52
_lpNextLinked$10481 = -56
_lpSearchViewOI$10496 = -60
_fnDropViewOI PROC NEAR

; 8604 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 8605 :    LPENTITYINSTANCE  lpEntityInstance;
; 8606 :    LPENTITYINSTANCE  lpNextEntityInstance;
; 8607 :    LPENTITYINSTANCE  lpLastEntityInstance;
; 8608 :    LPENTITYINSTANCE  lpSearchLink;
; 8609 :    LPENTITYINSTANCE  lpSearchVsn;
; 8610 :    LPTASK            lpOwningTask;
; 8611 :    zBOOL             bPrevVersion;
; 8612 : 
; 8613 :    lpOwningTask = zGETPTR( lpViewOI->hTask );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 8614 : 
; 8615 :    // If the ViewOI is in a task being shutdown and does not have any
; 8616 :    // instances shared with the system task, skip freeing up the instance
; 8617 :    // data, it will go away on completion of task cleanup.
; 8618 :    // If the task is running as a server task then we won't free memory
; 8619 :    // because it will be shut down shortly.
; 8620 :    // Things are unfortunately not working as suggested in the comment above.
; 8621 :    // So always do a drop, even when the task is a server task and is being
; 8622 :    // shutdown (US).
; 8623 :    // Check to see if we have any locking OI's.  If we do, drop them.
; 8624 :    if ( lpViewOI->vOriginalOI )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $L10409

; 8626 :       zVIEW vOriginalOI = zGETPTR( lpViewOI->vOriginalOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vOriginalOI$10404[ebp], eax

; 8627 : 
; 8628 :       // DGC 05/05/97
; 8629 :       // Following check shouldn't be needed once I fix a bug.
; 8630 :       if ( vOriginalOI->nTableID != iView )

	mov	edx, DWORD PTR _vOriginalOI$10404[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10021				; 00002725H
	je	SHORT $L10406

; 8632 :          fnSysMessageBox( zGETPTR( lpViewOI->hTask ), szlOE_SystemError,
; 8633 :                           "Trying to drop original OI but it's not there!", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CP@GGJF@Trying?5to?5drop?5original?5OI?5but?5i@ ; `string'
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnSysMessageBox@16

; 8635 :       else

	jmp	SHORT $L10409
$L10406:

; 8636 :          fnDropView( vOriginalOI );

	mov	ecx, DWORD PTR _vOriginalOI$10404[ebp]
	push	ecx
	call	_fnDropView@4
$L10409:

; 8638 : 
; 8639 :    if ( lpViewOI->vQualOI )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $L10410

; 8640 :       fnDropView( zGETPTR( lpViewOI->vQualOI ) );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4
$L10410:

; 8641 : 
; 8642 :    // If there are any outstanding versioned instances, find the
; 8643 :    // last entity instance in the object instance and work backward
; 8644 :    // from there to clean up outstanding versioned chains until all
; 8645 :    // versions are gone. First, find the last instance in the chain.
; 8646 :    if ( lpViewOI->nVersionedInstances )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	je	SHORT $L10412

; 8648 :       lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10415:

; 8649 :       while ( lpEntityInstance->hNextHier )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+14], 0
	je	SHORT $L10416

; 8651 :          if ( lpEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $L10417

; 8652 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 8653 :          else

	jmp	SHORT $L10419
$L10417:

; 8654 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10419:

; 8655 :       }

	jmp	SHORT $L10415
$L10416:

; 8656 : 
; 8657 :       lpLastEntityInstance = lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpLastEntityInstance$[ebp], eax
$L10412:

; 8659 : 
; 8660 :    // Delete the instance data associated with the ViewOI.
; 8661 : // AnchorBlock->nStatus = 101; // DGC debugging hack.
; 8662 :    if ( lpViewOI->hRootEntityInstance )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	$L10424
$L10423:

; 8665 :       lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0

; 8666 : 
; 8667 :       // If there are versioned instances out there, let's clean them
; 8668 :       // up!!!  Go to the end of the chain and find one.
; 8669 :       if ( lpViewOI->nVersionedInstances )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	je	$L10439

; 8671 :          LPENTITYINSTANCE lpPrevVsn;
; 8672 : 
; 8673 :          lpEntityInstance = lpLastEntityInstance;

	mov	ecx, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx

; 8674 :          lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$10426[ebp], eax
$L10429:

; 8675 : 
; 8676 :          // Search for an entity instance which has an outstanding
; 8677 :          // previous version.
; 8678 :          while ( lpEntityInstance &&
; 8679 :                  (lpPrevVsn == 0 || lpPrevVsn->u.nInd.bPrevVsnRoot == FALSE) )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L10430
	cmp	DWORD PTR _lpPrevVsn$10426[ebp], 0
	je	SHORT $L10431
	mov	ecx, DWORD PTR _lpPrevVsn$10426[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 9
	and	edx, 1
	test	edx, edx
	jne	SHORT $L10430
$L10431:

; 8681 :             // Since temporal entitys have no previous version, simply
; 8682 :             // unmark them and subtract 1 from the version count.
; 8683 :             if ( lpEntityInstance->u.nInd.bTemporal )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10433

; 8685 :                lpEntityInstance->u.nInd.bTemporal = 0;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -9					; fffffff7H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 8686 :                lpViewOI->nVersionedInstances--;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [ecx+22], ax

; 8687 :                if ( lpViewOI->nVersionedInstances == 0 )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	jne	SHORT $L10433

; 8689 :                   lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0

; 8690 :                   break;

	jmp	SHORT $L10430
$L10433:

; 8693 : 
; 8694 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 8695 :             if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L10435

; 8696 :                lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$10426[ebp], eax
$L10435:

; 8697 :          }

	jmp	$L10429
$L10430:

; 8698 : 
; 8699 :          if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L10437

; 8700 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 8701 :          else

	jmp	SHORT $L10439
$L10437:

; 8702 :             lpViewOI->nVersionedInstances = 0;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [ecx+22], 0
$L10439:

; 8704 : 
; 8705 :       // If no entity instance found which is a previous version, go
; 8706 :       // for the main entity instance chain!!
; 8707 :       if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L10440

; 8709 :          lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 8710 :          lpViewOI->hRootEntityInstance = 0;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+26], 0
$L10440:

; 8712 : 
; 8713 :       // Clean up the entity instances.
; 8714 :       while ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L10444

; 8716 :          LPVIEWENTITY lpViewEntity;
; 8717 : 
; 8718 :          lpNextEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextEntityInstance$[ebp], eax

; 8719 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$10445[ebp], eax

; 8720 : 
; 8721 :          // If there are versioned instances in this instance, zero
; 8722 :          // all records for newer versions linked to this instance
; 8723 :          // whose record matches the link instance record.
; 8724 :          if ( lpEntityInstance->hNextVsn )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+34], 0
	je	$L10467

; 8726 :             LPENTITYINSTANCE lpNextVsn;
; 8727 : 
; 8728 :             // If there are linked instances to the old version of an
; 8729 :             // entity instance, see if the prev-version indicator needs
; 8730 :             // to be unset for all the linked instances because the
; 8731 :             // new version is being dropped by fnDropViewOI.
; 8732 :             if ( lpEntityInstance->hNextLinked )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	$L10461

; 8734 :                bPrevVersion = FALSE;

	mov	BYTE PTR _bPrevVersion$[ebp], 0

; 8735 :                lpSearchLink = zGETPTR( lpEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$L10453:

; 8736 :                while ( lpSearchLink && lpSearchLink != lpEntityInstance )

	cmp	DWORD PTR _lpSearchLink$[ebp], 0
	je	SHORT $L10454
	mov	ecx, DWORD PTR _lpSearchLink$[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L10454

; 8738 :                   if ( lpSearchLink->hNextVsn )

	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $L10455

; 8740 :                      bPrevVersion = TRUE;

	mov	BYTE PTR _bPrevVersion$[ebp], 1

; 8741 :                      break;

	jmp	SHORT $L10454
$L10455:

; 8743 : 
; 8744 :                   lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax

; 8745 :                }

	jmp	SHORT $L10453
$L10454:

; 8746 : 
; 8747 :                if ( bPrevVersion == 0 )

	mov	edx, DWORD PTR _bPrevVersion$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L10461

; 8749 :                   lpSearchLink = zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$L10460:

; 8750 :                   while ( lpSearchLink &&
; 8751 :                           lpSearchLink != lpEntityInstance )

	cmp	DWORD PTR _lpSearchLink$[ebp], 0
	je	SHORT $L10461
	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	cmp	edx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L10461

; 8753 :                      lpSearchLink->u.nInd.bPrevVersion = FALSE;

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ch, -2					; fffffffeH
	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 8754 :                      lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax

; 8755 :                   }

	jmp	SHORT $L10460
$L10461:

; 8758 : 
; 8759 :             // If the newer version record matches the older version
; 8760 :             // record (because the entity is NOT UPDATEABLE), clear
; 8761 :             // all the record pointers in the newer versions so we do
; 8762 :             // not attempt to free the same record multiple times.
; 8763 :             lpNextVsn = zGETPTR( lpEntityInstance->hNextVsn );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextVsn$10449[ebp], eax

; 8764 :             if ( lpNextVsn->hPersistRecord == lpEntityInstance->hPersistRecord )

	mov	ecx, DWORD PTR _lpNextVsn$10449[ebp]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	cmp	eax, DWORD PTR [edx+60]
	jne	SHORT $L10467

; 8766 :                lpSearchVsn = lpNextVsn;

	mov	ecx, DWORD PTR _lpNextVsn$10449[ebp]
	mov	DWORD PTR _lpSearchVsn$[ebp], ecx
$L10466:

; 8767 :                while ( lpSearchVsn )

	cmp	DWORD PTR _lpSearchVsn$[ebp], 0
	je	SHORT $L10467

; 8769 :                   lpSearchVsn->hPersistRecord = 0;

	mov	edx, DWORD PTR _lpSearchVsn$[ebp]
	mov	DWORD PTR [edx+60], 0

; 8770 :                   lpSearchLink = zGETPTR( lpSearchVsn->hNextLinked );

	mov	eax, DWORD PTR _lpSearchVsn$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$L10470:

; 8771 :                   while ( lpSearchLink && lpSearchLink != lpSearchVsn )

	cmp	DWORD PTR _lpSearchLink$[ebp], 0
	je	SHORT $L10471
	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	cmp	edx, DWORD PTR _lpSearchVsn$[ebp]
	je	SHORT $L10471

; 8773 :                      lpSearchLink->hPersistRecord = 0;

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	DWORD PTR [eax+60], 0

; 8774 :                      lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	ecx, DWORD PTR _lpSearchLink$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax

; 8775 :                   }

	jmp	SHORT $L10470
$L10471:

; 8776 : 
; 8777 :                   lpSearchVsn = zGETPTR( lpSearchVsn->hNextVsn );

	mov	eax, DWORD PTR _lpSearchVsn$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchVsn$[ebp], eax

; 8778 :                }

	jmp	SHORT $L10466
$L10467:

; 8781 : 
; 8782 :          // Reset version pointers.
; 8783 :          if ( lpEntityInstance->hNextVsn )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $L10474

; 8785 :             LPENTITYINSTANCE lpNextVsn =
; 8786 :                                  zGETPTR( lpEntityInstance->hNextVsn );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextVsn$10475[ebp], eax

; 8787 : 
; 8788 :             lpNextVsn->hPrevVsn = lpEntityInstance->hPrevVsn;

	mov	edx, DWORD PTR _lpNextVsn$10475[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	mov	DWORD PTR [edx+38], ecx
$L10474:

; 8790 : 
; 8791 :          if ( lpEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $L10477

; 8793 :             LPENTITYINSTANCE lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$10478[ebp], eax

; 8794 : 
; 8795 :             lpPrevVsn->hNextVsn = lpEntityInstance->hNextVsn;

	mov	edx, DWORD PTR _lpPrevVsn$10478[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	mov	DWORD PTR [edx+34], ecx
$L10477:

; 8797 : 
; 8798 :          // If the entity instance is linked, remove the entity instance
; 8799 :          // from the link chain.
; 8800 :          if ( lpEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $L10480

; 8802 :             LPENTITYINSTANCE lpNextLinked =
; 8803 :                               zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$10481[ebp], eax

; 8804 : 
; 8805 :             if ( lpNextLinked->hNextLinked == zGETHNDL( lpEntityInstance ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNextLinked$10481[ebp]
	cmp	DWORD PTR [ecx+42], eax
	jne	SHORT $L10484

; 8806 :                lpNextLinked->hNextLinked = 0;

	mov	edx, DWORD PTR _lpNextLinked$10481[ebp]
	mov	DWORD PTR [edx+42], 0

; 8807 :             else

	jmp	SHORT $L10485
$L10484:

; 8809 :                lpSearchLink = lpNextLinked;

	mov	eax, DWORD PTR _lpNextLinked$10481[ebp]
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$L10488:

; 8810 :                while ( lpSearchLink->hNextLinked !=
; 8811 :                                              zGETHNDL( lpEntityInstance ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	cmp	DWORD PTR [edx+42], eax
	je	SHORT $L10489

; 8812 :                   lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
	jmp	SHORT $L10488
$L10489:

; 8813 : 
; 8814 :                lpSearchLink->hNextLinked = lpEntityInstance->hNextLinked;

	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
$L10485:

; 8817 :          else

	jmp	SHORT $L10491
$L10480:

; 8818 :             fnDeleteAttributeRecord( lpViewEntity, lpEntityInstance, TRUE );  // dks 2006.09.18 error while cleaning up client OE

	push	1
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$10445[ebp]
	push	eax
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH
$L10491:

; 8819 : 
; 8820 :          fnDeleteAttributeRecord( lpViewEntity, lpEntityInstance, FALSE );

	push	0
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$10445[ebp]
	push	edx
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 8821 :          fnRemoveEntityFromDebugChange( lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRemoveEntityFromDebugChange@4

; 8822 :          fnFreeDataspace( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8823 :          lpEntityInstance = lpNextEntityInstance;

	mov	edx, DWORD PTR _lpNextEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx

; 8824 :       }

	jmp	$L10440
$L10444:

; 8825 : 
; 8826 :       // Get out when no root instance exists any more.
; 8827 :       if ( lpViewOI->hRootEntityInstance == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $L10492

; 8828 :          break;

	jmp	SHORT $L10424
$L10492:

; 8829 :    }

	jmp	$L10423
$L10424:

; 8830 : 
; 8831 : // AnchorBlock->nStatus = AnchorInitialized;
; 8832 : 
; 8833 :    // Free the ViewOI.
; 8834 :    if ( lpOwningTask->hFirstViewOI == zGETHNDL( lpViewOI ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	cmp	DWORD PTR [edx+98], eax
	jne	SHORT $L10494

; 8835 :       lpOwningTask->hFirstViewOI = lpViewOI->hNextViewOI;

	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+98], edx

; 8836 :    else

	jmp	SHORT $L10498
$L10494:

; 8838 :       LPVIEWOI lpSearchViewOI;
; 8839 : 
; 8840 :       lpSearchViewOI = zGETPTR( lpOwningTask->hFirstViewOI );

	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	mov	ecx, DWORD PTR [eax+98]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewOI$10496[ebp], eax

; 8841 :       if ( lpSearchViewOI )

	cmp	DWORD PTR _lpSearchViewOI$10496[ebp], 0
	je	SHORT $L10498
$L10501:

; 8843 :          while ( lpSearchViewOI->hNextViewOI != zGETHNDL( lpViewOI ) )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSearchViewOI$10496[ebp]
	cmp	DWORD PTR [ecx+2], eax
	je	SHORT $L10502

; 8844 :             lpSearchViewOI = zGETPTR( lpSearchViewOI->hNextViewOI );

	mov	edx, DWORD PTR _lpSearchViewOI$10496[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewOI$10496[ebp], eax
	jmp	SHORT $L10501
$L10502:

; 8845 : 
; 8846 :          lpSearchViewOI->hNextViewOI = lpViewOI->hNextViewOI;

	mov	ecx, DWORD PTR _lpSearchViewOI$10496[ebp]
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+2], eax
$L10498:

; 8849 : 
; 8850 :    fnFreeDataspace( lpViewOI );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8851 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropViewOI ENDP
_TEXT	ENDS
EXTRN	_fnCreateEntityCsrHandle@12:NEAR
EXTRN	_UfStringToDateTime@8:NEAR
_TEXT	SEGMENT
_lpView$ = 12
_lControl$ = 16
_hInstanceOwningTask$ = -32
_lpInstanceOwningTask$ = -44
_lpViewOD$ = -36
_lpViewOI$ = -60
_lpViewCsr$ = -28
_lpViewEntity$ = -40
_lpViewEntityCsr$ = -64
_szDateTime$ = -24
_hViewOI$ = -52
_hViewCsr$ = -56
_uEntities$ = -4
_nHierNbr$ = -48
_lpParentViewEntityCsr$10548 = -68
_fnActivateEmptyObjectInstance PROC NEAR

; 8882 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 8883 :    LPTASK            hInstanceOwningTask;
; 8884 :    LPTASK            lpInstanceOwningTask;
; 8885 :    LPVIEWOD          lpViewOD;
; 8886 :    LPVIEWOI          lpViewOI;
; 8887 :    LPVIEWCSR         lpViewCsr;
; 8888 :    LPVIEWENTITY      lpViewEntity;
; 8889 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 8890 :    zCHAR             szDateTime[ 20 ];
; 8891 :    zPVOID            hViewOI;
; 8892 :    zPVOID            hViewCsr;
; 8893 :    zUSHORT           uEntities;
; 8894 :    zSHORT            nHierNbr;
; 8895 : 
; 8896 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 8897 : 
; 8898 :    // Determine the task which owns the instance, NOTE, this task
; 8899 :    // should be returned by fnValidView in the future since fnValidView
; 8900 :    // has already done the same search! Gig...9/1/92
; 8901 :    if ( lpView->bApplicationView )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L10524

; 8902 :       hInstanceOwningTask = AnchorBlock->hMainTask;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	mov	DWORD PTR _hInstanceOwningTask$[ebp], edx

; 8903 :    else

	jmp	SHORT $L10525
$L10524:

; 8904 :       hInstanceOwningTask = lpView->hTask;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hInstanceOwningTask$[ebp], ecx
$L10525:

; 8905 : 
; 8906 :    lpInstanceOwningTask = zGETPTR( hInstanceOwningTask );

	mov	edx, DWORD PTR _hInstanceOwningTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInstanceOwningTask$[ebp], eax

; 8907 : 
; 8908 :    // Create a ViewOI Record
; 8909 :    // NOTE: We create view oi records in the main dataspace so all
; 8910 :    // tasks can go through the ViewOI's on clean-up to determine if
; 8911 :    // an application is in use
; 8912 :    hViewOI = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,
; 8913 :                                sizeof( ViewOI_Record ), 1, 0, iViewOI );

	push	10018					; 00002722H
	push	0
	push	1
	push	65					; 00000041H
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewOI$[ebp], eax

; 8914 :    lpViewOI = zGETPTR( hViewOI );

	mov	edx, DWORD PTR _hViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8915 :    if ( lpViewOI == 0 )

	cmp	DWORD PTR _lpViewOI$[ebp], 0
	jne	SHORT $L10529

; 8917 :    // fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );
; 8918 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10510
$L10529:

; 8920 : 
; 8921 :    // Get the count of entities.
; 8922 :    uEntities = lpViewOD->uEntities;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	cx, WORD PTR [eax+234]
	mov	WORD PTR _uEntities$[ebp], cx

; 8923 : 
; 8924 :    // Allocate space for View
; 8925 :    // Create a ViewOI Record
; 8926 :    hViewCsr = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,
; 8927 :                                 sizeof( ViewCsrRecord ) + (zULONG)
; 8928 :                                   (uEntities * sizeof( ViewEntityCsrRecord )),
; 8929 :                                 1, 0, iViewCsr );

	push	10019					; 00002723H
	push	0
	push	1
	mov	edx, DWORD PTR _uEntities$[ebp]
	and	edx, 65535				; 0000ffffH
	imul	edx, 30					; 0000001eH
	add	edx, 46					; 0000002eH
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewCsr$[ebp], eax

; 8930 :    lpViewCsr = zGETPTR( hViewCsr );

	mov	edx, DWORD PTR _hViewCsr$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8931 :    if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	jne	SHORT $L10534

; 8933 :       fnFreeDataspace( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 8934 :    // fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );
; 8935 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10510
$L10534:

; 8937 : 
; 8938 :    // Set up View OI record
; 8939 :    lpViewOI->hViewOD            = zGETHNDL( lpViewOD );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+6], eax

; 8940 :    lpViewOI->hFirstViewCsr      = hViewCsr;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR _hViewCsr$[ebp]
	mov	DWORD PTR [eax+10], ecx

; 8941 :    lpViewOI->hTask              = hInstanceOwningTask;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR _hInstanceOwningTask$[ebp]
	mov	DWORD PTR [edx+14], eax

; 8942 :    lpViewOI->hAllocTask         = hInstanceOwningTask;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR _hInstanceOwningTask$[ebp]
	mov	DWORD PTR [ecx+18], edx

; 8943 : 
; 8944 :    // Put date time stamp into View OI record.
; 8945 :    SysGetDateTime( szDateTime );

	lea	eax, DWORD PTR _szDateTime$[ebp]
	push	eax
	call	_SysGetDateTime@4

; 8946 :    UfStringToDateTime( szDateTime, (LPDATETIME) &(lpViewOI->DateTime) );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	add	ecx, 30					; 0000001eH
	push	ecx
	lea	edx, DWORD PTR _szDateTime$[ebp]
	push	edx
	call	_UfStringToDateTime@8

; 8947 :    zstrcpy( lpViewOI->szRelease, szlReleaseCompatible );  // initialize release for compatiblity

	mov	eax, DWORD PTR _szlReleaseCompatible
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	call	_strcpy
	add	esp, 8

; 8948 : 
; 8949 :    // Mark View OI as read only if requested, and the View also ...
; 8950 :    if ( lControl & zREADONLY )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2048				; 00000800H
	test	edx, edx
	je	SHORT $L10537

; 8952 :       lpViewOI->bReadOnly = TRUE;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 4
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx
$L10537:

; 8954 : 
; 8955 :    if ( lControl & zMULTIPLE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $L10538

; 8956 :       lpViewOI->bMultipleRootLevels = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 1
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 8957 :    else

	jmp	SHORT $L10539
$L10538:

; 8958 :       lpViewOI->bMultipleRootLevels = FALSE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L10539:

; 8959 : 
; 8960 :    // Set up View Cursor Record
; 8961 :    lpViewCsr->hView             = zGETHNDL( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [edx+6], eax

; 8962 :    lpViewCsr->hViewOI           = hViewOI;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR _hViewOI$[ebp]
	mov	DWORD PTR [eax+10], ecx

; 8963 :    lpViewCsr->uEntities         = uEntities;

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	ax, WORD PTR _uEntities$[ebp]
	mov	WORD PTR [edx+34], ax

; 8964 :    lpViewCsr->nCurrentSelectSet = 0x0001;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	WORD PTR [ecx+36], 1

; 8965 : 
; 8966 :    // Set the View Csr in the View
; 8967 :    lpView->hViewCsr             = hViewCsr;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR _hViewCsr$[ebp]
	mov	DWORD PTR [edx+10], eax

; 8968 : 
; 8969 :    // Initialize ViewEntityCsr records
; 8970 :    lpViewEntity    = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 8971 :    lpViewEntityCsr = (LPVIEWENTITYCSR) (lpViewCsr + 1);

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	add	eax, 46					; 0000002eH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 8972 : 
; 8973 :    // Double assignment ...
; 8974 :    lpViewCsr->hRootViewEntityCsr  =         // continued ...
; 8975 :    lpViewCsr->hFirstOD_EntityCsr =
; 8976 :                   fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, 0 );

	push	0
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [ecx+14], eax
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR [edx+18], ecx

; 8977 :    nHierNbr = 1;

	mov	WORD PTR _nHierNbr$[ebp], 1
$L10544:

; 8980 :       lpViewEntityCsr->nTableID    = iViewEntityCsr;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	WORD PTR [edx], 10023			; 00002727H

; 8981 :       lpViewEntityCsr->hViewCsr    = hViewCsr;

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR _hViewCsr$[ebp]
	mov	DWORD PTR [eax+18], ecx

; 8982 :       lpViewEntityCsr->hNextHier   =
; 8983 :                   fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, 1 );

	push	1
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+2], eax

; 8984 :       lpViewEntityCsr->hViewEntity = zGETHNDL( lpViewEntity );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 8985 :       lpViewEntityCsr->nLevel      = lpViewEntity->nLevel;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	cx, WORD PTR [eax+215]
	mov	WORD PTR [edx+22], cx

; 8986 :       lpViewEntityCsr->nHierNbr    = nHierNbr;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ax, WORD PTR _nHierNbr$[ebp]
	mov	WORD PTR [edx+24], ax

; 8987 :       nHierNbr++;

	mov	cx, WORD PTR _nHierNbr$[ebp]
	add	cx, 1
	mov	WORD PTR _nHierNbr$[ebp], cx

; 8988 : 
; 8989 :       if ( lpViewEntity->hPrevHier )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+6], 0
	je	SHORT $L10547

; 8991 :          LPVIEWENTITYCSR lpParentViewEntityCsr;
; 8992 : 
; 8993 :          lpViewEntityCsr->hPrevHier =
; 8994 :                   fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, -1 );

	push	-1
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnCreateEntityCsrHandle@12
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+6], eax

; 8995 :          lpParentViewEntityCsr = zGETPTR( lpViewEntityCsr->hPrevHier );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntityCsr$10548[ebp], eax
$L10551:

; 8996 :          while ( lpParentViewEntityCsr->nLevel >= lpViewEntityCsr->nLevel )

	mov	edx, DWORD PTR _lpParentViewEntityCsr$10548[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	cmp	eax, edx
	jl	SHORT $L10552

; 8998 :             lpParentViewEntityCsr = zGETPTR( lpParentViewEntityCsr->hPrevHier );

	mov	eax, DWORD PTR _lpParentViewEntityCsr$10548[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntityCsr$10548[ebp], eax

; 8999 :          }

	jmp	SHORT $L10551
$L10552:

; 9000 : 
; 9001 :          lpViewEntityCsr->hParent =
; 9002 :                fnCreateEntityCsrHandle( lpParentViewEntityCsr, lpViewCsr, 0 );

	push	0
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParentViewEntityCsr$10548[ebp]
	push	eax
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+10], eax
$L10547:

; 9006 : 
; 9007 :       lpViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9008 : 
; 9009 :       if ( lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $L10555

; 9010 :          lpViewEntityCsr++;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], ecx

; 9011 :       else

	jmp	SHORT $L10556
$L10555:

; 9013 :          lpViewEntityCsr->hNextHier = 0;  // end ViewEntityCsr chain

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+2], 0

; 9014 :          break;

	jmp	SHORT $L10545
$L10556:

; 9016 :    }

	jmp	$L10544
$L10545:

; 9017 : 
; 9018 :    // Chain ViewOI to the application task
; 9019 :    lpViewOI->hNextViewOI = lpInstanceOwningTask->hFirstViewOI;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR _lpInstanceOwningTask$[ebp]
	mov	edx, DWORD PTR [ecx+98]
	mov	DWORD PTR [eax+2], edx

; 9020 :    lpInstanceOwningTask->hFirstViewOI = hViewOI;

	mov	eax, DWORD PTR _lpInstanceOwningTask$[ebp]
	mov	ecx, DWORD PTR _hViewOI$[ebp]
	mov	DWORD PTR [eax+98], ecx

; 9021 : 
; 9022 :    return( 0 );

	xor	ax, ax
$L10510:

; 9023 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnActivateEmptyObjectInstance ENDP
_TEXT	ENDS
PUBLIC	_fnAddHangingEntity@8
PUBLIC	??_C@_0BO@NIPI@?9?5ParentEntity?5?$DN?$DN?5ChildEntity?$AA@ ; `string'
PUBLIC	??_C@_0BI@NMHK@?$CIoi?$CJ?5Hangin?5key?5error?$CB?5?$AA@ ; `string'
EXTRN	_fnAttributeValueNull:NEAR
EXTRN	_StoreValueInRecord@20:NEAR
EXTRN	_GetValueFromRecord@24:NEAR
;	COMDAT ??_C@_0BO@NIPI@?9?5ParentEntity?5?$DN?$DN?5ChildEntity?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BO@NIPI@?9?5ParentEntity?5?$DN?$DN?5ChildEntity?$AA@ DB '- ParentE'
	DB	'ntity == ChildEntity', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@NMHK@?$CIoi?$CJ?5Hangin?5key?5error?$CB?5?$AA@
_DATA	SEGMENT
??_C@_0BI@NMHK@?$CIoi?$CJ?5Hangin?5key?5error?$CB?5?$AA@ DB '(oi) Hangin '
	DB	'key error! ', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_lpChildEntity$ = 12
_lpChildDataRecord$ = -12
_lpChildRelRecord$ = -4
_lpRelField$ = -16
_bEntityCreated$ = -8
_lpParentEntity$10574 = -36
_lpTargetAttrib$10575 = -44
_lpSrcAttrib$10576 = -40
_lpTargetDataField$10577 = -52
_lpSrcDataField$10578 = -32
_lpViewEntityCsr$10579 = -56
_lpEntityInstance$10580 = -28
_pchPtr$10581 = -24
_chType$10582 = -20
_ulLth$10583 = -48
_fnAddHangingEntity@8 PROC NEAR

; 9041 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 9042 :    LPDATARECORD lpChildDataRecord = zGETPTR( lpChildEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildDataRecord$[ebp], eax

; 9043 :    LPRELRECORD  lpChildRelRecord  = zGETPTR( lpChildDataRecord->hFirstRelRecord );

	mov	edx, DWORD PTR _lpChildDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildRelRecord$[ebp], eax

; 9044 :    LPRELFIELD   lpRelField;
; 9045 :    zBOOL        bEntityCreated = FALSE;

	mov	BYTE PTR _bEntityCreated$[ebp], 0

; 9046 : 
; 9047 :    for ( lpRelField = zGETPTR( lpChildRelRecord->hFirstRelField );
; 9048 :          lpRelField;
; 9049 :          lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	mov	ecx, DWORD PTR _lpChildRelRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax
	jmp	SHORT $L10571
$L10572:
	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax
$L10571:
	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$L10573

; 9051 :       LPVIEWENTITY     lpParentEntity;
; 9052 :       LPVIEWATTRIB     lpTargetAttrib;
; 9053 :       LPVIEWATTRIB     lpSrcAttrib;
; 9054 :       LPDATAFIELD      lpTargetDataField;
; 9055 :       LPDATAFIELD      lpSrcDataField;
; 9056 :       LPVIEWENTITYCSR  lpViewEntityCsr;
; 9057 :       LPENTITYINSTANCE lpEntityInstance;
; 9058 :       zPCHAR           pchPtr;
; 9059 :       zCHAR            chType;
; 9060 :       zULONG           ulLth;
; 9061 : 
; 9062 :       // Check to see if the Rel field (the target field) is not-null.  Note
; 9063 :       // the the rel field had better be in a parent entity!
; 9064 :       lpTargetDataField = zGETPTR( lpRelField->hRelDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTargetDataField$10577[ebp], eax

; 9065 :       lpTargetAttrib    = zGETPTR( lpTargetDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpTargetDataField$10577[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTargetAttrib$10575[ebp], eax

; 9066 :       lpParentEntity    = zGETPTR( lpTargetAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpTargetAttrib$10575[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentEntity$10574[ebp], eax

; 9067 : 
; 9068 :       if ( lpParentEntity == lpChildEntity )

	mov	edx, DWORD PTR _lpParentEntity$10574[ebp]
	cmp	edx, DWORD PTR _lpChildEntity$[ebp]
	jne	SHORT $L10587

; 9070 :          TraceLineS( "(oi) Hangin key error! ", "- ParentEntity == ChildEntity" );

	push	OFFSET FLAT:??_C@_0BO@NIPI@?9?5ParentEntity?5?$DN?$DN?5ChildEntity?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@NMHK@?$CIoi?$CJ?5Hangin?5key?5error?$CB?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9071 :          continue;

	jmp	SHORT $L10572
$L10587:

; 9073 : 
; 9074 :       // Get the entity csr.
; 9075 :       fnValidViewEntity( &lpViewEntityCsr, lpView, lpParentEntity->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpParentEntity$10574[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$10579[ebp]
	push	edx
	call	_fnValidViewEntity@16

; 9076 : 
; 9077 :       if ( fnAttributeValueNull( lpView,
; 9078 :                                  zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 9079 :                                  lpTargetAttrib ) )

	mov	eax, DWORD PTR _lpTargetAttrib$10575[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$10579[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnAttributeValueNull
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10591

; 9081 :          continue;

	jmp	$L10572
$L10591:

; 9083 : 
; 9084 :       // If we get here then the target attrib is not null.  This means we
; 9085 :       // need to create an entity instance (if not already created) and
; 9086 :       // copy the attribute value.
; 9087 : 
; 9088 :       if ( bEntityCreated == FALSE )

	mov	edx, DWORD PTR _bEntityCreated$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L10592

; 9090 :          // Get the entity csr.
; 9091 :          fnValidViewEntity( &lpViewEntityCsr, lpView, lpChildEntity->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpChildEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$10579[ebp]
	push	edx
	call	_fnValidViewEntity@16

; 9092 : 
; 9093 :          fnCreateEntity( lpView, lpChildEntity, lpViewEntityCsr, zPOS_NEXT, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _lpViewEntityCsr$10579[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpChildEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnCreateEntity@20

; 9094 :          lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$10579[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$10580[ebp], eax

; 9095 :          lpEntityInstance->u.nInd.bHangingEntity = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$10580[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	al, 1
	mov	ecx, DWORD PTR _lpEntityInstance$10580[ebp]
	mov	DWORD PTR [ecx+6], eax

; 9096 : 
; 9097 :          bEntityCreated = TRUE;

	mov	BYTE PTR _bEntityCreated$[ebp], 1
$L10592:

; 9099 : 
; 9100 :       GetValueFromRecord( lpView, lpParentEntity, lpTargetAttrib, &pchPtr,
; 9101 :                           &chType, &ulLth );

	lea	edx, DWORD PTR _ulLth$10583[ebp]
	push	edx
	lea	eax, DWORD PTR _chType$10582[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchPtr$10581[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTargetAttrib$10575[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParentEntity$10574[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_GetValueFromRecord@24

; 9102 : 
; 9103 :       lpSrcDataField = zGETPTR( lpRelField->hSrcDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcDataField$10578[ebp], eax

; 9104 :       lpSrcAttrib    = zGETPTR( lpSrcDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpSrcDataField$10578[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcAttrib$10576[ebp], eax

; 9105 : 
; 9106 :       StoreValueInRecord( lpView, lpChildEntity, lpSrcAttrib, pchPtr, ulLth );

	mov	eax, DWORD PTR _ulLth$10583[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchPtr$10581[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcAttrib$10576[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_StoreValueInRecord@20

; 9107 :    }

	jmp	$L10572
$L10573:

; 9108 : 
; 9109 :    return( 0 );

	xor	ax, ax

; 9110 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnAddHangingEntity@8 ENDP
_TEXT	ENDS
PUBLIC	_fnCreateQualification@36
EXTRN	_fnValidViewAttrib:NEAR
EXTRN	_fnSetEntityCursor:NEAR
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpView$ = 12
_pvQual$ = 16
_plpViewEntityCsr$ = 20
_pchEntitySpec$ = 24
_pchEntityName$ = 28
_pchAttributeName$ = 32
_pchOper$ = 36
_pchValue$ = 40
_lpViewEntity$ = -4
_lpViewAttrib$ = -12
_lpViewEntityCsr$ = -20
_vQual$ = -8
_lCnt$ = -16
_pchAttribName$10646 = -24
_fnCreateQualification@36 PROC NEAR

; 9123 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 9124 :    LPVIEWENTITY      lpViewEntity;
; 9125 :    LPVIEWATTRIB      lpViewAttrib;
; 9126 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 9127 :    zVIEW             vQual;
; 9128 :    zLONG             lCnt;
; 9129 : 
; 9130 :    if ( *pvQual == 0 )

	mov	eax, DWORD PTR _pvQual$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L10624

; 9132 :       if ( fnDeclareView( pvQual, lpCurrentTask, lpView,
; 9133 :                           "KZDBHQUA", TRUE ) != 0 )

	push	1
	push	OFFSET FLAT:??_C@_08ILBJ@KZDBHQUA?$AA@	; `string'
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvQual$[ebp]
	push	eax
	call	_fnDeclareView@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10623

; 9135 :          *pvQual = 0;

	mov	edx, DWORD PTR _pvQual$[ebp]
	mov	DWORD PTR [edx], 0

; 9136 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10616
$L10623:

; 9138 : 
; 9139 :       if ( fnActivateEmptyObjectInstance( lpCurrentTask, *pvQual,
; 9140 :                                           zSINGLE ) != 0 )

	push	0
	mov	eax, DWORD PTR _pvQual$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10624

; 9142 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10616
$L10624:

; 9145 : 
; 9146 :    vQual = *pvQual;

	mov	ecx, DWORD PTR _pvQual$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _vQual$[ebp], edx

; 9147 : 
; 9148 :    // If pchEntitySpec was supplied, then create an entity spec.
; 9149 :    if ( pchEntitySpec )

	cmp	DWORD PTR _pchEntitySpec$[ebp], 0
	je	$L10632

; 9151 :       // Get lpViewEntity, lpViewEntityCsr, and lpViewAttrib.
; 9152 :       lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, vQual, "EntitySpec", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9153 :       lpViewAttrib = fnValidViewAttrib( vQual, lpViewEntity, "EntityName", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 9154 : 
; 9155 :       // Make sure entity spec doesn't already exist.
; 9156 :       if ( fnSetEntityCursor( vQual, lpViewEntity, lpViewEntityCsr,
; 9157 :                               lpViewAttrib, zPOS_FIRST | zQUAL_STRING,
; 9158 :                               (zPVOID) pchEntitySpec,
; 9159 :                               0, 0, 0, 0, 0, lpCurrentTask ) != zCURSOR_SET )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _pchEntitySpec$[ebp]
	push	edx
	push	1025					; 00000401H
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10632

; 9161 :          if ( fnCreateEntity( vQual, lpViewEntity, lpViewEntityCsr,
; 9162 :                               zPOS_NEXT, FALSE ) != 0 )

	push	0
	push	3
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnCreateEntity@20
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10630

; 9164 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10616
$L10630:

; 9166 : 
; 9167 :          if ( fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9168 :                                           (zPVOID) pchEntitySpec, 'S', 0, 0,
; 9169 :                                           lpCurrentTask, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	83					; 00000053H
	mov	ecx, DWORD PTR _pchEntitySpec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10632

; 9171 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10616
$L10632:

; 9175 : 
; 9176 :    // If no oper was supplied we're done.
; 9177 :    if ( pchOper == 0 )

	cmp	DWORD PTR _pchOper$[ebp], 0
	jne	SHORT $L10633

; 9178 :       return( 0 );

	xor	ax, ax
	jmp	$L10616
$L10633:

; 9179 : 
; 9180 :    if ( plpViewEntityCsr )

	cmp	DWORD PTR _plpViewEntityCsr$[ebp], 0
	je	SHORT $L10634

; 9182 :       if ( *plpViewEntityCsr )

	mov	eax, DWORD PTR _plpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L10635

; 9184 :          // User supplied valid cursor so use it.
; 9185 :          lpViewEntityCsr = *plpViewEntityCsr;

	mov	ecx, DWORD PTR _plpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], edx

; 9186 :          lpViewEntity    = zGETPTR( (*plpViewEntityCsr)->hViewEntity );

	mov	eax, DWORD PTR _plpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9188 :       else

	jmp	SHORT $L10637
$L10635:

; 9190 :          // Get lpViewEntity and plpViewEntityCsr.
; 9191 :          lpViewEntity    = fnValidViewEntity( plpViewEntityCsr, vQual, "QualAttrib", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	mov	ecx, DWORD PTR _plpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9192 :          lpViewEntityCsr = *plpViewEntityCsr;

	mov	edx, DWORD PTR _plpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
$L10637:

; 9195 :    else

	jmp	SHORT $L10638
$L10634:

; 9197 :       lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, vQual, "QualAttrib", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$L10638:

; 9199 : 
; 9200 :    // Create the new qual attrib.
; 9201 :    if ( fnCreateEntity( vQual, lpViewEntity, lpViewEntityCsr,
; 9202 :                         zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_fnCreateEntity@20
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10640

; 9204 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10616
$L10640:

; 9206 : 
; 9207 :    // Loop through each of the view attribs.  When we find one we want, set
; 9208 :    // the value.  We keep track of the # of attributes we set so we don't
; 9209 :    // have to keep searching even when we've set all the values.
; 9210 :    lCnt = 0;

	mov	DWORD PTR _lCnt$[ebp], 0

; 9211 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 9212 :          lpViewAttrib;
; 9213 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L10643
$L10644:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L10643:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L10645

; 9215 :       zPCHAR pchAttribName = lpViewAttrib->szName;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	mov	DWORD PTR _pchAttribName$10646[ebp], edx

; 9216 : 
; 9217 :       if ( zstrcmp( pchAttribName, "EntityName" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$10646[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR ??_C@_0L@LOJF@EntityName?$AA@
	cmp	ecx, edx
	jne	SHORT $L12800
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchAttribName$10646[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L12801
$L12800:
	mov	ecx, DWORD PTR _pchAttribName$10646[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR ??_C@_0L@LOJF@EntityName?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -28+[ebp], ecx
$L12801:
	cmp	DWORD PTR -28+[ebp], 0
	jne	SHORT $L10653

; 9219 :          if ( pchEntityName &&
; 9220 :               fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9221 :                                           (zPVOID) pchEntityName, 'S', 0, 0,
; 9222 :                                           lpCurrentTask, 0 ) != 0 )

	cmp	DWORD PTR _pchEntityName$[ebp], 0
	je	SHORT $L10655
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10655

; 9224 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10616
$L10655:

; 9226 : 
; 9227 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $L10656

; 9228 :             break;               // We've set all values so break.

	jmp	$L10645
$L10656:

; 9230 :       else

	jmp	$L10689
$L10653:

; 9231 :       if ( zstrcmp( pchAttribName, "AttributeName" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$10646[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR ??_C@_0O@JICG@AttributeName?$AA@
	cmp	ecx, edx
	jne	SHORT $L12802
	push	OFFSET FLAT:??_C@_0O@JICG@AttributeName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchAttribName$10646[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -32+[ebp], eax
	jmp	SHORT $L12803
$L12802:
	mov	ecx, DWORD PTR _pchAttribName$10646[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR ??_C@_0O@JICG@AttributeName?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -32+[ebp], ecx
$L12803:
	cmp	DWORD PTR -32+[ebp], 0
	jne	SHORT $L10664

; 9233 :          if ( pchAttributeName &&
; 9234 :               fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9235 :                                           (zPVOID) pchAttributeName, 'S', 0, 0,
; 9236 :                                           lpCurrentTask, 0 ) != 0 )

	cmp	DWORD PTR _pchAttributeName$[ebp], 0
	je	SHORT $L10666
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10666

; 9238 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10616
$L10666:

; 9240 : 
; 9241 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $L10667

; 9242 :             break;               // We've set all values so break.

	jmp	$L10645
$L10667:

; 9244 :       else

	jmp	$L10689
$L10664:

; 9245 :       if ( zstrcmp( pchAttribName, "Oper" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$10646[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR ??_C@_04FKDH@Oper?$AA@
	cmp	ecx, edx
	jne	SHORT $L12804
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	eax, DWORD PTR _pchAttribName$10646[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -36+[ebp], eax
	jmp	SHORT $L12805
$L12804:
	mov	ecx, DWORD PTR _pchAttribName$10646[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR ??_C@_04FKDH@Oper?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -36+[ebp], ecx
$L12805:
	cmp	DWORD PTR -36+[ebp], 0
	jne	SHORT $L10675

; 9247 :          if ( fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9248 :                                           (zPVOID) pchOper, 'S', 0, 0,
; 9249 :                                           lpCurrentTask, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10677

; 9251 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10616
$L10677:

; 9253 : 
; 9254 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $L10678

; 9255 :             break;               // We've set all values so break.

	jmp	$L10645
$L10678:

; 9257 :       else

	jmp	$L10689
$L10675:

; 9258 :       if ( zstrcmp( pchAttribName, "Value" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$10646[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR ??_C@_05KBGO@Value?$AA@
	cmp	ecx, edx
	jne	SHORT $L12806
	push	OFFSET FLAT:??_C@_05KBGO@Value?$AA@	; `string'
	mov	eax, DWORD PTR _pchAttribName$10646[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -40+[ebp], eax
	jmp	SHORT $L12807
$L12806:
	mov	ecx, DWORD PTR _pchAttribName$10646[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR ??_C@_05KBGO@Value?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -40+[ebp], ecx
$L12807:
	cmp	DWORD PTR -40+[ebp], 0
	jne	SHORT $L10689

; 9260 :          if ( pchValue &&
; 9261 :               fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9262 :                                           (zPVOID) pchValue, 'S', 0, 0,
; 9263 :                                           lpCurrentTask, 0 ) != 0 )

	cmp	DWORD PTR _pchValue$[ebp], 0
	je	SHORT $L10688
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10688

; 9265 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L10616
$L10688:

; 9267 : 
; 9268 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $L10689

; 9269 :             break;               // We've set all values so break.

	jmp	SHORT $L10645
$L10689:

; 9271 : 
; 9272 :    } // for...

	jmp	$L10644
$L10645:

; 9273 : 
; 9274 :    return( 0 );

	xor	ax, ax
$L10616:

; 9275 : 
; 9276 : } // fnCreateQualification

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_fnCreateQualification@36 ENDP
_TEXT	ENDS
PUBLIC	_fnFindKeyDelim@16
_TEXT	SEGMENT
_chCurrentDelim$ = 8
_pchStart$ = 12
_pchEnd$ = 16
_pchNewString$ = 20
_pchOldDelim$ = -12
_pchNewDelim$ = -8
_pch$ = -4
_fnFindKeyDelim@16 PROC NEAR

; 9292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 9293 :    zPCHAR pchOldDelim;
; 9294 :    zPCHAR pchNewDelim;
; 9295 :    zPCHAR pch;
; 9296 : 
; 9297 :    if ( chCurrentDelim == 0 )

	movsx	eax, BYTE PTR _chCurrentDelim$[ebp]
	test	eax, eax
	jne	SHORT $L10704

; 9298 :       return( gszKeyDelimStr[ 0 ] );

	mov	al, BYTE PTR _gszKeyDelimStr
	jmp	$L10700
$L10704:

; 9299 : 
; 9300 :    // Look for current delim in string.
; 9301 :    pchOldDelim = zstrchr( gszKeyDelimStr, chCurrentDelim );

	movsx	ecx, BYTE PTR _chCurrentDelim$[ebp]
	push	ecx
	push	OFFSET FLAT:_gszKeyDelimStr
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchOldDelim$[ebp], eax

; 9302 : 
; 9303 :    // Point to next delim in string.
; 9304 :    pchNewDelim = pchOldDelim + 1;

	mov	edx, DWORD PTR _pchOldDelim$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchNewDelim$[ebp], edx
$L10706:

; 9305 : 
; 9306 :    // Look for next delim in gszKeyDelimStr not in buffer or new string.
; 9307 :    while ( zstrchr( pchNewString, *pchNewDelim ) )

	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pchNewString$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $L10707

; 9308 :       pchNewDelim++;

	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchNewDelim$[ebp], eax
	jmp	SHORT $L10706
$L10707:

; 9309 : 
; 9310 :    for ( pch = pchStart; pch < pchEnd; pch++ )

	mov	ecx, DWORD PTR _pchStart$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx
	jmp	SHORT $L10708
$L10709:
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
$L10708:
	mov	eax, DWORD PTR _pch$[ebp]
	cmp	eax, DWORD PTR _pchEnd$[ebp]
	jae	SHORT $L10710

; 9312 :       if ( *pch == *pchNewDelim )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $L10711

; 9314 :          pchNewDelim++;

	mov	edx, DWORD PTR _pchNewDelim$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchNewDelim$[ebp], edx
$L10713:

; 9315 : 
; 9316 :          // Make sure new delim isn't in new string.
; 9317 :          while ( zstrchr( pchNewString, *pchNewDelim ) )

	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pchNewString$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $L10714

; 9318 :             pchNewDelim++;

	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchNewDelim$[ebp], eax
	jmp	SHORT $L10713
$L10714:

; 9319 : 
; 9320 :          // Reset pch to start looking at the beginning of the string again.
; 9321 :          pch = pchStart;

	mov	ecx, DWORD PTR _pchStart$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx

; 9322 : 
; 9323 :          continue;

	jmp	SHORT $L10709
$L10711:

; 9325 :    }

	jmp	SHORT $L10709
$L10710:

; 9326 : 
; 9327 :    // Convert all pchOldDelims to pchNewDelim.
; 9328 :    for ( pch = pchStart; pch < pchEnd; pch++ )

	mov	edx, DWORD PTR _pchStart$[ebp]
	mov	DWORD PTR _pch$[ebp], edx
	jmp	SHORT $L10715
$L10716:
	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax
$L10715:
	mov	ecx, DWORD PTR _pch$[ebp]
	cmp	ecx, DWORD PTR _pchEnd$[ebp]
	jae	SHORT $L10717

; 9330 :       if ( *pch == *pchOldDelim )

	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchOldDelim$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L10718

; 9331 :          *pch = *pchNewDelim;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	ecx, DWORD PTR _pchNewDelim$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
$L10718:

; 9332 :    }

	jmp	SHORT $L10716
$L10717:

; 9333 : 
; 9334 :    return( *pchNewDelim );

	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	mov	al, BYTE PTR [eax]
$L10700:

; 9335 : 
; 9336 : } // fnFindKeyDelim

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnFindKeyDelim@16 ENDP
_TEXT	ENDS
EXTRN	_ConvertDecimalToString@52:NEAR
EXTRN	_UfDateTimeToString@12:NEAR
_TEXT	SEGMENT
_pchKeyString$ = 8
_lpEntityInstance$ = 12
_lpKeyViewAttrib$ = 16
_nKeyCnt$ = 20
_lpViewOI$ = -20
_lpAllocTask$ = -4
_pch$ = -8
_chDelim$ = -12
_k$ = -16
_lpPtr$10738 = -24
_ulLth$10739 = -28
_fnCreateConcatKey@16 PROC NEAR

; 9348 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	push	edi

; 9349 :    LPVIEWOI lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 9350 :    LPTASK   lpAllocTask = zGETPTR( lpViewOI->hAllocTask );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAllocTask$[ebp], eax

; 9351 :    zPCHAR   pch;
; 9352 :    zCHAR    chDelim;
; 9353 :    zSHORT   k;
; 9354 : 
; 9355 :    // Get the default key delimiter.
; 9356 :    chDelim = fnFindKeyDelim( 0, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	0
	call	_fnFindKeyDelim@16
	mov	BYTE PTR _chDelim$[ebp], al

; 9357 : 
; 9358 :    // Because the delimiter can change, the first char will be the delimiter
; 9359 :    // for the string.
; 9360 :    pch = pchKeyString;

	mov	ecx, DWORD PTR _pchKeyString$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx

; 9361 : 
; 9362 :    // Go through each of the keys are retrieve the values.
; 9363 :    for ( k = 0; k < nKeyCnt; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L10735
$L10736:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L10735:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	cmp	eax, ecx
	jge	$L10737

; 9365 :       zPVOID  lpPtr;
; 9366 :       zULONG  ulLth;
; 9367 : 
; 9368 :       *pch++ = chDelim;

	mov	edx, DWORD PTR _pch$[ebp]
	mov	al, BYTE PTR _chDelim$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx

; 9369 : 
; 9370 :       // Get pointer to key value.
; 9371 :       if ( fnGetAttrAddrFromEntityInstance( (zCOREMEM) &lpPtr,
; 9372 :                                             &ulLth, lpEntityInstance,
; 9373 :                                             lpKeyViewAttrib[ k ] ) == -1 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpKeyViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	lea	eax, DWORD PTR _ulLth$10739[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpPtr$10738[ebp]
	push	ecx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L10741

; 9375 :          // Key is null so just continue.
; 9376 :          continue;

	jmp	SHORT $L10736
$L10741:

; 9378 : 
; 9379 :       // Convert internal key value to string.
; 9380 :       switch ( lpKeyViewAttrib[ k ]->cType )
; 9381 :       {

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpKeyViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, BYTE PTR [edx+202]
	mov	DWORD PTR -32+[ebp], eax
	mov	ecx, DWORD PTR -32+[ebp]
	sub	ecx, 76					; 0000004cH
	mov	DWORD PTR -32+[ebp], ecx
	cmp	DWORD PTR -32+[ebp], 8
	ja	SHORT $L10743
	mov	edx, DWORD PTR -32+[ebp]
	jmp	DWORD PTR $L12810[edx*4]
$L10746:

; 9382 :          case zTYPE_STRING:
; 9383 :             // Don't need to convert it--just copy it.
; 9384 :             zstrcpy( pch, (zPCHAR) lpPtr );

	mov	eax, DWORD PTR _lpPtr$10738[ebp]
	push	eax
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 9385 :             break;

	jmp	SHORT $L10743
$L10748:

; 9386 : 
; 9387 :          case zTYPE_INTEGER:
; 9388 :             zltoa( *((zPLONG) lpPtr), pch );

	push	10					; 0000000aH
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpPtr$10738[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 9389 :             break;

	jmp	SHORT $L10743
$L10750:

; 9390 : 
; 9391 :          case zTYPE_DECIMAL:
; 9392 :             ConvertDecimalToString( pch, lpKeyViewAttrib[ k ],
; 9393 :                                     *((zPDECIMAL) lpPtr), 0 );

	push	0
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	esi, DWORD PTR _lpPtr$10738[ebp]
	mov	edi, esp
	rep movsd
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpKeyViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_ConvertDecimalToString@52

; 9394 :             break;

	jmp	SHORT $L10743
$L10753:

; 9395 : 
; 9396 :          case zTYPE_BLOB:
; 9397 :             // No blobs should ever be keys.
; 9398 :             break;
; 9399 : 
; 9400 :          case zTYPE_DATETIME:
; 9401 :              UfDateTimeToString( (LPDATETIME) lpPtr, pch, 18 );

	push	18					; 00000012H
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpPtr$10738[ebp]
	push	ecx
	call	_UfDateTimeToString@12
$L10743:

; 9405 : 
; 9406 :       // Make sure that the delimiter is not in the new value.
; 9407 :       if ( zstrchr( pch, chDelim ) != 0 )

	movsx	edx, BYTE PTR _chDelim$[ebp]
	push	edx
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $L10755

; 9409 :          // The current delimiter exists in the key value so we must get a
; 9410 :          // new one.  fnFindKeyDelim will change all the old delims to match
; 9411 :          // the new delim.
; 9412 :          chDelim = fnFindKeyDelim( chDelim, pchKeyString, pch, pch );

	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchKeyString$[ebp]
	push	eax
	mov	cl, BYTE PTR _chDelim$[ebp]
	push	ecx
	call	_fnFindKeyDelim@16
	mov	BYTE PTR _chDelim$[ebp], al
$L10755:

; 9414 : 
; 9415 :       // Set pch to point to the end of the string.
; 9416 :       pch = zstrchr( pch, 0 );

	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pch$[ebp], eax

; 9417 : 
; 9418 :    } // for ( k... )

	jmp	$L10736
$L10737:

; 9419 : 
; 9420 :    return( 0 );

	xor	ax, ax

; 9421 : 
; 9422 : } // fnCreateConcatKey

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L12810:
	DD	$L10748
	DD	$L10750
	DD	$L10743
	DD	$L10743
	DD	$L10743
	DD	$L10743
	DD	$L10743
	DD	$L10746
	DD	$L10753
_fnCreateConcatKey@16 ENDP
_TEXT	ENDS
PUBLIC	_fnCheckLocksOnTwins@24
PUBLIC	??_C@_0BD@BKHK@LOD?5?8?$CFs?8?5is?5locked?$AA@	; `string'
PUBLIC	??_C@_0BG@JJPK@Entity?5?8?$CFs?8?5is?5locked?$AA@ ; `string'
PUBLIC	??_C@_0BC@NLCC@YYYY?9M?9D?5HH?3MI?3SS?$AA@	; `string'
PUBLIC	??_C@_0BH@NCBI@?$CIoi?$CJ?5Object?5locked?5by?5?$AA@ ; `string'
PUBLIC	??_C@_0BH@FDBN@?$CIoi?$CJ?5Object?5locked?5on?5?$AA@ ; `string'
PUBLIC	??_C@_0BJ@POBP@?$CIoi?$CJ?5Concatenated?5key?5?$DN?5?$AA@ ; `string'
EXTRN	_UfFormatDateTime@12:NEAR
EXTRN	_GetStringFromAttribute@16:NEAR
;	COMDAT ??_C@_0BD@BKHK@LOD?5?8?$CFs?8?5is?5locked?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BD@BKHK@LOD?5?8?$CFs?8?5is?5locked?$AA@ DB 'LOD ''%s'' is locked', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JJPK@Entity?5?8?$CFs?8?5is?5locked?$AA@
_DATA	SEGMENT
??_C@_0BG@JJPK@Entity?5?8?$CFs?8?5is?5locked?$AA@ DB 'Entity ''%s'' is lo'
	DB	'cked', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@NLCC@YYYY?9M?9D?5HH?3MI?3SS?$AA@
_DATA	SEGMENT
??_C@_0BC@NLCC@YYYY?9M?9D?5HH?3MI?3SS?$AA@ DB 'YYYY-M-D HH:MI:SS', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NCBI@?$CIoi?$CJ?5Object?5locked?5by?5?$AA@
_DATA	SEGMENT
??_C@_0BH@NCBI@?$CIoi?$CJ?5Object?5locked?5by?5?$AA@ DB '(oi) Object lock'
	DB	'ed by ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@FDBN@?$CIoi?$CJ?5Object?5locked?5on?5?$AA@
_DATA	SEGMENT
??_C@_0BH@FDBN@?$CIoi?$CJ?5Object?5locked?5on?5?$AA@ DB '(oi) Object lock'
	DB	'ed on ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@POBP@?$CIoi?$CJ?5Concatenated?5key?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BJ@POBP@?$CIoi?$CJ?5Concatenated?5key?5?$DN?5?$AA@ DB '(oi) Concat'
	DB	'enated key = ', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_bLOD_Lock$ = 12
_bAllowReadOnly$ = 16
_lpView$ = 20
_lpFirstEntityInstance$ = 24
_lpViewOD$ = 28
_lpViewEntity$ = -60
_lpViewAttrib$ = -72
_lpKeyViewAttrib$ = -232
_lpEntityInstance$ = -56
_lpQualAttribEntityCsr$ = -4
_lpValueViewAttrib$ = -12
_vQual$ = -68
_vLock$ = -8
_szKeyString$ = -436
_szLockName$ = -52
_nKeyCnt$ = -64
_nRC$ = -16
_k$10796 = -440
_pch$10801 = -444
_szWhat$10804 = -544
_szMsg$10805 = -796
_szDate$10806 = -596
_fnCheckLocksOnTwins@24 PROC NEAR

; 9440 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 796				; 0000031cH

; 9441 :    LPVIEWENTITY      lpViewEntity;
; 9442 :    LPVIEWATTRIB      lpViewAttrib;
; 9443 :    LPVIEWATTRIB      lpKeyViewAttrib[ zMAX_KEYS_FOR_LOCK ];
; 9444 :    LPENTITYINSTANCE  lpEntityInstance;
; 9445 :    LPVIEWENTITYCSR   lpQualAttribEntityCsr = 0;

	mov	DWORD PTR _lpQualAttribEntityCsr$[ebp], 0

; 9446 :    LPVIEWATTRIB      lpValueViewAttrib;
; 9447 :    zVIEW             vQual = 0;

	mov	DWORD PTR _vQual$[ebp], 0

; 9448 :    zVIEW             vLock = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 9449 :    zCHAR             szKeyString[ zMAX_KEYLTH_FOR_LOCK + 1 ];
; 9450 :    zCHAR             szLockName[ 35 ];
; 9451 :    zSHORT            nKeyCnt;
; 9452 :    zSHORT            nRC = zCALL_ERROR;       // Assume everything error.

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 9453 : 
; 9454 :    lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9455 : 
; 9456 :    // To save time later find all the keys in the LOD and store them in a table.
; 9457 :    nKeyCnt = 0;

	mov	WORD PTR _nKeyCnt$[ebp], 0

; 9458 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 9459 :          lpViewAttrib;
; 9460 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L10785
$L10786:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L10785:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L10787

; 9462 :       if ( lpViewAttrib->bKey )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10788

; 9463 :          lpKeyViewAttrib[ nKeyCnt++ ] = lpViewAttrib;

	movsx	edx, WORD PTR _nKeyCnt$[ebp]
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeyViewAttrib$[ebp+edx*4], eax
	mov	cx, WORD PTR _nKeyCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nKeyCnt$[ebp], cx
$L10788:

; 9464 :    }

	jmp	SHORT $L10786
$L10787:

; 9465 : 
; 9466 :    if ( bLOD_Lock )

	mov	edx, DWORD PTR _bLOD_Lock$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L10789

; 9468 :       // We are checking a LOD level lock so we set LockName to the name of
; 9469 :       // the LOD.
; 9470 :       zstrcpy( szLockName, lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 9472 :    else

	jmp	SHORT $L10790
$L10789:

; 9474 :       // We are checking a lock at the entity level so use the name of the
; 9475 :       // entity for the LockName.  In addition, to handle the rare case where
; 9476 :       // a LOD and entity name are the same we prefix all entity names with
; 9477 :       // a '@' because it's an invalid character for entity names.  This
; 9478 :       // insures that the LockName for the entity does not match a LOD name.
; 9479 :       zsprintf( szLockName, "@%s", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET FLAT:??_C@_03LNBB@?$EA?$CFs?$AA@	; `string'
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L10790:

; 9481 : 
; 9482 :    // Create EntitySpec and QualAttribs.  This creates a qual that
; 9483 :    // is analogous to:
; 9484 :    //    ACTIVATE view WHERE view.ZeidonLock.LOD_Name = lod-name AND
; 9485 :    //                        view.ZeidonLock.KeyValue = ?
; 9486 :    fnCreateQualification( lpCurrentTask, lpView, &vQual,
; 9487 :                           &lpQualAttribEntityCsr, "ZeidonLock", "ZeidonLock",
; 9488 :                           "LOD_Name", "=", szLockName );

	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_01KPOD@?$DN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_08GDMG@LOD_Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	lea	edx, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _vQual$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCreateQualification@36

; 9489 :    fnCreateQualification( lpCurrentTask, lpView, &vQual,
; 9490 :                           &lpQualAttribEntityCsr, 0, 0, 0, "AND", 0 );

	push	0
	push	OFFSET FLAT:??_C@_03LACO@AND?$AA@	; `string'
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCreateQualification@36

; 9491 :    fnCreateQualification( lpCurrentTask, lpView, &vQual,
; 9492 :                           &lpQualAttribEntityCsr,
; 9493 :                           0, "ZeidonLock", "KeyValue", "=", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_01KPOD@?$DN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_08GOHN@KeyValue?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	push	0
	lea	ecx, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vQual$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCreateQualification@36

; 9494 : 
; 9495 :    // Get the lpViewAttrib for the Value attribute for later use with
; 9496 :    // fnSetAttributeFromVariable.
; 9497 :    lpValueViewAttrib =
; 9498 :            fnValidViewAttrib( vQual,
; 9499 :                               zGETPTR( lpQualAttribEntityCsr->hViewEntity ),
; 9500 :                               "Value", 0 );

	push	0
	push	OFFSET FLAT:??_C@_05KBGO@Value?$AA@	; `string'
	mov	edx, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpValueViewAttrib$[ebp], eax

; 9501 : 
; 9502 :    // Loop through each of the root entities and make sure that none of the
; 9503 :    // key values already exist.
; 9504 :    for ( lpEntityInstance = lpFirstEntityInstance;
; 9505 :          lpEntityInstance;
; 9506 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $L10793
$L10794:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10793:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L10795

; 9508 :       zSHORT k;
; 9509 : 
; 9510 :       // Create the concat key string and set the value in the qual object.
; 9511 :       fnCreateConcatKey( szKeyString, lpEntityInstance,
; 9512 :                          lpKeyViewAttrib, nKeyCnt );

	mov	dx, WORD PTR _nKeyCnt$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpKeyViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szKeyString$[ebp]
	push	edx
	call	_fnCreateConcatKey@16

; 9513 :       fnSetAttributeFromVariable( vQual, lpQualAttribEntityCsr,
; 9514 :                                   lpValueViewAttrib, (zPVOID) szKeyString,
; 9515 :                                   'S', 0, 0, lpCurrentTask, 0 );

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	83					; 00000053H
	lea	ecx, DWORD PTR _szKeyString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpValueViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H

; 9516 : 
; 9517 : 
; 9518 :       k = ActivateObjectInstance( &vLock, "ZPLOCKO", lpView, vQual, 0 );

	push	0
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	lea	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_ActivateObjectInstance@20
	mov	WORD PTR _k$10796[ebp], ax

; 9519 :       if ( k < -1 )

	movsx	edx, WORD PTR _k$10796[ebp]
	cmp	edx, -1
	jge	SHORT $L10798

; 9520 :          goto EndOfFunction;

	jmp	$EndOfFunction$10799
$L10798:

; 9521 : 
; 9522 :       if ( k >= 0 )

	movsx	eax, WORD PTR _k$10796[ebp]
	test	eax, eax
	jl	$L10802

; 9524 :          zPCHAR pch;
; 9525 : 
; 9526 :          // Uh-oh -- we found a lock record matching the keys.  Check to see
; 9527 :          // if we can at least keep the view as read-only.
; 9528 :          GetAddrForAttribute( &pch, vLock, "ZeidonLock", "AllowRead" );

	push	OFFSET FLAT:??_C@_09NCPC@AllowRead?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$10801[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 9529 :          if ( *pch != 'Y' || bAllowReadOnly == FALSE )

	mov	eax, DWORD PTR _pch$10801[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $L10803
	mov	edx, DWORD PTR _bAllowReadOnly$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	$L10802
$L10803:

; 9531 :             zCHAR szWhat[ 100 ];
; 9532 :             zCHAR szMsg[ 200 ];
; 9533 :             zCHAR szDate[ 50 ];
; 9534 : 
; 9535 :             // User attempted to get some sort of lock but it's already locked
; 9536 :             // OR
; 9537 :             // someone has an exclusive lock that doesn't even allow
; 9538 :             // read-only views so don't allow activate.
; 9539 : 
; 9540 :             if ( bLOD_Lock )

	mov	eax, DWORD PTR _bLOD_Lock$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10807

; 9541 :                zsprintf( szWhat, "LOD '%s' is locked", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0BD@BKHK@LOD?5?8?$CFs?8?5is?5locked?$AA@ ; `string'
	lea	edx, DWORD PTR _szWhat$10804[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 9542 :             else

	jmp	SHORT $L10809
$L10807:

; 9543 :                zsprintf( szWhat, "Entity '%s' is locked", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET FLAT:??_C@_0BG@JJPK@Entity?5?8?$CFs?8?5is?5locked?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWhat$10804[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L10809:

; 9544 : 
; 9545 :             GetAddrForAttribute( &pch, vLock, "ZeidonLock", "UserName" );

	push	OFFSET FLAT:??_C@_08BJPE@UserName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _pch$10801[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 9546 :             GetStringFromAttribute( szMsg, vLock, "ZeidonLock", "Timestamp" );

	push	OFFSET FLAT:??_C@_09KMOL@Timestamp?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szMsg$10805[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 9547 :             UfFormatDateTime( szDate, szMsg, "YYYY-M-D HH:MI:SS" );

	push	OFFSET FLAT:??_C@_0BC@NLCC@YYYY?9M?9D?5HH?3MI?3SS?$AA@ ; `string'
	lea	eax, DWORD PTR _szMsg$10805[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDate$10806[ebp]
	push	ecx
	call	_UfFormatDateTime@12

; 9548 :             TraceLineS( "(oi) Object locked by ", pch );

	mov	edx, DWORD PTR _pch$10801[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BH@NCBI@?$CIoi?$CJ?5Object?5locked?5by?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9549 :             TraceLineS( "(oi) Object locked on ", szDate );

	lea	eax, DWORD PTR _szDate$10806[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BH@FDBN@?$CIoi?$CJ?5Object?5locked?5on?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9550 :             TraceLineS( "(oi) Concatenated key = ", szKeyString );

	lea	ecx, DWORD PTR _szKeyString$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BJ@POBP@?$CIoi?$CJ?5Concatenated?5key?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9551 :          // zsprintf( szMsg, "By '%s' on %s", pch, szDate );
; 9552 :          // fnIssueCoreError( lpTask, lpView, 16, 94, 0, szWhat, szMsg );
; 9553 : 
; 9554 :             nRC = zLOCK_ERROR;

	mov	WORD PTR _nRC$[ebp], -5			; fffffffbH

; 9555 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$10799
$L10802:

; 9558 : 
; 9559 :       // We don't need it anymore so...
; 9560 :       fnDropView( vLock );

	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDropView@4

; 9561 :       vLock = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 9562 : 
; 9563 :    } // for ( lpEntityInstance...)

	jmp	$L10794
$L10795:

; 9564 : 
; 9565 :    // If we get here then everything is OK.
; 9566 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$10799:

; 9567 : 
; 9568 : EndOfFunction:
; 9569 :    if ( vQual )

	cmp	DWORD PTR _vQual$[ebp], 0
	je	SHORT $L10815

; 9570 :       fnDropView( vQual );

	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnDropView@4
$L10815:

; 9571 : 
; 9572 :    if ( vLock )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $L10816

; 9573 :       fnDropView( vLock );

	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnDropView@4
$L10816:

; 9574 : 
; 9575 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 9576 : 
; 9577 : } // fnCheckLocksOnTwins

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnCheckLocksOnTwins@24 ENDP
_TEXT	ENDS
PUBLIC	_fnCompareEIAttrs@36
PUBLIC	_fnCheckForRecursiveLoop@8
PUBLIC	??_C@_0DH@OLHA@?$DN?$DN?$DN?$DN?5Activate?5error?3?5Infinite?5re@ ; `string'
PUBLIC	??_C@_0BB@JOON@Object?5Name?5?5?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_0BB@LMMD@Parent?5Entity?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_0BB@BHHL@Parent?5level?5?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_0BB@NJHF@Child?5Entity?5?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_0BB@IHNO@Child?5level?5?5?5?$DN?5?$AA@	; `string'
EXTRN	_DisplayEntityInstance@8:NEAR
;	COMDAT ??_C@_0DH@OLHA@?$DN?$DN?$DN?$DN?5Activate?5error?3?5Infinite?5re@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0DH@OLHA@?$DN?$DN?$DN?$DN?5Activate?5error?3?5Infinite?5re@ DB '==='
	DB	'= Activate error: Infinite recursive subobject ====', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@JOON@Object?5Name?5?5?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BB@JOON@Object?5Name?5?5?5?$DN?5?$AA@ DB 'Object Name   = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LMMD@Parent?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BB@LMMD@Parent?5Entity?5?$DN?5?$AA@ DB 'Parent Entity = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@BHHL@Parent?5level?5?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BB@BHHL@Parent?5level?5?5?$DN?5?$AA@ DB 'Parent level  = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NJHF@Child?5Entity?5?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BB@NJHF@Child?5Entity?5?5?$DN?5?$AA@ DB 'Child Entity  = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@IHNO@Child?5level?5?5?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BB@IHNO@Child?5level?5?5?5?$DN?5?$AA@ DB 'Child level   = ', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_lpEntityInstance$ = 12
_lpViewEntity$ = -8
_lpParent$ = -4
_lpKeys$ = -812
_lpViewAttrib$ = -816
_lpCurrentTask$ = -820
_nKeyCnt$ = -12
_lpParentViewEntity$10842 = -828
_bKeysMatch$10844 = -824
_k$10845 = -832
_lpParentViewAttrib$10851 = -836
_lpViewOD$10861 = -840
_fnCheckForRecursiveLoop@8 PROC NEAR

; 9860 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 840				; 00000348H

; 9861 :    LPVIEWENTITY     lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9862 :    LPENTITYINSTANCE lpParent;
; 9863 :    LPVIEWATTRIB     lpKeys[ 200 ];
; 9864 :    LPVIEWATTRIB     lpViewAttrib;
; 9865 :    LPTASK           lpCurrentTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 9866 :    zSHORT           nKeyCnt;
; 9867 : 
; 9868 :    // In an attempt to make things faster later let's get all the keys for
; 9869 :    // lpEntityInstance.
; 9870 :    nKeyCnt = 0;

	mov	WORD PTR _nKeyCnt$[ebp], 0

; 9871 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 9872 :          lpViewAttrib;
; 9873 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L10833
$L10834:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L10833:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L10835

; 9875 :       if ( lpViewAttrib->bKey == FALSE )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $L10836

; 9876 :         continue;

	jmp	SHORT $L10834
$L10836:

; 9877 : 
; 9878 :       lpKeys[ nKeyCnt++ ] = lpViewAttrib;

	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeys$[ebp+ecx*4], edx
	mov	ax, WORD PTR _nKeyCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nKeyCnt$[ebp], ax

; 9879 :    }

	jmp	SHORT $L10834
$L10835:

; 9880 : 
; 9881 : 
; 9882 :    for ( lpParent = zGETPTR( lpEntityInstance->hParent );
; 9883 :          lpParent;
; 9884 :          lpParent = zGETPTR( lpParent->hParent ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$[ebp], eax
	jmp	SHORT $L10839
$L10840:
	mov	eax, DWORD PTR _lpParent$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$[ebp], eax
$L10839:
	cmp	DWORD PTR _lpParent$[ebp], 0
	je	$L10841

; 9886 :       LPVIEWENTITY lpParentViewEntity = zGETPTR( lpParent->hViewEntity );

	mov	edx, DWORD PTR _lpParent$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$10842[ebp], eax

; 9887 :       zBOOL        bKeysMatch;
; 9888 :       zSHORT       k;
; 9889 : 
; 9890 :       // We only care about the parent if it's also recursive.  If NONE of the
; 9891 :       // recursive flags are set then skip it.  It's possible--althought
; 9892 :       // highly unlikely--that the entity we are looking for also exists as
; 9893 :       // a non-recursive entity between the recursive parent & child.
; 9894 :       if ( lpParentViewEntity->bRecursiveSt  == 0 &&
; 9895 :            lpParentViewEntity->bRecursive    == 0 &&
; 9896 :            lpParentViewEntity->bRecursivePar == 0 )

	mov	ecx, DWORD PTR _lpParentViewEntity$10842[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L10846
	mov	eax, DWORD PTR _lpParentViewEntity$10842[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L10846
	mov	edx, DWORD PTR _lpParentViewEntity$10842[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 29					; 0000001dH
	and	eax, 1
	test	eax, eax
	jne	SHORT $L10846

; 9898 :          continue;

	jmp	SHORT $L10840
$L10846:

; 9900 : 
; 9901 :       // The parent must be the same ER entity as the child.
; 9902 :       if ( lpParentViewEntity->lEREntTok != lpViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpParentViewEntity$10842[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	je	SHORT $L10847

; 9903 :          continue;

	jmp	$L10840
$L10847:

; 9904 : 
; 9905 :       // Make sure the keys are different.  We will start by assuming they
; 9906 :       // are the same until proven otherwise.
; 9907 :       bKeysMatch = TRUE;

	mov	BYTE PTR _bKeysMatch$10844[ebp], 1

; 9908 :       for ( k = 0; k < nKeyCnt; k++ )

	mov	WORD PTR _k$10845[ebp], 0
	jmp	SHORT $L10848
$L10849:
	mov	cx, WORD PTR _k$10845[ebp]
	add	cx, 1
	mov	WORD PTR _k$10845[ebp], cx
$L10848:
	movsx	edx, WORD PTR _k$10845[ebp]
	movsx	eax, WORD PTR _nKeyCnt$[ebp]
	cmp	edx, eax
	jge	$L10850

; 9910 :          LPVIEWATTRIB lpParentViewAttrib;
; 9911 : 
; 9912 :          // Now find the key value in the parent.
; 9913 :          if ( lpViewEntity == lpParentViewEntity )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	ecx, DWORD PTR _lpParentViewEntity$10842[ebp]
	jne	SHORT $L10852

; 9914 :             lpParentViewAttrib = lpKeys[ k ];

	movsx	edx, WORD PTR _k$10845[ebp]
	mov	eax, DWORD PTR _lpKeys$[ebp+edx*4]
	mov	DWORD PTR _lpParentViewAttrib$10851[ebp], eax

; 9915 :          else

	jmp	SHORT $L10858
$L10852:

; 9917 :             // We have to hunt for it.
; 9918 :             for ( lpParentViewAttrib = zGETPTR( lpParentViewEntity->hFirstOD_Attrib );
; 9919 :                   lpParentViewAttrib->lERAttTok != lpKeys[ k ]->lERAttTok;
; 9920 :                   lpParentViewAttrib = zGETPTR( lpParentViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpParentViewEntity$10842[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewAttrib$10851[ebp], eax
	jmp	SHORT $L10856
$L10857:
	mov	eax, DWORD PTR _lpParentViewAttrib$10851[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewAttrib$10851[ebp], eax
$L10856:
	movsx	edx, WORD PTR _k$10845[ebp]
	mov	eax, DWORD PTR _lpKeys$[ebp+edx*4]
	mov	ecx, DWORD PTR _lpParentViewAttrib$10851[ebp]
	mov	edx, DWORD PTR [ecx+177]
	cmp	edx, DWORD PTR [eax+177]
	je	SHORT $L10858

; 9922 :                ; // nothing needs to be done here
; 9923 :             }

	jmp	SHORT $L10857
$L10858:

; 9925 : 
; 9926 :          if ( fnCompareEIAttrs( lpCurrentTask,
; 9927 :                                 0, lpParent, lpParentViewAttrib, 0,
; 9928 :                                 0, lpEntityInstance, lpKeys[ k ], 0 ) != 0 )

	push	0
	movsx	eax, WORD PTR _k$10845[ebp]
	mov	ecx, DWORD PTR _lpKeys$[ebp+eax*4]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _lpParentViewAttrib$10851[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpParent$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCompareEIAttrs@36
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10859

; 9930 :             bKeysMatch = FALSE;

	mov	BYTE PTR _bKeysMatch$10844[ebp], 0

; 9931 :             break;

	jmp	SHORT $L10850
$L10859:

; 9933 :       }

	jmp	$L10849
$L10850:

; 9934 : 
; 9935 :       // If bKeysMatch is still TRUE then lpParent and lpEntityInstance
; 9936 :       // reference the same data.  This is an error that will cause an
; 9937 :       // infinite loop in the recursive subobject.
; 9938 :       if ( bKeysMatch )

	mov	ecx, DWORD PTR _bKeysMatch$10844[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	$L10860

; 9940 :          LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$10861[ebp], eax

; 9941 : 
; 9942 :          TraceLineS( "==== Activate error: Infinite recursive subobject ====", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0DH@OLHA@?$DN?$DN?$DN?$DN?5Activate?5error?3?5Infinite?5re@ ; `string'
	call	_TraceLineS@8

; 9943 :          TraceLineS( "Object Name   = ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$10861[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0BB@JOON@Object?5Name?5?5?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9944 :          TraceLineS( "Parent Entity = ", lpParentViewEntity->szName );

	mov	edx, DWORD PTR _lpParentViewEntity$10842[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET FLAT:??_C@_0BB@LMMD@Parent?5Entity?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9945 :          TraceLineI( "Parent level  = ", lpParent->nLevel );

	mov	eax, DWORD PTR _lpParent$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	push	ecx
	push	OFFSET FLAT:??_C@_0BB@BHHL@Parent?5level?5?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8

; 9946 :          TraceLineS( "Child Entity  = ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET FLAT:??_C@_0BB@NJHF@Child?5Entity?5?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9947 :          TraceLineI( "Child level   = ", lpEntityInstance->nLevel );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	push	ecx
	push	OFFSET FLAT:??_C@_0BB@IHNO@Child?5level?5?5?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8

; 9948 :          DisplayEntityInstance( lpView, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_DisplayEntityInstance@8

; 9949 : 
; 9950 :          //  "KZOEE095 - Recursive error."
; 9951 :          fnIssueCoreError( lpCurrentTask, lpView, 16, 95, 0, lpViewOD->szName, 0 );

	push	0
	mov	ecx, DWORD PTR _lpViewOD$10861[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	0
	push	95					; 0000005fH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9952 : 
; 9953 :          return( TRUE );

	mov	ax, 1
	jmp	SHORT $L10822
$L10860:

; 9955 : 
; 9956 :    } // for each lpParent...

	jmp	$L10840
$L10841:

; 9957 : 
; 9958 :    // If we get here then everything must be OK.
; 9959 :    return( FALSE );

	xor	ax, ax
$L10822:

; 9960 : 
; 9961 : } // fnCheckForRecursiveLoop.

	mov	esp, ebp
	pop	ebp
	ret	8
_fnCheckForRecursiveLoop@8 ENDP
_TEXT	ENDS
PUBLIC	_fnLoadChildEntities
EXTRN	_fnSetViewToSubobject:NEAR
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpView$ = 12
_lpEntityInstance$ = 16
_lpQualView$ = 20
_pOper$ = 24
_lpPtr$ = 28
_lpViewOD$ = -12
_hViewEntity$ = -28
_lpViewEntity$ = -24
_lpChildViewEntity$ = -36
_hChildViewEntity$ = -8
_lpViewEntityCsr$ = -40
_lpChildEntityInstance$ = -16
_nEntityInstanceLevel$ = -4
_nReturnCode$ = -32
_nRC$ = -20
_lCurrentEREntTok$10896 = -44
_fnLoadChildEntities PROC NEAR

; 9995 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 9996 :    LPVIEWOD         lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 9997 :    LPVIEWENTITY     hViewEntity;
; 9998 :    LPVIEWENTITY     lpViewEntity;
; 9999 :    LPVIEWENTITY     lpChildViewEntity;
; 10000:    LPVIEWENTITY     hChildViewEntity;
; 10001:    LPVIEWENTITYCSR  lpViewEntityCsr;
; 10002:    LPENTITYINSTANCE lpChildEntityInstance;
; 10003:    zSHORT           nEntityInstanceLevel;
; 10004:    zSHORT           nReturnCode = 0;

	mov	WORD PTR _nReturnCode$[ebp], 0

; 10005:    zSHORT           nRC;
; 10006: 
; 10007:    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10008:    nEntityInstanceLevel = lpEntityInstance->nLevel;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	dx, WORD PTR [ecx+58]
	mov	WORD PTR _nEntityInstanceLevel$[ebp], dx

; 10009: 
; 10010:    // If view entity is recursive, then reset lpViewEntity to point to the
; 10011:    // parent view entity that has the same EREntTok as the current lpViewEntity.
; 10012:    if ( lpViewEntity->bRecursive )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10900

; 10014:       zLONG lCurrentEREntTok;
; 10015: 
; 10016:       lCurrentEREntTok = lpViewEntity->lEREntTok;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+195]
	mov	DWORD PTR _lCurrentEREntTok$10896[ebp], eax

; 10017:       lpViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$L10899:

; 10018:       while ( lpViewEntity->lEREntTok != lCurrentEREntTok )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+195]
	cmp	ecx, DWORD PTR _lCurrentEREntTok$10896[ebp]
	je	SHORT $L10900

; 10019:          lpViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $L10899
$L10900:

; 10021: 
; 10022:    hViewEntity = zGETHNDL( lpViewEntity );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hViewEntity$[ebp], eax

; 10023: 
; 10024:    // The first child ViewEntity of the current lpViewEntity is the next
; 10025:    // view entity in hierachical order.
; 10026:    hChildViewEntity  = lpViewEntity->hNextHier;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR _hChildViewEntity$[ebp], eax

; 10027:    lpChildViewEntity = zGETPTR( hChildViewEntity );

	mov	ecx, DWORD PTR _hChildViewEntity$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildViewEntity$[ebp], eax

; 10028: 
; 10029:    // Check to see if there are child entity definitions.  If not, there are
; 10030:    // no children to load, so exit.  There is no child entity if:
; 10031:    //    o lpChildViewEntity is null (there are no entities after
; 10032:    //      lpViewEntity).
; 10033:    //    o The level number of the next view entity is "equal to" (which means
; 10034:    //      that the next view entity is a sibling) or "less than" (which means
; 10035:    //      that the next view entity is the sibling of an ancestor).
; 10036:    if ( lpChildViewEntity == 0 ||
; 10037:         lpChildViewEntity->nLevel <= lpViewEntity->nLevel )

	cmp	DWORD PTR _lpChildViewEntity$[ebp], 0
	je	SHORT $L10905
	mov	edx, DWORD PTR _lpChildViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jg	SHORT $L10904
$L10905:

; 10039:       return( 0 );

	xor	ax, ax
	jmp	$L10882
$L10904:

; 10041: 
; 10042:    // Load all the child entities of lpEntityInstance, starting with the first
; 10043:    // child entity definition via hierarchical ordering.  After loading a type
; 10044:    // of entity, find the next child entity type and (if there are more) load
; 10045:    // those.  Keep going until there are no more child entity types for
; 10046:    // lpEntityInstance.
; 10047: 
; 10048:    for ( ;
; 10049:          lpChildViewEntity;
; 10050:          lpChildViewEntity = zGETPTR( lpChildViewEntity->hNextSibling ) )

	jmp	SHORT $L10907
$L10908:
	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+247]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildViewEntity$[ebp], eax
$L10907:
	cmp	DWORD PTR _lpChildViewEntity$[ebp], 0
	je	$L10909

; 10052:       hChildViewEntity = zGETHNDL( lpChildViewEntity );

	mov	edx, DWORD PTR _lpChildViewEntity$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hChildViewEntity$[ebp], eax

; 10053: 
; 10054:       // If the max cardinality of the child instance is 1 then it's possible
; 10055:       // that the child was already activated by the DBHandler.  Check to see
; 10056:       // if a child EI already exists.
; 10057:       if ( lpChildViewEntity->uCardMax == 1 )

	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+221]
	cmp	ecx, 1
	jne	$L10911

; 10059:          // Because the object might be recursive, we also
; 10060:          // need to check to make sure that the level of the child entity
; 10061:          // instance is exactly 1 more the the level of the parent entity.
; 10062:          lpChildEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
$L10914:

; 10063:          while ( lpChildEntityInstance &&
; 10064:                  (lpChildEntityInstance->hViewEntity != hChildViewEntity ||
; 10065:                   lpChildEntityInstance->nLevel != nEntityInstanceLevel + 1) )

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	SHORT $L10915
	mov	ecx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hChildViewEntity$[ebp]
	jne	SHORT $L10916
	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nEntityInstanceLevel$[ebp]
	add	edx, 1
	cmp	ecx, edx
	je	SHORT $L10915
$L10916:

; 10067:             if ( lpChildEntityInstance->nLevel <= nEntityInstanceLevel )

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nEntityInstanceLevel$[ebp]
	cmp	ecx, edx
	jg	SHORT $L10917

; 10069:                lpChildEntityInstance = 0;

	mov	DWORD PTR _lpChildEntityInstance$[ebp], 0

; 10070:                break;

	jmp	SHORT $L10915
$L10917:

; 10072: 
; 10073:             while ( lpChildEntityInstance->hNextTwin )

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $L10920

; 10074:                lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
	jmp	SHORT $L10917
$L10920:

; 10075: 
; 10076:             lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax

; 10077:          }

	jmp	SHORT $L10914
$L10915:

; 10078: 
; 10079:          nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 10081:       else

	jmp	SHORT $L10923
$L10911:

; 10082:          lpChildEntityInstance = 0;

	mov	DWORD PTR _lpChildEntityInstance$[ebp], 0
$L10923:

; 10083: 
; 10084:       // If lpChildEntityInstance is still 0 then we need to load it.
; 10085:       if ( lpChildEntityInstance == 0 )

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	jne	$L10936

; 10087:          // If the child entity not either a derived path or a duplicate
; 10088:          // relationship path then attempt to load that entity.
; 10089:          if ( lpChildViewEntity->bDerivedPath == FALSE &&
; 10090:               lpChildViewEntity->bDupRelPath == FALSE )

	mov	edx, DWORD PTR _lpChildViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	jne	$L10931
	mov	ecx, DWORD PTR _lpChildViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	test	edx, edx
	jne	$L10931

; 10092:             // Child entities couldn't be loaded via cacheing, so call the
; 10093:             // db-handler.
; 10094:             nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 10095:                             DBH_Entity | DBH_Load, 0, lpViewOD,
; 10096:                             lpChildViewEntity, lpView, lpQualView, lpPtr );

	mov	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	0
	push	32800					; 00008020H
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 10097:             if ( nRC == zDB_DEADLOCK )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -3					; fffffffdH
	jne	SHORT $L10928

; 10098:                return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L10882
$L10928:

; 10099: 
; 10100:             if ( lpCurrentTask->bLoadAllocLimit )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	test	edx, edx
	je	SHORT $L10929

; 10102:                lpCurrentTask->bLoadAllocLimit = FALSE;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	and	ch, -65					; ffffffbfH
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [edx+443], ecx

; 10103:                return( zMEMORY_LIMIT );

	mov	ax, -7					; fffffff9H
	jmp	$L10882
$L10929:

; 10105: 
; 10106:             if ( nRC < -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jge	SHORT $L10930

; 10107:                return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10882
$L10930:

; 10108: 
; 10109:             // Check to see if the activate limit was reached.
; 10110:             if ( nRC == 2 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, 2
	jne	SHORT $L10931

; 10111:                nReturnCode = 2;

	mov	WORD PTR _nReturnCode$[ebp], 2
$L10931:

; 10113: 
; 10114:          // If we didn't load any child entities see if we need to create a
; 10115:          // child entity because of the "hanging keys" problem.
; 10116:          if ( nRC == -1 && lpChildViewEntity->bHangingFKey )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jne	SHORT $L10932
	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10932

; 10117:             fnAddHangingEntity( lpView, lpChildViewEntity );

	mov	edx, DWORD PTR _lpChildViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnAddHangingEntity@8
$L10932:

; 10118: 
; 10119:          // If any children were loaded, call this proc recursively to load all
; 10120:          // of THEIR children.
; 10121: 
; 10122:          // Find the first child entity of lpChildViewEntity.
; 10123:          lpChildEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
$L10935:

; 10124: 
; 10125:          // Now find the first child entity instance that matches
; 10126:          // lpChildViewEntity.  Because the object might be recursive, we also
; 10127:          // need to check to make sure that the level of the child entity
; 10128:          // instance is exactly 1 more the the level of the parent entity.
; 10129:          while ( lpChildEntityInstance &&
; 10130:                  (lpChildEntityInstance->hViewEntity != hChildViewEntity ||
; 10131:                   lpChildEntityInstance->nLevel != nEntityInstanceLevel + 1) )

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	SHORT $L10936
	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hChildViewEntity$[ebp]
	jne	SHORT $L10937
	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nEntityInstanceLevel$[ebp]
	add	ecx, 1
	cmp	eax, ecx
	je	SHORT $L10936
$L10937:

; 10133:             if ( lpChildEntityInstance->nLevel <= nEntityInstanceLevel )

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nEntityInstanceLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $L10938

; 10135:                lpChildEntityInstance = 0;

	mov	DWORD PTR _lpChildEntityInstance$[ebp], 0

; 10136:                break;

	jmp	SHORT $L10936
$L10938:

; 10138: 
; 10139:             while ( lpChildEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $L10941

; 10140:                lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
	jmp	SHORT $L10938
$L10941:

; 10141: 
; 10142:             lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax

; 10143:          }

	jmp	SHORT $L10935
$L10936:

; 10146: 
; 10147:       // If nRC == -1, then no children were loaded.
; 10148:       if ( nRC >= 0 && lpChildEntityInstance )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L10947
	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	$L10947
$L10946:

; 10150:          // Load the children of the just-loaded children.
; 10151:          while ( lpChildEntityInstance )

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	$L10947

; 10153:             //
; 10154:             // Make lpChildEntityInstance the current instance.
; 10155:             //
; 10156:             lpViewEntityCsr =
; 10157:                 fnEstablishViewForInstance( lpView, 0, lpChildEntityInstance );

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 10158: 
; 10159:             // If the entity is flagged as recursive, then set the view to
; 10160:             // have the current child entity as the parent of the recursive
; 10161:             // relationship before calling fnLoadChildEntities.
; 10162:             if ( lpChildViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpChildViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	test	edx, edx
	je	$L10948

; 10164:                fnSetViewToSubobject( lpView, lpChildViewEntity,
; 10165:                                      lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpChildViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH

; 10166: 
; 10167:                // Check to make sure the recursive entity instance hasn't
; 10168:                // already been loaded as a parent.  If it has then this is
; 10169:                // an error because the OI has an infinite looping sub-object.
; 10170:                // If the return value is TRUE then there was an error.
; 10171:                if ( fnCheckForRecursiveLoop( lpView,
; 10172:                                              lpChildEntityInstance ) == 0 )

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnCheckForRecursiveLoop@8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L10953

; 10174:                   // Everything ok so load children.
; 10175:                   nRC = fnLoadChildEntities( lpCurrentTask, lpView,
; 10176:                                              lpChildEntityInstance, lpQualView,
; 10177:                                              pOper, lpPtr );

	mov	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnLoadChildEntities
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 10178:                   if ( nRC == zDB_DEADLOCK || nRC == zMEMORY_LIMIT )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -3					; fffffffdH
	je	SHORT $L10951
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -7					; fffffff9H
	jne	SHORT $L10950
$L10951:

; 10179:                      return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L10882
$L10950:

; 10180: 
; 10181:                   if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L10952

; 10182:                      return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10882
$L10952:

; 10183: 
; 10184:                   if ( nRC == 2 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 2
	jne	SHORT $L10953

; 10185:                      nReturnCode = 2;

	mov	WORD PTR _nReturnCode$[ebp], 2
$L10953:

; 10187: 
; 10188:                fnResetViewFromSubobject( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 10190:             else

	jmp	SHORT $L10958
$L10948:

; 10192:                nRC = fnLoadChildEntities( lpCurrentTask, lpView,
; 10193:                                           lpChildEntityInstance, lpQualView,
; 10194:                                           pOper, lpPtr );

	mov	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnLoadChildEntities
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 10195:                if ( nRC == zDB_DEADLOCK || nRC == zMEMORY_LIMIT )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -3					; fffffffdH
	je	SHORT $L10956
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -7					; fffffff9H
	jne	SHORT $L10955
$L10956:

; 10196:                   return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L10882
$L10955:

; 10197: 
; 10198:                if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L10957

; 10199:                   return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L10882
$L10957:

; 10200: 
; 10201:                if ( nRC == 2 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 2
	jne	SHORT $L10958

; 10202:                   nReturnCode = 2;

	mov	WORD PTR _nReturnCode$[ebp], 2
$L10958:

; 10204: 
; 10205:             // Get next twin.
; 10206:             lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax

; 10207: 
; 10208:          }  // while ( lpChildEntityInstance )...

	jmp	$L10946
$L10947:

; 10211: 
; 10212:    } // for ( lpChildViewEntity )

	jmp	$L10908
$L10909:

; 10213: 
; 10214:    return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]
$L10882:

; 10215: 
; 10216: }  // fnLoadChildEntities

	mov	esp, ebp
	pop	ebp
	ret	0
_fnLoadChildEntities ENDP
_TEXT	ENDS
PUBLIC	_fnSetLocksOnTwins@24
PUBLIC	??_C@_01PCJP@Y?$AA@				; `string'
;	COMDAT ??_C@_01PCJP@Y?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_01PCJP@Y?$AA@ DB 'Y', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_bLOD_Lock$ = 12
_lpView$ = 16
_lpFirstEntityInstance$ = 20
_lpViewOI$ = 24
_bAllowRead$ = 28
_vLock$ = -8
_lpViewEntity$ = -60
_lpViewAttrib$ = -132
_lpKeyViewAttrib$ = -292
_lpEntityInstance$ = -56
_lpViewEntityCsr$ = -500
_lpViewOD$ = -12
_tViewArrayBlock$ = -128
_szKeyString$ = -496
_szLockName$ = -52
_nKeyCnt$ = -64
_nRC$ = -16
_lpLockInstance$11003 = -504
_fnSetLocksOnTwins@24 PROC NEAR

; 10232: {

	push	ebp
	mov	ebp, esp
	sub	esp, 508				; 000001fcH
	push	edi

; 10233:    ViewClusterRecord vLock;
; 10234:    LPVIEWENTITY      lpViewEntity;
; 10235:    LPVIEWATTRIB      lpViewAttrib;
; 10236:    LPVIEWATTRIB      lpKeyViewAttrib[ zMAX_KEYS_FOR_LOCK ];
; 10237:    LPENTITYINSTANCE  lpEntityInstance;
; 10238:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10239:    LPVIEWOD          lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 10240:    VIEWARRAYBLOCK    tViewArrayBlock = { 0 };

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	mov	ecx, 15					; 0000000fH
	xor	eax, eax
	lea	edi, DWORD PTR _tViewArrayBlock$[ebp+4]
	rep stosd

; 10241:    zCHAR             szKeyString[ zMAX_KEYLTH_FOR_LOCK + 1 ];
; 10242:    zCHAR             szLockName[ 35 ];
; 10243:    zSHORT            nKeyCnt;
; 10244:    zSHORT            nRC = zCALL_ERROR;       // Assume everything error.

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10245: 
; 10246:    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 10247:    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 10248: 
; 10249:    lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10250: 
; 10251:    // To save time later find all the keys in the LOD and store them in a table.
; 10252:    nKeyCnt = 0;

	mov	WORD PTR _nKeyCnt$[ebp], 0

; 10253:    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 10254:          lpViewAttrib;
; 10255:          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L10990
$L10991:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L10990:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L10992

; 10257:       if ( lpViewAttrib->bKey )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $L10993

; 10258:          lpKeyViewAttrib[ nKeyCnt++ ] = lpViewAttrib;

	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeyViewAttrib$[ebp+ecx*4], edx
	mov	ax, WORD PTR _nKeyCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nKeyCnt$[ebp], ax
$L10993:

; 10259:    }

	jmp	SHORT $L10991
$L10992:

; 10260: 
; 10261:    // Create an empty lock OI.
; 10262:    if ( fnDeclareView( &vLock.vOI, lpCurrentTask, lpView, "ZPLOCKO", FALSE ) != 0 )

	push	0
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnDeclareView@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10994

; 10263:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10973
$L10994:

; 10264: 
; 10265:    if ( fnActivateEmptyObjectInstance( lpCurrentTask, vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10995

; 10266:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10973
$L10995:

; 10267: 
; 10268:    // Get the lpViewEntity and lpViewEntityCsr for the lock OI.
; 10269:    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, vLock.vOI, "ZeidonLock", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10270: 
; 10271:    if ( bLOD_Lock )

	mov	ecx, DWORD PTR _bLOD_Lock$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L10996

; 10273:       // We are setting a LOD level lock so we set LockName to the name of
; 10274:       // the LOD.
; 10275:       zstrcpy( szLockName, lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 10277:    else

	jmp	SHORT $L10997
$L10996:

; 10279:       // We are setting a lock at the entity level so use the name of the
; 10280:       // entity for the LockName.  In addition, to handle the rare case where
; 10281:       // a LOD and entity name are the same we prefix all entity names with
; 10282:       // a '@' because it's an invalid character for entity names.  This
; 10283:       // insures that the LockName for the entity does not match a LOD name.
; 10284:       lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10285:       zsprintf( szLockName, "@%s", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET FLAT:??_C@_03LNBB@?$EA?$CFs?$AA@	; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L10997:

; 10287: 
; 10288:    // Loop through each of the root entities and create a locking record.
; 10289:    for ( lpEntityInstance = lpFirstEntityInstance;
; 10290:          lpEntityInstance;
; 10291:          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $L11000
$L11001:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L11000:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L11002

; 10293:       LPENTITYINSTANCE lpLockInstance;
; 10294: 
; 10295:       // Create the concat key string.
; 10296:       fnCreateConcatKey( szKeyString, lpEntityInstance,
; 10297:                          lpKeyViewAttrib, nKeyCnt );

	mov	dx, WORD PTR _nKeyCnt$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpKeyViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szKeyString$[ebp]
	push	edx
	call	_fnCreateConcatKey@16

; 10298: 
; 10299:       if ( fnCreateEntity( vLock.vOI, lpViewEntity, lpViewEntityCsr,
; 10300:                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCreateEntity@20
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11005

; 10302:          goto EndOfFunction;

	jmp	$EndOfFunction$11006
$L11005:

; 10304: 
; 10305:       // fnCreateEntity DOES NOT set the bCreated flag so set it.
; 10306:       lpLockInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLockInstance$11003[ebp], eax

; 10307:       lpLockInstance->u.nInd.bCreated = TRUE;

	mov	eax, DWORD PTR _lpLockInstance$11003[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 2
	mov	edx, DWORD PTR _lpLockInstance$11003[ebp]
	mov	DWORD PTR [edx+6], ecx

; 10308: 
; 10309:       if ( fnSetLockingAttributes( lpCurrentTask,
; 10310:                                    vLock.vOI, lpViewEntity, lpViewEntityCsr,
; 10311:                                    szLockName, szKeyString,
; 10312:                                    TRUE, TRUE, bAllowRead ? "Y" : "N" ) != 0 )

	mov	eax, DWORD PTR _bAllowRead$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L12815
	mov	DWORD PTR -508+[ebp], OFFSET FLAT:??_C@_01PCJP@Y?$AA@ ; `string'
	jmp	SHORT $L12816
$L12815:
	mov	DWORD PTR -508+[ebp], OFFSET FLAT:??_C@_01OAK@N?$AA@ ; `string'
$L12816:
	mov	ecx, DWORD PTR -508+[ebp]
	push	ecx
	push	1
	push	1
	lea	edx, DWORD PTR _szKeyString$[ebp]
	push	edx
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnSetLockingAttributes@36
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L11008

; 10314:          goto EndOfFunction;

	jmp	SHORT $EndOfFunction$11006
$L11008:

; 10316:    } // for ( lpEntityInstance...)

	jmp	$L11001
$L11002:

; 10317: 
; 10318:    // Now commit the lock OI.
; 10319:    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11010

; 10320:       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$11006
$L11010:

; 10321: 
; 10322:    if ( fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0, lpCurrentTask,
; 10323:                                 0, &tViewArrayBlock ) != 0 )

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	1
	lea	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCommitObjectInstance@28
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11011

; 10325:       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$11006
$L11011:

; 10327: 
; 10328:    lpViewOI->bIsLocked = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 10329: 
; 10330:    // If we get here then everything is OK.
; 10331:    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$11006:

; 10332: 
; 10333: EndOfFunction:
; 10334:    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $L11012

; 10335:       fnDropView( vLock.vOI );

	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnDropView@4
$L11012:

; 10336: 
; 10337:    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 10338: 
; 10339:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10973:

; 10340: 
; 10341: } // fnSetLocksOnTwins

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnSetLocksOnTwins@24 ENDP
_lpCurrentTask$ = 8
_lpView$ = 12
_lpQualView$ = 16
_lControl$ = 20
_lpViewOD$ = -8
_lpViewOI$ = -40
_lpViewCsr$ = -4
_lpEntityInstance$ = -20
_lpTaskDBHandler$ = -32
_pOper$ = -24
_lpPtr$ = -16
_bTransactionStartedHere$ = -28
_nReturnCode$ = -36
_nRC$ = -12
_bReadOnly$11048 = -44
_bAllowRead$11051 = -48
_lpViewEntity$11071 = -52
_bReadOnly$11073 = -56
_bAllowRead$11078 = -60
_fnActivateObjectInstance PROC NEAR

; 10376: {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 10377:    LPVIEWOD          lpViewOD;
; 10378:    LPVIEWOI          lpViewOI;
; 10379:    LPVIEWCSR         lpViewCsr;
; 10380:    LPENTITYINSTANCE  lpEntityInstance;
; 10381:    LPTASKDBHANDLER   lpTaskDBHandler;
; 10382:    zPDBHOPER         pOper;
; 10383:    zPVOID            lpPtr;
; 10384:    zBOOL             bTransactionStartedHere;
; 10385:    zSHORT            nReturnCode;
; 10386:    zSHORT            nRC;
; 10387: 
; 10388:    lpPtr       = 0;

	mov	DWORD PTR _lpPtr$[ebp], 0

; 10389:    nReturnCode = 0;

	mov	WORD PTR _nReturnCode$[ebp], 0

; 10390: 
; 10391:    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 10392:    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 10393:    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 10394:    lpTaskDBHandler = fnGetDBHandlerOper( lpCurrentTask, lpView,
; 10395:                                          (zlpPDBHOPER) &pOper );

	lea	eax, DWORD PTR _pOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnGetDBHandlerOper@12
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax

; 10396:    if ( lpTaskDBHandler == 0 )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	jne	SHORT $L11036

; 10397:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11021
$L11036:

; 10398: 
; 10399:    // Check to see if a transaction has already been started for the database.
; 10400:    // If it has already been started we don't want to do it again but set a
; 10401:    // flag to indicate we don't want to END the transaction later.
; 10402:    //
; 10403:    // We need to do this because fnActivateObjectInstance can be called
; 10404:    // recursively.
; 10405:    if ( lpTaskDBHandler->bTranStarted )

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L11037

; 10407:       bTransactionStartedHere = FALSE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 0

; 10408:       lpPtr = lpTaskDBHandler->lpConnection;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR _lpPtr$[ebp], eax

; 10410:    else

	jmp	SHORT $L11038
$L11037:

; 10412:       // Call DBHandler routine to issue start of transaction.
; 10413:       nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 10414:                       DBH_Object | DBH_TranBegin, DBH_LoadOI,
; 10415:                       lpViewOD, 0, lpView, lpQualView, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	1
	push	16385					; 00004001H
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 10416:       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $L11041

; 10417:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11021
$L11041:

; 10418: 
; 10419:       // Set flag to indicate that we started the transaction here and will
; 10420:       // need to end the transaction before we exit the operation.
; 10421:       bTransactionStartedHere = TRUE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 1

; 10422:       lpTaskDBHandler->bTranStarted = TRUE;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	or	edx, 1
	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [eax+26], edx

; 10423:       lpTaskDBHandler->lpConnection = lpPtr;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR _lpPtr$[ebp]
	mov	DWORD PTR [ecx+18], edx
$L11038:

; 10425: 
; 10426:    // Retrieve the root entity(-ies).
; 10427:    nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 10428:                    DBH_Entity | DBH_Load, (int) lControl, lpViewOD,
; 10429:                    zGETPTR( lpViewOD->hFirstOD_Entity ),
; 10430:                    lpView, lpQualView, &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	push	32800					; 00008020H
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 10431: 
; 10432:    // If nRC > 0, then the root entity was loaded OK but multiple roots were
; 10433:    // found and lControl = zSINGLE or the multi-root limit was reached.
; 10434:    // This means that not all roots where loaded.
; 10435:    // Set nRC back to 0 (indicate load was OK) and set nReturnCode = 1 (this
; 10436:    // will be returned by the Activate if everything else goes OK).
; 10437:    if ( nRC >= 1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 1
	jl	SHORT $L11046

; 10439:       nReturnCode = nRC;

	mov	ax, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturnCode$[ebp], ax

; 10440:       nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$L11046:

; 10442: 
; 10443:    // If we activated some information check to see if we need to set up
; 10444:    // some pessimistic locks.
; 10445:    if ( nRC >= 0 && lpViewOD->nLock >= zLL_PESSIMISTIC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L11053
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+236]
	cmp	eax, 3
	jl	$L11053

; 10447:       zBOOL bReadOnly = (lControl & zSINGLE_FOR_UPDATE) == 0 ||
; 10448:                         lpViewOD->nLock == zLL_PESSIMISTIC;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 67108864				; 04000000H
	test	ecx, ecx
	je	SHORT $L12818
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+236]
	cmp	eax, 3
	je	SHORT $L12818
	mov	DWORD PTR -64+[ebp], 0
	jmp	SHORT $L12819
$L12818:
	mov	DWORD PTR -64+[ebp], 1
$L12819:
	mov	cl, BYTE PTR -64+[ebp]
	mov	BYTE PTR _bReadOnly$11048[ebp], cl

; 10449: 
; 10450:       nRC = fnCheckLocksOnTwins( lpCurrentTask, TRUE, bReadOnly, lpView,
; 10451:                                  zGETPTR( lpViewOI->hRootEntityInstance ),
; 10452:                                  lpViewOD );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	al, BYTE PTR _bReadOnly$11048[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCheckLocksOnTwins@24
	mov	WORD PTR _nRC$[ebp], ax

; 10453: 
; 10454:       // If nRC >= 0 then we might need to set locks on the parent entities.
; 10455:       if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L11053

; 10457:          zBOOL bAllowRead = lpViewOD->nLock == zLL_PESSIMISTIC_WITHREAD;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+236]
	xor	edx, edx
	cmp	ecx, 4
	sete	dl
	mov	BYTE PTR _bAllowRead$11051[ebp], dl

; 10458: 
; 10459:          if ( bReadOnly == FALSE &&
; 10460:               fnSetLocksOnTwins( lpCurrentTask, TRUE, lpView,
; 10461:                                  zGETPTR( lpViewOI->hRootEntityInstance ),
; 10462:                                  lpViewOI, bAllowRead ) != 0 )

	mov	eax, DWORD PTR _bReadOnly$11048[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L11053
	mov	cl, BYTE PTR _bAllowRead$11051[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnSetLocksOnTwins@24
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11053

; 10464:             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H
$L11053:

; 10468: 
; 10469:    // For each of the root entities, call fnLoadChildEntities to load all of
; 10470:    // their children if lower-level entities are to be loaded.
; 10471:    if ( nRC >= 0 && (lControl & zACTIVATE_ROOTONLY) == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$L11054
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	jne	$L11054

; 10473:       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 10474:             lpEntityInstance && nRC >= 0;
; 10475:             lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L11057
$L11058:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L11057:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L11059
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L11059

; 10477:          // Make lpEntityInstance the current instance.
; 10478:          fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 10479: 
; 10480:          nRC = fnLoadChildEntities( lpCurrentTask, lpView, lpEntityInstance,
; 10481:                                     lpQualView, pOper, &lpPtr );

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnLoadChildEntities
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 10482:          if ( nRC == zDB_DEADLOCK || nRC == zMEMORY_LIMIT )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -3					; fffffffdH
	je	SHORT $L11061
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -7					; fffffff9H
	jne	SHORT $L11060
$L11061:

; 10483:             nReturnCode = nRC;

	mov	cx, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturnCode$[ebp], cx
$L11060:

; 10484: 
; 10485:          // If nRC is 2 then not all child entities where loaded because the
; 10486:          // Activate Limit constraint was reached.
; 10487:          if ( nRC == 2 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 2
	jne	SHORT $L11062

; 10488:             nReturnCode = 2;

	mov	WORD PTR _nReturnCode$[ebp], 2
$L11062:

; 10489: 
; 10490:       }  // for ( lpEntityInstance )...

	jmp	SHORT $L11058
$L11059:

; 10493:    else

	jmp	SHORT $L11064
$L11054:

; 10494:    if ( lControl == (lControl | zACTIVATE_ROOTONLY) )

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 268435456				; 10000000H
	cmp	DWORD PTR _lControl$[ebp], eax
	jne	SHORT $L11064

; 10495:       lpViewOI->bRootOnly = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 2
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L11064:

; 10496: 
; 10497:    // If we activated some information check to see if we need to set up
; 10498:    // some pessimistic locks.
; 10499:    if ( nRC >= 0 && lpViewOD->nEntityLock >= zLL_PESSIMISTIC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L11070
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+237]
	cmp	eax, 3
	jl	$L11070

; 10501:       // Loop through all the instances and check to see if
; 10502:       // the entity has locking.
; 10503:       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 10504:             lpEntityInstance;
; 10505:             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L11068
$L11069:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L11068:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L11070

; 10507:          LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$11071[ebp], eax

; 10508:          zBOOL        bReadOnly;
; 10509: 
; 10510:          // If entity has no locking skip it.
; 10511:          if ( lpViewEntity->nLock == 0 )

	mov	ecx, DWORD PTR _lpViewEntity$11071[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+230]
	test	edx, edx
	jne	SHORT $L11074

; 10512:             continue;

	jmp	SHORT $L11069
$L11074:

; 10513: 
; 10514:          // If the instance is not the first twin then skip it.
; 10515:          if ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L11075

; 10516:             continue;

	jmp	SHORT $L11069
$L11075:

; 10517: 
; 10518:          // We're about to check the locks on the entity instances but if the
; 10519:          // zSINGLE_FOR_UPDATE flag is not set or if the locking level is only
; 10520:          // zLL_PESSIMISTIC then the entity instance is read-only.
; 10521:          bReadOnly = (lControl & zSINGLE_FOR_UPDATE) == 0 ||
; 10522:                      lpViewEntity->nLock == zLL_PESSIMISTIC;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 67108864				; 04000000H
	test	ecx, ecx
	je	SHORT $L12820
	mov	edx, DWORD PTR _lpViewEntity$11071[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+230]
	cmp	eax, 3
	je	SHORT $L12820
	mov	DWORD PTR -68+[ebp], 0
	jmp	SHORT $L12821
$L12820:
	mov	DWORD PTR -68+[ebp], 1
$L12821:
	mov	cl, BYTE PTR -68+[ebp]
	mov	BYTE PTR _bReadOnly$11073[ebp], cl

; 10523: 
; 10524:          // Make sure the entities aren't locked.
; 10525:          if ( fnCheckLocksOnTwins( lpCurrentTask, FALSE, bReadOnly, lpView,
; 10526:                                    lpEntityInstance, lpViewOD ) != 0 )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	dl, BYTE PTR _bReadOnly$11073[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCheckLocksOnTwins@24
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11076

; 10528:             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10529:             break;

	jmp	SHORT $L11070
$L11076:

; 10531: 
; 10532:          // If entity instances are not read-only then we need to set up locks
; 10533:          // for the entities.
; 10534:          if ( bReadOnly == FALSE )

	mov	edx, DWORD PTR _bReadOnly$11073[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L11079

; 10536:             zBOOL bAllowRead = lpViewEntity->nLock == zLL_PESSIMISTIC_WITHREAD;

	mov	eax, DWORD PTR _lpViewEntity$11071[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+230]
	xor	edx, edx
	cmp	ecx, 4
	sete	dl
	mov	BYTE PTR _bAllowRead$11078[ebp], dl

; 10537: 
; 10538:             if ( fnSetLocksOnTwins( lpCurrentTask, FALSE, lpView,
; 10539:                                     lpEntityInstance, lpViewOI,
; 10540:                                     bAllowRead ) != 0 )

	mov	al, BYTE PTR _bAllowRead$11078[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnSetLocksOnTwins@24
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L11079

; 10542:                nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10543:                break;

	jmp	SHORT $L11070
$L11079:

; 10546:       } // for...

	jmp	$L11069
$L11070:

; 10548: 
; 10549:    // Check to see if we need to close the transaction.
; 10550:    if ( bTransactionStartedHere )

	mov	eax, DWORD PTR _bTransactionStartedHere$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L11085

; 10552:       // We're about to close the transaction so set flag.
; 10553:       lpTaskDBHandler->bTranStarted = FALSE;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [eax+26], edx

; 10554:       lpTaskDBHandler->lpConnection = 0;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [ecx+18], 0

; 10555: 
; 10556:       if ( nRC >= -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	SHORT $L11081

; 10558:          // Call DBHandler routine to commit transaction.
; 10559:          if ( (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 10560:                         DBH_Object | DBH_Commit, DBH_LoadOI,
; 10561:                         lpViewOD, 0, lpView, 0, &lpPtr ) != 0 )

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	1
	push	16386					; 00004002H
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11084

; 10563:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11021
$L11084:

; 10566:       else

	jmp	SHORT $L11085
$L11081:

; 10568:          // Call DBHandler routine to rollback transaction.
; 10569:          (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 10570:                    DBH_Object | DBH_Rollback, DBH_LoadOI,
; 10571:                    lpViewOD, 0, lpView, 0, &lpPtr );

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	1
	push	16388					; 00004004H
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]

; 10572:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11021
$L11085:

; 10575: 
; 10576:    // At this point if:
; 10577:    //    nRC = 0, nReturnCode = 1 -- 1 root loaded, mult found; children loaded
; 10578:    //    nRC = 0, nReturnCode = 0 -- all roots (possibly only 1) loaded.
; 10579:    //    nRC = -1                 -- No root found matching lpQual.
; 10580:    //    nRC < -1                 -- Error loading entities.
; 10581: 
; 10582:    if ( nRC >= -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jl	$L11095

; 10584:       // Before we exit, reset indicators in object instance to denote
; 10585:       // that entities are not to be created/include at commit time.
; 10586:       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 10587:             lpEntityInstance;
; 10588:             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L11091
$L11092:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L11091:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L11093

; 10590:          lpEntityInstance->u.nInd.bCreated        =
; 10591:             lpEntityInstance->u.nInd.bIncluded    =
; 10592:             lpEntityInstance->u.nInd.bUpdated     =
; 10593:             lpEntityInstance->u.nInd.bDBHCreated  =
; 10594:             lpEntityInstance->u.nInd.bDBHIncluded =
; 10595:             lpEntityInstance->u.nInd.bDBHDeleted  =
; 10596:             lpEntityInstance->u.nInd.bDBHExcluded =
; 10597:             lpEntityInstance->u.nInd.bDBHUpdated  = 0;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -131073				; fffdffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -65537				; fffeffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -65					; ffffffbfH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, 127					; 0000007fH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -5					; fffffffbH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -3					; fffffffdH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 10598:       }

	jmp	$L11092
$L11093:

; 10599: 
; 10600:       lpViewOI->bUpdated = lpViewOI->bUpdatedFile = 0;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	al, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	al, -17					; ffffffefH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 10601: 
; 10602:       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $L11094

; 10603:          return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]
	jmp	SHORT $L11021
$L11094:

; 10604:       else
; 10605:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L11021
$L11095:

; 10607: 
; 10608:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L11021:

; 10609: 
; 10610: }  //  fnActivateObjectInstance

	mov	esp, ebp
	pop	ebp
	ret	0
_fnActivateObjectInstance ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@GEOJ@?$CIWARNING?$CJ?5Couldn?8t?5find?5entity?5?$AA@ ; `string'
PUBLIC	??_C@_0BC@FECF@?$CIWARNING?$CJ?5in?5LOD?5?$AA@	; `string'
PUBLIC	??_C@_01PJCK@?4?$AA@				; `string'
PUBLIC	??_C@_0CH@HIC@Error?5from?5UUDECODE_NextLineToBu@ ; `string'
PUBLIC	??_C@_0BK@FNGM@UUDECODE?5length?5invalid?3?5?$AA@ ; `string'
PUBLIC	??_C@_0FA@FOLJ@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Tgt?5View?5E@ ; `string'
PUBLIC	??_C@_0CL@DJNN@ER?5Tokens?5don?8t?5match?5for?5linked@ ; `string'
PUBLIC	??_C@_0BL@IKLP@?$CIoi?$CJ?5Failed?5entity?5linking?$AA@ ; `string'
PUBLIC	??_C@_0BD@FPOB@?$CIoi?$CJ?5Link?5Src?5?$CD?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BG@GFPE@?$CIoi?$CJ?5Source?5Entity?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BD@GIND@?$CIoi?$CJ?5Link?5Tgt?5?$CD?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BG@FHME@?$CIoi?$CJ?5Target?5Entity?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0EA@MMNH@?$CIoi?$CJ?5Entity?5type?5mismatch?5during@ ; `string'
PUBLIC	_UUDECODE_NextLineToBuffer@16
PUBLIC	_fnActivateOI_FromTextStream
PUBLIC	??_C@_07ICJO@CONTROL?$AA@			; `string'
PUBLIC	??_C@_04EECP@ETAG?$AA@				; `string'
PUBLIC	??_C@_04BDIB@EKEY?$AA@				; `string'
PUBLIC	??_C@_05JDHD@OITAG?$AA@				; `string'
PUBLIC	??_C@_07IFBG@OIFLAGS?$AA@			; `string'
EXTRN	_fnSetAttributeFromBlob:NEAR
EXTRN	_SysParseLine@12:NEAR
EXTRN	__imp__strtoul:NEAR
EXTRN	_fnSetAttributeFromString:NEAR
EXTRN	_fnSetAttributeFromInteger:NEAR
;	COMDAT ??_C@_07ICJO@CONTROL?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_07ICJO@CONTROL?$AA@ DB 'CONTROL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EECP@ETAG?$AA@
_DATA	SEGMENT
??_C@_04EECP@ETAG?$AA@ DB 'ETAG', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BDIB@EKEY?$AA@
_DATA	SEGMENT
??_C@_04BDIB@EKEY?$AA@ DB 'EKEY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JDHD@OITAG?$AA@
_DATA	SEGMENT
??_C@_05JDHD@OITAG?$AA@ DB 'OITAG', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07IFBG@OIFLAGS?$AA@
_DATA	SEGMENT
??_C@_07IFBG@OIFLAGS?$AA@ DB 'OIFLAGS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@GEOJ@?$CIWARNING?$CJ?5Couldn?8t?5find?5entity?5?$AA@
_DATA	SEGMENT
??_C@_0CA@GEOJ@?$CIWARNING?$CJ?5Couldn?8t?5find?5entity?5?$AA@ DB '(WARNI'
	DB	'NG) Couldn''t find entity ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@FECF@?$CIWARNING?$CJ?5in?5LOD?5?$AA@
_DATA	SEGMENT
??_C@_0BC@FECF@?$CIWARNING?$CJ?5in?5LOD?5?$AA@ DB '(WARNING) in LOD ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PJCK@?4?$AA@
_DATA	SEGMENT
??_C@_01PJCK@?4?$AA@ DB '.', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CH@HIC@Error?5from?5UUDECODE_NextLineToBu@
_DATA	SEGMENT
??_C@_0CH@HIC@Error?5from?5UUDECODE_NextLineToBu@ DB 'Error from UUDECODE'
	DB	'_NextLineToBuffer: ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@FNGM@UUDECODE?5length?5invalid?3?5?$AA@
_DATA	SEGMENT
??_C@_0BK@FNGM@UUDECODE?5length?5invalid?3?5?$AA@ DB 'UUDECODE length inv'
	DB	'alid: ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FA@FOLJ@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Tgt?5View?5E@
_DATA	SEGMENT
??_C@_0FA@FOLJ@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Tgt?5View?5E@ DB '('
	DB	'oi) Error (OD: %s) - Tgt View Entity: %s Token: %d  View Enti'
	DB	'ty: %s Token = %d', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@DJNN@ER?5Tokens?5don?8t?5match?5for?5linked@
_DATA	SEGMENT
??_C@_0CL@DJNN@ER?5Tokens?5don?8t?5match?5for?5linked@ DB 'ER Tokens don'''
	DB	't match for linked entities!', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@IKLP@?$CIoi?$CJ?5Failed?5entity?5linking?$AA@
_DATA	SEGMENT
??_C@_0BL@IKLP@?$CIoi?$CJ?5Failed?5entity?5linking?$AA@ DB '(oi) Failed e'
	DB	'ntity linking', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@FPOB@?$CIoi?$CJ?5Link?5Src?5?$CD?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BD@FPOB@?$CIoi?$CJ?5Link?5Src?5?$CD?5?$DN?5?$AA@ DB '(oi) Link Src'
	DB	' # = ', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@GFPE@?$CIoi?$CJ?5Source?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BG@GFPE@?$CIoi?$CJ?5Source?5Entity?5?$DN?5?$AA@ DB '(oi) Source En'
	DB	'tity = ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GIND@?$CIoi?$CJ?5Link?5Tgt?5?$CD?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BD@GIND@?$CIoi?$CJ?5Link?5Tgt?5?$CD?5?$DN?5?$AA@ DB '(oi) Link Tgt'
	DB	' # = ', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FHME@?$CIoi?$CJ?5Target?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BG@FHME@?$CIoi?$CJ?5Target?5Entity?5?$DN?5?$AA@ DB '(oi) Target En'
	DB	'tity = ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EA@MMNH@?$CIoi?$CJ?5Entity?5type?5mismatch?5during@
_DATA	SEGMENT
??_C@_0EA@MMNH@?$CIoi?$CJ?5Entity?5type?5mismatch?5during@ DB '(oi) Entit'
	DB	'y type mismatch during cursor restoration for entity ', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpWkViewEntity$11276 = -456
_lpAttribFlags$11309 = -464
_AttribFlags$11310 = -460
_pchStart$11312 = -468
_l$11329 = -472
_szAttribFlags$11339 = -484
_j$11340 = -488
_lXVATok$11347 = -492
_sz$11366 = -892
_l$11409 = -896
_lLinkTgt$11420 = -900
_lLinkSrc$11421 = -904
_lpTgtViewEntity$11428 = -908
_nHierNbr$11452 = -912
_l$11453 = -916
_lpFirstViewCsr$11462 = -920
_lpWk$11486 = -924
_lpView$ = 8
_lpfnStreamFunc$ = 12
_lpvData$ = 16
_plControl$ = 20
_lpViewOD$ = -40
_lpViewOI$ = -384
_lpViewEntity$ = -76
_lpViewAttrib$ = -92
_lpViewCsr$ = -8
_lpViewEntityCsr$ = -440
_lpEntityInstance$ = -68
_lpSrcInstance$ = -72
_lpTgtInstance$ = -48
_lpCursorEI$ = -44
_lpTask$ = -84
_pchAttr$ = -64
_pchLine$ = -28
_pRelinkBufferTable$ = -432
_pRelinkBufferPtr$ = -24
_pRelinkBufferEnd$ = -60
_ulLth$ = -376
_ulLthDecoded$ = -436
_uPos$ = -360
_bIgnoreEntityErrors$ = -356
_bIgnoreAttribErrors$ = -56
_bEntityIsCompressed$ = -392
_bOI_IsUpdated$ = -80
_bSkipAttributes$ = -20
_bMsgBox$ = -352
_szWorkString$ = -348
_lIndicators$ = -380
_lPrevIndicators$ = -388
_lEntityCnt$ = -36
_lLineCount$ = -372
_k$ = -368
_nErrorEntityLvl$ = -364
_nErrorEntityCnt$ = -16
_nErrorAttribCnt$ = -4
_nEOF$ = -88
_nLevel$ = -12
_nRC$ = -52
_lInstanceCount$ = -32
_uFlags$11215 = -444
_nHierNbr$11235 = -448
_lpSearchViewEntityCsr$11240 = -452
_fnActivateOI_FromTextStream PROC NEAR

; 10618: {

	push	ebp
	mov	ebp, esp
	sub	esp, 956				; 000003bcH
	push	edi

; 10619:    LPVIEWOD          lpViewOD;
; 10620:    LPVIEWOI          lpViewOI;
; 10621:    LPVIEWENTITY      lpViewEntity;
; 10622:    LPVIEWATTRIB      lpViewAttrib;
; 10623:    LPVIEWCSR         lpViewCsr;
; 10624:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10625:    LPENTITYINSTANCE  lpEntityInstance;
; 10626:    LPENTITYINSTANCE  lpSrcInstance;
; 10627:    LPENTITYINSTANCE  lpTgtInstance;
; 10628:    LPENTITYINSTANCE  lpCursorEI;    // Used to set cursors.
; 10629:    LPTASK            lpTask;
; 10630:    zPCHAR            pchAttr;
; 10631:    zPCHAR            pchLine;
; 10632:    zPLONG            pRelinkBufferTable[ 10 ] = { 0 };

	mov	DWORD PTR _pRelinkBufferTable$[ebp], 0
	mov	ecx, 9
	xor	eax, eax
	lea	edi, DWORD PTR _pRelinkBufferTable$[ebp+4]
	rep stosd

; 10633:    zPLONG            pRelinkBufferPtr;
; 10634:    zPLONG            pRelinkBufferEnd;
; 10635:    zULONG            ulLth;
; 10636:    zULONG            ulLthDecoded;
; 10637:    zULONG            uPos;
; 10638:    zBOOL             bIgnoreEntityErrors;
; 10639:    zBOOL             bIgnoreAttribErrors;
; 10640:    zBOOL             bEntityIsCompressed;
; 10641:    zBOOL             bOI_IsUpdated = FALSE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 0

; 10642:    zBOOL             bSkipAttributes = FALSE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 0

; 10643:    zBOOL             bMsgBox = TRUE;

	mov	BYTE PTR _bMsgBox$[ebp], 1

; 10644:    zCHAR             szWorkString[ 256 ];
; 10645:    zLONG             lIndicators = 0, lPrevIndicators;

	mov	DWORD PTR _lIndicators$[ebp], 0

; 10646:    zLONG             lEntityCnt = 0;

	mov	DWORD PTR _lEntityCnt$[ebp], 0

; 10647:    zLONG             lLineCount = 0;

	mov	DWORD PTR _lLineCount$[ebp], 0

; 10648:    zLONG             k;
; 10649:    zSHORT            nErrorEntityLvl;
; 10650:    zSHORT            nErrorEntityCnt;
; 10651:    zSHORT            nErrorAttribCnt;
; 10652:    zSHORT            nEOF;
; 10653:    zSHORT            nLevel;
; 10654:    zSHORT            nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 10655: 
; 10656:    // The following should only be used for cursor processing.
; 10657:    zLONG             lInstanceCount = 0;

	mov	DWORD PTR _lInstanceCount$[ebp], 0

; 10658: 
; 10659:    bIgnoreEntityErrors = (*plControl & zIGNORE_ENTITY_ERRORS) ? 1 : 0;

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 4096				; 00001000H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	BYTE PTR _bIgnoreEntityErrors$[ebp], cl

; 10660:    bIgnoreAttribErrors = (*plControl & zIGNORE_ATTRIB_ERRORS) ? 1 : 0;

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 8192				; 00002000H
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	BYTE PTR _bIgnoreAttribErrors$[ebp], al

; 10661: 
; 10662:    nErrorEntityLvl = 0;

	mov	WORD PTR _nErrorEntityLvl$[ebp], 0

; 10663:    nErrorEntityCnt = 0;

	mov	WORD PTR _nErrorEntityCnt$[ebp], 0

; 10664:    nErrorAttribCnt = 0;

	mov	WORD PTR _nErrorAttribCnt$[ebp], 0

; 10665: 
; 10666:    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 10667:    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 10668:    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 10669:    lpTask    = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 10670: 
; 10671:    // Initialize buffer pointers to indicate it hasn't been allocated yet.
; 10672:    pRelinkBufferEnd = pRelinkBufferPtr = 0;

	mov	DWORD PTR _pRelinkBufferPtr$[ebp], 0
	mov	eax, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	DWORD PTR _pRelinkBufferEnd$[ebp], eax

; 10673: 
; 10674:    // Process the stream
; 10675:    lpViewEntityCsr = 0;

	mov	DWORD PTR _lpViewEntityCsr$[ebp], 0

; 10676:    lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0
$L11149:

; 10677:    while ( (nEOF = (*lpfnStreamFunc)( lpView, lpvData,
; 10678:                                       &pchLine, 0, 0 )) == 1 )

	push	0
	push	0
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
	movsx	ecx, WORD PTR _nEOF$[ebp]
	cmp	ecx, 1
	jne	$L11150

; 10680:       lLineCount++;

	mov	edx, DWORD PTR _lLineCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _lLineCount$[ebp], edx

; 10681:       if ( pRelinkBufferPtr == pRelinkBufferEnd )

	mov	eax, DWORD PTR _pRelinkBufferPtr$[ebp]
	cmp	eax, DWORD PTR _pRelinkBufferEnd$[ebp]
	jne	$L11151

; 10683:          k = lEntityCnt / 160000;  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	DWORD PTR _k$[ebp], eax

; 10684: 
; 10685:          // If we've loaded 160000 * 10 entities then bomb.
; 10686:          if ( k > 10 )

	cmp	DWORD PTR _k$[ebp], 10			; 0000000aH
	jle	SHORT $L11152

; 10688:             // if the relink entity pointer is at the end of the
; 10689:             // space allocated, issue an error
; 10690:             //  "KZOEE090 - Maximum number of entities in portable file exceeded "
; 10691:             (*lpfnStreamFunc)( lpView, lpvData, 0, 0, 90 );

	push	90					; 0000005aH
	push	0
	push	0
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 10692:             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10693:             break;

	jmp	$L11150
$L11152:

; 10695: 
; 10696:          pRelinkBufferTable[ k ] =
; 10697:             (zPLONG) fnAllocDataspace( lpTask->hFirstDataHeader,
; 10698:                                        640000L, TRUE, 0, iRelinkBuffer );  // moved up from 64000 dks/don 2007.01.04

	push	10107					; 0000277bH
	push	0
	push	1
	push	640000					; 0009c400H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _pRelinkBufferTable$[ebp+ecx*4], eax

; 10699: 
; 10700:          pRelinkBufferTable[ k ] = zGETPTR( pRelinkBufferTable[ k ] );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pRelinkBufferTable$[ebp+edx*4]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _pRelinkBufferTable$[ebp+ecx*4], eax

; 10701: 
; 10702:          pRelinkBufferEnd = pRelinkBufferTable[ k ] + 640000 / 4;  // Space for 160000 entities ... moved up from 16000 dks/don 2007.01.04

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pRelinkBufferTable$[ebp+edx*4]
	add	eax, 640000				; 0009c400H
	mov	DWORD PTR _pRelinkBufferEnd$[ebp], eax

; 10703:          pRelinkBufferPtr = pRelinkBufferTable[ k ];

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pRelinkBufferTable$[ebp+ecx*4]
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], edx
$L11151:

; 10706: 
; 10707:       if ( nErrorEntityLvl )

	movsx	eax, WORD PTR _nErrorEntityLvl$[ebp]
	test	eax, eax
	je	$L11163

; 10709:          if ( pchLine[ 0 ] == 'e' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 101				; 00000065H
	jne	$L11156

; 10711:             SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_SysParseLine@12

; 10712:             if ( *plControl & zCOMPRESSED )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L11157

; 10713:                nLevel = (zSHORT) zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nLevel$[ebp], ax

; 10714:             else

	jmp	SHORT $L11159
$L11157:

; 10715:                nLevel = (zSHORT) zatol( pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nLevel$[ebp], ax
$L11159:

; 10716: 
; 10717:             if ( nLevel > nErrorEntityLvl )

	movsx	ecx, WORD PTR _nLevel$[ebp]
	movsx	edx, WORD PTR _nErrorEntityLvl$[ebp]
	cmp	ecx, edx
	jle	SHORT $L11161

; 10718:                pchLine[ 0 ] = ' ';

	mov	eax, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
$L11161:

; 10719: 
; 10720:             *pRelinkBufferPtr = 0;

	mov	ecx, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	DWORD PTR [ecx], 0

; 10721:             pRelinkBufferPtr++;

	mov	edx, DWORD PTR _pRelinkBufferPtr$[ebp]
	add	edx, 4
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], edx

; 10722:             lEntityCnt++;

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _lEntityCnt$[ebp], eax

; 10724:          else

	jmp	SHORT $L11163
$L11156:

; 10725:          if ( pchLine[ 0 ] == 'a' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 97					; 00000061H
	jne	SHORT $L11163

; 10726:             pchLine[ 0 ] = ' ';

	mov	eax, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
$L11163:

; 10728: 
; 10729:       if ( pchLine[ 0 ] == 'm' )  // Meta information

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 109				; 0000006dH
	jne	$L11164

; 10731:          // Meta information is information about the OI (as opposed to the
; 10732:          // info *in* the OI).
; 10733:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_SysParseLine@12

; 10734:          switch ( szWorkString[ 0 ] )
; 10735:          {

	mov	al, BYTE PTR _szWorkString$[ebp]
	mov	BYTE PTR -928+[ebp], al
	cmp	BYTE PTR -928+[ebp], 67			; 00000043H
	je	SHORT $L11169
	cmp	BYTE PTR -928+[ebp], 69			; 00000045H
	je	$L11178
	cmp	BYTE PTR -928+[ebp], 79			; 0000004fH
	je	$L11197
	jmp	$L11166
$L11169:

; 10736:             case 'C':
; 10737:                if ( zstrcmp( szWorkString, "CONTROL" ) == 0 )

	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	movsx	edx, BYTE PTR ??_C@_07ICJO@CONTROL?$AA@
	cmp	ecx, edx
	jne	SHORT $L12823
	push	OFFSET FLAT:??_C@_07ICJO@CONTROL?$AA@	; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -932+[ebp], eax
	jmp	SHORT $L12824
$L12823:
	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	movsx	edx, BYTE PTR ??_C@_07ICJO@CONTROL?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -932+[ebp], eax
$L12824:
	cmp	DWORD PTR -932+[ebp], 0
	jne	SHORT $L11176

; 10738:                   lpViewOI->lActivateControl = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+48], eax
$L11176:

; 10739: 
; 10740:                break;

	jmp	$L11166
$L11178:

; 10741: 
; 10742:             case 'E':
; 10743:                if ( zstrcmp( szWorkString, "ETAG" ) == 0 )

	movsx	eax, BYTE PTR _szWorkString$[ebp]
	movsx	ecx, BYTE PTR ??_C@_04EECP@ETAG?$AA@
	cmp	eax, ecx
	jne	SHORT $L12825
	push	OFFSET FLAT:??_C@_04EECP@ETAG?$AA@	; `string'
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -936+[ebp], eax
	jmp	SHORT $L12826
$L12825:
	movsx	eax, BYTE PTR _szWorkString$[ebp]
	movsx	ecx, BYTE PTR ??_C@_04EECP@ETAG?$AA@
	sub	eax, ecx
	xor	edx, edx
	test	eax, eax
	setle	dl
	dec	edx
	and	edx, 2
	add	edx, -1
	mov	DWORD PTR -936+[ebp], edx
$L12826:
	cmp	DWORD PTR -936+[ebp], 0
	jne	SHORT $L11185

; 10744:                   lpEntityInstance->lTag = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+46], eax

; 10745:                else

	jmp	SHORT $L11194
$L11185:

; 10746:                if ( zstrcmp( szWorkString, "EKEY" ) == 0 )

	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_04BDIB@EKEY?$AA@
	cmp	edx, eax
	jne	SHORT $L12827
	push	OFFSET FLAT:??_C@_04BDIB@EKEY?$AA@	; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -940+[ebp], eax
	jmp	SHORT $L12828
$L12827:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_04BDIB@EKEY?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -940+[ebp], ecx
$L12828:
	cmp	DWORD PTR -940+[ebp], 0
	jne	SHORT $L11194

; 10747:                   lpEntityInstance->ulKey = (zULONG) zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+50], eax
$L11194:

; 10748: 
; 10749:                break;

	jmp	$L11166
$L11197:

; 10750: 
; 10751:             case 'O':
; 10752:                if ( zstrcmp( szWorkString, "OITAG" ) == 0 )

	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_05JDHD@OITAG?$AA@
	cmp	edx, eax
	jne	SHORT $L12829
	push	OFFSET FLAT:??_C@_05JDHD@OITAG?$AA@	; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -944+[ebp], eax
	jmp	SHORT $L12830
$L12829:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_05JDHD@OITAG?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -944+[ebp], ecx
$L12830:
	cmp	DWORD PTR -944+[ebp], 0
	jne	SHORT $L11204

; 10753:                   lpViewOI->lTag = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 10754:                else

	jmp	$L11217
$L11204:

; 10755:                if ( zstrcmp( szWorkString, "OIFLAGS" ) == 0 )

	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_07IFBG@OIFLAGS?$AA@
	cmp	edx, eax
	jne	SHORT $L12831
	push	OFFSET FLAT:??_C@_07IFBG@OIFLAGS?$AA@	; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -948+[ebp], eax
	jmp	SHORT $L12832
$L12831:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_07IFBG@OIFLAGS?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -948+[ebp], ecx
$L12832:
	cmp	DWORD PTR -948+[ebp], 0
	jne	SHORT $L11217

; 10757:                   zULONG uFlags = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _uFlags$11215[ebp], eax

; 10758: 
; 10759:                   // If zOI_ISLOCKED flag is set then the OI has pessimistic
; 10760:                   // locks set.
; 10761:                   if ( uFlags & zOI_ISLOCKED )

	mov	eax, DWORD PTR _uFlags$11215[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L11216

; 10762:                      lpViewOI->bIsLocked = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L11216:

; 10763: 
; 10764:                   if ( uFlags & zOI_READONLY )

	mov	ecx, DWORD PTR _uFlags$11215[ebp]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L11217

; 10765:                      lpView->bReadOnly = TRUE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 64					; 00000040H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax
$L11217:
$L11166:

; 10771:       else

	jmp	$L11491
$L11164:

; 10772:       if ( pchLine[ 0 ] == 'e' )  // Entity type

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 101				; 00000065H
	jne	$L11219

; 10774:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_SysParseLine@12

; 10775:          if ( *plControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L11220

; 10776:             nLevel = (zSHORT) zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nLevel$[ebp], ax

; 10777:          else

	jmp	SHORT $L11222
$L11220:

; 10778:             nLevel = (zSHORT) zatol( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nLevel$[ebp], ax
$L11222:

; 10779: 
; 10780:          if ( *plControl & zINCREMENTAL )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $L11230
$L11226:

; 10782:             while ( pchLine[ 0 ] != ',' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $L11227

; 10783:                pchLine++;

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLine$[ebp], eax
	jmp	SHORT $L11226
$L11227:

; 10784: 
; 10785:             pchLine++;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLine$[ebp], ecx

; 10786:             lPrevIndicators = lIndicators;

	mov	edx, DWORD PTR _lIndicators$[ebp]
	mov	DWORD PTR _lPrevIndicators$[ebp], edx

; 10787: 
; 10788:             if ( *plControl & zCOMPRESSED )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L11228

; 10789:                lIndicators = (zLONG) zxtob( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lIndicators$[ebp], eax

; 10790:             else

	jmp	SHORT $L11230
$L11228:

; 10791:                lIndicators = (zLONG) zatob( pchLine ); /* HH, 14.10.96 */

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lIndicators$[ebp], eax
$L11230:

; 10796:             zSHORT nHierNbr;
; 10797: 
; 10798:             lpViewEntity    = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10799:             lpViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 10800: 
; 10801:             // If the root cursor is not the first cursor, skip ViewEntities
; 10802:             // until we get to the entity matching the root cursor
; 10803:             if ( lpViewEntityCsr != zGETPTR( lpViewCsr->hFirstOD_EntityCsr ) )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpViewEntityCsr$[ebp], eax
	je	SHORT $L11244

; 10805:                LPVIEWENTITYCSR lpSearchViewEntityCsr;
; 10806: 
; 10807:                lpSearchViewEntityCsr =
; 10808:                                     zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntityCsr$11240[ebp], eax
$L11243:

; 10809: 
; 10810:                while ( lpSearchViewEntityCsr != lpViewEntityCsr )

	mov	eax, DWORD PTR _lpSearchViewEntityCsr$11240[ebp]
	cmp	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	je	SHORT $L11244

; 10812:                   lpViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10813:                   lpSearchViewEntityCsr++;

	mov	eax, DWORD PTR _lpSearchViewEntityCsr$11240[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpSearchViewEntityCsr$11240[ebp], eax

; 10814:                }

	jmp	SHORT $L11243
$L11244:

; 10816: 
; 10817:             if ( *plControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L11246

; 10818:                nHierNbr = (zSHORT) zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nHierNbr$11235[ebp], ax
$L11246:

; 10819: 
; 10820:             while ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	$L11250

; 10822:                if ( *plControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L11251

; 10824:                   if ( lpViewEntity->nHierNbr == nHierNbr )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	movsx	edx, WORD PTR _nHierNbr$11235[ebp]
	cmp	ecx, edx
	jne	SHORT $L11252

; 10825:                      break;

	jmp	$L11250
$L11252:

; 10827:                else

	jmp	SHORT $L11260
$L11251:

; 10828:                if ( zstrcmp( lpViewEntity->szName, szWorkString ) == 0 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	cmp	ecx, edx
	jne	SHORT $L12833
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -952+[ebp], eax
	jmp	SHORT $L12834
$L12833:
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, BYTE PTR [edx+14]
	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	sub	eax, ecx
	xor	edx, edx
	test	eax, eax
	setle	dl
	dec	edx
	and	edx, 2
	add	edx, -1
	mov	DWORD PTR -952+[ebp], edx
$L12834:
	cmp	DWORD PTR -952+[ebp], 0
	jne	SHORT $L11260

; 10829:                   break;

	jmp	SHORT $L11250
$L11260:

; 10830: 
; 10831:                lpViewEntity    = zGETPTR( lpViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10832:                lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 10833:             }

	jmp	$L11246
$L11250:

; 10834: 
; 10835:             if ( lpViewEntityCsr == 0 )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	jne	SHORT $L11263

; 10837:                // OK, No cursor was found in the current view, if there are
; 10838:                // outstanding subobjects, do a reset and try again to find
; 10839:                // the entity
; 10840:                if ( lpViewCsr->hFirstViewSubobject )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $L11264

; 10841:                   fnResetViewFromSubobject( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 10842:                else

	jmp	SHORT $L11265
$L11264:

; 10844:                   lpViewEntity = 0;

	mov	DWORD PTR _lpViewEntity$[ebp], 0

; 10845:                   break;  // Ouch, Entity does not exist, give up

	jmp	$L11234
$L11265:

; 10848:             else

	jmp	$L11274
$L11263:

; 10850:                // We've found a cursor which matches the entity type
; 10851:                // now check to see if a SetViewToSubobject or a reset is
; 10852:                // needed to create the entity at the appropriate level
; 10853:                if ( lpViewEntityCsr->nLevel == nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jne	SHORT $L11267

; 10855:                   break;

	jmp	$L11234
$L11267:

; 10857:                else
; 10858:                if ( lpViewEntityCsr->nLevel > nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $L11269

; 10860:                   if ( lpViewCsr->hFirstViewSubobject == 0 )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [eax+30], 0
	jne	SHORT $L11270

; 10861:                      break;

	jmp	SHORT $L11234
$L11270:

; 10862: 
; 10863:                   while ( lpViewEntityCsr->nLevel > nLevel &&
; 10864:                           lpViewCsr->hFirstViewSubobject )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	edx, eax
	jle	SHORT $L11273
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $L11273

; 10866:                      fnResetViewFromSubobject( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 10867:                   }

	jmp	SHORT $L11270
$L11273:

; 10869:                else

	jmp	SHORT $L11274
$L11269:

; 10871:                   // The view entity csr level is < the entity level.
; 10872:                   // In this case, the current (last) instance must be the
; 10873:                   // parent of the instance we are about to create and
; 10874:                   // it must have recursive behaviour. Otherwise we will
; 10875:                   // drop out and issue a level error
; 10876:                   if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L11278

; 10878:                      LPVIEWENTITY lpWkViewEntity =
; 10879:                                  zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$11276[ebp], eax

; 10880: 
; 10881:                      if ( lpWkViewEntity->bRecursive )

	mov	edx, DWORD PTR _lpWkViewEntity$11276[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	test	eax, eax
	je	SHORT $L11278

; 10882:                         fnSetViewToSubobject( lpView, lpWkViewEntity, 0 );

	push	0
	mov	ecx, DWORD PTR _lpWkViewEntity$11276[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH
$L11278:

; 10884: 
; 10885:                   break;

	jmp	SHORT $L11234
$L11274:

; 10888:          }  // for ( ; ; )...

	jmp	$L11230
$L11234:

; 10889: 
; 10890:          bSkipAttributes = FALSE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 0

; 10891: 
; 10892:          if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $L11279

; 10894:             // Let's at least trace it out.
; 10895:             TraceLineS( "(WARNING) Couldn't find entity ", szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CA@GEOJ@?$CIWARNING?$CJ?5Couldn?8t?5find?5entity?5?$AA@ ; `string'
	call	_TraceLineS@8

; 10896:             TraceLineS( "(WARNING) in LOD ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0BC@FECF@?$CIWARNING?$CJ?5in?5LOD?5?$AA@ ; `string'
	call	_TraceLineS@8

; 10897: 
; 10898:             if ( bIgnoreEntityErrors == FALSE || nLevel == 1 )

	mov	edx, DWORD PTR _bIgnoreEntityErrors$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L11283
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	jne	SHORT $L11282
$L11283:

; 10900:                //  "KZOEE074 - Invalid Entity name on line "
; 10901:                (*lpfnStreamFunc)( lpView, lpvData, (zPPCHAR) szWorkString, 0, 74 );

	push	74					; 0000004aH
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 10902:                nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10903:                break;

	jmp	$L11150
$L11282:

; 10905: 
; 10906:             nErrorEntityLvl = nLevel;

	mov	cx, WORD PTR _nLevel$[ebp]
	mov	WORD PTR _nErrorEntityLvl$[ebp], cx

; 10907:             nErrorEntityCnt++;

	mov	dx, WORD PTR _nErrorEntityCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nErrorEntityCnt$[ebp], dx

; 10909:          else

	jmp	$L11292
$L11279:

; 10910:          if ( *plControl & zACTIVATE_ROOTONLY && nLevel > 1 )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 268435456				; 10000000H
	test	ecx, ecx
	je	SHORT $L11286
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 1
	jle	SHORT $L11286

; 10912:             // Current entity is not a root and user indicated that she only
; 10913:             // wants roots.  Set flag to indicate we want to skip setting
; 10914:             // attribute values.
; 10915:             bSkipAttributes = TRUE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 1

; 10916:             continue;

	jmp	$L11149
$L11286:

; 10918:          else
; 10919:          if ( lpViewEntityCsr->nLevel != nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	je	SHORT $L11288

; 10921:             // if the view cursor level does not equal the entity
; 10922:             // level coming in, issue an error
; 10923:             //  "KZOEE075 - Invalid Entity level on line "
; 10924:             (*lpfnStreamFunc)( lpView, lpvData, (zPPCHAR) szWorkString, 0, 75 );

	push	75					; 0000004bH
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 10925:             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10926:             break;

	jmp	$L11150
$L11288:

; 10930:             if ( nLevel == 1 && lpViewEntityCsr->hEntityInstance &&
; 10931:                  lpViewOI->bMultipleRootLevels == FALSE )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	jne	SHORT $L11291
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $L11291
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11291

; 10933:                // Doing this stuff means that there are multiple level 1
; 10934:                // roots in the the file, but that the user has requested
; 10935:                // activation of the the instance with zSINGLE rather than
; 10936:                // zMULTIPLE.  We will act like the EOF condition has
; 10937:                // occurred and set return code to indicate that we found
; 10938:                // multiple roots.
; 10939:                nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1

; 10940:                bSkipAttributes = TRUE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 1

; 10941:                continue;

	jmp	$L11149
$L11291:

; 10945:                nRC = fnCreateEntity( lpView, lpViewEntity,
; 10946:                                      lpViewEntityCsr, zPOS_AFTER, 0 );

	push	0
	push	3
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 10947:                if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L11294

; 10948:                   break;

	jmp	$L11150
$L11294:

; 10949: 
; 10950:                nErrorEntityLvl = 0;

	mov	WORD PTR _nErrorEntityLvl$[ebp], 0
$L11292:

; 10953: 
; 10954:          // The current entity is compressed if:
; 10955:          // o  The portable file is stored in compressed format.
; 10956:          // o  The max size of all the attributes for the entity is smaller
; 10957:          //    then the buffer we set up to hold all the attribute values.
; 10958:          bEntityIsCompressed = (*plControl & zCOMPRESSED) &&
; 10959:                                (lpViewEntity->ulMaxLth < zENTITY_BUFFER_SIZE);

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L12835
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+203], 10000		; 00002710H
	jae	SHORT $L12835
	mov	DWORD PTR -956+[ebp], 1
	jmp	SHORT $L12836
$L12835:
	mov	DWORD PTR -956+[ebp], 0
$L12836:
	mov	dl, BYTE PTR -956+[ebp]
	mov	BYTE PTR _bEntityIsCompressed$[ebp], dl

; 10960: 
; 10961:          if ( nErrorEntityLvl == 0 )

	movsx	eax, WORD PTR _nErrorEntityLvl$[ebp]
	test	eax, eax
	jne	$L11295

; 10963:             // if this is not the first instance, set the indicators on
; 10964:             // the previous instance. NOTE this is done after all updates
; 10965:             // so the update flag can be reset!
; 10966:             if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L11302

; 10968:                if ( *plControl & zINCREMENTAL )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 65536				; 00010000H
	test	edx, edx
	je	$L11297

; 10970:                   lpEntityInstance->u.nIndicators = lPrevIndicators;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lPrevIndicators$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 10971:                   lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -2					; fffffffeH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 10972: 
; 10973:                   // A hack to make sure that a delete/excluded entity is
; 10974:                   // flagged as hidden.  This tries to fix a bug.
; 10975:                   if ( lpEntityInstance->u.nInd.bDeleted  ||
; 10976:                        lpEntityInstance->u.nInd.bExcluded )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11299
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L11298
$L11299:

; 10978:                      lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ch, 4
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L11298:

; 10980: 
; 10981:                   if ( lpEntityInstance->u.nInd.bCreated  ||
; 10982:                        lpEntityInstance->u.nInd.bDeleted  ||
; 10983:                        lpEntityInstance->u.nInd.bIncluded ||
; 10984:                        lpEntityInstance->u.nInd.bExcluded ||
; 10985:                        lpEntityInstance->u.nInd.bUpdated )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11301
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11301
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	jne	SHORT $L11301
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11301
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $L11300
$L11301:

; 10987:                      bOI_IsUpdated = TRUE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 1
$L11300:

; 10990:                else

	jmp	SHORT $L11302
$L11297:

; 10991:                   lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$L11302:

; 10993: 
; 10994:             // Set lpEntityInstance to instance just created.
; 10995:             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 10996:             *pRelinkBufferPtr = (zLONG) lpEntityInstance;

	mov	eax, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax], ecx

; 10997:             pRelinkBufferPtr++;

	mov	edx, DWORD PTR _pRelinkBufferPtr$[ebp]
	add	edx, 4
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], edx

; 10998:             lEntityCnt++;

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _lEntityCnt$[ebp], eax

; 10999:             lpEntityInstance->u.nInd.bCreated = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 2
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 11000:             lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	dh, -2					; fffffffeH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 11002:          else

	jmp	SHORT $L11306
$L11295:

; 11004:             *pRelinkBufferPtr = 0;

	mov	ecx, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	DWORD PTR [ecx], 0

; 11005:             pRelinkBufferPtr++;

	mov	edx, DWORD PTR _pRelinkBufferPtr$[ebp]
	add	edx, 4
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], edx

; 11006:             lEntityCnt++;

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _lEntityCnt$[ebp], eax

; 11007: 
; 11008:             // If we're ignoring errors then set the error code back to 0
; 11009:             // so that we can keep processing entities.
; 11010:             if ( bIgnoreEntityErrors )

	mov	ecx, DWORD PTR _bIgnoreEntityErrors$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L11306

; 11011:                nErrorEntityLvl = 0;

	mov	WORD PTR _nErrorEntityLvl$[ebp], 0
$L11306:

; 11014:       else

	jmp	$L11491
$L11219:

; 11015:       if ( pchLine[ 0 ] == 'a' && lpViewEntity )  // Attrib and entity exists

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jne	$L11308
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	$L11308

; 11017:          LPATTRIBFLAGS     lpAttribFlags;
; 11018:          AttribFlagsRecord AttribFlags;
; 11019: 
; 11020:          if ( bEntityIsCompressed && pchLine[ 1 ] == ' ' )

	mov	ecx, DWORD PTR _bEntityIsCompressed$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	$L11311
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 32					; 00000020H
	jne	$L11311

; 11022:             zPCHAR pchStart;
; 11023: 
; 11024:             // The entity is stored in a compressed format.  The line we just
; 11025:             // read contains an 'a' followed by the length of all the attribute
; 11026:             // data in hex.
; 11027:             ulLth = zxtol( pchLine + 2 );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 2
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ulLth$[ebp], eax

; 11028:             nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );

	push	0
	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11029:             if ( nEOF != 1 )

	movsx	eax, WORD PTR _nEOF$[ebp]
	cmp	eax, 1
	je	SHORT $L11313

; 11031:                nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11032:                break;

	jmp	$L11150
$L11313:

; 11034: 
; 11035:             pchStart = pchLine;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	mov	DWORD PTR _pchStart$11312[ebp], ecx

; 11036: 
; 11037:             // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11038:             if ( bSkipAttributes )

	mov	edx, DWORD PTR _bSkipAttributes$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L11314

; 11039:                continue;

	jmp	$L11149
$L11314:

; 11040: 
; 11041:             // pchLine should now point to a buffer containing all the
; 11042:             // attribute values.  Copy each value to the entity.
; 11043:             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 11044:                   lpViewAttrib;
; 11045:                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L11317
$L11318:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L11317:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L11319

; 11047:                if ( lpViewAttrib->szDerivedOper[ 0 ] &&
; 11048:                     lpViewAttrib->bPersist == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+213]
	test	edx, edx
	je	SHORT $L11320
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11320

; 11050:                   continue;

	jmp	SHORT $L11318
$L11320:

; 11052: 
; 11053:                if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $L11321

; 11054:                   continue;

	jmp	SHORT $L11318
$L11321:

; 11055: 
; 11056:                if ( *pchLine == 0 )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L11322

; 11058:                   // Attribute value is null.  Skip over 0.
; 11059:                   pchLine++;

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLine$[ebp], eax

; 11060: 
; 11061:                   // Make sure that a record (data stick exists).
; 11062:                   if ( (lpViewAttrib->bPersist &&
; 11063:                         lpEntityInstance->hPersistRecord == 0) ||
; 11064:                        (lpViewAttrib->bPersist == FALSE &&
; 11065:                         lpEntityInstance->hNonPersistRecord == 0) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	test	edx, edx
	je	SHORT $L11325
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+60], 0
	je	SHORT $L11324
$L11325:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	test	edx, edx
	jne	SHORT $L11326
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+64], 0
	jne	SHORT $L11326
$L11324:

; 11067:                      // Set a null value so that the record gets created.
; 11068:                      if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11069:                                                     lpViewAttrib,
; 11070:                                                     "", 0 ) != 0 )

	push	0
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11326

; 11072:                         nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11073:                         break;

	jmp	$L11319
$L11326:

; 11077:                else

	jmp	$L11327
$L11322:

; 11079:                   if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $L11328

; 11081:                      zLONG l;
; 11082: 
; 11083:                      l = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _l$11329[ebp], eax

; 11084:                      if ( fnSetAttributeFromInteger( lpView, lpViewEntityCsr,
; 11085:                                                      lpViewAttrib, l ) != 0 )

	mov	edx, DWORD PTR _l$11329[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromInteger
	add	esp, 16					; 00000010H
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11330

; 11087:                         nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11088:                         break;

	jmp	$L11319
$L11330:

; 11091:                   else

	jmp	SHORT $L11332
$L11328:

; 11093:                      if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11094:                                                     lpViewAttrib,
; 11095:                                                     pchLine, 0 ) != 0 )

	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L11332

; 11097:                         nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11098:                         break;

	jmp	SHORT $L11319
$L11332:

; 11101: 
; 11102:                   pchLine += zstrlen( pchLine ) + 1;

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchLine$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchLine$[ebp], edx
$L11327:

; 11104: 
; 11105:                // Now set the attribute flags.
; 11106:                if ( (*plControl & zINCREMENTAL) &&
; 11107:                     (*plControl & zATTRIBFLAGS) )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 65536				; 00010000H
	test	ecx, ecx
	je	SHORT $L11333
	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	SHORT $L11333

; 11109:                   lpAttribFlags = fnGetAttribFlagsPtr( lpEntityInstance,
; 11110:                                                        lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$11309[ebp], eax

; 11111:                   lpAttribFlags->u.uFlags = zxtob( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpAttribFlags$11309[ebp]
	mov	DWORD PTR [ecx], eax

; 11112: 
; 11113:                   pchLine += zstrlen( pchLine ) + 1;

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchLine$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchLine$[ebp], edx
$L11333:

; 11115:             }

	jmp	$L11318
$L11319:

; 11116: 
; 11117:             if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L11334

; 11118:                break;

	jmp	$L11150
$L11334:

; 11119: 
; 11120:             // Continue with the next line in the file.
; 11121:             continue;

	jmp	$L11149
$L11311:

; 11124: 
; 11125:          // If we get here, then bEntityIsCompressed is FALSE.  But it's still
; 11126:          // possible that the OI is stored in a compressed format--it's just
; 11127:          // that the attributes couldn't be squeezed into one line.  If the OI
; 11128:          // is compressed, then the attribute names are stored as the XVA
; 11129:          // tokens instead of the names.
; 11130: 
; 11131:          // First get the attribute name/number into szWorkString.  The end of
; 11132:          // the name/number is indicated when we find a space or comma.
; 11133:          for ( k = 0, pchLine++;
; 11134:                pchLine[ k ] && pchLine[ k ] != ' ' && pchLine[ k ] != ',';
; 11135:                k++ )

	mov	DWORD PTR _k$[ebp], 0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLine$[ebp], ecx
	jmp	SHORT $L11335
$L11336:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$L11335:
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L11337
	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $L11337
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $L11337

; 11137:             szWorkString[ k ] = pchLine[ k ];

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR _szWorkString$[ebp+ecx], dl

; 11138:          }

	jmp	SHORT $L11336
$L11337:

; 11139: 
; 11140:          // Terminate szWorkString.
; 11141:          szWorkString[ k ] = 0;

	mov	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 0

; 11142: 
; 11143:          // If the next char in the line is a comma then we also need to
; 11144:          // retrieve the attribute flags.
; 11145:          if ( pchLine[ k ] == ',' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	jne	$L11338

; 11147:             zCHAR  szAttribFlags[ 12 ];
; 11148:             zSHORT j;
; 11149: 
; 11150:             k++;  // Skip over the ','.

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 11151:             j = 0;

	mov	WORD PTR _j$11340[ebp], 0
$L11342:

; 11152:             while ( pchLine[ k ] && pchLine[ k ] != ' ' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L11343
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $L11343

; 11153:                szAttribFlags[ j++ ] = pchLine[ k++ ];

	movsx	edx, WORD PTR _j$11340[ebp]
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szAttribFlags$11339[ebp+edx], cl
	mov	dx, WORD PTR _j$11340[ebp]
	add	dx, 1
	mov	WORD PTR _j$11340[ebp], dx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $L11342
$L11343:

; 11154: 
; 11155:             szAttribFlags[ j ] = 0;

	movsx	ecx, WORD PTR _j$11340[ebp]
	mov	BYTE PTR _szAttribFlags$11339[ebp+ecx], 0

; 11156: 
; 11157:             AttribFlags.u.uFlags = zxtob( szAttribFlags );

	push	16					; 00000010H
	push	0
	lea	edx, DWORD PTR _szAttribFlags$11339[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _AttribFlags$11310[ebp], eax

; 11159:          else

	jmp	SHORT $L11345
$L11338:

; 11161:             // If flags aren't specified then they are assumed 0 *unless* this
; 11162:             // OI wasn't stored with attrib flags (this means it was stored
; 11163:             // with a pre-10a version).  In this case we have to assume that
; 11164:             // every attribute has been changed.
; 11165:             AttribFlags.u.uFlags = 0; // Turn off all flags.

	mov	DWORD PTR _AttribFlags$11310[ebp], 0

; 11166:             if ( (*plControl & zATTRIBFLAGS ) == 0 )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 33554432				; 02000000H
	test	ecx, ecx
	jne	SHORT $L11345

; 11168:                // No attrib flags--turn on 'changed' bit.
; 11169:                AttribFlags.u.bFlags.bUpdated = TRUE;

	mov	edx, DWORD PTR _AttribFlags$11310[ebp]
	or	edx, 2
	mov	DWORD PTR _AttribFlags$11310[ebp], edx
$L11345:

; 11172: 
; 11173:          if ( *plControl & zCOMPRESSED )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L11346

; 11175:             zLONG lXVATok;
; 11176: 
; 11177:             // Point pchLine to first char of attribute value if there is
; 11178:             // more info after the attribute name.
; 11179:             if ( pchLine[ k ] )

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L11348

; 11180:                pchLine += k + 1;

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pchLine$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _pchLine$[ebp], eax
$L11348:

; 11181: 
; 11182:             lXVATok = zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lXVATok$11347[ebp], eax

; 11183: 
; 11184:             // Look for the attribute that matches the XVA token.
; 11185:             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 11186:                   lpViewAttrib && lpViewAttrib->lXVAAttTok != lXVATok;
; 11187:                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L11351
$L11352:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L11351:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L11353
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+181]
	cmp	ecx, DWORD PTR _lXVATok$11347[ebp]
	je	SHORT $L11353

; 11189:                // nothing needs to be done here
; 11190:             }

	jmp	SHORT $L11352
$L11353:

; 11192:          else

	jmp	SHORT $L11362
$L11346:

; 11194:             // Point pchLine to first char of attribute value if there is
; 11195:             // more info after the attribute name.
; 11196: 
; 11197:             // Skip over any blanks that filled out the name.
; 11198:             if ( pchLine[ k ] )

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L11357

; 11200:                if ( k < 9 )

	cmp	DWORD PTR _k$[ebp], 9
	jge	SHORT $L11356

; 11201:                   pchLine += 10;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _pchLine$[ebp], ecx

; 11202:                else

	jmp	SHORT $L11357
$L11356:

; 11203:                   pchLine += k + 1;

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pchLine$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	mov	DWORD PTR _pchLine$[ebp], ecx
$L11357:

; 11205: 
; 11206:             // Look for the attribute that matches the attribute name.
; 11207:             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 11208:                   lpViewAttrib;
; 11209:                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L11360
$L11361:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L11360:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L11362

; 11211:                if ( zstrcmpi( lpViewAttrib->szName, szWorkString ) == 0 )

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L11363

; 11212:                   break;

	jmp	SHORT $L11362
$L11363:

; 11213:             }

	jmp	SHORT $L11361
$L11362:

; 11215: 
; 11216:          // If entity not found return error.
; 11217:          if ( lpViewAttrib == 0 )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $L11364

; 11219:             if ( bIgnoreAttribErrors == FALSE )

	mov	edx, DWORD PTR _bIgnoreAttribErrors$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L11365

; 11221:                zCHAR sz[ 400 ];
; 11222: 
; 11223:                zstrcpy( sz, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _sz$11366[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 11224:                zstrcat( sz, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	edx, DWORD PTR _sz$11366[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 11225:                zstrcat( sz, szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz$11366[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 11226: 
; 11227:                //  "KZOEE104 - Invalid Attribute name for Entity"
; 11228:                (*lpfnStreamFunc)( lpView, lpvData, (zPPCHAR) sz, 0, 104 );

	push	104					; 00000068H
	push	0
	lea	edx, DWORD PTR _sz$11366[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
$L11365:

; 11235: 
; 11236:             nErrorAttribCnt++;

	mov	dx, WORD PTR _nErrorAttribCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nErrorAttribCnt$[ebp], dx

; 11238:          else

	jmp	$L11406
$L11364:

; 11239:          if ( lpViewAttrib->cType == zTYPE_BLOB ||
; 11240:               (lpViewAttrib->cType == zTYPE_STRING &&
; 11241:                *pchLine == zSTRING_STORED_AS_BLOB) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	je	SHORT $L11371
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	$L11370
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 31					; 0000001fH
	jne	$L11370
$L11371:

; 11243:             // If a string is stored with special characters (e.g. '\n') then
; 11244:             // is is stored as a blob.  This is indicated if the first char
; 11245:             // in pchLine is zSTRING_STORED_AS_BLOB.
; 11246:             if ( lpViewAttrib->cType == zTYPE_STRING &&
; 11247:                  *pchLine == zSTRING_STORED_AS_BLOB )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $L11372
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 31					; 0000001fH
	jne	SHORT $L11372

; 11249:                pchLine++;  // Point pchLine past zSTRING_STORED_AS_BLOB.

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLine$[ebp], ecx

; 11250:                ulLth = zatol( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 11251:                if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $L11373

; 11252:                   nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );

	push	0
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$L11373:

; 11254:             else // must be blob, so need to check for encoding

	jmp	$L11393
$L11372:

; 11256:                ulLthDecoded = 0;

	mov	DWORD PTR _ulLthDecoded$[ebp], 0

; 11257:                if ( *pchLine == zBLOB_STORED_ENCODED )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 85					; 00000055H
	jne	$L11375

; 11259:                   pchLine++;  // point pchLine past zBLOB_STORED_ENCODED

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLine$[ebp], eax

; 11260:                   ulLth = zatol( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 11261:                   if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	$L11390

; 11263:                      // If are ignoring attributes, just skip the encoded lines.
; 11264:                      if ( bSkipAttributes )

	mov	edx, DWORD PTR _bSkipAttributes$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L11377

; 11266:                         nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$L11379:

; 11267:                         while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L11380

; 11269:                            if ( *pchLine == 0x60 )  // terminating "`" line

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 96					; 00000060H
	jne	SHORT $L11381

; 11270:                               break;

	jmp	SHORT $L11380
$L11381:

; 11271: 
; 11272:                            nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11273:                         }

	jmp	SHORT $L11379
$L11380:

; 11275:                      else

	jmp	$L11390
$L11377:

; 11277:                         // Init the blob attribute to have a buffer for decoding.
; 11278:                         if ( fnSetAttributeFromBlob( lpView, lpViewEntityCsr,
; 11279:                                                      lpViewAttrib,
; 11280:                                                      0, ulLth ) != 0 )

	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11383

; 11282:                            nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11283:                            break;

	jmp	$L11150
$L11383:

; 11285: 
; 11286:                         fnGetAddrForAttribute( &pchAttr, lpView, lpViewEntityCsr, 0,
; 11287:                                                lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchAttr$[ebp]
	push	edx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 11288: 
; 11289:                         // Now decode the blob lines until the 'zero length' line is found.
; 11290:                         uPos = 0;

	mov	DWORD PTR _uPos$[ebp], 0

; 11291:                         nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$L11385:

; 11292:                         while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L11386

; 11294:                            nRC = UUDECODE_NextLineToBuffer( pchLine, pchAttr, ulLth, &uPos );

	lea	ecx, DWORD PTR _uPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchAttr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_UUDECODE_NextLineToBuffer@16
	mov	WORD PTR _nRC$[ebp], ax

; 11295:                            //TraceLineS( "Decoded Line: ", pchLine);
; 11296:                            if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L11387

; 11298:                               TraceLineI( "Error from UUDECODE_NextLineToBuffer: ", nRC );

	movsx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CH@HIC@Error?5from?5UUDECODE_NextLineToBu@ ; `string'
	call	_TraceLineI@8

; 11299:                               nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11300:                               break;

	jmp	SHORT $L11386
$L11387:

; 11302: 
; 11303:                            if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L11389

; 11304:                               break;

	jmp	SHORT $L11386
$L11389:

; 11305: 
; 11306:                            ulLthDecoded = ulLthDecoded + nRC;

	movsx	edx, WORD PTR _nRC$[ebp]
	mov	eax, DWORD PTR _ulLthDecoded$[ebp]
	add	eax, edx
	mov	DWORD PTR _ulLthDecoded$[ebp], eax

; 11307:                            nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11308:                         }

	jmp	SHORT $L11385
$L11386:

; 11309: 
; 11310:                         if ( ulLthDecoded != ulLth )

	mov	ecx, DWORD PTR _ulLthDecoded$[ebp]
	cmp	ecx, DWORD PTR _ulLth$[ebp]
	je	SHORT $L11390

; 11312:                            TraceLineI( "UUDECODE length invalid: ", ulLthDecoded );

	mov	edx, DWORD PTR _ulLthDecoded$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BK@FNGM@UUDECODE?5length?5invalid?3?5?$AA@ ; `string'
	call	_TraceLineI@8

; 11313:                            nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11314:                            break;

	jmp	$L11150
$L11390:

; 11319:                else

	jmp	SHORT $L11393
$L11375:

; 11321:                   ulLth = zatol( pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 11322:                   if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $L11393

; 11323:                      nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );

	push	0
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$L11393:

; 11326: 
; 11327:          // ulLth = zatol( pchLine );
; 11328:             if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	$L11394

; 11330:             // nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );
; 11331:                if ( nEOF != 1 )

	movsx	edx, WORD PTR _nEOF$[ebp]
	cmp	edx, 1
	je	SHORT $L11395

; 11333:                   nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11334:                   break;

	jmp	$L11150
$L11395:

; 11336: 
; 11337:                lLineCount++;

	mov	eax, DWORD PTR _lLineCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _lLineCount$[ebp], eax

; 11338: 
; 11339:                // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11340:                if ( bSkipAttributes )

	mov	ecx, DWORD PTR _bSkipAttributes$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L11396

; 11341:                   continue;

	jmp	$L11149
$L11396:

; 11342: 
; 11343:                if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $L11397

; 11345:                   if ( ulLthDecoded > 0 )

	cmp	DWORD PTR _ulLthDecoded$[ebp], 0
	jbe	SHORT $L11398

; 11349:                   else

	jmp	SHORT $L11400
$L11398:

; 11351:                      if ( fnSetAttributeFromBlob( lpView, lpViewEntityCsr,
; 11352:                                                   lpViewAttrib,
; 11353:                                                   pchLine, ulLth ) != 0 )

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11400

; 11355:                         nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11356:                         break;

	jmp	$L11150
$L11400:

; 11360:                else

	jmp	SHORT $L11402
$L11397:

; 11362:                   // PAS 03-09-2001 - x00 is no longer put at the end of
; 11363:                   //                  a string that was stored as a BLOB
; 11364:                   //                  (with length), so always terminate
; 11365:                   pchLine[ ulLth - 1 ] = 0;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [ecx-1], 0

; 11366:                   if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11367:                                                  lpViewAttrib,
; 11368:                                                  pchLine, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11402

; 11370:                      nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11371:                      break;

	jmp	$L11150
$L11402:

; 11375:             else

	jmp	SHORT $L11404
$L11394:

; 11376:                // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11377:                if ( bSkipAttributes )

	mov	ecx, DWORD PTR _bSkipAttributes$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L11404

; 11378:                   continue;

	jmp	$L11149
$L11404:

; 11379: 
; 11380:             // Now set the attribute flags.
; 11381:             lpAttribFlags = fnGetAttribFlagsPtr( zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 11382:                                                  lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$11309[ebp], eax

; 11383:             lpAttribFlags->u.uFlags = AttribFlags.u.uFlags;

	mov	edx, DWORD PTR _lpAttribFlags$11309[ebp]
	mov	eax, DWORD PTR _AttribFlags$11310[ebp]
	mov	DWORD PTR [edx], eax

; 11385:          else

	jmp	$L11406
$L11370:

; 11387:             // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11388:             if ( bSkipAttributes )

	mov	ecx, DWORD PTR _bSkipAttributes$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L11407

; 11389:                continue;

	jmp	$L11149
$L11407:

; 11390: 
; 11391:             if ( *plControl & zCOMPRESSED &&
; 11392:                  lpViewAttrib->cType == zTYPE_INTEGER )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	$L11408
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 76					; 0000004cH
	jne	$L11408

; 11394:                zLONG  l;
; 11395: 
; 11396:                if ( *pchLine == '*' )

	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $L11410

; 11398:                   // Integer attribute is NULL.
; 11399:                   fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11400:                                             lpViewAttrib, "", 0 );

	push	0
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H

; 11402:                else

	jmp	SHORT $L11414
$L11410:

; 11404:                   if ( *pchLine == '-' )

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $L11412

; 11405:                      l = zxtol( pchLine + 1 ) * -1;

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	imul	eax, -1
	mov	DWORD PTR _l$11409[ebp], eax

; 11406:                   else

	jmp	SHORT $L11413
$L11412:

; 11407:                      l = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _l$11409[ebp], eax
$L11413:

; 11408: 
; 11409:                   if ( fnSetAttributeFromInteger( lpView, lpViewEntityCsr,
; 11410:                                                   lpViewAttrib, l ) != 0 )

	mov	eax, DWORD PTR _l$11409[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromInteger
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11414

; 11412:                      nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11413:                      break;

	jmp	$L11150
$L11414:

; 11417:             else

	jmp	SHORT $L11416
$L11408:

; 11419:                if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11420:                                               lpViewAttrib, pchLine, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11416

; 11422:                   nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11423:                   break;

	jmp	$L11150
$L11416:

; 11426: 
; 11427:             // Now set the attribute flags.
; 11428:             lpAttribFlags = fnGetAttribFlagsPtr( zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 11429:                                                  lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$11309[ebp], eax

; 11430:             lpAttribFlags->u.uFlags = AttribFlags.u.uFlags;

	mov	ecx, DWORD PTR _lpAttribFlags$11309[ebp]
	mov	edx, DWORD PTR _AttribFlags$11310[ebp]
	mov	DWORD PTR [ecx], edx
$L11406:

; 11432: 
; 11433:          nRC = 0;  // Everything OK so far...

	mov	WORD PTR _nRC$[ebp], 0

; 11436:       else

	jmp	$L11491
$L11308:

; 11437:       if ( pchLine[ 0 ] == 'i' )

	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 105				; 00000069H
	jne	$L11419

; 11439:          zLONG  lLinkTgt;
; 11440:          zLONG  lLinkSrc;
; 11441: 
; 11442:          // If we are reading root only then don't bother with the link cards.
; 11443:          if ( *plControl & zACTIVATE_ROOTONLY )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $L11422

; 11444:             continue;

	jmp	$L11149
$L11422:

; 11445: 
; 11446:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_SysParseLine@12

; 11447:          if ( *plControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L11423

; 11449:             lLinkTgt = zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lLinkTgt$11420[ebp], eax

; 11450:             lLinkSrc = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lLinkSrc$11421[ebp], eax

; 11452:          else

	jmp	SHORT $L11424
$L11423:

; 11454:             lLinkTgt = zatol( szWorkString );

	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lLinkTgt$11420[ebp], eax

; 11455:             lLinkSrc = zatol( pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lLinkSrc$11421[ebp], eax
$L11424:

; 11457: 
; 11458:          k = lLinkSrc / 160000;  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lLinkSrc$11421[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	DWORD PTR _k$[ebp], eax

; 11459:          lpSrcInstance = (LPENTITYINSTANCE) *(pRelinkBufferTable[ k ] +
; 11460:                                                      lLinkSrc % 160000);  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lLinkSrc$11421[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pRelinkBufferTable$[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _lpSrcInstance$[ebp], edx

; 11461:          k = lLinkTgt / 160000;  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lLinkTgt$11420[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	DWORD PTR _k$[ebp], eax

; 11462:          lpTgtInstance = (LPENTITYINSTANCE) *(pRelinkBufferTable[ k ] +
; 11463:                                                      lLinkTgt % 160000);  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lLinkTgt$11420[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pRelinkBufferTable$[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _lpTgtInstance$[ebp], edx

; 11464: 
; 11465:          if ( lpTgtInstance && lpSrcInstance )

	cmp	DWORD PTR _lpTgtInstance$[ebp], 0
	je	$L11427
	cmp	DWORD PTR _lpSrcInstance$[ebp], 0
	je	$L11427

; 11467:             LPVIEWENTITY lpTgtViewEntity;
; 11468: 
; 11469:             lpViewEntity    = zGETPTR( lpSrcInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 11470:             lpTgtViewEntity = zGETPTR( lpTgtInstance->hViewEntity );

	mov	edx, DWORD PTR _lpTgtInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewEntity$11428[ebp], eax

; 11471: 
; 11472:             if ( lpTgtViewEntity->lEREntTok != lpViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpTgtViewEntity$11428[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	je	SHORT $L11431

; 11474:                TraceLine( "(oi) Error (OD: %s) - Tgt View Entity: %s Token: %d  View Entity: %s Token = %d",
; 11475:                           lpViewOD->szName, lpTgtViewEntity->szName, lpTgtViewEntity->lEREntTok,
; 11476:                           lpViewEntity->szName, lpViewEntity->lEREntTok );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+195]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$11428[ebp]
	mov	edx, DWORD PTR [ecx+195]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntity$11428[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0FA@FOLJ@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Tgt?5View?5E@ ; `string'
	call	_TraceLine
	add	esp, 24					; 00000018H

; 11477:                if ( bMsgBox )

	mov	edx, DWORD PTR _bMsgBox$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L11433

; 11479:                   bMsgBox = FALSE;

	mov	BYTE PTR _bMsgBox$[ebp], 0

; 11480:                   SysMessageBox( lpView, szlOE_SystemError,
; 11481:                                  "ER Tokens don't match for linked entities!", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CL@DJNN@ER?5Tokens?5don?8t?5match?5for?5linked@ ; `string'
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16
$L11433:

; 11484:             else

	jmp	SHORT $L11435
$L11431:

; 11486:                lpTgtInstance->hPersistRecord = lpSrcInstance->hPersistRecord;

	mov	edx, DWORD PTR _lpTgtInstance$[ebp]
	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx

; 11487:                if ( lpSrcInstance->hNextLinked )

	mov	edx, DWORD PTR _lpSrcInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $L11436

; 11488:                   lpTgtInstance->hNextLinked = lpSrcInstance->hNextLinked;

	mov	eax, DWORD PTR _lpTgtInstance$[ebp]
	mov	ecx, DWORD PTR _lpSrcInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	mov	DWORD PTR [eax+42], edx

; 11489:                else

	jmp	SHORT $L11437
$L11436:

; 11490:                   lpTgtInstance->hNextLinked = zGETHNDL( lpSrcInstance );

	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
$L11437:

; 11491: 
; 11492:                lpSrcInstance->hNextLinked = zGETHNDL( lpTgtInstance );

	mov	edx, DWORD PTR _lpTgtInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
$L11435:

; 11495:          else

	jmp	SHORT $L11447
$L11427:

; 11497:             TraceLineS( "(oi) Failed entity linking", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BL@IKLP@?$CIoi?$CJ?5Failed?5entity?5linking?$AA@ ; `string'
	call	_TraceLineS@8

; 11498: 
; 11499:             TraceLineI( "(oi) Link Src # = ", lLinkSrc );

	mov	edx, DWORD PTR _lLinkSrc$11421[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BD@FPOB@?$CIoi?$CJ?5Link?5Src?5?$CD?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8

; 11500:             if ( lpSrcInstance )

	cmp	DWORD PTR _lpSrcInstance$[ebp], 0
	je	SHORT $L11443

; 11502:                lpViewEntity = zGETPTR( lpSrcInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 11503:                TraceLineS( "(oi) Source Entity = ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET FLAT:??_C@_0BG@GFPE@?$CIoi?$CJ?5Source?5Entity?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8
$L11443:

; 11505: 
; 11506:             TraceLineI( "(oi) Link Tgt # = ", lLinkTgt );

	mov	eax, DWORD PTR _lLinkTgt$11420[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BD@GIND@?$CIoi?$CJ?5Link?5Tgt?5?$CD?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8

; 11507:             if ( lpTgtInstance )

	cmp	DWORD PTR _lpTgtInstance$[ebp], 0
	je	SHORT $L11447

; 11509:                lpViewEntity = zGETPTR( lpTgtInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpTgtInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 11510:                TraceLineS( "(oi) Target Entity = ", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET FLAT:??_C@_0BG@FHME@?$CIoi?$CJ?5Target?5Entity?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8
$L11447:

; 11515:       else

	jmp	$L11491
$L11419:

; 11516:       if ( pchLine[ 0 ] == 'c' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 99					; 00000063H
	jne	$L11451

; 11518:          zSHORT nHierNbr;
; 11519:          zLONG  l;
; 11520: 
; 11521:          // First make sure that the last created entity instance has it's
; 11522:          // indicators set.
; 11523:          if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L11454

; 11525:             if ( *plControl & zINCREMENTAL )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 65536				; 00010000H
	test	ecx, ecx
	je	$L11455

; 11527:                lpEntityInstance->u.nIndicators = lIndicators;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lIndicators$[ebp]
	mov	DWORD PTR [edx+6], eax

; 11528:                lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	dh, -2					; fffffffeH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 11529: 
; 11530:                // A hack to make sure that a delete/excluded entity is
; 11531:                // flagged as hidden.  This tries to fix a bug.
; 11532:                if ( lpEntityInstance->u.nInd.bDeleted  ||
; 11533:                     lpEntityInstance->u.nInd.bExcluded )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L11457
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L11456
$L11457:

; 11535:                   lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 4
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L11456:

; 11537: 
; 11538:                if ( lpEntityInstance->u.nInd.bCreated  ||
; 11539:                     lpEntityInstance->u.nInd.bDeleted  ||
; 11540:                     lpEntityInstance->u.nInd.bIncluded ||
; 11541:                     lpEntityInstance->u.nInd.bExcluded ||
; 11542:                     lpEntityInstance->u.nInd.bUpdated )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11459
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L11459
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11459
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11459
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 2
	and	edx, 1
	test	edx, edx
	je	SHORT $L11458
$L11459:

; 11544:                   bOI_IsUpdated = TRUE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 1
$L11458:

; 11547:             else

	jmp	SHORT $L11460
$L11455:

; 11548:                lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L11460:

; 11549: 
; 11550:             // Set lpEntityInstance to 0 to indicate that the indicators for
; 11551:             // the last entity instance has been set.
; 11552:             lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0
$L11454:

; 11554: 
; 11555:          // Cursor positions are saved in cursor records.  A cursor record
; 11556:          // looks like:
; 11557:          //    cEnt-hier-nbr, absolute-instance-count
; 11558:          // For example, the cursor record for the root might look like:
; 11559:          //    c1, 1
; 11560:          // Numbers are stored in hex format.
; 11561: 
; 11562:          // If lInstanceCount is 0, then we need to set up some stuff.
; 11563:          if ( lInstanceCount == 0 )

	cmp	DWORD PTR _lInstanceCount$[ebp], 0
	jne	$L11461

; 11565:             LPVIEWCSR lpFirstViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewCsr$11462[ebp], eax

; 11566: 
; 11567:             // Indicate that cursor positions have been loaded.
; 11568:             *plControl = *plControl | zSAVE_CURSORS;

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 262144				; 00040000H
	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	DWORD PTR [ecx], eax

; 11569: 
; 11570:             // Initialize all entity cursors to be NULL.
; 11571:             for ( lpViewEntityCsr = zGETPTR( lpFirstViewCsr->hFirstOD_EntityCsr );
; 11572:                   lpViewEntityCsr;
; 11573:                   lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier ) )

	mov	edx, DWORD PTR _lpFirstViewCsr$11462[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
	jmp	SHORT $L11466
$L11467:
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
$L11466:
	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $L11468

; 11575:                lpViewEntityCsr->hEntityInstance = 0;

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+26], 0

; 11576:             }

	jmp	SHORT $L11467
$L11468:

; 11577: 
; 11578:             lpViewEntityCsr = zGETPTR( lpFirstViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpFirstViewCsr$11462[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 11579:             lpCursorEI      = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCursorEI$[ebp], eax

; 11580:             lInstanceCount  = 1;

	mov	DWORD PTR _lInstanceCount$[ebp], 1
$L11461:

; 11582: 
; 11583:          // Get entity hier number and absolute instance position from record.
; 11584:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 1
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_SysParseLine@12

; 11585:          nHierNbr = (zSHORT) zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nHierNbr$11452[ebp], ax

; 11586:          l = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _l$11453[ebp], eax
$L11473:

; 11587: 
; 11588:          // Entity cursors that are NULL do not have a cursor record.  If the
; 11589:          // hier nbr read from the record is greater than the "current"
; 11590:          // entity cursor, then at least one cursor is NULL.
; 11591:          while ( lpViewEntityCsr->nHierNbr < nHierNbr )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+24]
	movsx	eax, WORD PTR _nHierNbr$11452[ebp]
	cmp	edx, eax
	jge	SHORT $L11474

; 11592:             lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
	jmp	SHORT $L11473
$L11474:

; 11593: 
; 11594:          if ( l == 0 )

	cmp	DWORD PTR _l$11453[ebp], 0
	jne	SHORT $L11476

; 11596:             lpViewEntityCsr->hEntityInstance = UNSET_CSR;

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+26], 1

; 11600:          else

	jmp	SHORT $L11485
$L11476:

; 11602:             // Look for the entity instance that has the absolute position l.
; 11603:             while ( lInstanceCount < l )

	mov	ecx, DWORD PTR _lInstanceCount$[ebp]
	cmp	ecx, DWORD PTR _l$11453[ebp]
	jge	SHORT $L11481

; 11605:                lpCursorEI = zGETPTR( lpCursorEI->hNextHier );

	mov	edx, DWORD PTR _lpCursorEI$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCursorEI$[ebp], eax

; 11606:                lInstanceCount++;

	mov	ecx, DWORD PTR _lInstanceCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lInstanceCount$[ebp], ecx

; 11607:             }

	jmp	SHORT $L11476
$L11481:

; 11608: 
; 11609:             if ( lpViewEntityCsr->hViewEntity == lpCursorEI->hViewEntity )

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpCursorEI$[ebp]
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+2]
	jne	SHORT $L11483

; 11611:                lpViewEntityCsr->hEntityInstance = zGETHNDL( lpCursorEI );

	mov	edx, DWORD PTR _lpCursorEI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 11615:             else

	jmp	SHORT $L11485
$L11483:

; 11617:                LPVIEWENTITY lpWk = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk$11486[ebp], eax

; 11618: 
; 11619:                TraceLineS( "(oi) Entity type mismatch during cursor restoration"
; 11620:                            " for entity ", lpWk->szName );

	mov	ecx, DWORD PTR _lpWk$11486[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET FLAT:??_C@_0EA@MMNH@?$CIoi?$CJ?5Entity?5type?5mismatch?5during@ ; `string'
	call	_TraceLineS@8
$L11485:

; 11623: 
; 11624:          lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 11627:       else

	jmp	SHORT $L11491
$L11451:

; 11628:       if ( zstrncmp( pchLine, "ZEND", 4 ) == 0 )

	push	4
	push	OFFSET FLAT:??_C@_04JJOE@ZEND?$AA@	; `string'
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L11491

; 11630:          // "ZEND" means we got to the end of the current OI so break out
; 11631:          // of loop.
; 11632:          nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 11633:          break;

	jmp	SHORT $L11150
$L11491:

; 11635: 
; 11636:    } // while ( (nEOF = (*lpfnStreamFunc)( ... )) == 1 )

	jmp	$L11149
$L11150:

; 11637: 
; 11638:    for ( lEntityCnt = 0; pRelinkBufferTable[ lEntityCnt ]; lEntityCnt++ )

	mov	DWORD PTR _lEntityCnt$[ebp], 0
	jmp	SHORT $L11492
$L11493:
	mov	edx, DWORD PTR _lEntityCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lEntityCnt$[ebp], edx
$L11492:
	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	cmp	DWORD PTR _pRelinkBufferTable$[ebp+eax*4], 0
	je	SHORT $L11494

; 11639:       fnFreeDataspace( pRelinkBufferTable[ lEntityCnt ] );

	mov	ecx, DWORD PTR _lEntityCnt$[ebp]
	mov	edx, DWORD PTR _pRelinkBufferTable$[ebp+ecx*4]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
	jmp	SHORT $L11493
$L11494:

; 11640: 
; 11641:    if ( nEOF == zCALL_ERROR )

	movsx	eax, WORD PTR _nEOF$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L11495

; 11642:       nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H
$L11495:

; 11643: 
; 11644:    // Mark the final instance indicators after updating all of the attributes.
; 11645:    if ( nRC >= 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L11496

; 11647:       if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L11501

; 11649:          if ( *plControl & zINCREMENTAL )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $L11498

; 11651:             lpEntityInstance->u.nIndicators = lIndicators;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR _lIndicators$[ebp]
	mov	DWORD PTR [ecx+6], edx

; 11652:             lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ch, -2					; fffffffeH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 11653: 
; 11654:             if ( lpEntityInstance->u.nInd.bCreated  ||
; 11655:                  lpEntityInstance->u.nInd.bDeleted  ||
; 11656:                  lpEntityInstance->u.nInd.bIncluded ||
; 11657:                  lpEntityInstance->u.nInd.bExcluded ||
; 11658:                  lpEntityInstance->u.nInd.bUpdated )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11500
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11500
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	jne	SHORT $L11500
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11500
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $L11499
$L11500:

; 11660:                bOI_IsUpdated = TRUE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 1
$L11499:

; 11663:          else

	jmp	SHORT $L11501
$L11498:

; 11664:             lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$L11501:

; 11666: 
; 11667:       // Check if OI is updated.
; 11668:       lpViewOI->bUpdated     = bOI_IsUpdated;

	mov	ecx, DWORD PTR _bOI_IsUpdated$[ebp]
	and	ecx, 255				; 000000ffH
	and	ecx, 1
	shl	ecx, 4
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	al, -17					; ffffffefH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 11669:       lpViewOI->bUpdatedFile = FALSE;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	al, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
$L11496:

; 11671: 
; 11672:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 11673: 
; 11674: } // fnActivateOI_FromTextStream

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnActivateOI_FromTextStream ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@HFJB@?$CIoi?$CJ?5Total?5time?5for?5SfActivateOI@ ; `string'
EXTRN	__imp__strncpy:NEAR
;	COMDAT ??_C@_0CN@HFJB@?$CIoi?$CJ?5Total?5time?5for?5SfActivateOI@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CN@HFJB@?$CIoi?$CJ?5Total?5time?5for?5SfActivateOI@ DB '(oi) Total'
	DB	' time for SfActivateOI_FromStream ', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_lControl$ = 20
_lpfnStreamFunc$ = 24
_lpvData$ = 28
_lpCurrentTask$ = -52
_lpOwningTask$ = -28
_lpViewCsr$ = -4
_lpViewOI$ = -44
_lpViewOD$ = -12
_lpView$ = -20
_vOrigView$ = -36
_vQualView$ = -16
_pchLine$ = -8
_lTickCount$ = -48
_bContainsOptimisticOIs$ = -40
_nEOF$ = -32
_nRC$ = -24
_lTempControl$11571 = -56
_nSaveRC$11572 = -60
_lpRootEntityInstance$11591 = -64
_k$11596 = -72
_nState$11597 = -68
_sz$11606 = -172
_SfActivateOI_FromStream@24 PROC NEAR

; 11747: {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H

; 11748:    LPTASK            lpCurrentTask;
; 11749:    LPTASK            lpOwningTask;
; 11750:    LPVIEWCSR         lpViewCsr;
; 11751:    LPVIEWOI          lpViewOI;
; 11752:    LPVIEWOD          lpViewOD;
; 11753:    zVIEW             lpView;
; 11754:    zVIEW             vOrigView = 0;

	mov	DWORD PTR _vOrigView$[ebp], 0

; 11755:    zVIEW             vQualView = 0;

	mov	DWORD PTR _vQualView$[ebp], 0

; 11756:    zPCHAR            pchLine;
; 11757:    zLONG             lTickCount;
; 11758:    zBOOL             bContainsOptimisticOIs = FALSE;

	mov	BYTE PTR _bContainsOptimisticOIs$[ebp], 0

; 11759:    zSHORT            nEOF;
; 11760:    zSHORT            nRC;
; 11761: 
; 11762:    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L11528

; 11763:       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$L11528:

; 11764: 
; 11765:    // Init in case of error.
; 11766:    *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0

; 11767: 
; 11768:    // If task not active or disabled, return zCALL_ERROR.
; 11769:    lpCurrentTask = zGETPTR( lpAppQualView->hTask );

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 11770:    if ( lpCurrentTask == 0 )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L11530

; 11772:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11514
$L11530:

; 11774: 
; 11775:    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 12					; 0000000cH
	test	edx, edx
	je	SHORT $L11531

; 11776:       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 11777:    else

	jmp	SHORT $L11533
$L11531:

; 11778:       lpOwningTask = lpCurrentTask;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], edx
$L11533:

; 11779: 
; 11780:    if ( lControl & zACTIVATE_SYSTEM )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	je	SHORT $L11534

; 11782:       if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 11783:                                  lpAppQualView, cpcViewOD_Name, 1 )) != 0 )

	push	1
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L11535

; 11785:       // fnOperationReturn( iSfActivateSysOI_FromFile, lpCurrentTask, 0 );
; 11786:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11514
$L11535:

; 11802:    else

	jmp	SHORT $L11537
$L11534:

; 11804:       if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 11805:                                  lpAppQualView, cpcViewOD_Name, 0 )) != 0 )

	push	0
	mov	eax, DWORD PTR _cpcViewOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L11537

; 11807:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11514
$L11537:

; 11820: 
; 11821:    lpView   = *pvReturnView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpView$[ebp], eax

; 11822:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 11823: 
; 11824:    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, lpView, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 11825:    if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L11539

; 11826:       goto EndOfFunction;

	jmp	$EndOfFunction$11540
$L11539:

; 11827: 
; 11828:    //======================================================================
; 11829:    // Retrieve the first line from the stream and determine if the stream
; 11830:    // is a binary or ASCII stream.
; 11831:    //======================================================================
; 11832: 
; 11833:    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 11834:    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 11835: 
; 11836:    nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11837:    if ( nEOF == 0 || nEOF == zCALL_ERROR )

	movsx	edx, WORD PTR _nEOF$[ebp]
	test	edx, edx
	je	SHORT $L11544
	movsx	eax, WORD PTR _nEOF$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L11543
$L11544:

; 11839:       //  "KZOEE072 - Error reading instance file "
; 11840:    // fnIssueCoreError( lpCurrentTask, lpView, 16, 72, 0, szOpenFileName, 0 );
; 11841:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11514
$L11543:

; 11843: 
; 11844: #if 0    // sample header
; 11845: rZeidon    SPARDA01 TZEREMDO 03/01/96   09:03:16 1.0a
; 11846: 
; 11847:       // sample new header
; 11848: z0100-Zeidon    SPARDA01 TZEREMDO 03/01/96   09:03:16 1.0a
; 11849: z1000-Zeidon    ACCOUNT  TZWDLGSO 04/18/07   09:18:42 1.0a2
; 11850: #endif
; 11851: 
; 11852:    // DGC 10/23/96  New header style where binary, incremental, and compressed
; 11853:    // information is stored as bit-flags.
; 11854:    if ( *pchLine == 'z' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jne	$L11545

; 11856:       // New header style.
; 11857:       if ( zstrncmp( pchLine + 6, szlmZeidon, 6 ) != 0 )

	push	6
	mov	eax, DWORD PTR _szlmZeidon
	push	eax
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 6
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L11546

; 11859:          //  "KZOEE073 - Invalid instance file header in "
; 11860:       // fnIssueCoreError( lpCurrentTask, lpView, 16, 73, 0, szOpenFileName, 0 );
; 11861:          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11514
$L11546:

; 11863: 
; 11864:       // Just got the header ... set the release value from the file
; 11865:       // header into the view (object instance) release value. (dks 3/5/96)
; 11866:       if ( zstrlen( pchLine ) > 55 )

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 55					; 00000037H
	jbe	SHORT $L11547

; 11868:          zstrncpy( lpViewOI->szRelease, pchLine + 54, 8 );

	push	8
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 54					; 00000036H
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 11869:          lpViewOI->szRelease[ 8 ] = 0;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	BYTE PTR [edx+64], 0
$L11547:

; 11871: 
; 11872:       if ( pchLine[ 2 ] == '1' )

	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 49					; 00000031H
	jne	SHORT $L11548

; 11873:          lControl |= zINCREMENTAL;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 65536				; 00010000H
	mov	DWORD PTR _lControl$[ebp], edx

; 11874:       else

	jmp	SHORT $L11549
$L11548:

; 11875:          lControl &= ~zINCREMENTAL;

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, -65537				; fffeffffH
	mov	DWORD PTR _lControl$[ebp], eax
$L11549:

; 11876: 
; 11877:       if ( pchLine[ 3 ] == '1' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+3]
	cmp	edx, 49					; 00000031H
	jne	SHORT $L11550

; 11878:          lControl |= zCOMPRESSED;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 131072				; 00020000H
	mov	DWORD PTR _lControl$[ebp], eax

; 11879:       else

	jmp	SHORT $L11551
$L11550:

; 11880:          lControl &= ~zCOMPRESSED;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, -131073				; fffdffffH
	mov	DWORD PTR _lControl$[ebp], ecx
$L11551:

; 11881: 
; 11882:       if ( pchLine[ 4 ] == '1' )

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, 49					; 00000031H
	jne	SHORT $L11552

; 11883:          bContainsOptimisticOIs = TRUE;

	mov	BYTE PTR _bContainsOptimisticOIs$[ebp], 1
$L11552:

; 11884: 
; 11885:       // Attrib flags have been written if the 5th flag is set or if the OI is
; 11886:       // written in incremental/compressed form.
; 11887:       if ( pchLine[ 5 ] == '1' ||
; 11888:            ((lControl & zCOMPRESSED) && (lControl & zINCREMENTAL)) )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	cmp	edx, 49					; 00000031H
	je	SHORT $L11554
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L11553
	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 65536				; 00010000H
	test	ecx, ecx
	je	SHORT $L11553
$L11554:

; 11890:          lControl |= zATTRIBFLAGS;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 33554432				; 02000000H
	mov	DWORD PTR _lControl$[ebp], edx
$L11553:

; 11892: 
; 11893:       // This used to be the binary flag.  For now it tells us whether the
; 11894:       // ER_Date is stored with the LOD.
; 11895:       if ( pchLine[ 1 ] == '1' && (lControl & zINCREMENTAL) != 0 )

	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 49					; 00000031H
	jne	$L11562
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 65536				; 00010000H
	test	edx, edx
	je	$L11562

; 11897:          // Get the ER date.
; 11898:          (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 11899: 
; 11900:          // Check to see if the ER dates match.  We only worry about this if
; 11901:          // the OI is compressed.  If it's not compressed then we can probably
; 11902:          // handle any differences.
; 11903:          if ( (lControl & zCOMPRESSED) &&
; 11904:               pchLine[ 0 ] && lpViewOD->szER_Date[ 0 ] &&
; 11905:               zstrcmp( lpViewOD->szER_Date, pchLine ) != 0 )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	$L11562
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$L11562
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+248]
	test	ecx, ecx
	je	$L11562
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L12838
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 248				; 000000f8H
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -176+[ebp], eax
	jmp	SHORT $L12839
$L12838:
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	xor	ecx, ecx
	test	eax, eax
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -176+[ebp], ecx
$L12839:
	cmp	DWORD PTR -176+[ebp], 0
	je	SHORT $L11562

; 11907:             // "KZOEE088 - Compressed OI is out of sync with LOD/XOD"
; 11908:             fnIssueCoreError( lpCurrentTask, lpView, 16, 88, 0, lpViewOD->szName, 0 );

	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	0
	push	88					; 00000058H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 11909:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11514
$L11562:

; 11913:    else

	jmp	SHORT $L11567
$L11545:

; 11915:       // Old header style.
; 11916:       if ( zstrncmp( pchLine + 1, szlmZeidon, 6 ) )

	push	6
	mov	edx, DWORD PTR _szlmZeidon
	push	edx
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L11564

; 11918:          //  "KZOEE073 - Invalid instance file header in "
; 11919:       // fnIssueCoreError( lpCurrentTask, lpView, 16, 73, 0, szOpenFileName, 0 );
; 11920:          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11514
$L11564:

; 11922: 
; 11923:       // just got the header ... set the release value from the file
; 11924:       // header into the view (object instance) release value. (dks 3/5/96)
; 11925:       if ( zstrlen( pchLine ) > 50 )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	eax, 50					; 00000032H
	jbe	SHORT $L11565

; 11927:          zstrncpy( lpViewOI->szRelease, pchLine + 49, 8 );

	push	8
	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 49					; 00000031H
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 11928:          lpViewOI->szRelease[ 8 ] = 0;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	BYTE PTR [ecx+64], 0
$L11565:

; 11930: 
; 11931:       // Set Incremental.
; 11932:       if ( pchLine[ 0 ] == 'r' )

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 114				; 00000072H
	jne	SHORT $L11566

; 11933:          lControl |= zINCREMENTAL;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 65536				; 00010000H
	mov	DWORD PTR _lControl$[ebp], ecx

; 11934:       else

	jmp	SHORT $L11567
$L11566:

; 11935:          lControl &= ~zINCREMENTAL;

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, -65537				; fffeffffH
	mov	DWORD PTR _lControl$[ebp], edx
$L11567:

; 11937: 
; 11938:    // Set Root only indicator.
; 11939:    if ( lControl & zACTIVATE_ROOTONLY )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $L11568

; 11940:       lpViewOI->bRootOnly = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 2
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L11568:

; 11941: 
; 11942:    nRC = fnActivateOI_FromTextStream( lpView, lpfnStreamFunc,
; 11943:                                       lpvData, &lControl );

	lea	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpfnStreamFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnActivateOI_FromTextStream
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 11944:    if ( nRC < -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jge	SHORT $L11569

; 11945:       goto EndOfFunction;

	jmp	$EndOfFunction$11540
$L11569:

; 11946: 
; 11947:    // If the stream has optimistic locking information try to activate
; 11948:    // the "original view" and the qualification view.  These should appear
; 11949:    // in the stream after the main view.
; 11950:    if ( bContainsOptimisticOIs )

	mov	eax, DWORD PTR _bContainsOptimisticOIs$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L11570

; 11952:       zLONG  lTempControl;
; 11953:       zSHORT nSaveRC = nRC;

	mov	cx, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nSaveRC$11572[ebp], cx

; 11954: 
; 11955:       // lTempControl is what we use to activate the original OI and the
; 11956:       // qualification OI.  Since no OI is OK, add it to the flag.
; 11957:       lTempControl = lControl | zNOI_OKAY;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	dh, 2
	mov	DWORD PTR _lTempControl$11571[ebp], edx

; 11958: 
; 11959:       if ( lControl & zACTIVATE_SYSTEM )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	je	SHORT $L11573

; 11961:          nRC = fnDeclareView( &vOrigView, lpOwningTask,
; 11962:                               lpAppQualView, cpcViewOD_Name, 1 );

	push	1
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax

; 11964:       else

	jmp	SHORT $L11574
$L11573:

; 11966:          nRC = fnDeclareView( &vOrigView, lpOwningTask,
; 11967:                               lpAppQualView, cpcViewOD_Name, 0 );

	push	0
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
$L11574:

; 11969: 
; 11970:       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $L11575

; 11971:          goto EndOfFunction;

	jmp	$EndOfFunction$11540
$L11575:

; 11972: 
; 11973:       nRC = fnActivateEmptyObjectInstance( lpCurrentTask, vOrigView, lControl );

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 11974: 
; 11975:       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L11576

; 11976:          goto EndOfFunction;

	jmp	$EndOfFunction$11540
$L11576:

; 11977: 
; 11978:       nRC = fnActivateOI_FromTextStream( vOrigView, lpfnStreamFunc,
; 11979:                                          lpvData, &lTempControl );

	lea	edx, DWORD PTR _lTempControl$11571[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpfnStreamFunc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	call	_fnActivateOI_FromTextStream
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 11980: 
; 11981:       if ( nRC < -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jge	SHORT $L11577

; 11982:          goto EndOfFunction;

	jmp	$EndOfFunction$11540
$L11577:

; 11983: 
; 11984:       nRC = fnDeclareView( &vQualView, lpOwningTask,
; 11985:                            lpAppQualView, "KZDBHQUA", 1 );

	push	1
	push	OFFSET FLAT:??_C@_08ILBJ@KZDBHQUA?$AA@	; `string'
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _vQualView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax

; 11986: 
; 11987:       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L11578

; 11988:          goto EndOfFunction;

	jmp	$EndOfFunction$11540
$L11578:

; 11989: 
; 11990:       nRC = fnActivateEmptyObjectInstance( lpCurrentTask, vQualView, lControl );

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 11991: 
; 11992:       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L11579

; 11993:          goto EndOfFunction;

	jmp	$EndOfFunction$11540
$L11579:

; 11994: 
; 11995:       nRC = fnActivateOI_FromTextStream( vQualView, lpfnStreamFunc,
; 11996:                                          lpvData, &lTempControl );

	lea	eax, DWORD PTR _lTempControl$11571[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpfnStreamFunc$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQualView$[ebp]
	push	eax
	call	_fnActivateOI_FromTextStream
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 11997: 
; 11998:       if ( nRC < -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jge	SHORT $L11580

; 11999:          goto EndOfFunction;

	jmp	$EndOfFunction$11540
$L11580:

; 12000:       else
; 12001:       if ( nRC == -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jne	SHORT $L11582

; 12003:          // Qual view is empty so we really don't need it.
; 12004:          fnDropView( vQualView );

	mov	eax, DWORD PTR _vQualView$[ebp]
	push	eax
	call	_fnDropView@4

; 12005:          vQualView = 0;

	mov	DWORD PTR _vQualView$[ebp], 0
$L11582:

; 12007: 
; 12008:       nRC = nSaveRC;

	mov	cx, WORD PTR _nSaveRC$11572[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 12009: 
; 12010:       vOrigView->bOrigView   = TRUE;

	mov	edx, DWORD PTR _vOrigView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, -128				; ffffff80H
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 12011:       vOrigView->bViewLocked = TRUE;

	mov	edx, DWORD PTR _vOrigView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 12012:       vOrigView->hMainOI     = zGETHNDL( lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 12013:       lpViewOI->vOriginalOI  = zGETHNDL( vOrigView );

	mov	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 12014: 
; 12015:       vQualView->bQualView   = TRUE;

	mov	edx, DWORD PTR _vQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	ah, 1
	mov	ecx, DWORD PTR _vQualView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 12016:       vQualView->bViewLocked = TRUE;

	mov	edx, DWORD PTR _vQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _vQualView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 12017:       vQualView->hMainOI     = zGETHNDL( lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _vQualView$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 12018:       lpViewOI->vQualOI      = zGETHNDL( vQualView );

	mov	edx, DWORD PTR _vQualView$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+44], eax
$L11570:

; 12020: 
; 12021:    // Reset the view if successful.
; 12022:    if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L11589

; 12024:       if ( (lControl & zSAVE_CURSORS) == 0 )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 262144				; 00040000H
	test	eax, eax
	jne	SHORT $L11588

; 12025:          fnResetView( lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetView
	add	esp, 8
$L11588:

; 12026: 
; 12027:       if ( lControl & zREADONLY )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2048				; 00000800H
	test	edx, edx
	je	SHORT $L11589

; 12028:          lpView->bReadOnly = TRUE;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx
$L11589:

; 12030: 
; 12031:    // Now that we are finished activating, check the root instance
; 12032:    // to determine if multiple roots were loaded.
; 12033:    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $L11593

; 12035:       LPENTITYINSTANCE lpRootEntityInstance =
; 12036:                                  zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$11591[ebp], eax

; 12037: 
; 12038:       if ( lpRootEntityInstance && lpRootEntityInstance->hNextTwin )

	cmp	DWORD PTR _lpRootEntityInstance$11591[ebp], 0
	je	SHORT $L11593
	mov	eax, DWORD PTR _lpRootEntityInstance$11591[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $L11593

; 12040:          nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1
$L11593:

; 12043: 
; 12044: #ifdef __ACTIVATE_CONSTRAINTS__
; 12045:    if ( (lControl & zACTIVATE_NOCONSTRAINTS) == 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 16777216				; 01000000H
	test	ecx, ecx
	jne	$EndOfFunction$11540

; 12047:       if ( lpViewOD->bActivateConstraint && nRC >= -1 )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $EndOfFunction$11540
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jl	SHORT $EndOfFunction$11540

; 12049:          zSHORT   k;
; 12050:          zSHORT   nState = zOCE_STATE_FILE;

	mov	WORD PTR _nState$11597[ebp], 1

; 12051: 
; 12052:          if ( lControl & zLEVEL_SYSTEM )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 8
	test	edx, edx
	je	SHORT $L11598

; 12053:             nState += zOCE_STATE_SYSTEM;

	mov	ax, WORD PTR _nState$11597[ebp]
	add	ax, 4
	mov	WORD PTR _nState$11597[ebp], ax
$L11598:

; 12054: 
; 12055:          if ( nRC == -2 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -2					; fffffffeH
	jne	SHORT $L11599

; 12056:             nState += zOCE_STATE_NOI;

	mov	dx, WORD PTR _nState$11597[ebp]
	add	dx, 8
	mov	WORD PTR _nState$11597[ebp], dx
$L11599:

; 12057: 
; 12058:          k = fnInvokeOCEOperation( lpView, lpCurrentTask,
; 12059:                                    zOCE_ACTIVATE, nState );

	mov	ax, WORD PTR _nState$11597[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _k$11596[ebp], ax

; 12060:          if ( k )

	movsx	eax, WORD PTR _k$11596[ebp]
	test	eax, eax
	je	SHORT $EndOfFunction$11540

; 12062:             fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropView@4

; 12063:             *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0

; 12064:          // fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );
; 12065:             return( k );

	mov	ax, WORD PTR _k$11596[ebp]
	jmp	$L11514
$EndOfFunction$11540:

; 12069: #endif
; 12070: 
; 12071: EndOfFunction:
; 12072: 
; 12073:    // Based on the return code, see if we have to reset the view to the
; 12074:    // prior instance or clean up the prior instance.
; 12075:    // note: rc = indicates multiple level1 roots present
; 12076:    if ( nRC >= -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jl	SHORT $L11601

; 12078:       lpViewOI->bUpdatedFile = FALSE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 12080:    else

	jmp	SHORT $L11604
$L11601:

; 12082:       fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropView@4

; 12083:       *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0

; 12084: 
; 12085:       if ( vOrigView )

	cmp	DWORD PTR _vOrigView$[ebp], 0
	je	SHORT $L11603

; 12086:          fnDropView( vOrigView );

	mov	eax, DWORD PTR _vOrigView$[ebp]
	push	eax
	call	_fnDropView@4
$L11603:

; 12087: 
; 12088:       if ( vQualView )

	cmp	DWORD PTR _vQualView$[ebp], 0
	je	SHORT $L11604

; 12089:          fnDropView( vQualView );

	mov	ecx, DWORD PTR _vQualView$[ebp]
	push	ecx
	call	_fnDropView@4
$L11604:

; 12091: 
; 12092:    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	and	eax, 1
	test	eax, eax
	je	SHORT $L11605

; 12094:       zCHAR sz[ 100 ];
; 12095: 
; 12096:       zsprintf( sz, "(%s) = %lf seconds", lpViewOD->szName,
; 12097:                 (double) (SysGetTickCount( ) - lTickCount) / zTICKS_PER_SECOND );

	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR -184+[ebp], eax
	mov	DWORD PTR -184+[ebp+4], 0
	fild	QWORD PTR -184+[ebp]
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@ ; `string'
	lea	edx, DWORD PTR _sz$11606[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 12098:       TraceLineS( "(oi) Total time for SfActivateOI_FromStream ", sz );

	lea	eax, DWORD PTR _sz$11606[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CN@HFJB@?$CIoi?$CJ?5Total?5time?5for?5SfActivateOI@ ; `string'
	call	_TraceLineS@8
$L11605:

; 12100: 
; 12101:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L11514:

; 12102: 
; 12103: } // SfActivateOI_FromStream

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_SfActivateOI_FromStream@24 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FO@KBNJ@SfActivateSysOI_FromFile?5now?5REQ@ ; `string'
PUBLIC	??_C@_0FM@LNBI@SfActivateSysOI_FromFile?5now?5REQ@ ; `string'
PUBLIC	??_C@_09BPDN@Zeidon?5OE?$AA@			; `string'
PUBLIC	_SfActivateSysOI_FromFile@20
;	COMDAT ??_C@_0FO@KBNJ@SfActivateSysOI_FromFile?5now?5REQ@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0FO@KBNJ@SfActivateSysOI_FromFile?5now?5REQ@ DB 'SfActivateSysOI_Fr'
	DB	'omFile now REQUIRES a non-zero qualification view for Object '
	DB	'Definition: %s', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FM@LNBI@SfActivateSysOI_FromFile?5now?5REQ@
_DATA	SEGMENT
??_C@_0FM@LNBI@SfActivateSysOI_FromFile?5now?5REQ@ DB 'SfActivateSysOI_Fr'
	DB	'omFile now REQUIRES a non-zero qualification view.  System wi'
	DB	'll now crash', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_09BPDN@Zeidon?5OE?$AA@
_DATA	SEGMENT
??_C@_09BPDN@Zeidon?5OE?$AA@ DB 'Zeidon OE', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_cpcFileName$ = 20
_lControl$ = 24
_lpCurrentTask$ = -8
_nRC$ = -4
_SfActivateSysOI_FromFile@20 PROC NEAR

; 12159: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 12160:    LPTASK      lpCurrentTask;
; 12161:    zSHORT      nRC;
; 12162: 
; 12163:    // init in case of error
; 12164:    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 12165: 
; 12166: #ifdef DEBUG
; 12167:    if ( lpAppQualView == 0 )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	jne	SHORT $L11622

; 12169:       TraceLine( "SfActivateSysOI_FromFile now REQUIRES a non-zero "
; 12170:                    "qualification view for Object Definition: %s", cpcViewOD_Name );

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0FO@KBNJ@SfActivateSysOI_FromFile?5now?5REQ@ ; `string'
	call	_TraceLine
	add	esp, 8

; 12171:       SysMessageBox( 0, "Zeidon OE", "SfActivateSysOI_FromFile now REQUIRES a "
; 12172:                      "non-zero qualification view.  System will now crash", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0FM@LNBI@SfActivateSysOI_FromFile?5now?5REQ@ ; `string'
	push	OFFSET FLAT:??_C@_09BPDN@Zeidon?5OE?$AA@ ; `string'
	push	0
	call	_SysMessageBox@16
$L11622:

; 12174: #endif
; 12175: 
; 12176:    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 12177:    if ( (lpCurrentTask = fnOperationCall( iSfActivateSysOI_FromFile,
; 12178:                                           lpAppQualView, zVALID_VIEW )) == 0 )

	push	1
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	215					; 000000d7H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L11626

; 12180:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L11619
$L11626:

; 12182: 
; 12183:    nRC = ActivateOI_FromFile( pvReturnView, cpcViewOD_Name, lpAppQualView,
; 12184:                               cpcFileName, lControl | zACTIVATE_SYSTEM );

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 536870912				; 20000000H
	push	eax
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcViewOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_ActivateOI_FromFile@20
	mov	WORD PTR _nRC$[ebp], ax

; 12185: 
; 12186:    fnOperationReturn( iSfActivateSysOI_FromFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	215					; 000000d7H
	call	_fnOperationReturn
	add	esp, 8

; 12187:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L11619:

; 12188: 
; 12189: } // SfActivateSysOI_FromFile

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SfActivateSysOI_FromFile@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FL@BEFB@SfActivateSysEmptyOI?5now?5REQUIRE@ ; `string'
PUBLIC	??_C@_0FI@FKHH@SfActivateSysEmptyOI?5now?5REQUIRE@ ; `string'
;	COMDAT ??_C@_0FL@BEFB@SfActivateSysEmptyOI?5now?5REQUIRE@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0FL@BEFB@SfActivateSysEmptyOI?5now?5REQUIRE@ DB 'SfActivateSysEmpty'
	DB	'OI now REQUIRES a non-zero qualification view for Object Defi'
	DB	'nition: %s.', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FI@FKHH@SfActivateSysEmptyOI?5now?5REQUIRE@
_DATA	SEGMENT
??_C@_0FI@FKHH@SfActivateSysEmptyOI?5now?5REQUIRE@ DB 'SfActivateSysEmpty'
	DB	'OI now REQUIRES a non-zero qualification view.  System will n'
	DB	'ow crash', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_lControl$ = 20
_lpCurrentTask$ = -20
_lpOwningTask$ = -16
_lpViewOD$ = -4
_lpView$ = -8
_nRC$ = -12
_nState$11652 = -24
_SfActivateSysEmptyOI@16 PROC NEAR

; 12233: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 12234:    LPTASK      lpCurrentTask;
; 12235:    LPTASK      lpOwningTask;
; 12236:    LPVIEWOD    lpViewOD;
; 12237:    zVIEW       lpView;
; 12238:    zSHORT      nRC;
; 12239: 
; 12240:    // init in case of error
; 12241:    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 12242: 
; 12243: #ifdef DEBUG
; 12244:    if ( lpAppQualView == 0 )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	jne	SHORT $L11641

; 12246:       TraceLine( "SfActivateSysEmptyOI now REQUIRES a non-zero "
; 12247:                    "qualification view for Object Definition: %s.", cpcViewOD_Name );

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0FL@BEFB@SfActivateSysEmptyOI?5now?5REQUIRE@ ; `string'
	call	_TraceLine
	add	esp, 8

; 12248:       SysMessageBox( 0, "Zeidon OE", "SfActivateSysEmptyOI now REQUIRES a "
; 12249:                      "non-zero qualification view.  System will now crash", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0FI@FKHH@SfActivateSysEmptyOI?5now?5REQUIRE@ ; `string'
	push	OFFSET FLAT:??_C@_09BPDN@Zeidon?5OE?$AA@ ; `string'
	push	0
	call	_SysMessageBox@16
$L11641:

; 12251: #endif
; 12252: 
; 12253:    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 12254:    if ( (lpCurrentTask = fnOperationCall( iSfActivateSysEmptyOI,
; 12255:                                           lpAppQualView, zVALID_VIEW )) == 0 )

	push	1
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	216					; 000000d8H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L11644

; 12257:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11635
$L11644:

; 12259: 
; 12260:    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L11645

; 12261:       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 12262:    else

	jmp	SHORT $L11647
$L11645:

; 12263:       lpOwningTask = lpCurrentTask;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], eax
$L11647:

; 12264: 
; 12265:    if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 12266:                               lpAppQualView, cpcViewOD_Name, 1 )) != 0 )

	push	1
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L11648

; 12268:       fnOperationReturn( iSfActivateSysEmptyOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	216					; 000000d8H
	call	_fnOperationReturn
	add	esp, 8

; 12269:       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11635
$L11648:

; 12271: 
; 12272: #if 0
; 12273:    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 12274:    {
; 12275:       zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 12276:                                   zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 12277:       if ( (nRC = SfTransferView( *pvReturnView, lpAppQualView,
; 12278:                                   nScope )) != 0 )
; 12279:       {
; 12280:          fnOperationReturn( iSfActivateSysEmptyOI, lpCurrentTask );
; 12281:          return( nRC );
; 12282:       }
; 12283:    }
; 12284: #endif
; 12285: 
; 12286:    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, *pvReturnView, lControl );

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 12287:    lpView = *pvReturnView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpView$[ebp], eax

; 12288:    if ( lControl & zREADONLY )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 2048				; 00000800H
	test	ecx, ecx
	je	SHORT $L11649

; 12289:       lpView->bReadOnly = TRUE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 64					; 00000040H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax
$L11649:

; 12290: 
; 12291: #ifdef __ACTIVATE_CONSTRAINTS__
; 12292:    // If object has activate constraint active, check for objections.
; 12293:    // If any drop view and exit...
; 12294:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 12295:    if ( lpViewOD->bActivateEmptyConstraint && nRC == 0 )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L11653
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $L11653

; 12297:       zSHORT nState = zOCE_STATE_SYSTEM;

	mov	WORD PTR _nState$11652[ebp], 4

; 12298: 
; 12299:       nRC = fnInvokeOCEOperation( lpView, lpCurrentTask,
; 12300:                                   zOCE_ACTIVATE_EMPTY, nState );

	mov	cx, WORD PTR _nState$11652[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 12301:       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L11653

; 12303:          fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDropView@4

; 12304:          *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0
$L11653:

; 12307: #endif
; 12308: 
; 12309:    fnOperationReturn( iSfActivateSysEmptyOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	216					; 000000d8H
	call	_fnOperationReturn
	add	esp, 8

; 12310:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L11635:

; 12311: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SfActivateSysEmptyOI@16 ENDP
_pchDateTime$ = 8
_pchDate$ = 12
_pchTime$ = 16
_fnDateTimeFormat PROC NEAR

; 12330: {

	push	ebp
	mov	ebp, esp

; 12331:    zstrncpy( pchDate, pchDateTime + 4, 2 );      // copy month

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pchDate$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12332:    pchDate[ 2 ] = '/';                           // separator

	mov	edx, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [edx+2], 47			; 0000002fH

; 12333:    zstrncpy( pchDate + 3, pchDateTime + 6, 2 );  // copy day

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _pchDate$[ebp]
	add	ecx, 3
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12334:    pchDate[ 5 ] = '/';                           // separator

	mov	edx, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [edx+5], 47			; 0000002fH

; 12335:    zstrncpy( pchDate + 6, pchDateTime + 2, 2 );  // copy year

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pchDate$[ebp]
	add	ecx, 6
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12336:    pchDate[ 8 ] = 0;                             // null terminator

	mov	edx, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [edx+8], 0

; 12337: 
; 12338:    zstrncpy( pchTime, pchDateTime + 8, 2 );      // copy hours

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pchTime$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12339:    pchTime[ 2 ] = ':';                           // separator

	mov	edx, DWORD PTR _pchTime$[ebp]
	mov	BYTE PTR [edx+2], 58			; 0000003aH

; 12340:    zstrncpy( pchTime + 3, pchDateTime + 10, 2 ); // copy minutes

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _pchTime$[ebp]
	add	ecx, 3
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12341:    pchTime[ 5 ] = ':';                           // separator

	mov	edx, DWORD PTR _pchTime$[ebp]
	mov	BYTE PTR [edx+5], 58			; 0000003aH

; 12342:    zstrncpy( pchTime + 6, pchDateTime + 12, 2 ); // copy seconds

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _pchTime$[ebp]
	add	ecx, 6
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12343:    pchDate[ 8 ] = 0;                             // null terminator

	mov	edx, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [edx+8], 0

; 12344: }

	pop	ebp
	ret	0
_fnDateTimeFormat ENDP
_TEXT	ENDS
EXTRN	_fnGetVariableFromAttribute:NEAR
EXTRN	_fnCompareDateTimeToDateTime:NEAR
EXTRN	_memcmp:NEAR
EXTRN	_SysCompareDecimalToDecimal@8:NEAR
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpView1$ = 12
_lpInstance1$ = 16
_lpViewAttrib1$ = 20
_pchContextName1$ = 24
_lpView2$ = 28
_lpInstance2$ = 32
_lpViewAttrib2$ = 36
_pchContextName2$ = 40
_pchValue1$ = -20
_pchValue2$ = -16
_bNull1$ = -8
_bNull2$ = -4
_chType1$ = -536
_chType2$ = -540
_nRC$ = -12
_AttrVal1$ = -276
_AttrVal2$ = -532
_lpViewEntityCsr$11701 = -548
_ulLth$11702 = -544
_lpViewEntityCsr$11709 = -556
_uLth$11710 = -552
_ulLth1$11746 = -568
_ulLth2$11747 = -564
_uBlobLth$11748 = -560
_fnCompareEIAttrs@36 PROC NEAR

; 12382: {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H

; 12383:    zPCHAR   pchValue1, pchValue2;
; 12384:    zSHORT   bNull1, bNull2;
; 12385:    zCHAR    chType1, chType2;
; 12386:    zSHORT   nRC;
; 12387: 
; 12388:    typedef union _AttrValues
; 12389:    {
; 12390:       zLONG          l;
; 12391:       zCHAR          sz[ 256 ];
; 12392:       zDECIMAL       d;
; 12393:       DateTimeRecord dt;
; 12394:    } AttrValues;
; 12395:    AttrValues AttrVal1, AttrVal2;
; 12396: 
; 12397:    bNull1 = fnAttributeValueNull( 0, lpInstance1, lpViewAttrib1 );

	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInstance1$[ebp]
	push	ecx
	push	0
	call	_fnAttributeValueNull
	add	esp, 12					; 0000000cH
	mov	WORD PTR _bNull1$[ebp], ax

; 12398:    bNull2 = fnAttributeValueNull( 0, lpInstance2, lpViewAttrib2 );

	mov	edx, DWORD PTR _lpViewAttrib2$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInstance2$[ebp]
	push	eax
	push	0
	call	_fnAttributeValueNull
	add	esp, 12					; 0000000cH
	mov	WORD PTR _bNull2$[ebp], ax

; 12399: 
; 12400:    if ( bNull1 )

	movsx	ecx, WORD PTR _bNull1$[ebp]
	test	ecx, ecx
	je	SHORT $L11695

; 12402:       if ( bNull2 )

	movsx	edx, WORD PTR _bNull2$[ebp]
	test	edx, edx
	je	SHORT $L11696

; 12403:          return( 0 );

	xor	ax, ax
	jmp	$L11679
$L11696:

; 12404:       else
; 12405:          return( -1 );

	or	ax, -1
	jmp	$L11679
$L11695:

; 12407:    else
; 12408:    if ( bNull2 )

	movsx	eax, WORD PTR _bNull2$[ebp]
	test	eax, eax
	je	SHORT $L11699

; 12410:       // We know that attrib 1 is NOT null so it is > than attrib 2.
; 12411:       return( 1 );

	mov	ax, 1
	jmp	$L11679
$L11699:

; 12413: 
; 12414:    chType1 = lpViewAttrib1->cType;

	mov	ecx, DWORD PTR _lpViewAttrib1$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR _chType1$[ebp], dl

; 12415: 
; 12416:    // Check to see if we have a context.  If we do, use it to get the attr
; 12417:    // value.  If not, get a pointer to the internal value.
; 12418: 
; 12419:    if ( pchContextName1 && chType1 != zTYPE_BLOB && chType1 != zTYPE_DATETIME )

	cmp	DWORD PTR _pchContextName1$[ebp], 0
	je	$L11700
	movsx	eax, BYTE PTR _chType1$[ebp]
	cmp	eax, 66					; 00000042H
	je	SHORT $L11700
	movsx	ecx, BYTE PTR _chType1$[ebp]
	cmp	ecx, 84					; 00000054H
	je	SHORT $L11700

; 12421:       LPVIEWENTITYCSR lpViewEntityCsr;
; 12422:       zULONG          ulLth;
; 12423: 
; 12424:       // Use the context name to get attribute value.
; 12425:       lpViewEntityCsr = fnEstablishViewForInstance( lpView1, 0, lpInstance1 );

	mov	edx, DWORD PTR _lpInstance1$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView1$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$11701[ebp], eax

; 12426: 
; 12427:       // Use default context if pchContextName points to an empty string.
; 12428:       fnGetVariableFromAttribute( (zPVOID) &AttrVal1, &ulLth,
; 12429:                                   chType1, (zULONG) sizeof( AttrVal2 ),
; 12430:                                   lpView1, lpViewEntityCsr,
; 12431:                                   lpViewAttrib1,
; 12432:                                   pchContextName1,
; 12433:                                   lpCurrentTask,
; 12434:                                   (zSHORT) (*pchContextName1 ? 0 : zUSE_DEFAULT_CONTEXT) );

	mov	ecx, DWORD PTR _pchContextName1$[ebp]
	movsx	edx, BYTE PTR [ecx]
	neg	edx
	sbb	edx, edx
	and	edx, -8					; fffffff8H
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchContextName1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib1$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$11701[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView1$[ebp]
	push	ecx
	push	256					; 00000100H
	mov	dl, BYTE PTR _chType1$[ebp]
	push	edx
	lea	eax, DWORD PTR _ulLth$11702[ebp]
	push	eax
	lea	ecx, DWORD PTR _AttrVal1$[ebp]
	push	ecx
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H

; 12435: 
; 12436:       pchValue1 = (zPCHAR) &AttrVal1;

	lea	edx, DWORD PTR _AttrVal1$[ebp]
	mov	DWORD PTR _pchValue1$[ebp], edx

; 12438:    else

	jmp	SHORT $L11707
$L11700:

; 12439:       fnGetAddrForAttribute( &pchValue1, 0, 0, lpInstance1, lpViewAttrib1 );

	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInstance1$[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _pchValue1$[ebp]
	push	edx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H
$L11707:

; 12440: 
; 12441:    chType2 = lpViewAttrib2->cType;

	mov	eax, DWORD PTR _lpViewAttrib2$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR _chType2$[ebp], cl

; 12442: 
; 12443:    if ( pchContextName2 && chType2 != zTYPE_BLOB && chType2 != zTYPE_DATETIME )

	cmp	DWORD PTR _pchContextName2$[ebp], 0
	je	$L11708
	movsx	edx, BYTE PTR _chType2$[ebp]
	cmp	edx, 66					; 00000042H
	je	SHORT $L11708
	movsx	eax, BYTE PTR _chType2$[ebp]
	cmp	eax, 84					; 00000054H
	je	SHORT $L11708

; 12445:       LPVIEWENTITYCSR lpViewEntityCsr;
; 12446:       zLONG           uLth;
; 12447: 
; 12448:       // Use the context name to get attribute value.
; 12449:       lpViewEntityCsr = fnEstablishViewForInstance( lpView2, 0, lpInstance2 );

	mov	ecx, DWORD PTR _lpInstance2$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView2$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$11709[ebp], eax

; 12450: 
; 12451:       // Use default context if pchContextName points to an empty string.
; 12452:       fnGetVariableFromAttribute( (zPVOID) &AttrVal2, &uLth,
; 12453:                                   chType2, (zULONG) sizeof( AttrVal2 ),
; 12454:                                   lpView2, lpViewEntityCsr,
; 12455:                                   lpViewAttrib2,
; 12456:                                   pchContextName2,
; 12457:                                   lpCurrentTask,
; 12458:                                   (zSHORT) ( *pchContextName2 ? 0 : zUSE_DEFAULT_CONTEXT ) );

	mov	eax, DWORD PTR _pchContextName2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, -8					; fffffff8H
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchContextName2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$11709[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView2$[ebp]
	push	eax
	push	256					; 00000100H
	mov	cl, BYTE PTR _chType2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _uLth$11710[ebp]
	push	edx
	lea	eax, DWORD PTR _AttrVal2$[ebp]
	push	eax
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H

; 12459: 
; 12460:       pchValue2 = (zPCHAR) &AttrVal2;

	lea	ecx, DWORD PTR _AttrVal2$[ebp]
	mov	DWORD PTR _pchValue2$[ebp], ecx

; 12462:    else

	jmp	SHORT $L11715
$L11708:

; 12463:       fnGetAddrForAttribute( &pchValue2, 0, 0, lpInstance2, lpViewAttrib2 );

	mov	edx, DWORD PTR _lpViewAttrib2$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInstance2$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _pchValue2$[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H
$L11715:

; 12464: 
; 12465:    switch ( chType1 )
; 12466:    {

	movsx	edx, BYTE PTR _chType1$[ebp]
	mov	DWORD PTR -572+[ebp], edx
	mov	eax, DWORD PTR -572+[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR -572+[ebp], eax
	cmp	DWORD PTR -572+[ebp], 18		; 00000012H
	ja	$L11717
	mov	edx, DWORD PTR -572+[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR $L12848[edx]
	jmp	DWORD PTR $L12849[ecx*4]
$L11720:

; 12467:       case zTYPE_STRING:
; 12468:          if ( lpViewAttrib1->bCaseSens )

	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 6
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L11721

; 12469:             nRC = zstrcmp( pchValue1, pchValue2 );

	mov	edx, DWORD PTR _pchValue1$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchValue2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L12844
	mov	eax, DWORD PTR _pchValue2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchValue1$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -576+[ebp], eax
	jmp	SHORT $L12845
$L12844:
	mov	edx, DWORD PTR _pchValue1$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchValue2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	xor	ecx, ecx
	test	eax, eax
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -576+[ebp], ecx
$L12845:
	mov	dx, WORD PTR -576+[ebp]
	mov	WORD PTR _nRC$[ebp], dx

; 12470:          else

	jmp	SHORT $L11728
$L11721:

; 12471:             nRC = zstrcmpi( pchValue1, pchValue2 );

	mov	eax, DWORD PTR _pchValue2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchValue1$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$L11728:

; 12472: 
; 12473:          if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L11729

; 12474:             nRC = -1;

	mov	WORD PTR _nRC$[ebp], -1

; 12475:          else

	jmp	SHORT $L11731
$L11729:

; 12476:          if ( nRC > 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jle	SHORT $L11731

; 12477:             nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1
$L11731:

; 12478: 
; 12479:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11679
$L11732:

; 12480: 
; 12481:       case zTYPE_INTEGER:
; 12482:          if ( *((zPLONG) pchValue1) == *((zPLONG) pchValue2) )

	mov	ecx, DWORD PTR _pchValue1$[ebp]
	mov	edx, DWORD PTR _pchValue2$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $L11735

; 12483:             nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 12484:          else

	jmp	SHORT $L11736
$L11735:

; 12485:             nRC = (*((zPLONG) pchValue1) < *((zPLONG) pchValue2)) ? -1 : 1;

	mov	ecx, DWORD PTR _pchValue1$[ebp]
	mov	edx, DWORD PTR _pchValue2$[ebp]
	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setge	cl
	dec	ecx
	and	ecx, -2					; fffffffeH
	add	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
$L11736:

; 12486: 
; 12487:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11679
$L11739:

; 12488: 
; 12489:       case zTYPE_DECIMAL:
; 12490:          return( SysCompareDecimalToDecimal( (zPDECIMAL) pchValue1,
; 12491:                                              (zPDECIMAL) pchValue2 ) );

	mov	edx, DWORD PTR _pchValue2$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchValue1$[ebp]
	push	eax
	call	_SysCompareDecimalToDecimal@8
	jmp	$L11679
$L11742:

; 12492: 
; 12493:       case zTYPE_DATETIME:
; 12494:          nRC = fnCompareDateTimeToDateTime( (LPDTINTERNAL) pchValue1,
; 12495:                                             (LPDTINTERNAL) pchValue2 );

	mov	ecx, DWORD PTR _pchValue2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchValue1$[ebp]
	push	edx
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 12496:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11679
$L11745:

; 12500:          zULONG ulLth1, ulLth2, uBlobLth;
; 12501: 
; 12502:          fnGetAttributeLength( &ulLth1, 0, lpInstance1, lpViewAttrib1 );

	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInstance1$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _ulLth1$11746[ebp]
	push	edx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 12503:          fnGetAttributeLength( &ulLth2, 0, lpInstance2, lpViewAttrib2 );

	mov	eax, DWORD PTR _lpViewAttrib2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInstance2$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _ulLth2$11747[ebp]
	push	edx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 12504: 
; 12505:          uBlobLth = min( ulLth1, ulLth2 );

	mov	eax, DWORD PTR _ulLth1$11746[ebp]
	cmp	eax, DWORD PTR _ulLth2$11747[ebp]
	jae	SHORT $L12846
	mov	ecx, DWORD PTR _ulLth1$11746[ebp]
	mov	DWORD PTR -580+[ebp], ecx
	jmp	SHORT $L12847
$L12846:
	mov	edx, DWORD PTR _ulLth2$11747[ebp]
	mov	DWORD PTR -580+[ebp], edx
$L12847:
	mov	eax, DWORD PTR -580+[ebp]
	mov	DWORD PTR _uBlobLth$11748[ebp], eax

; 12506: 
; 12507:          nRC = zmemcmp( pchValue1, pchValue2, (int) uBlobLth );

	mov	ecx, DWORD PTR _uBlobLth$11748[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchValue2$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchValue1$[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 12508:          if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L11750

; 12510:             if ( ulLth1 == ulLth2 )

	mov	edx, DWORD PTR _ulLth1$11746[ebp]
	cmp	edx, DWORD PTR _ulLth2$11747[ebp]
	jne	SHORT $L11751

; 12511:                return( 0 );

	xor	ax, ax
	jmp	SHORT $L11679
$L11751:

; 12512:             else
; 12513:                return( ulLth1 < ulLth2 ? -1 : 1 );

	mov	eax, DWORD PTR _ulLth1$11746[ebp]
	cmp	eax, DWORD PTR _ulLth2$11747[ebp]
	sbb	eax, eax
	and	al, -2					; fffffffeH
	add	eax, 1
	jmp	SHORT $L11679
$L11750:

; 12515:          else
; 12516:             return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L11679
$L11717:

; 12520: 
; 12521:    return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
$L11679:

; 12522: }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
$L12849:
	DD	$L11745
	DD	$L11732
	DD	$L11739
	DD	$L11720
	DD	$L11742
	DD	$L11717
$L12848:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnCompareEIAttrs@36 ENDP
_TEXT	ENDS
PUBLIC	_fnCmprEntities
_TEXT	SEGMENT
_hViewEntity1$ = 8
_hViewEntity2$ = 12
_lpViewEntity1$ = -4
_lpViewEntity2$ = -8
_fnCmprEntities PROC NEAR

; 12539: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 12540:    LPVIEWENTITY lpViewEntity1 = zGETPTR( hViewEntity1 );

	mov	eax, DWORD PTR _hViewEntity1$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity1$[ebp], eax

; 12541:    LPVIEWENTITY lpViewEntity2 = zGETPTR( hViewEntity2 );

	mov	ecx, DWORD PTR _hViewEntity2$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity2$[ebp], eax

; 12542: 
; 12543: #if 0
; 12544:    TraceLine( "fnSortCmpr Checking Entities: %s : 0x%08x, %s : 0x%08x",
; 12545:               lpViewEntity1->szName, lpViewEntity1->lEREntTok,
; 12546:               lpViewEntity2->szName, lpViewEntity2->lEREntTok );
; 12547: #endif
; 12548: 
; 12549:    // It appears that it is "good enough" for the entity tokens to
; 12550:    // match when doing the compare.  In such a case, for example,
; 12551:    // CtrlCtrl matches Control in TZWDLGSO.   dks 2005.12.26
; 12552:    if ( lpViewEntity1 && lpViewEntity2 &&
; 12553:         lpViewEntity1->lEREntTok == lpViewEntity2->lEREntTok )

	cmp	DWORD PTR _lpViewEntity1$[ebp], 0
	je	SHORT $L11771
	cmp	DWORD PTR _lpViewEntity2$[ebp], 0
	je	SHORT $L11771
	mov	edx, DWORD PTR _lpViewEntity1$[ebp]
	mov	eax, DWORD PTR _lpViewEntity2$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	jne	SHORT $L11771

; 12555:       return( 0 );

	xor	ax, ax
	jmp	SHORT $L11766
$L11771:

; 12557: 
; 12558:    return( 1 );

	mov	ax, 1
$L11766:

; 12559: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCmprEntities ENDP
_TEXT	ENDS
PUBLIC	_fnSortCmpr
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI1$ = 12
_lpEI2$ = 16
_lpAttrListPtr$ = -16
_lpCompareEI1$ = -8
_lpCompareEI2$ = -4
_nComp$ = -12
_fnSortCmpr PROC NEAR

; 12571: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 12572:    LPVIEWATTRLIST   lpAttrListPtr;
; 12573:    LPENTITYINSTANCE lpCompareEI1;
; 12574:    LPENTITYINSTANCE lpCompareEI2;
; 12575:    zSHORT           nComp;
; 12576: 
; 12577:    // Compare sort keys from major to minor.  When an inequality is
; 12578:    // found, see if an entity swap is needed.
; 12579:    for ( lpAttrListPtr = lpSortData->lpViewAttrList;
; 12580:          lpAttrListPtr->lpViewAttrib;
; 12581:          lpAttrListPtr++ )

	mov	eax, DWORD PTR _lpSortData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpAttrListPtr$[ebp], ecx
	jmp	SHORT $L11784
$L11785:
	mov	edx, DWORD PTR _lpAttrListPtr$[ebp]
	add	edx, 13					; 0000000dH
	mov	DWORD PTR _lpAttrListPtr$[ebp], edx
$L11784:
	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$L11786

; 12583:       // Check to see if the sort key belongs to the same entity that we are
; 12584:       // sorting.  If not we need to retrieve the EI for the sort key.
; 12585:       if ( lpAttrListPtr->lpViewAttrib->hViewEntity != lpEI1->hViewEntity &&
; 12586:            fnCmprEntities( lpAttrListPtr->lpViewAttrib->hViewEntity,
; 12587:                            lpEI1->hViewEntity ) != 0 )

	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	ecx, DWORD PTR [edx+6]
	cmp	ecx, DWORD PTR [eax+2]
	je	$L11787
	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_fnCmprEntities
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	$L11787

; 12589:          // Sort key is from a different entity than the swap entity.  This
; 12590:          // could happen if the user is sorting entities using the value of a
; 12591:          // child entity.  We need to retrieve the EI for the child entity.
; 12592:          // Since cursor positions are undefined at this point we will assume
; 12593:          // the first child entity.
; 12594:          lpCompareEI1 = zGETPTR( lpEI1->hNextHier );

	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI1$[ebp], eax
$L11790:

; 12595:          while ( lpCompareEI1 )

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	je	SHORT $L11791

; 12597:             // Check to see if this is the EI we are looking for.
; 12598:             if ( lpCompareEI1->hViewEntity ==
; 12599:                                   lpAttrListPtr->lpViewAttrib->hViewEntity )

	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpCompareEI1$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR [edx+6]
	jne	SHORT $L11792

; 12601:                break;  // it is the EI we are looking for

	jmp	SHORT $L11791
$L11792:

; 12603: 
; 12604:             // Check the next EI.
; 12605:             lpCompareEI1 = zGETPTR( lpCompareEI1->hNextHier );

	mov	edx, DWORD PTR _lpCompareEI1$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI1$[ebp], eax

; 12606: 
; 12607:             if ( lpCompareEI1 == 0 )

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	jne	SHORT $L11794

; 12608:                break;

	jmp	SHORT $L11791
$L11794:

; 12609: 
; 12610:             // If the level of the current EI is <= the level of the parent
; 12611:             // EI then we never found a matching child entity ... so break.
; 12612:             if ( lpCompareEI1->nLevel <= lpEI1->nLevel )

	mov	ecx, DWORD PTR _lpCompareEI1$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpEI1$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jg	SHORT $L11795

; 12614:                lpCompareEI1 = 0;

	mov	DWORD PTR _lpCompareEI1$[ebp], 0

; 12615:                break;

	jmp	SHORT $L11791
$L11795:

; 12617:          }

	jmp	SHORT $L11790
$L11791:

; 12618: 
; 12619:          // Do the same thing for the second EI.
; 12620:          lpCompareEI2 = zGETPTR( lpEI2->hNextHier );

	mov	edx, DWORD PTR _lpEI2$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI2$[ebp], eax
$L11798:

; 12621:          while ( lpCompareEI2 )

	cmp	DWORD PTR _lpCompareEI2$[ebp], 0
	je	SHORT $L11799

; 12623:             // Check to see if this is the EI we are looking for.
; 12624:             if ( lpCompareEI2->hViewEntity ==
; 12625:                                   lpAttrListPtr->lpViewAttrib->hViewEntity )

	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpCompareEI2$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR [edx+6]
	jne	SHORT $L11800

; 12627:                break;  // it is the EI we are looking for

	jmp	SHORT $L11799
$L11800:

; 12629: 
; 12630:             // Check the next EI.
; 12631:             lpCompareEI2 = zGETPTR( lpCompareEI2->hNextHier );

	mov	edx, DWORD PTR _lpCompareEI2$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI2$[ebp], eax

; 12632: 
; 12633:             if ( lpCompareEI2 == 0 )

	cmp	DWORD PTR _lpCompareEI2$[ebp], 0
	jne	SHORT $L11802

; 12634:                break;

	jmp	SHORT $L11799
$L11802:

; 12635: 
; 12636:             // If the level of the current EI is <= the level of the parent
; 12637:             // EI then we never found a matching child entity ... so break.
; 12638:             if ( lpCompareEI2->nLevel <= lpEI2->nLevel )

	mov	ecx, DWORD PTR _lpCompareEI2$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpEI2$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jg	SHORT $L11803

; 12640:                lpCompareEI2 = 0;

	mov	DWORD PTR _lpCompareEI2$[ebp], 0

; 12641:                break;

	jmp	SHORT $L11799
$L11803:

; 12643:          }

	jmp	SHORT $L11798
$L11799:

; 12644: 
; 12645:          // If either of the compare entities are 0 then they don't
; 12646:          // exist so set nComp and break.
; 12647:          if ( lpCompareEI1 == 0 || lpCompareEI2 == 0 )

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	je	SHORT $L11805
	cmp	DWORD PTR _lpCompareEI2$[ebp], 0
	jne	SHORT $L11804
$L11805:

; 12649:             // If they are the same then they are both 0 and we'll assume
; 12650:             // that they compare equal.
; 12651:             if ( lpCompareEI1 == lpCompareEI2 )

	mov	edx, DWORD PTR _lpCompareEI1$[ebp]
	cmp	edx, DWORD PTR _lpCompareEI2$[ebp]
	jne	SHORT $L11806

; 12652:                nComp = 0;

	mov	WORD PTR _nComp$[ebp], 0

; 12653:             else

	jmp	SHORT $L11809
$L11806:

; 12654:             if ( lpCompareEI1 ) // EI1 is valid but EI2 is not so we'll assume EI1 > EI2.

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	je	SHORT $L11808

; 12655:                nComp = 1;

	mov	WORD PTR _nComp$[ebp], 1

; 12656:             else

	jmp	SHORT $L11809
$L11808:

; 12657:                nComp = -1;

	mov	WORD PTR _nComp$[ebp], -1
$L11809:

; 12658: 
; 12659:             break;

	jmp	SHORT $L11786
$L11804:

; 12662:       else

	jmp	SHORT $L11810
$L11787:

; 12664:          // We are comparing the same entity we are swapping.
; 12665:          lpCompareEI1 = lpEI1;

	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	DWORD PTR _lpCompareEI1$[ebp], eax

; 12666:          lpCompareEI2 = lpEI2;

	mov	ecx, DWORD PTR _lpEI2$[ebp]
	mov	DWORD PTR _lpCompareEI2$[ebp], ecx
$L11810:

; 12668: 
; 12669:       // Now actually perform the compare.
; 12670:       nComp = fnCompareEIAttrs( lpSortData->lpCurrentTask,
; 12671:                                 lpSortData->lpView1, lpCompareEI1,
; 12672:                                 lpAttrListPtr->lpViewAttrib,
; 12673:                                 lpAttrListPtr->pszContextName,
; 12674:                                 lpSortData->lpView2, lpCompareEI2,
; 12675:                                 lpAttrListPtr->lpViewAttrib,
; 12676:                                 lpAttrListPtr->pszContextName );

	mov	edx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	eax, DWORD PTR [edx+9]
	push	eax
	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _lpCompareEI2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	mov	ecx, DWORD PTR [eax+9]
	push	ecx
	mov	edx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpCompareEI1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fnCompareEIAttrs@36
	mov	WORD PTR _nComp$[ebp], ax

; 12677: 
; 12678:       // If the compare wasn't equal then we don't need to compare any more
; 12679:       // because we know the EIs are different.
; 12680:       if ( nComp )

	movsx	eax, WORD PTR _nComp$[ebp]
	test	eax, eax
	je	SHORT $L11811

; 12681:          break;

	jmp	SHORT $L11786
$L11811:

; 12682: 
; 12683:    } // for...

	jmp	$L11785
$L11786:

; 12684: 
; 12685:    // If the EIs are different then find out if they need to be swapped.
; 12686:    if ( nComp )

	movsx	ecx, WORD PTR _nComp$[ebp]
	test	ecx, ecx
	je	SHORT $L11814

; 12688:       if ( nComp < 0 && lpAttrListPtr->bOrder )

	movsx	edx, WORD PTR _nComp$[ebp]
	test	edx, edx
	jge	SHORT $L11813
	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+8]
	test	ecx, ecx
	je	SHORT $L11813

; 12689:          return( 1 );

	mov	ax, 1
	jmp	SHORT $L11779
$L11813:

; 12690: 
; 12691:       if ( nComp > 0 && lpAttrListPtr->bOrder == FALSE )

	movsx	edx, WORD PTR _nComp$[ebp]
	test	edx, edx
	jle	SHORT $L11814
	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $L11814

; 12692:          return( 1 );

	mov	ax, 1
	jmp	SHORT $L11779
$L11814:

; 12694: 
; 12695:    // If we get here then the EIs are in correct order.
; 12696:    return( 0 );

	xor	ax, ax
$L11779:

; 12697: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSortCmpr ENDP
_TEXT	ENDS
PUBLIC	_Heapify
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI$ = 12
_ulRecordCnt$ = 16
_k$ = 20
_ulLeft$ = -8
_ulLargest$ = -4
_t$11832 = -12
_Heapify PROC NEAR

; 12716: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 12717: // ASSERT_TRACE( "Heapify error", 0, k <= ulRecordCnt );
; 12718:    zULONG ulLeft = k << 1;

	mov	eax, DWORD PTR _k$[ebp]
	shl	eax, 1
	mov	DWORD PTR _ulLeft$[ebp], eax

; 12719:    zULONG ulLargest;
; 12720: 
; 12721:    if ( ulLeft > ulRecordCnt )

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	cmp	ecx, DWORD PTR _ulRecordCnt$[ebp]
	jbe	SHORT $L11827

; 12723:       return( 0 );

	xor	eax, eax
	jmp	$L11824
$L11827:

; 12725: 
; 12726:    ulLargest = k;

	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _ulLargest$[ebp], edx

; 12727: // if ( CompareRecords( ulLeft, ulLargest ) > 0 )
; 12728:    if ( fnSortCmpr( lpSortData, lpEI[ ulLeft - 1 ], lpEI[ ulLargest - 1 ] ) )

	mov	eax, DWORD PTR _ulLargest$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	push	edx
	mov	eax, DWORD PTR _ulLeft$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	push	edx
	mov	eax, DWORD PTR _lpSortData$[ebp]
	push	eax
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11828

; 12730:       ulLargest = ulLeft;

	mov	edx, DWORD PTR _ulLeft$[ebp]
	mov	DWORD PTR _ulLargest$[ebp], edx
$L11828:

; 12732: 
; 12733:    ulLeft++;   // ulRight (use ulLeft to conserve stack space)

	mov	eax, DWORD PTR _ulLeft$[ebp]
	add	eax, 1
	mov	DWORD PTR _ulLeft$[ebp], eax

; 12734:    if ( ulLeft <= ulRecordCnt )

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	cmp	ecx, DWORD PTR _ulRecordCnt$[ebp]
	ja	SHORT $L11830

; 12736:    // if ( CompareRecords( ulLeft, ulLargest ) > 0 )
; 12737:       if ( fnSortCmpr( lpSortData, lpEI[ ulLeft - 1 ], lpEI[ ulLargest - 1 ] ) )

	mov	edx, DWORD PTR _ulLargest$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4-4]
	push	ecx
	mov	edx, DWORD PTR _ulLeft$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4-4]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	push	edx
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11830

; 12739:          ulLargest = ulLeft;

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	mov	DWORD PTR _ulLargest$[ebp], ecx
$L11830:

; 12742: 
; 12743:    if ( k != ulLargest )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _ulLargest$[ebp]
	je	SHORT $L11831

; 12745:       SWAP_EI( lpEI[ k - 1 ], lpEI[ ulLargest - 1 ] );

	mov	eax, DWORD PTR _ulLargest$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	DWORD PTR _t$11832[ebp], edx
	mov	eax, DWORD PTR _ulLargest$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [esi+edx*4-4]
	mov	DWORD PTR [ecx+eax*4-4], edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _t$11832[ebp]
	mov	DWORD PTR [ecx+eax*4-4], edx

; 12746:    // zULONG *p1;
; 12747:    // zULONG *p2;
; 12748: 
; 12749:    // // Use uLeft to conserve stack.
; 12750:    // p1 = CSIMP_GETSORTIDX_PTR( k, m_pUseIdx->m_pxIdx );
; 12751:    // p2 = CSIMP_GETSORTIDX_PTR( ulLargest, m_pUseIdx->m_pxIdx );
; 12752:    // ulLeft = *p1;
; 12753:    // *p1 = *p2;
; 12754:    // *p2 = ulLeft;
; 12755:       return( ulLargest );

	mov	eax, DWORD PTR _ulLargest$[ebp]
	jmp	SHORT $L11824
$L11831:

; 12757: 
; 12758:    return( 0 );

	xor	eax, eax
$L11824:

; 12759: }  // end of:  Heapify

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Heapify ENDP
_TEXT	ENDS
PUBLIC	_BuildHeap
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI$ = 12
_ulRecordCnt$ = 16
_k$ = -8
_ul$ = -4
_BuildHeap PROC NEAR

; 12768: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 12769:    zULONG k;
; 12770:    zULONG ul;
; 12771: 
; 12772: #ifdef DEBUG_ALL
; 12773:    OutputDebugString( "\nShowing heap prior to build heap ...\n" );
; 12774:    ShowHeap( this, m_pUseIdx->m_pxIdx );
; 12775: #endif
; 12776: 
; 12777:    k = ulRecordCnt / 2;

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	shr	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$L11844:

; 12778:    while ( k > 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jbe	SHORT $L11845

; 12780:       ul = Heapify( lpSortData, lpEI, ulRecordCnt, k-- );

	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR -12+[ebp], ecx
	mov	edx, DWORD PTR -12+[ebp]
	push	edx
	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax
$L11847:

; 12781:       while ( ul )

	cmp	DWORD PTR _ul$[ebp], 0
	je	SHORT $L11848

; 12783:          ul = Heapify( lpSortData, lpEI, ulRecordCnt, ul );

	mov	ecx, DWORD PTR _ul$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulRecordCnt$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax

; 12784:       }

	jmp	SHORT $L11847
$L11848:

; 12785:    }

	jmp	SHORT $L11844
$L11845:

; 12786: }  // end of:  BuildHeap

	mov	esp, ebp
	pop	ebp
	ret	0
_BuildHeap ENDP
_TEXT	ENDS
PUBLIC	_fnHeapSort
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI$ = 12
_ulRecordCnt$ = 16
_ul$ = -4
_fnHeapSort PROC NEAR

; 12795: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 12796: // zULONG ulHoldCnt = ulRecordCnt;
; 12797: // zULONG ulHoldMax = ulMaxRecords;
; 12798: // zULONG *p1;
; 12799:    zULONG ul;
; 12800: 
; 12801:    BuildHeap( lpSortData, lpEI, ulRecordCnt );

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	push	edx
	call	_BuildHeap
	add	esp, 12					; 0000000cH
$L11859:

; 12802: 
; 12803:    while ( ulRecordCnt > 1 )

	cmp	DWORD PTR _ulRecordCnt$[ebp], 1
	jbe	SHORT $L11860

; 12805:       ulRecordCnt--;

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ulRecordCnt$[ebp], eax

; 12806:    // ulMaxRecords--;
; 12807:    //
; 12808:    // p1 = CSIMP_GETSORTIDX_PTR( ulRecordCnt + 1, m_pUseIdx->m_pxIdx );
; 12809:    // ul = *p1;
; 12810:    // *p1 = *(m_pUseIdx->m_pxIdx);
; 12811:    // *(m_pUseIdx->m_pxIdx) = ul;
; 12812: 
; 12813:    // ul = Heapify( 1 );
; 12814:       ul = Heapify( lpSortData, lpEI, ulRecordCnt, 1 );

	push	1
	mov	ecx, DWORD PTR _ulRecordCnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEI$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSortData$[ebp]
	push	eax
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax
$L11862:

; 12815:       while ( ul )

	cmp	DWORD PTR _ul$[ebp], 0
	je	SHORT $L11863

; 12817:       // ul = Heapify( ul );
; 12818:          ul = Heapify( lpSortData, lpEI, ulRecordCnt, ul );

	mov	ecx, DWORD PTR _ul$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulRecordCnt$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax

; 12819:       }

	jmp	SHORT $L11862
$L11863:

; 12820:    }

	jmp	SHORT $L11859
$L11860:

; 12821: 
; 12822: // ulRecordCnt = ulHoldCnt;
; 12823: // ulMaxRecords = ulHoldMax;
; 12824: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnHeapSort ENDP
_TEXT	ENDS
PUBLIC	_fnQuickSort
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI$ = 12
_ulRecordCnt$ = 16
_k$ = -12
_j$ = -8
_ulLeft$ = -16
_ulRight$ = -4
_t$11879 = -20
_t$11892 = -24
_t$11893 = -28
_fnQuickSort PROC NEAR

; 12833: {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
$L11877:

; 12834:    zULONG k, j, ulLeft, ulRight;
; 12835: 
; 12836:    while ( ulRecordCnt > 1 )

	cmp	DWORD PTR _ulRecordCnt$[ebp], 1
	jbe	$L11878

; 12838:       SWAP_EI( lpEI[ 0 ], lpEI[ ulRecordCnt / 2 ] );

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _t$11879[ebp], edx
	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR _t$11879[ebp]
	mov	DWORD PTR [eax], ecx

; 12839: 
; 12840:       for ( k = 0, j = ulRecordCnt; ; )

	mov	DWORD PTR _k$[ebp], 0
	mov	edx, DWORD PTR _ulRecordCnt$[ebp]
	mov	DWORD PTR _j$[ebp], edx
$L11881:

; 12842:          // Search for an EI that is "less than" lpEI[ 0 ].
; 12843:          do
; 12844:             j--;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 12845:          while ( j > 0 && fnSortCmpr( lpSortData, lpEI[ j ], lpEI[ 0 ] ) );

	cmp	DWORD PTR _j$[ebp], 0
	jbe	SHORT $L11886
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _lpSortData$[ebp]
	push	eax
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L11881
$L11886:

; 12846: 
; 12847:          // Search for an EI that is "less than" lpEI[ 0 ].
; 12848:          do
; 12849:             k++;

	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 12850:          while ( k < j && !fnSortCmpr( lpSortData, lpEI[ k ], lpEI[ 0 ] ) );

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _j$[ebp]
	jae	SHORT $L11890
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _lpSortData$[ebp]
	push	eax
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11886
$L11890:

; 12851: 
; 12852:          if ( k >= j )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _j$[ebp]
	jb	SHORT $L11891

; 12853:             break;

	jmp	SHORT $L11882
$L11891:

; 12854: 
; 12855:          SWAP_EI( lpEI[ k ], lpEI[ j ] );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _t$11892[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _t$11892[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 12856:       }

	jmp	$L11881
$L11882:

; 12857: 
; 12858:       SWAP_EI( lpEI[ j ], lpEI[ 0 ] );

	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _t$11893[ebp], ecx
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _t$11893[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 12859: 
; 12860:       ulLeft = j;

	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _ulLeft$[ebp], ecx

; 12861:       ulRight = ulRecordCnt - ++j;

	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	sub	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _ulRight$[ebp], eax

; 12862:       if ( ulLeft < ulRight )

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	cmp	ecx, DWORD PTR _ulRight$[ebp]
	jae	SHORT $L11894

; 12864:          fnQuickSort( lpSortData, lpEI, ulLeft );

	mov	edx, DWORD PTR _ulLeft$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_fnQuickSort
	add	esp, 12					; 0000000cH

; 12865: 
; 12866:          lpEI += j;

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _lpEI$[ebp], ecx

; 12867:          ulRecordCnt = ulRight;

	mov	edx, DWORD PTR _ulRight$[ebp]
	mov	DWORD PTR _ulRecordCnt$[ebp], edx

; 12869:       else

	jmp	SHORT $L11895
$L11894:

; 12871:          fnQuickSort( lpSortData, lpEI + j, ulRight );

	mov	eax, DWORD PTR _ulRight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_fnQuickSort
	add	esp, 12					; 0000000cH

; 12872:          ulRecordCnt = ulLeft;

	mov	edx, DWORD PTR _ulLeft$[ebp]
	mov	DWORD PTR _ulRecordCnt$[ebp], edx
$L11895:

; 12874: 
; 12875:    } // while ( ulRecordCnt > 1 )...

	jmp	$L11877
$L11878:

; 12876: 
; 12877: } // fnQuickSort

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnQuickSort ENDP
_TEXT	ENDS
PUBLIC	_fnBubbleSort
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI$ = 12
_ulRecordCnt$ = 16
_k$ = -8
_j$ = -4
_bSwaps$ = -12
_t$11914 = -16
_fnBubbleSort PROC NEAR

; 12883: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 12884:    zULONG k, j;
; 12885:    zBOOL  bSwaps;
; 12886: 
; 12887:    for ( k = ulRecordCnt - 1; k > 0; k-- )

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $L11907
$L11908:
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$L11907:
	cmp	DWORD PTR _k$[ebp], 0
	jbe	$L11909

; 12889:       bSwaps = FALSE;

	mov	BYTE PTR _bSwaps$[ebp], 0

; 12890: 
; 12891:       for ( j = 0; j < k; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L11910
$L11911:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L11910:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jae	SHORT $L11912

; 12893:          // If EI[ j ] is > EI[ j + 1 ] then swap them.
; 12894:          if ( fnSortCmpr( lpSortData, lpEI[ j ], lpEI[ j + 1 ] ) )

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L11913

; 12896:             bSwaps = TRUE;

	mov	BYTE PTR _bSwaps$[ebp], 1

; 12897:             SWAP_EI( lpEI[ j ], lpEI[ j + 1 ] );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR _t$11914[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4+4], edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _t$11914[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$L11913:

; 12899:       }

	jmp	SHORT $L11911
$L11912:

; 12900: 
; 12901:       // If there were no swaps then everything's in order so get out.
; 12902:       if ( bSwaps == FALSE )

	mov	eax, DWORD PTR _bSwaps$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L11915

; 12903:          break;

	jmp	SHORT $L11909
$L11915:

; 12904:    }

	jmp	$L11908
$L11909:

; 12905: 
; 12906: } // fnBubbleSort

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnBubbleSort ENDP
_TEXT	ENDS
PUBLIC	_fnOrderEntityForView@16
EXTRN	_fnGetAttribOper:NEAR
EXTRN	_fnFindLastEntityUnderParent@8:NEAR
EXTRN	_SysAllocMemory@20:NEAR
EXTRN	_SysFreeMemory@4:NEAR
_TEXT	SEGMENT
_zView$ = 8
_lpEntityInstance$ = 12
_lpViewAttrList$ = 16
_bUseBubbleSort$ = 20
_SortData$ = -60
_lpViewAttrListPtr$ = -8
_lpEI1$ = -72
_lpLastChild$ = -32
_lpLastOldChild$ = -44
_lpEIBuffer$ = -4
_lpFirstEntityInstance$ = -40
_lpLastEntityInstance$ = -28
_ulEntityCnt$ = -68
_ulFront$ = -64
_ulBack$ = -24
_k$ = -36
_hEIBuffer$ = -20
_bDerivedAttribPresent$ = -12
_nRC$ = -16
_lpCurrentTask$ = -76
_lpViewAttrib$11949 = -80
_lpView$11970 = -84
_lpViewEntityCsr$11976 = -88
_hViewEntity$11981 = -96
_lpViewEntity$11982 = -92
_lpSearch$11985 = -100
_lpViewCsr$12000 = -104
_lpViewOI$12002 = -108
_lpPrevHier$12006 = -112
_lpNextHier$12011 = -116
_fnOrderEntityForView@16 PROC NEAR

; 12925: {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H

; 12926:    SortDataRecord    SortData;
; 12927:    LPVIEWATTRLIST    lpViewAttrListPtr;
; 12928:    LPENTITYINSTANCE  lpEI1;
; 12929:    LPENTITYINSTANCE  lpLastChild;
; 12930:    LPENTITYINSTANCE  lpLastOldChild;
; 12931:    LPENTITYINSTANCE  *lpEIBuffer;
; 12932:    LPENTITYINSTANCE  lpFirstEntityInstance;
; 12933:    LPENTITYINSTANCE  lpLastEntityInstance;
; 12934:    zULONG            ulEntityCnt;
; 12935:    zULONG            ulFront, ulBack, k;
; 12936:    zLONG             hEIBuffer;
; 12937:    zBOOL             bDerivedAttribPresent = FALSE;

	mov	BYTE PTR _bDerivedAttribPresent$[ebp], 0

; 12938:    zSHORT            nRC;
; 12939: 
; 12940:    // Only used with derived attributes ...
; 12941:    LPTASK            lpCurrentTask;
; 12942: 
; 12943:    // If instance is null, there is nothing to sort ...
; 12944:    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L11942

; 12945:       return( 0 );

	xor	ax, ax
	jmp	$L11925
$L11942:

; 12946: 
; 12947:    // Error if trying to sort "unset".
; 12948:    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $L11944

; 12949:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11925
$L11944:

; 12950: 
; 12951:    lpCurrentTask = zGETPTR( zView->hTask );

	mov	eax, DWORD PTR _zView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 12952: // lpCurrentTask = fnFindTask( 0 );  // dks 2006.04.05  back to 10b
; 12953: 
; 12954:    // Scan through the view attributes for any derived attributes.
; 12955:    for ( lpViewAttrListPtr = lpViewAttrList;
; 12956:          lpViewAttrListPtr->lpViewAttrib;
; 12957:          lpViewAttrListPtr++ )

	mov	edx, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], edx
	jmp	SHORT $L11946
$L11947:
	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	add	eax, 13					; 0000000dH
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], eax
$L11946:
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L11948

; 12959:       LPVIEWATTRIB lpViewAttrib = lpViewAttrListPtr->lpViewAttrib;

	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpViewAttrib$11949[ebp], eax

; 12960: 
; 12961:       if ( lpViewAttrib->szDerivedOper[ 0 ] )

	mov	ecx, DWORD PTR _lpViewAttrib$11949[ebp]
	movsx	edx, BYTE PTR [ecx+213]
	test	edx, edx
	je	SHORT $L11950

; 12963:          bDerivedAttribPresent = TRUE;

	mov	BYTE PTR _bDerivedAttribPresent$[ebp], 1

; 12964:          lpViewAttrListPtr->pfObjectOper =
; 12965:                        fnGetAttribOper( zView, lpViewAttrib, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$11949[ebp]
	push	ecx
	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	call	_fnGetAttribOper
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	DWORD PTR [ecx+4], eax
$L11950:

; 12967:    }

	jmp	SHORT $L11947
$L11948:

; 12968: 
; 12969:    // Count the number of entities after lpEntityInstance.
; 12970:    ulEntityCnt = 1; // account for the current lpEntityInstance

	mov	DWORD PTR _ulEntityCnt$[ebp], 1

; 12971:    for ( lpLastEntityInstance = lpEntityInstance;
; 12972:          lpLastEntityInstance->hNextTwin;
; 12973:          lpLastEntityInstance = zGETPTR( lpLastEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpLastEntityInstance$[ebp], edx
	jmp	SHORT $L11952
$L11953:
	mov	eax, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastEntityInstance$[ebp], eax
$L11952:
	mov	edx, DWORD PTR _lpLastEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $L11954

; 12975:       ulEntityCnt++;

	mov	eax, DWORD PTR _ulEntityCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _ulEntityCnt$[ebp], eax

; 12976:    }

	jmp	SHORT $L11953
$L11954:

; 12977: 
; 12978:    // Add the number of entities prior to lpEntityInstance.
; 12979:    for ( lpFirstEntityInstance = lpEntityInstance;
; 12980:          lpFirstEntityInstance->hPrevTwin;
; 12981:          lpFirstEntityInstance = zGETPTR( lpFirstEntityInstance->hPrevTwin ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpFirstEntityInstance$[ebp], ecx
	jmp	SHORT $L11956
$L11957:
	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstEntityInstance$[ebp], eax
$L11956:
	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $L11958

; 12983:       ulEntityCnt++;

	mov	edx, DWORD PTR _ulEntityCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _ulEntityCnt$[ebp], edx

; 12984:    }

	jmp	SHORT $L11957
$L11958:

; 12985: 
; 12986:    // If we only have 1 entity then there's nothing to sort.
; 12987:    if ( ulEntityCnt == 1 )

	cmp	DWORD PTR _ulEntityCnt$[ebp], 1
	jne	SHORT $L11959

; 12988:       return( 0 );

	xor	ax, ax
	jmp	$L11925
$L11959:

; 12989: 
; 12990:    // Now allocate space to hold all the entity instances.
; 12991:    hEIBuffer = SysAllocMemory( (zCOREMEM) &lpEIBuffer,
; 12992:                                sizeof( LPENTITYINSTANCE ) * ulEntityCnt,
; 12993:                                0, zCOREMEM_ALLOC, 0 );

	push	0
	push	32768					; 00008000H
	push	0
	mov	eax, DWORD PTR _ulEntityCnt$[ebp]
	shl	eax, 2
	push	eax
	lea	ecx, DWORD PTR _lpEIBuffer$[ebp]
	push	ecx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hEIBuffer$[ebp], eax

; 12994: 
; 12995:    // Copy the list of entity pointers into the buffer.  We'll put all the
; 12996:    // hidden instances at the end because we don't need/want to sort them.
; 12997:    ulFront = 0;

	mov	DWORD PTR _ulFront$[ebp], 0

; 12998:    ulBack  = ulEntityCnt - 1;

	mov	edx, DWORD PTR _ulEntityCnt$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ulBack$[ebp], edx

; 12999:    for ( lpEI1 = lpFirstEntityInstance;
; 13000:          lpEI1;
; 13001:          lpEI1 = zGETPTR( lpEI1->hNextTwin ) )

	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEI1$[ebp], eax
	jmp	SHORT $L11963
$L11964:
	mov	ecx, DWORD PTR _lpEI1$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI1$[ebp], eax
$L11963:
	cmp	DWORD PTR _lpEI1$[ebp], 0
	je	SHORT $L11965

; 13003:       if ( lpEI1->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L11966

; 13004:          lpEIBuffer[ ulBack-- ] = lpEI1;  // put hidden EI at the end

	mov	edx, DWORD PTR _ulBack$[ebp]
	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR _lpEI1$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR _ulBack$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ulBack$[ebp], edx

; 13005:       else

	jmp	SHORT $L11967
$L11966:

; 13006:          lpEIBuffer[ ulFront++ ] = lpEI1;

	mov	eax, DWORD PTR _ulFront$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _ulFront$[ebp]
	add	eax, 1
	mov	DWORD PTR _ulFront$[ebp], eax
$L11967:

; 13007:    }

	jmp	SHORT $L11964
$L11965:

; 13008: 
; 13009:    // ulFront is a count of all the non-hidden EIs.  If there's only one EI
; 13010:    // then don't bother sorting.
; 13011:    if ( ulFront <= 1 )

	cmp	DWORD PTR _ulFront$[ebp], 1
	ja	SHORT $L11968

; 13013:       SysFreeMemory( hEIBuffer );

	mov	ecx, DWORD PTR _hEIBuffer$[ebp]
	push	ecx
	call	_SysFreeMemory@4

; 13014:       return( 0 );

	xor	ax, ax
	jmp	$L11925
$L11968:

; 13016: 
; 13017:    // If any derived attributes in the order keys, go set them for all of
; 13018:    // the entities now.
; 13019:    if ( bDerivedAttribPresent )

	mov	edx, DWORD PTR _bDerivedAttribPresent$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L11969

; 13021:       zVIEW lpView;
; 13022: 
; 13023:       if ( (nRC = fnDeclareView( &lpView, lpCurrentTask, zView, 0, 0 )) != 0 )

	push	0
	push	0
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpView$11970[ebp]
	push	edx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L11971

; 13025:          SysFreeMemory( hEIBuffer );

	mov	ecx, DWORD PTR _hEIBuffer$[ebp]
	push	ecx
	call	_SysFreeMemory@4

; 13026:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11925
$L11971:

; 13028: 
; 13029:       fnSetViewFromView( lpView, zView );

	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$11970[ebp]
	push	eax
	call	_fnSetViewFromView
	add	esp, 8

; 13030:       for ( lpEI1 = lpFirstEntityInstance;
; 13031:             lpEI1;
; 13032:             lpEI1 = zGETPTR( lpEI1->hNextTwin ) )

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEI1$[ebp], ecx
	jmp	SHORT $L11973
$L11974:
	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI1$[ebp], eax
$L11973:
	cmp	DWORD PTR _lpEI1$[ebp], 0
	je	$L11975

; 13034:          LPVIEWENTITYCSR   lpViewEntityCsr;
; 13035: 
; 13036:          if ( lpEI1->u.nInd.bHidden )

	mov	ecx, DWORD PTR _lpEI1$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	je	SHORT $L11977

; 13037:             continue;

	jmp	SHORT $L11974
$L11977:

; 13038: 
; 13039:          lpViewEntityCsr = fnEstablishViewForInstance( lpView, 0, lpEI1 );

	mov	eax, DWORD PTR _lpEI1$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$11970[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$11976[ebp], eax

; 13040: 
; 13041:          // Set all of the derived attributes (that are used as sort keys)
; 13042:          // for the entity instance.
; 13043:          for ( lpViewAttrListPtr = lpViewAttrList;
; 13044:                lpViewAttrListPtr->lpViewAttrib;
; 13045:                lpViewAttrListPtr++ )

	mov	edx, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], edx
	jmp	SHORT $L11978
$L11979:
	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	add	eax, 13					; 0000000dH
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], eax
$L11978:
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$L11980

; 13047:             LPVIEWENTITY hViewEntity;
; 13048:             LPVIEWENTITY lpViewEntity;
; 13049: 
; 13050:             if ( lpViewAttrListPtr->pfObjectOper == 0 )

	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $L11983

; 13051:                continue;

	jmp	SHORT $L11979
$L11983:

; 13052: 
; 13053:             // If the view entity for the sorting attribute is different
; 13054:             // from the view entity for the EI we're sorting then the attr
; 13055:             // must be from a child entity.  Make sure a child EI exists
; 13056:             // before we call the derived operation.
; 13057:             hViewEntity = lpViewAttrListPtr->lpViewAttrib->hViewEntity;

	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR _hViewEntity$11981[ebp], edx

; 13058:             if ( hViewEntity != lpEI1->hViewEntity )

	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	ecx, DWORD PTR _hViewEntity$11981[ebp]
	cmp	ecx, DWORD PTR [eax+2]
	je	SHORT $L11994

; 13060:                LPENTITYINSTANCE lpSearch;
; 13061: 
; 13062:                for ( lpSearch = zGETPTR( lpEI1->hNextHier );
; 13063:                      lpSearch;
; 13064:                      lpSearch = zGETPTR( lpSearch->hNextHier ) )

	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearch$11985[ebp], eax
	jmp	SHORT $L11988
$L11989:
	mov	ecx, DWORD PTR _lpSearch$11985[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearch$11985[ebp], eax
$L11988:
	cmp	DWORD PTR _lpSearch$11985[ebp], 0
	je	SHORT $L11990

; 13066:                   if ( lpSearch->nLevel <= lpEI1->nLevel )

	mov	eax, DWORD PTR _lpSearch$11985[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpEI1$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	jg	SHORT $L11991

; 13068:                      lpSearch = 0;

	mov	DWORD PTR _lpSearch$11985[ebp], 0

; 13069:                      break;

	jmp	SHORT $L11990
$L11991:

; 13071: 
; 13072:                   if ( lpSearch->hViewEntity == hViewEntity )

	mov	ecx, DWORD PTR _lpSearch$11985[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hViewEntity$11981[ebp]
	jne	SHORT $L11992

; 13073:                      break;

	jmp	SHORT $L11990
$L11992:

; 13074:                }

	jmp	SHORT $L11989
$L11990:

; 13075: 
; 13076:                // If lpSearch is 0 then we didn't find a child EI matching
; 13077:                // hViewEntity so don't call the derived operation.
; 13078:                if ( lpSearch == 0 )

	cmp	DWORD PTR _lpSearch$11985[ebp], 0
	jne	SHORT $L11993

; 13079:                   continue;

	jmp	$L11979
$L11993:

; 13082:                   // Establish cursor position for the child entity. (dks and DonC 2009.12.23)
; 13083:                   fnEstablishViewForInstance( lpView, 0, lpSearch );

	mov	eax, DWORD PTR _lpSearch$11985[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$11970[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
$L11994:

; 13086: 
; 13087:             lpViewEntity = zGETPTR( hViewEntity );

	mov	edx, DWORD PTR _hViewEntity$11981[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$11982[ebp], eax

; 13088: 
; 13089:             nRC = (*lpViewAttrListPtr->pfObjectOper)( lpView, lpViewEntity,
; 13090:                                                       lpViewAttrListPtr->lpViewAttrib,
; 13091:                                                       zDERIVED_GET );

	push	2
	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$11982[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$11970[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	call	DWORD PTR [ecx+4]
	mov	WORD PTR _nRC$[ebp], ax

; 13092:             if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L11996

; 13094:                SysFreeMemory( hEIBuffer );

	mov	eax, DWORD PTR _hEIBuffer$[ebp]
	push	eax
	call	_SysFreeMemory@4

; 13095:                fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$11970[ebp]
	push	ecx
	call	_fnDropView@4

; 13096:                return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11925
$L11996:

; 13098:          }

	jmp	$L11979
$L11980:

; 13099: 
; 13100:       } // for each lpEI1...

	jmp	$L11974
$L11975:

; 13101: 
; 13102:       fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$11970[ebp]
	push	edx
	call	_fnDropView@4
$L11969:

; 13105: 
; 13106:    // Set up information for sorting.
; 13107:    SortData.lpViewAttrList = lpViewAttrList;

	mov	eax, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _SortData$[ebp+4], eax

; 13108:    SortData.lpCurrentTask  = lpCurrentTask;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _SortData$[ebp], ecx

; 13109:    CreateViewFromViewForTask( &SortData.lpView1, zView, zView );

	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _SortData$[ebp+8]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 13110:    CreateViewFromViewForTask( &SortData.lpView2, zView, zView );

	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _SortData$[ebp+12]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 13111: 
; 13112:    // Call operation to sort the entity list.  We use ulFront instead of
; 13113:    // ulEntityCnt because we only want to sort the non-hidden EIs.
; 13114:    if ( bUseBubbleSort )

	mov	edx, DWORD PTR _bUseBubbleSort$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L11997

; 13115:       fnBubbleSort( &SortData, lpEIBuffer, ulFront );

	mov	eax, DWORD PTR _ulFront$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _SortData$[ebp]
	push	edx
	call	_fnBubbleSort
	add	esp, 12					; 0000000cH

; 13116:    else

	jmp	SHORT $L11998
$L11997:

; 13117:       fnQuickSort( &SortData, lpEIBuffer, ulFront );

	mov	eax, DWORD PTR _ulFront$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _SortData$[ebp]
	push	edx
	call	_fnQuickSort
	add	esp, 12					; 0000000cH
$L11998:

; 13118:    // fnHeapSort( &SortData, lpEIBuffer, ulFront );  // does not work (yet)!
; 13119: 
; 13120:    fnDropView( SortData.lpView1 );

	mov	eax, DWORD PTR _SortData$[ebp+8]
	push	eax
	call	_fnDropView@4

; 13121:    fnDropView( SortData.lpView2 );

	mov	ecx, DWORD PTR _SortData$[ebp+12]
	push	ecx
	call	_fnDropView@4

; 13122: 
; 13123:    // Subtract 1 from ulEntityCnt so it points to the last EI.  This will
; 13124:    // save us a little time later on.
; 13125:    ulEntityCnt--;

	mov	edx, DWORD PTR _ulEntityCnt$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ulEntityCnt$[ebp], edx

; 13126: 
; 13127:    //---------------------------------------------------------------------
; 13128:    // Re-arrange the EI pointers.
; 13129:    //---------------------------------------------------------------------
; 13130: 
; 13131:    // If we sorted the root instances then set the root entity instance.
; 13132:    if ( lpFirstEntityInstance->nLevel == 1 )

	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	ecx, 1
	jne	SHORT $L11999

; 13134:       LPVIEWCSR lpViewCsr = zGETPTR( zView->hViewCsr );

	mov	edx, DWORD PTR _zView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$12000[ebp], eax

; 13135:       LPVIEWOI  lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$12000[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$12002[ebp], eax

; 13136: 
; 13137:       lpViewOI->hRootEntityInstance = zGETHNDL( lpEIBuffer[ 0 ] );

	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewOI$12002[ebp]
	mov	DWORD PTR [edx+26], eax
$L11999:

; 13139: 
; 13140:    // Reset the EI pointer for the entity before the "old" first entity.
; 13141:    if ( lpFirstEntityInstance->hPrevHier )

	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $L12005

; 13143:       LPENTITYINSTANCE lpPrevHier = zGETPTR( lpFirstEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevHier$12006[ebp], eax

; 13144: 
; 13145:       // Change lpPrevHier to point to the "new" first entity.
; 13146:       lpPrevHier->hNextHier = zGETHNDL( lpEIBuffer[ 0 ] );

	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpPrevHier$12006[ebp]
	mov	DWORD PTR [edx+14], eax

; 13147: 
; 13148:       lpEIBuffer[ 0 ]->hPrevHier = lpFirstEntityInstance->hPrevHier;

	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR [ecx+18], eax

; 13150:    else

	jmp	SHORT $L12009
$L12005:

; 13151:       lpEIBuffer[ 0 ]->hPrevHier = 0;

	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+18], 0
$L12009:

; 13152: 
; 13153:    // Get the last child of the last old or "unsorted" entity.
; 13154:    lpLastOldChild = fnFindLastEntityUnderParent( lpLastEntityInstance, FALSE );

	push	0
	mov	eax, DWORD PTR _lpLastEntityInstance$[ebp]
	push	eax
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpLastOldChild$[ebp], eax

; 13155: 
; 13156:    // Get the last child for the last "sorted" entity.
; 13157:    lpLastChild = fnFindLastEntityUnderParent( lpEIBuffer[ ulEntityCnt ], FALSE );

	push	0
	mov	ecx, DWORD PTR _ulEntityCnt$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpLastChild$[ebp], eax

; 13158: 
; 13159:    // Reset the EI pointer for the entity after the "old" last entity.
; 13160:    if ( lpLastOldChild->hNextHier )

	mov	ecx, DWORD PTR _lpLastOldChild$[ebp]
	cmp	DWORD PTR [ecx+14], 0
	je	SHORT $L12010

; 13162:       LPENTITYINSTANCE lpNextHier = zGETPTR( lpLastOldChild->hNextHier );

	mov	edx, DWORD PTR _lpLastOldChild$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$12011[ebp], eax

; 13163: 
; 13164:       lpLastChild->hNextHier = lpLastOldChild->hNextHier;

	mov	ecx, DWORD PTR _lpLastChild$[ebp]
	mov	edx, DWORD PTR _lpLastOldChild$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR [ecx+14], eax

; 13165:       lpNextHier->hPrevHier = zGETHNDL( lpLastChild );

	mov	ecx, DWORD PTR _lpLastChild$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpNextHier$12011[ebp]
	mov	DWORD PTR [edx+18], eax

; 13168:    else

	jmp	SHORT $L12014
$L12010:

; 13169:       lpLastChild->hNextHier = 0;

	mov	eax, DWORD PTR _lpLastChild$[ebp]
	mov	DWORD PTR [eax+14], 0
$L12014:

; 13170: 
; 13171:    // Now we'll loop through ALL the EIs and set the
; 13172:    // PrevHier/NextHier/PrevTwin/NextTwin pointers.
; 13173:    for ( k = 0; k <= ulEntityCnt; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L12015
$L12016:
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$L12015:
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _ulEntityCnt$[ebp]
	ja	$L12017

; 13175:       // If 'k' is > 0 then we need to set up Prev pointers.
; 13176:       if ( k > 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jbe	SHORT $L12018

; 13178:          lpEIBuffer[ k ]->hPrevHier = zGETHNDL( lpLastChild );

	mov	eax, DWORD PTR _lpLastChild$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+18], eax

; 13179:          lpEIBuffer[ k ]->hPrevTwin = zGETHNDL( lpEIBuffer[ k - 1 ] );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4-4]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edx+26], eax

; 13181:       else

	jmp	SHORT $L12021
$L12018:

; 13182:          lpEIBuffer[ k ]->hPrevTwin = 0;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+26], 0
$L12021:

; 13183: 
; 13184:       // Find the last child (hierarchically) under the current EI.
; 13185:       lpLastChild = fnFindLastEntityUnderParent( lpEIBuffer[ k ], FALSE );

	push	0
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpLastChild$[ebp], eax

; 13186: 
; 13187:       // If 'k' is < ulEntityCnt then we need to set up Next pointers.
; 13188:       if ( k < ulEntityCnt )

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _ulEntityCnt$[ebp]
	jae	SHORT $L12022

; 13190:          lpEIBuffer[ k ]->hNextTwin = zGETHNDL( lpEIBuffer[ k + 1 ] );

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+22], eax

; 13191:          lpLastChild->hNextHier     = zGETHNDL( lpEIBuffer[ k + 1 ] );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpLastChild$[ebp]
	mov	DWORD PTR [edx+14], eax

; 13193:       else

	jmp	SHORT $L12025
$L12022:

; 13194:          lpEIBuffer[ k ]->hNextTwin = 0;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+22], 0
$L12025:

; 13195:    }

	jmp	$L12016
$L12017:

; 13196: 
; 13197:    SysFreeMemory( hEIBuffer );

	mov	eax, DWORD PTR _hEIBuffer$[ebp]
	push	eax
	call	_SysFreeMemory@4

; 13198: 
; 13199:    return( 0 );

	xor	ax, ax
$L11925:

; 13200: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnOrderEntityForView@16 ENDP
_TEXT	ENDS
PUBLIC	_OrderEntityForView@12
PUBLIC	??_C@_0N@CEOG@?4bubblesort?5?$AA@		; `string'
EXTRN	__imp__toupper:NEAR
EXTRN	_fnSetUpdateIndicator:NEAR
EXTRN	_fnEstablishCursorForView:NEAR
EXTRN	__chkstk:NEAR
;	COMDAT ??_C@_0N@CEOG@?4bubblesort?5?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0N@CEOG@?4bubblesort?5?$AA@ DB '.bubblesort ', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_zView$ = 8
_cpcEntityName$ = 12
_cpcOrderKeys$ = 16
_lpViewEntity$ = -13340
_lpTempViewEntity$ = -13352
_lpViewEntityCsr$ = -17472
_lpEntityInstance$ = -13336
_lpCurrentTask$ = -17468
_lpViewAttrList$ = -13320
_lpViewAttrListPtr$ = -8
_szWorkString$ = -17452
_chOrder$ = -4
_pchWSPtr$ = -17460
_pchWSBuffer$ = -13348
_pchEntityName$ = -17456
_pchAttrName$ = -17464
_pchScan$ = -13328
_bBubbleSort$ = -13356
_bAutoSeq$ = -13324
_lTemp$ = -13344
_nRC$ = -13332
_idx$12096 = -17476
_OrderEntityForView@12 PROC NEAR

; 13231: {

	push	ebp
	mov	ebp, esp
	mov	eax, 17476				; 00004444H
	call	__chkstk
	push	edi

; 13232:    LPVIEWENTITY       lpViewEntity;
; 13233:    LPVIEWENTITY       lpTempViewEntity;
; 13234:    LPVIEWENTITYCSR    lpViewEntityCsr;
; 13235:    LPENTITYINSTANCE   lpEntityInstance;
; 13236:    LPTASK             lpCurrentTask;
; 13237:    ViewAttrListRecord lpViewAttrList[ 1024 ] = {0};

	mov	DWORD PTR _lpViewAttrList$[ebp], 0
	mov	ecx, 3327				; 00000cffH
	xor	eax, eax
	lea	edi, DWORD PTR _lpViewAttrList$[ebp+4]
	rep stosd

; 13238:    LPVIEWATTRLIST     lpViewAttrListPtr = 0;

	mov	DWORD PTR _lpViewAttrListPtr$[ebp], 0

; 13239:    zCHAR              szWorkString[ 4096 ];
; 13240:    zCHAR              chOrder;
; 13241:    zPCHAR             pchWSPtr = 0;

	mov	DWORD PTR _pchWSPtr$[ebp], 0

; 13242:    zPCHAR             pchWSBuffer = 0;

	mov	DWORD PTR _pchWSBuffer$[ebp], 0

; 13243:    zPCHAR             pchEntityName;
; 13244:    zPCHAR             pchAttrName;
; 13245:    zPCHAR             pchScan;
; 13246:    zBOOL              bBubbleSort;
; 13247:    zBOOL              bAutoSeq = FALSE;

	mov	BYTE PTR _bAutoSeq$[ebp], 0

; 13248:    zLONG              lTemp;
; 13249:    zSHORT             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 13250: 
; 13251:    // Validate task and entity ... ensure entity cursor is established.
; 13252: 
; 13253:    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 13254:    if ( (lpCurrentTask = fnOperationCall( iOrderEntityForView,
; 13255:                                           zView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	push	122					; 0000007aH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L12051

; 13257:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12032
$L12051:

; 13259: 
; 13260: // TraceLine( "OrderEntityForView Entity: %s   OrderKeys: %s",
; 13261: //            cpcEntityName, cpcOrderKeys );
; 13262: 
; 13263: // SetEntityCursor( zView, cpcEntityName, 0, zPOS_FIRST, 0, 0, 0, 0, 0, 0 ); does nothing
; 13264: 
; 13265:    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13266:    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $L12052

; 13268:       fnOperationReturn( iOrderEntityForView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	122					; 0000007aH
	call	_fnOperationReturn
	add	esp, 8

; 13269:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12032
$L12052:

; 13271: 
; 13272:    if ( lpViewEntity->bAutoSeq )  // added dks 2006.07.31 because this entity may be the

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 20					; 00000014H
	and	eax, 1
	test	eax, eax
	je	SHORT $L12053

; 13273:       bAutoSeq = TRUE;            // only AutoSeq entity

	mov	BYTE PTR _bAutoSeq$[ebp], 1
$L12053:

; 13274: 
; 13275:    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 13276:    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $L12056

; 13277:       lpEntityInstance = fnEstablishCursorForView( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEstablishCursorForView
	add	esp, 4
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L12056:

; 13278: 
; 13279:    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L12057

; 13280:       goto EndOfFunction;

	jmp	$EndOfFunction$12058
$L12057:

; 13281: 
; 13282: #if 0
; 13283:    lpTempViewEntity = zGETPTR( lpEntityInstance->hViewEntity );
; 13284:    if ( lpTempViewEntity && lpTempViewEntity != lpViewEntity &&
; 13285:         lpTempViewEntity->bRecursive )
; 13286:    {
; 13287:       LPVIEWENTITY lpTempViewEntityParent = lpTempViewEntity;
; 13288: 
; 13289:       while ( lpTempViewEntityParent->hParent )
; 13290:       {
; 13291:          lpTempViewEntityParent = zGETPTR( lpTempViewEntity->hParent );
; 13292:          if ( lpTempViewEntityParent->lEREntTok == lpTempViewEntity->lEREntTok &&
; 13293:               lpTempViewEntityParent == lpViewEntity )
; 13294:          {
; 13295: #if 0
; 13296:             // Found same entity at another level.
; 13297:             fnResetCursorForViewChildren( lpViewEntityCsr );
; 13298:             lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView,
; 13299:                                               cpcEntityName, 0 );
; 13300:             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );
; 13301: #endif
; 13302:          // lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView,
; 13303:          //                                   lpTempViewEntity->szName, 0 );
; 13304:             break;
; 13305:          }
; 13306:       }
; 13307:    }
; 13308: #endif
; 13309: 
; 13310:    // Check to see if user wants a bubble sort instead of the (default)
; 13311:    // quicksort.  Note that the only reason to use a bubble sort instead of
; 13312:    // quicksort is to maintain sort order on previously sorted items.
; 13313:    // Quicksort will switch items that compare equal, bubble sort will not.
; 13314:    if ( zstrncmpi( cpcOrderKeys, ".bubblesort ", 12 ) == 0 )

	push	12					; 0000000cH
	push	OFFSET FLAT:??_C@_0N@CEOG@?4bubblesort?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _cpcOrderKeys$[ebp]
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L12059

; 13316:       bBubbleSort = TRUE;

	mov	BYTE PTR _bBubbleSort$[ebp], 1

; 13317:       cpcOrderKeys += 12;

	mov	edx, DWORD PTR _cpcOrderKeys$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _cpcOrderKeys$[ebp], edx

; 13319:    else

	jmp	SHORT $L12061
$L12059:

; 13320:       bBubbleSort = FALSE;

	mov	BYTE PTR _bBubbleSort$[ebp], 0
$L12061:

; 13321: 
; 13322:    lpViewAttrListPtr = lpViewAttrList;

	lea	eax, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], eax

; 13323: 
; 13324:    lTemp = zstrlen( cpcOrderKeys );

	mov	ecx, DWORD PTR _cpcOrderKeys$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lTemp$[ebp], eax

; 13325:    if ( lTemp > 4094 )

	cmp	DWORD PTR _lTemp$[ebp], 4094		; 00000ffeH
	jle	SHORT $L12062

; 13327:       pchWSBuffer = (zPCHAR) fnAllocDataspace( lpCurrentTask->hFirstDataHeader,
; 13328:                                                lTemp, 0, 0, iBuffer );

	push	10105					; 00002779H
	push	0
	push	0
	mov	edx, DWORD PTR _lTemp$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pchWSBuffer$[ebp], eax

; 13329:       pchWSBuffer = zGETPTR( pchWSBuffer );

	mov	edx, DWORD PTR _pchWSBuffer$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchWSBuffer$[ebp], eax

; 13330:       pchWSPtr = pchWSBuffer;

	mov	eax, DWORD PTR _pchWSBuffer$[ebp]
	mov	DWORD PTR _pchWSPtr$[ebp], eax

; 13332:    else

	jmp	SHORT $L12065
$L12062:

; 13333:       pchWSPtr = szWorkString;

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	mov	DWORD PTR _pchWSPtr$[ebp], ecx
$L12065:

; 13334: 
; 13335:    zstrcpy( pchWSPtr, cpcOrderKeys );

	mov	edx, DWORD PTR _cpcOrderKeys$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchWSPtr$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 13336: 
; 13337:    // Validate each of the attributes in the sort list.
; 13338:    for ( pchScan = pchWSPtr; *pchScan; )

	mov	ecx, DWORD PTR _pchWSPtr$[ebp]
	mov	DWORD PTR _pchScan$[ebp], ecx
$L12067:
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$L12068
$L12070:

; 13340:       // Initialize current AttrList entry ... done above at instantiation
; 13341:    // lpViewAttrListPtr->bOrder = FALSE; // order ascending by default
; 13342:    // lpViewAttrListPtr->pfObjectOper = 0;
; 13343:    // lpViewAttrListPtr->pszContextName = 0;
; 13344:    // lpViewAttrListPtr->lpViewAttrib = 0;  // this gets set for sure
; 13345: 
; 13346:       while ( *pchScan == ' ' || *pchScan == ',' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $L12072
	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	jne	SHORT $L12071
$L12072:

; 13347:          pchScan++;

	mov	edx, DWORD PTR _pchScan$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchScan$[ebp], edx
	jmp	SHORT $L12070
$L12071:

; 13348: 
; 13349:       pchAttrName = pchScan;  // save pointer to attr name

	mov	eax, DWORD PTR _pchScan$[ebp]
	mov	DWORD PTR _pchAttrName$[ebp], eax
$L12074:

; 13350:       while ( *pchScan != ' ' && *pchScan != 0 )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $L12075
	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L12075

; 13351:          pchScan++;

	mov	edx, DWORD PTR _pchScan$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchScan$[ebp], edx
	jmp	SHORT $L12074
$L12075:

; 13352: 
; 13353:       if ( *pchScan )     // if space is found,

	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L12076

; 13354:          *pchScan++ = 0;  // null terminate

	mov	edx, DWORD PTR _pchScan$[ebp]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _pchScan$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchScan$[ebp], eax
$L12076:

; 13355: 
; 13356:       if ( *pchAttrName == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L12077

; 13357:          break;

	jmp	$L12068
$L12077:

; 13358: 
; 13359:       // Check to see if the attribute name also has an entity name.  It
; 13360:       // should be seperated from the attr name by a '.'.
; 13361:       pchEntityName = zstrchr( pchAttrName, '.' );

	push	46					; 0000002eH
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchEntityName$[ebp], eax

; 13362:       if ( pchEntityName )

	cmp	DWORD PTR _pchEntityName$[ebp], 0
	je	SHORT $L12078

; 13364:          // We have an entity name.
; 13365:          *pchEntityName = 0;       // change '.' to null

	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	mov	BYTE PTR [ecx], 0

; 13366:          lpTempViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView,
; 13367:                                                pchAttrName, 0 );

	push	0
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpTempViewEntity$[ebp], eax

; 13368:          if ( lpTempViewEntity == 0 )

	cmp	DWORD PTR _lpTempViewEntity$[ebp], 0
	jne	SHORT $L12079

; 13369:             goto EndOfFunction;

	jmp	$EndOfFunction$12058
$L12079:

; 13370: 
; 13371:          // Change attr pointer to point to beginning of attr name.
; 13372:          pchAttrName = pchEntityName + 1;

	mov	edx, DWORD PTR _pchEntityName$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchAttrName$[ebp], edx

; 13374:       else

	jmp	SHORT $L12080
$L12078:

; 13376:          // No entity name specified so use default entity.
; 13377:          lpTempViewEntity = lpViewEntity;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpTempViewEntity$[ebp], eax
$L12080:

; 13379: 
; 13380:    // if ( lpTempViewEntity->bAutoSeq ) // dropped dks/don 2006.07.31 since we
; 13381:    //    bAutoSeq = TRUE;               // believe only sort entity should be considered
; 13382: 
; 13383:       lpViewAttrListPtr->lpViewAttrib =
; 13384:                 fnValidViewAttrib( zView, lpTempViewEntity, pchAttrName, 0 );

	push	0
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTempViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	DWORD PTR [ecx], eax

; 13385:       if ( lpViewAttrListPtr->lpViewAttrib == 0 )

	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L12081

; 13386:          goto EndOfFunction;

	jmp	$EndOfFunction$12058
$L12081:

; 13387: 
; 13388:       while ( *pchScan == ' ' || *pchScan == ',' )

	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $L12085
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $L12084
$L12085:

; 13389:          pchScan++;

	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
	jmp	SHORT $L12081
$L12084:

; 13390: 
; 13391:       // Is there an order character present?
; 13392:       if ( pchScan && *pchScan )

	cmp	DWORD PTR _pchScan$[ebp], 0
	je	$L12093
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$L12093

; 13394:          chOrder = ztoupper( *pchScan );

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	BYTE PTR _chOrder$[ebp], al

; 13395:          if ( (chOrder == 'A' || chOrder == 'D') &&
; 13396:               (pchScan[ 1 ] == 0 || pchScan[ 1 ] == ' ' || pchScan[ 1 ] == ',') )

	movsx	eax, BYTE PTR _chOrder$[ebp]
	cmp	eax, 65					; 00000041H
	je	SHORT $L12088
	movsx	ecx, BYTE PTR _chOrder$[ebp]
	cmp	ecx, 68					; 00000044H
	jne	SHORT $L12093
$L12088:
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	test	eax, eax
	je	SHORT $L12089
	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 32					; 00000020H
	je	SHORT $L12089
	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 44					; 0000002cH
	jne	SHORT $L12093
$L12089:

; 13398:             if ( chOrder == 'D' )

	movsx	edx, BYTE PTR _chOrder$[ebp]
	cmp	edx, 68					; 00000044H
	jne	SHORT $L12090

; 13399:                lpViewAttrListPtr->bOrder = TRUE; // order descending

	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	BYTE PTR [eax+8], 1
$L12090:

; 13400: 
; 13401:             pchScan++;

	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
$L12092:

; 13402:             while ( *pchScan == ' ' || *pchScan == ',' )

	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $L12094
	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	jne	SHORT $L12093
$L12094:

; 13403:                pchScan++;

	mov	eax, DWORD PTR _pchScan$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchScan$[ebp], eax
	jmp	SHORT $L12092
$L12093:

; 13406: 
; 13407:       // Check for a Context Name.  It should be surrounded by brackets.
; 13408:       if ( *pchScan == '[' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 91					; 0000005bH
	jne	$L12105

; 13410:          zSHORT idx = 0;

	mov	WORD PTR _idx$12096[ebp], 0

; 13411: 
; 13412:          pchScan++;   // Skip over bracket.

	mov	eax, DWORD PTR _pchScan$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchScan$[ebp], eax
$L12098:

; 13413:          while ( *pchScan == ' ' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $L12099

; 13414:             pchScan++;

	mov	eax, DWORD PTR _pchScan$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchScan$[ebp], eax
	jmp	SHORT $L12098
$L12099:

; 13415: 
; 13416:          if ( *pchScan != ']' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 93					; 0000005dH
	je	SHORT $L12100

; 13417:             lpViewAttrListPtr->pszContextName = pchScan;

	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	ecx, DWORD PTR _pchScan$[ebp]
	mov	DWORD PTR [eax+9], ecx
$L12100:

; 13418: 
; 13419:          while ( *pchScan && *pchScan != ']' )

	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L12103
	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 93					; 0000005dH
	je	SHORT $L12103

; 13421:             // If we find a space we'll convert it into a null-terminator.
; 13422:             // This will cause us to ignore trailing spaces.
; 13423:             if ( *pchScan == ' ' )

	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $L12104

; 13424:                *pchScan = 0;

	mov	edx, DWORD PTR _pchScan$[ebp]
	mov	BYTE PTR [edx], 0
$L12104:

; 13425: 
; 13426:             pchScan++;

	mov	eax, DWORD PTR _pchScan$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchScan$[ebp], eax

; 13427:          }

	jmp	SHORT $L12100
$L12103:

; 13428: 
; 13429:          // If we found a closing bracket (only other possiblity is a 0) then
; 13430:          // change it to a null-terminator and skip to next char.
; 13431:          if ( *pchScan == ']' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 93					; 0000005dH
	jne	SHORT $L12105

; 13432:             *pchScan++ = 0;

	mov	eax, DWORD PTR _pchScan$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
$L12105:

; 13434: 
; 13435:       lpViewAttrListPtr++;

	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	add	edx, 13					; 0000000dH
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], edx

; 13436: 
; 13437:    } // for ( pchScan = pchWSPtr; *pchScan; )

	jmp	$L12067
$L12068:

; 13438: 
; 13439:    // Initialize last AttrList entry ... done above at instantiation
; 13440: // lpViewAttrListPtr->lpViewAttrib = 0;
; 13441: 
; 13442:    // Call the actual sort routine.
; 13443:    nRC = fnOrderEntityForView( zView, lpEntityInstance,
; 13444:                                lpViewAttrList, bBubbleSort );

	mov	al, BYTE PTR _bBubbleSort$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewAttrList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	call	_fnOrderEntityForView@16
	mov	WORD PTR _nRC$[ebp], ax

; 13445: 
; 13446:    if ( nRC != zCALL_ERROR && bAutoSeq )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	je	SHORT $EndOfFunction$12058
	mov	edx, DWORD PTR _bAutoSeq$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $EndOfFunction$12058

; 13448:       fnSetUpdateIndicator( 0, lpEntityInstance, 0, TRUE, TRUE, TRUE );

	push	1
	push	1
	push	1
	push	0
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H
$EndOfFunction$12058:

; 13450: 
; 13451: EndOfFunction:
; 13452: 
; 13453:    if ( pchWSBuffer )

	cmp	DWORD PTR _pchWSBuffer$[ebp], 0
	je	SHORT $L12107

; 13454:       fnFreeDataspace( pchWSBuffer );   // free work area

	mov	ecx, DWORD PTR _pchWSBuffer$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4
$L12107:

; 13455: 
; 13456:    fnOperationReturn( iOrderEntityForView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	122					; 0000007aH
	call	_fnOperationReturn
	add	esp, 8

; 13457:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L12032:

; 13458: }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_OrderEntityForView@12 ENDP
_TEXT	ENDS
PUBLIC	_fnGetSortAttrsFromEntity@16
PUBLIC	??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@ ; `string'
PUBLIC	??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ ; `string'
PUBLIC	??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@	; `string'
;	COMDAT ??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@ DB 'Maximum # of'
	DB	' order attributes used', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@
_DATA	SEGMENT
??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ DB 'KZOEE013 - Inte'
	DB	'rnal operation call error: ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@
_DATA	SEGMENT
??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@ DB 'fnOrderOI_ByDefaultAttr'
	DB	'ibs', 00H					; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_plAttribCnt$ = 12
_lpAttribList$ = 16
_lpViewEntity$ = 20
_lpViewAttrib$ = -4
_nSeq$12127 = -8
_lpTask$12129 = -12
_fnGetSortAttrsFromEntity@16 PROC NEAR

; 13470: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 13471:    LPVIEWATTRIB lpViewAttrib;
; 13472: 
; 13473:    // Loop through all the view attribs looking for default sorting attribs.
; 13474:    // When one is found, add it to the attrib list.
; 13475:    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 13476:          lpViewAttrib;
; 13477:          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L12121
$L12122:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L12121:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L12123

; 13479:       if ( lpViewAttrib->bAutoSeq )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	je	SHORT $L12124

; 13481:          *plAttribCnt = 1;

	mov	eax, DWORD PTR _plAttribCnt$[ebp]
	mov	DWORD PTR [eax], 1

; 13482:          lpAttribList[ 0 ].lpViewAttrib = lpViewAttrib;

	mov	ecx, DWORD PTR _lpAttribList$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx], edx

; 13483:          lpAttribList[ 0 ].bOrder = FALSE;

	mov	eax, DWORD PTR _lpAttribList$[ebp]
	mov	BYTE PTR [eax+8], 0

; 13484: 
; 13485:          // Make sure next attrib is 0.
; 13486:          lpAttribList[ 1 ].lpViewAttrib = 0;

	mov	ecx, DWORD PTR _lpAttribList$[ebp]
	mov	DWORD PTR [ecx+13], 0

; 13487: 
; 13488:          return( 1 ); // There is only 1 autoseq attr per entity, so return.

	mov	ax, 1
	jmp	$L12117
$L12124:

; 13490:       else
; 13491:       if ( lpViewAttrib->cSequencing > 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+197]
	test	eax, eax
	jle	$L12135

; 13493:          zSHORT nSeq;
; 13494: 
; 13495:          nSeq = lpViewAttrib->cSequencing;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movzx	dx, BYTE PTR [ecx+197]
	mov	WORD PTR _nSeq$12127[ebp], dx

; 13496:          if ( nSeq >= MAX_SEQ_ATTS )

	movsx	eax, WORD PTR _nSeq$12127[ebp]
	cmp	eax, 20					; 00000014H
	jl	SHORT $L12128

; 13498:             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$12129[ebp], eax

; 13499:             // "KZOEE013 - Internal operation call error"
; 13500:             TraceLineS( "KZOEE013 - Internal operation call error: ",
; 13501:                         "Maximum # of order attributes used" );

	push	OFFSET FLAT:??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@ ; `string'
	push	OFFSET FLAT:??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ ; `string'
	call	_TraceLineS@8

; 13502:             fnIssueCoreError( lpTask, lpView, 16, 13, 0,
; 13503:                               "Maximum # of order attributes used",
; 13504:                               "fnOrderOI_ByDefaultAttribs" );

	push	OFFSET FLAT:??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@ ; `string'
	push	0
	push	13					; 0000000dH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$12129[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13505:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L12117
$L12128:

; 13507: 
; 13508:          if ( *plAttribCnt < nSeq )

	movsx	edx, WORD PTR _nSeq$12127[ebp]
	mov	eax, DWORD PTR _plAttribCnt$[ebp]
	cmp	DWORD PTR [eax], edx
	jge	SHORT $L12134

; 13509:             *plAttribCnt = nSeq;

	movsx	ecx, WORD PTR _nSeq$12127[ebp]
	mov	edx, DWORD PTR _plAttribCnt$[ebp]
	mov	DWORD PTR [edx], ecx
$L12134:

; 13510: 
; 13511:          lpAttribList[ nSeq - 1 ].lpViewAttrib = lpViewAttrib;

	movsx	eax, WORD PTR _nSeq$12127[ebp]
	sub	eax, 1
	imul	eax, 13					; 0000000dH
	mov	ecx, DWORD PTR _lpAttribList$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 13512:          if ( lpViewAttrib->bSequencingD )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L12135

; 13513:             lpAttribList[ nSeq - 1 ].bOrder = TRUE;

	movsx	edx, WORD PTR _nSeq$12127[ebp]
	sub	edx, 1
	imul	edx, 13					; 0000000dH
	mov	eax, DWORD PTR _lpAttribList$[ebp]
	mov	BYTE PTR [eax+edx+8], 1
$L12135:

; 13515:    } // for ( lpViewAttrib )...

	jmp	$L12122
$L12123:

; 13516: 
; 13517:    return( 0 );

	xor	ax, ax
$L12117:

; 13518: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnGetSortAttrsFromEntity@16 ENDP
_TEXT	ENDS
PUBLIC	_fnOrderOI_ByDefaultAttribs
PUBLIC	??_C@_0BK@NHNF@Out?5of?5space?5for?5entities?$AA@ ; `string'
PUBLIC	??_C@_0CB@LCPB@Maximum?5?$CD?5of?5order?5entities?5used@ ; `string'
;	COMDAT ??_C@_0BK@NHNF@Out?5of?5space?5for?5entities?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BK@NHNF@Out?5of?5space?5for?5entities?$AA@ DB 'Out of space for en'
	DB	'tities', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@LCPB@Maximum?5?$CD?5of?5order?5entities?5used@
_DATA	SEGMENT
??_C@_0CB@LCPB@Maximum?5?$CD?5of?5order?5entities?5used@ DB 'Maximum # of'
	DB	' order entities used', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_EntityList$ = -820
_lpViewCsr$ = -4
_lpViewOI$ = -828
_lpEntityInstance$ = -16
_lpViewEntity$ = -20
_AttribList$ = -1088
_lEntityCnt$ = -8
_k$ = -824
_nRC$ = -12
_lpPrevHier$12160 = -1092
_lAttribCnt$12170 = -1096
_lpTask$12172 = -1100
_lpSrchViewEntity$12179 = -1104
_nChildLevel$12185 = -1108
_fnOrderOI_ByDefaultAttribs PROC NEAR

; 13535: {

	push	ebp
	mov	ebp, esp
	sub	esp, 1108				; 00000454H

; 13536:    struct EntityListStruct
; 13537:    {
; 13538:       LPVIEWENTITY   lpViewEntity;
; 13539:       LPVIEWATTRLIST lpPtr;
; 13540:    } EntityList[ MAX_SEQ_ENTS ];
; 13541: 
; 13542:    LPVIEWCSR          lpViewCsr;
; 13543:    LPVIEWOI           lpViewOI;
; 13544:    LPENTITYINSTANCE   lpEntityInstance;
; 13545:    LPVIEWENTITY       lpViewEntity;
; 13546:    ViewAttrListRecord AttribList[ MAX_SEQ_ATTS ];
; 13547:    zLONG              lEntityCnt;
; 13548:    zLONG              k;
; 13549:    zSHORT             nRC;
; 13550: 
; 13551:    // Fill EntityList with zeros.
; 13552:    zmemset( (zPVOID) EntityList, 0,
; 13553:             sizeof( struct EntityListStruct ) * MAX_SEQ_ENTS );

	push	800					; 00000320H
	push	0
	lea	eax, DWORD PTR _EntityList$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 13554:    lEntityCnt = 0;

	mov	DWORD PTR _lEntityCnt$[ebp], 0

; 13555: 
; 13556:    lpViewCsr        = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 13557:    lpViewOI         = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 13558: 
; 13559:    // For each of the entity instances, sort all groups of twin entities if
; 13560:    // the entity instance is the first twin.
; 13561:    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 13562:          lpEntityInstance;
; 13563:          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L12157
$L12158:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L12157:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L12159

; 13565:       LPENTITYINSTANCE lpPrevHier;
; 13566: 
; 13567:       // Sort the group of entity instances if:
; 13568:       //    o  The entity instance is supposed to be sorted AND
; 13569:       //    o  The entity instance is the first twin (prev twin == 0) AND
; 13570:       //    o  There are more than 1 twins (next twin != 0).
; 13571: 
; 13572:       // If EI has a prev twin then it's not the first twin so don't bother
; 13573:       // sorting.
; 13574:       if ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L12161

; 13575:          continue;

	jmp	SHORT $L12158
$L12161:

; 13576: 
; 13577:       // If next twin is NULL then there is only one EI so there's nothing to
; 13578:       // sort.
; 13579:       if ( lpEntityInstance->hNextTwin == 0 )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	jne	SHORT $L12162

; 13580:          continue;

	jmp	SHORT $L12158
$L12162:

; 13581: 
; 13582:       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13583: 
; 13584:       // If this entity doesn't have sorting attributes then skip it.
; 13585:       if ( lpViewEntity->bAutoSeq == FALSE && lpViewEntity->bAttrOrder == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 20					; 00000014H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L12164
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 18					; 00000012H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L12164

; 13586:          continue;

	jmp	SHORT $L12158
$L12164:

; 13587: 
; 13588:       // If we get here then we're going to sort the twins.  Save the prev
; 13589:       // hier EI of the current EI.  Once we are done sorting the EIs we can
; 13590:       // quickly find the first twin by using the prev hier ptr.
; 13591:       lpPrevHier = zGETPTR( lpEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevHier$12160[ebp], eax

; 13592: 
; 13593:       // First check to see if this lpViewEntity has been sorted already.
; 13594:       // If it has, then we already have the list of default sort attribs.
; 13595:       k = 0;

	mov	DWORD PTR _k$[ebp], 0
$L12167:

; 13596:       while ( EntityList[ k ].lpViewEntity != lpViewEntity && k < lEntityCnt )

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _EntityList$[ebp+ecx*8]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $L12168
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _lEntityCnt$[ebp]
	jge	SHORT $L12168

; 13597:          k++;

	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
	jmp	SHORT $L12167
$L12168:

; 13598: 
; 13599:       // If k == lEntityCnt, then lpViewEntity has not been sorted yet.
; 13600:       // Go through each of the lpViewAttribs for the lpViewEntity and
; 13601:       // find all default sort attributes.
; 13602:       if ( k == lEntityCnt )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _lEntityCnt$[ebp]
	jne	$L12169

; 13604:          zLONG  lAttribCnt;
; 13605: 
; 13606:          // If k >= MAX_SEQ_ENTS, then we have run out of space for entities.
; 13607:          if ( k >= MAX_SEQ_ENTS )

	cmp	DWORD PTR _k$[ebp], 100			; 00000064H
	jl	SHORT $L12171

; 13609:             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$12172[ebp], eax

; 13610:             // "KZOEE013 - Internal operation call error"
; 13611:             TraceLineS( "KZOEE013 - Internal operation call error: ",
; 13612:                         "Out of space for entities" );

	push	OFFSET FLAT:??_C@_0BK@NHNF@Out?5of?5space?5for?5entities?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ ; `string'
	call	_TraceLineS@8

; 13613:             fnIssueCoreError( lpTask, lpView, 16, 13, 0,
; 13614:                               "Maximum # of order entities used",
; 13615:                               "fnOrderOI_ByDefaultAttribs" );

	push	OFFSET FLAT:??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CB@LCPB@Maximum?5?$CD?5of?5order?5entities?5used@ ; `string'
	push	0
	push	13					; 0000000dH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$12172[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13616:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12138
$L12171:

; 13618: 
; 13619:          // Zero out attribute list.
; 13620:          lAttribCnt = 0;

	mov	DWORD PTR _lAttribCnt$12170[ebp], 0

; 13621:          zmemset( (zPVOID) AttribList, 0,
; 13622:                   sizeof( ViewAttrListRecord ) * MAX_SEQ_ATTS );

	push	260					; 00000104H
	push	0
	lea	ecx, DWORD PTR _AttribList$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 13623: 
; 13624:          // Find all the sorting attributes and add them to AttribList.
; 13625:          nRC = fnGetSortAttrsFromEntity( lpView, &lAttribCnt, AttribList,
; 13626:                                          lpViewEntity );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _AttribList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lAttribCnt$12170[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnGetSortAttrsFromEntity@16
	mov	WORD PTR _nRC$[ebp], ax

; 13627: 
; 13628:          // If nRC != 0 then sorting is done by using autosequencing fields
; 13629:          // and there can be only one autoseq field per entity.  Otherwise
; 13630:          // check to see if the entity is sorted using child attributes and
; 13631:          // if so then add them to AttribList.
; 13632:          if ( nRC == 0 && lpViewEntity->bAttrOrderChild )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L12183
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 19					; 00000013H
	and	edx, 1
	test	edx, edx
	je	$L12183

; 13634:             LPVIEWENTITY lpSrchViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$12179[ebp], eax
$L12182:

; 13635: 
; 13636:             while ( lpSrchViewEntity &&
; 13637:                     lpSrchViewEntity->nLevel > lpViewEntity->nLevel )

	cmp	DWORD PTR _lpSrchViewEntity$12179[ebp], 0
	je	$L12183
	mov	edx, DWORD PTR _lpSrchViewEntity$12179[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jle	$L12183

; 13639:                // We can only sort using children that have a max cardinality
; 13640:                // of 1.  If it's greater than 1 then we can ignore it and all
; 13641:                // it's children.
; 13642:                if ( lpSrchViewEntity->uCardMax > 1 )

	mov	eax, DWORD PTR _lpSrchViewEntity$12179[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+221]
	cmp	ecx, 1
	jle	SHORT $L12184

; 13644:                   zSHORT nChildLevel;
; 13645: 
; 13646:                   // Entity doesn't have a twin so use next hier pointers to
; 13647:                   // skip the children.
; 13648:                   nChildLevel = lpSrchViewEntity->nLevel;

	mov	edx, DWORD PTR _lpSrchViewEntity$12179[ebp]
	mov	ax, WORD PTR [edx+215]
	mov	WORD PTR _nChildLevel$12185[ebp], ax

; 13649:                   for ( lpSrchViewEntity = zGETPTR( lpSrchViewEntity->hNextHier );
; 13650:                         lpSrchViewEntity;
; 13651:                         lpSrchViewEntity = zGETPTR( lpSrchViewEntity->hNextHier ) )

	mov	ecx, DWORD PTR _lpSrchViewEntity$12179[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$12179[ebp], eax
	jmp	SHORT $L12188
$L12189:
	mov	eax, DWORD PTR _lpSrchViewEntity$12179[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$12179[ebp], eax
$L12188:
	cmp	DWORD PTR _lpSrchViewEntity$12179[ebp], 0
	je	SHORT $L12190

; 13653:                      if ( lpSrchViewEntity->nLevel > nChildLevel )

	mov	edx, DWORD PTR _lpSrchViewEntity$12179[ebp]
	movsx	eax, WORD PTR [edx+215]
	movsx	ecx, WORD PTR _nChildLevel$12185[ebp]
	cmp	eax, ecx
	jle	SHORT $L12191

; 13654:                         break;

	jmp	SHORT $L12190
$L12191:

; 13655:                   }

	jmp	SHORT $L12189
$L12190:

; 13656: 
; 13657:                   continue;

	jmp	$L12182
$L12184:

; 13659: 
; 13660:                // If we get here then the max card is 1.
; 13661:                fnGetSortAttrsFromEntity( lpView, &lAttribCnt, AttribList,
; 13662:                                          lpSrchViewEntity );

	mov	edx, DWORD PTR _lpSrchViewEntity$12179[ebp]
	push	edx
	lea	eax, DWORD PTR _AttribList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lAttribCnt$12170[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnGetSortAttrsFromEntity@16

; 13663: 
; 13664:                lpSrchViewEntity = zGETPTR( lpSrchViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpSrchViewEntity$12179[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$12179[ebp], eax

; 13665: 
; 13666:             } // while...

	jmp	$L12182
$L12183:

; 13669: 
; 13670:          // Allocate space to hold the attribute list.  We use
; 13671:          // "lAttribCnt + 1" to allocate space for the NULL attribute.
; 13672:          EntityList[ k ].lpPtr = (LPVIEWATTRLIST)
; 13673:                    fnAllocDataspace( ((LPTASK) zGETPTR (lpView->hTask))->hFirstDataHeader,
; 13674:                                      (sizeof( ViewAttrListRecord ) * (zULONG)
; 13675:                                         (lAttribCnt + 1)), 0, 0, iBuffer );

	push	10105					; 00002779H
	push	0
	push	0
	mov	edx, DWORD PTR _lAttribCnt$12170[ebp]
	add	edx, 1
	imul	edx, 13					; 0000000dH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR [eax+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _EntityList$[ebp+ecx*8+4], eax

; 13676:          if ( EntityList[ k ].lpPtr == 0 )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	DWORD PTR _EntityList$[ebp+edx*8+4], 0
	jne	SHORT $L12198

; 13677:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12138
$L12198:

; 13678: 
; 13679:          EntityList[ k ].lpPtr = zGETPTR( EntityList[ k ].lpPtr );

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _EntityList$[ebp+eax*8+4]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _EntityList$[ebp+edx*8+4], eax

; 13680: 
; 13681:          // Copy attribute list + NULL attribute to entity list.
; 13682:          zmemcpy( (zPVOID) EntityList[ k ].lpPtr, (zPVOID) AttribList,
; 13683:                   sizeof( ViewAttrListRecord ) * (lAttribCnt + 1) );

	mov	eax, DWORD PTR _lAttribCnt$12170[ebp]
	add	eax, 1
	imul	eax, 13					; 0000000dH
	push	eax
	lea	ecx, DWORD PTR _AttribList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _EntityList$[ebp+edx*8+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 13684:          EntityList[ k ].lpViewEntity = lpViewEntity;

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _EntityList$[ebp+ecx*8], edx

; 13685: 
; 13686:          lEntityCnt++;

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _lEntityCnt$[ebp], eax
$L12169:

; 13689: 
; 13690:       nRC = fnOrderEntityForView( lpView, lpEntityInstance,
; 13691:                                   EntityList[ k ].lpPtr, FALSE );

	push	0
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _EntityList$[ebp+ecx*8+4]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnOrderEntityForView@16
	mov	WORD PTR _nRC$[ebp], ax

; 13692:       if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $L12203

; 13694:          for ( k = 0; k < lEntityCnt; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L12204
$L12205:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$L12204:
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _lEntityCnt$[ebp]
	jge	SHORT $L12206

; 13695:             fnFreeDataspace( EntityList[ k ].lpPtr );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _EntityList$[ebp+edx*8+4]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	jmp	SHORT $L12205
$L12206:

; 13696: 
; 13697:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L12138
$L12203:

; 13699: 
; 13700:       // Set lpEntityInstance to be the first twin in its particular group.
; 13701:       if ( lpPrevHier )

	cmp	DWORD PTR _lpPrevHier$12160[ebp], 0
	je	SHORT $L12207

; 13702:          lpEntityInstance = zGETPTR( lpPrevHier->hNextHier );

	mov	ecx, DWORD PTR _lpPrevHier$12160[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 13703:       else

	jmp	SHORT $L12209
$L12207:

; 13704:          lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L12209:

; 13705: 
; 13706:    } // for ( lpEntityInstance )...

	jmp	$L12158
$L12159:

; 13707: 
; 13708:    for ( k = 0; k < lEntityCnt; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L12211
$L12212:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$L12211:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _lEntityCnt$[ebp]
	jge	SHORT $L12213

; 13709:       fnFreeDataspace( EntityList[ k ].lpPtr );

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _EntityList$[ebp+ecx*8+4]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
	jmp	SHORT $L12212
$L12213:

; 13710: 
; 13711:    return( 0 );

	xor	ax, ax
$L12138:

; 13712: 
; 13713: } // fnOrderOI_ByDefaultAttribs

	mov	esp, ebp
	pop	ebp
	ret	0
_fnOrderOI_ByDefaultAttribs ENDP
_TEXT	ENDS
PUBLIC	_OrderOI_ByDefaultAttribs@4
_TEXT	SEGMENT
_lpView$ = 8
_lpCurrentTask$ = -12
_lpViewOD$ = -4
_nRC$ = -8
_OrderOI_ByDefaultAttribs@4 PROC NEAR

; 13734: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 13735:    LPTASK            lpCurrentTask;
; 13736:    LPVIEWOD          lpViewOD;
; 13737:    zSHORT            nRC;
; 13738: 
; 13739:    // validate some stuff
; 13740: 
; 13741:    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 13742:    if ( (lpCurrentTask = fnOperationCall( iOrderOI_ByDefaultAttribs,
; 13743:                                            lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	125					; 0000007dH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L12220

; 13745:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L12216
$L12220:

; 13747: 
; 13748:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 13749:    if ( lpViewOD->bAutoSeq == FALSE )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L12222

; 13750:       nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1

; 13751:    else

	jmp	SHORT $L12223
$L12222:

; 13752:       nRC = fnOrderOI_ByDefaultAttribs( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnOrderOI_ByDefaultAttribs
	add	esp, 4
	mov	WORD PTR _nRC$[ebp], ax
$L12223:

; 13753: 
; 13754:    fnOperationReturn( iOrderOI_ByDefaultAttribs, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	125					; 0000007dH
	call	_fnOperationReturn
	add	esp, 8

; 13755:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L12216:

; 13756: 
; 13757: } // OrderOI_ByDefaultAttribs

	mov	esp, ebp
	pop	ebp
	ret	4
_OrderOI_ByDefaultAttribs@4 ENDP
_TEXT	ENDS
PUBLIC	_fnOrderEntitiesByDefaultAttribs
PUBLIC	??_C@_0BG@KEBP@Sequencing?5error?5?$DO?540?$AA@	; `string'
PUBLIC	??_C@_0CA@OIFL@fnOrderEntitiesByDefaultAttribs?$AA@ ; `string'
;	COMDAT ??_C@_0BG@KEBP@Sequencing?5error?5?$DO?540?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BG@KEBP@Sequencing?5error?5?$DO?540?$AA@ DB 'Sequencing error > 40'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@OIFL@fnOrderEntitiesByDefaultAttribs?$AA@
_DATA	SEGMENT
??_C@_0CA@OIFL@fnOrderEntitiesByDefaultAttribs?$AA@ DB 'fnOrderEntitiesBy'
	DB	'DefaultAttribs', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_lpEntityInstance$ = 12
_AttribList$ = -540
_lpViewEntity$ = -12
_lpTopViewEntity$ = -16
_lpViewAttrib$ = -20
_lAttribCnt$ = -4
_nRC$ = -8
_nSeq$12254 = -544
_lpTask$12257 = -548
_fnOrderEntitiesByDefaultAttribs PROC NEAR

; 13775: {

	push	ebp
	mov	ebp, esp
	sub	esp, 548				; 00000224H
$L12236:

; 13776:    ViewAttrListRecord AttribList[ 40 ]; // Max 40 attribs for sorting.
; 13777:    LPVIEWENTITY       lpViewEntity;
; 13778:    LPVIEWENTITY       lpTopViewEntity;
; 13779:    LPVIEWATTRIB       lpViewAttrib;
; 13780:    zLONG              lAttribCnt;
; 13781:    zSHORT             nRC;
; 13782: 
; 13783:    // Find first twin of lpEntityInstance.
; 13784:    while ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L12237

; 13785:       lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L12236
$L12237:

; 13786: 
; 13787:    lpTopViewEntity = lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpTopViewEntity$[ebp], edx

; 13788: 
; 13789:    // Sort the group of entity instances if:
; 13790:    //   - The entity instance is supposed to be sorted AND
; 13791:    //   - There are more than 1 twins (next twin != 0).
; 13792:    if ( lpViewEntity->bAttrOrder == FALSE && lpViewEntity->bAutoSeq == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 18					; 00000012H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L12240
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 20					; 00000014H
	and	eax, 1
	test	eax, eax
	jne	SHORT $L12240

; 13793:       return( 0 ); // No sorting for entity.

	xor	ax, ax
	jmp	$L12228
$L12240:

; 13794: 
; 13795:    if ( lpEntityInstance->hNextTwin == 0 )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	jne	SHORT $L12241

; 13796:       return( 0 ); // Nothing to sort.

	xor	ax, ax
	jmp	$L12228
$L12241:

; 13797: 
; 13798:    zmemset( (zPVOID) AttribList, 0, sizeof( ViewAttrListRecord ) * 40 );

	push	520					; 00000208H
	push	0
	lea	edx, DWORD PTR _AttribList$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 13799:    lAttribCnt = 0;

	mov	DWORD PTR _lAttribCnt$[ebp], 0

; 13800: 
; 13801:    // Loop through all the attributes for the current entity and possibly
; 13802:    // loop through the attrs for child entities.
; 13803:    for ( ;
; 13804:          lpViewEntity->nLevel > lpTopViewEntity->nLevel ||
; 13805:             lpViewEntity == lpTopViewEntity;
; 13806:          lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	jmp	SHORT $L12245
$L12246:
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$L12245:
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpTopViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jg	SHORT $L12248
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	eax, DWORD PTR _lpTopViewEntity$[ebp]
	jne	$L12247
$L12248:

; 13808:       for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 13809:             lpViewAttrib;
; 13810:             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L12251
$L12252:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L12251:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L12253

; 13812:          zSHORT nSeq;
; 13813: 
; 13814:          // Forget about it if no sequencing value.
; 13815:          if ( lpViewAttrib->cSequencing == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+197]
	test	eax, eax
	jne	SHORT $L12255

; 13816:             continue;

	jmp	SHORT $L12252
$L12255:

; 13817: 
; 13818:          nSeq = lpViewAttrib->cSequencing;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movzx	dx, BYTE PTR [ecx+197]
	mov	WORD PTR _nSeq$12254[ebp], dx

; 13819:          if ( nSeq > 40 )

	movsx	eax, WORD PTR _nSeq$12254[ebp]
	cmp	eax, 40					; 00000028H
	jle	SHORT $L12256

; 13821:             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$12257[ebp], eax

; 13822:             // "KZOEE013 - Internal operation call error"
; 13823:             TraceLineS( "KZOEE013 - Internal operation call error: ",
; 13824:                         "Sequencing error > 40" );

	push	OFFSET FLAT:??_C@_0BG@KEBP@Sequencing?5error?5?$DO?540?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ ; `string'
	call	_TraceLineS@8

; 13825:             fnIssueCoreError( lpTask, lpView, 16, 13, 0,
; 13826:                               "Maximum # of order attributes used",
; 13827:                               "fnOrderEntitiesByDefaultAttribs" );

	push	OFFSET FLAT:??_C@_0CA@OIFL@fnOrderEntitiesByDefaultAttribs?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@ ; `string'
	push	0
	push	13					; 0000000dH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$12257[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13828:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12228
$L12256:

; 13830: 
; 13831:          if ( lAttribCnt < nSeq )

	movsx	edx, WORD PTR _nSeq$12254[ebp]
	cmp	DWORD PTR _lAttribCnt$[ebp], edx
	jge	SHORT $L12261

; 13832:             lAttribCnt = nSeq;

	movsx	eax, WORD PTR _nSeq$12254[ebp]
	mov	DWORD PTR _lAttribCnt$[ebp], eax
$L12261:

; 13833: 
; 13834:          AttribList[ nSeq - 1 ].lpViewAttrib = lpViewAttrib;

	movsx	ecx, WORD PTR _nSeq$12254[ebp]
	sub	ecx, 1
	imul	ecx, 13					; 0000000dH
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _AttribList$[ebp+ecx], edx

; 13835:          if ( lpViewAttrib->bSequencingD )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L12262

; 13836:             AttribList[ nSeq - 1 ].bOrder = TRUE;

	movsx	edx, WORD PTR _nSeq$12254[ebp]
	sub	edx, 1
	imul	edx, 13					; 0000000dH
	mov	BYTE PTR _AttribList$[ebp+edx+8], 1
$L12262:

; 13837: 
; 13838:       } // for ( lpViewAttrib )...

	jmp	$L12252
$L12253:

; 13839: 
; 13840:       // If the top level entity isn't ordered by child entity attributes then
; 13841:       // we can break this loop.
; 13842:       if ( lpTopViewEntity->bAttrOrderChild == FALSE )

	mov	eax, DWORD PTR _lpTopViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 19					; 00000013H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L12263

; 13843:          break;

	jmp	SHORT $L12247
$L12263:

; 13844: 
; 13845:    } // for ( lpViewEntity )...

	jmp	$L12246
$L12247:

; 13846: 
; 13847:    if ( lAttribCnt > 0 )

	cmp	DWORD PTR _lAttribCnt$[ebp], 0
	jle	SHORT $L12265

; 13849:       nRC = fnOrderEntityForView( lpView, lpEntityInstance, AttribList, FALSE );

	push	0
	lea	edx, DWORD PTR _AttribList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnOrderEntityForView@16
	mov	WORD PTR _nRC$[ebp], ax

; 13850:       if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $L12265

; 13851:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L12228
$L12265:

; 13853: 
; 13854:    return( 0 );

	xor	ax, ax
$L12228:

; 13855: 
; 13856: } // fnOrderEntitiesByDefaultAttribs

	mov	esp, ebp
	pop	ebp
	ret	0
_fnOrderEntitiesByDefaultAttribs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@GNIP@OrderEntities?$AA@		; `string'
PUBLIC	??_C@_0CO@OBEN@Ordering?5attributes?5?9?9?5Entity?5cu@ ; `string'
PUBLIC	_OrderEntitiesByDefaultAttribs@8
PUBLIC	??_C@_0DA@BDHH@Ordering?5attributes?5?9?9?5resetting@ ; `string'
PUBLIC	??_C@_0BF@KJKO@Unset?5or?5Null?5Cursor?$AA@	; `string'
;	COMDAT ??_C@_0DA@BDHH@Ordering?5attributes?5?9?9?5resetting@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0DA@BDHH@Ordering?5attributes?5?9?9?5resetting@ DB 'Ordering attrib'
	DB	'utes -- resetting entity cursor.', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@KJKO@Unset?5or?5Null?5Cursor?$AA@
_DATA	SEGMENT
??_C@_0BF@KJKO@Unset?5or?5Null?5Cursor?$AA@ DB 'Unset or Null Cursor', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@GNIP@OrderEntities?$AA@
_DATA	SEGMENT
??_C@_0O@GNIP@OrderEntities?$AA@ DB 'OrderEntities', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CO@OBEN@Ordering?5attributes?5?9?9?5Entity?5cu@
_DATA	SEGMENT
??_C@_0CO@OBEN@Ordering?5attributes?5?9?9?5Entity?5cu@ DB 'Ordering attri'
	DB	'butes -- Entity cursor is null!', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_pchEntityName$ = 12
_lpCurrentTask$ = -20
_lpViewEntityCsr$ = -16
_lpEntityInstance$ = -8
_lpViewEntity$ = -12
_nRC$ = -4
_OrderEntitiesByDefaultAttribs@8 PROC NEAR

; 13874: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 13875:    LPTASK            lpCurrentTask;
; 13876:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 13877:    LPENTITYINSTANCE  lpEntityInstance;
; 13878:    LPVIEWENTITY      lpViewEntity;
; 13879:    zSHORT            nRC;
; 13880: 
; 13881:    // validate some stuff
; 13882: 
; 13883:    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 13884:    if ( (lpCurrentTask = fnOperationCall( iOrderEntitiesByDefaultAttribs,
; 13885:                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	124					; 0000007cH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L12276

; 13887:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12270
$L12276:

; 13889: 
; 13890:    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView, pchEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13891:    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $L12277

; 13893:       fnOperationReturn( iOrderEntitiesByDefaultAttribs, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	124					; 0000007cH
	call	_fnOperationReturn
	add	esp, 8

; 13894:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12270
$L12277:

; 13896: 
; 13897:    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 13898:    if ( (zLONG) lpEntityInstance == 1 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	$L12280

; 13900:       TraceLineS( "Ordering attributes -- resetting entity cursor.", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0DA@BDHH@Ordering?5attributes?5?9?9?5resetting@ ; `string'
	call	_TraceLineS@8

; 13901:       fnEstablishCursorForView( lpViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4

; 13902:       lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView, pchEntityName, 0 );

	push	0
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13903:       if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $L12282

; 13905:          fnOperationReturn( iOrderEntitiesByDefaultAttribs, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	124					; 0000007cH
	call	_fnOperationReturn
	add	esp, 8

; 13906:          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12270
$L12282:

; 13908: 
; 13909:       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 13910:       if ( lpEntityInstance == UNSET_CSR || lpEntityInstance == NULL_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	je	SHORT $L12286
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L12285
$L12286:

; 13912:          // "KZOEE013 - Internal operation call error"
; 13913:          TraceLineS( "KZOEE013 - Internal operation call error: ",
; 13914:                      "Unset or Null Cursor" );

	push	OFFSET FLAT:??_C@_0BF@KJKO@Unset?5or?5Null?5Cursor?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ ; `string'
	call	_TraceLineS@8

; 13915:          fnIssueCoreError( lpCurrentTask, lpView, 8, 13, 0, "OrderEntities", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0O@GNIP@OrderEntities?$AA@ ; `string'
	push	0
	push	13					; 0000000dH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13916:          nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 13918:       else

	jmp	SHORT $L12289
$L12285:

; 13919:          nRC = fnOrderEntitiesByDefaultAttribs( lpView, lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnOrderEntitiesByDefaultAttribs
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$L12289:

; 13921:    else

	jmp	SHORT $L12292
$L12280:

; 13922:    if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L12291

; 13923:       nRC = fnOrderEntitiesByDefaultAttribs( lpView, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnOrderEntitiesByDefaultAttribs
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 13924:    else

	jmp	SHORT $L12292
$L12291:

; 13926:       TraceLineS( "Ordering attributes -- Entity cursor is null!", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CO@OBEN@Ordering?5attributes?5?9?9?5Entity?5cu@ ; `string'
	call	_TraceLineS@8

; 13927:       nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$L12292:

; 13929: 
; 13930:    fnOperationReturn( iOrderEntitiesByDefaultAttribs, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	124					; 0000007cH
	call	_fnOperationReturn
	add	esp, 8

; 13931:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L12270:

; 13932: 
; 13933: } // OrderEntitiesByDefaultAttribs

	mov	esp, ebp
	pop	ebp
	ret	8
_OrderEntitiesByDefaultAttribs@8 ENDP
_TEXT	ENDS
PUBLIC	_fnGetObjCnstrntOper
_TEXT	SEGMENT
_lpView$ = 8
_lpCurrentTask$ = 12
_hCurrentTask$ = -28
_lpViewOD$ = -16
_hLibrary$ = -12
_lpTaskOperation$ = -24
_hTaskOperation$ = -8
_pchOperLibName$ = -20
_lProcessID$ = -4
_bMutexLocked$12319 = -32
_lpLastTaskOperation$12327 = -36
_fnGetObjCnstrntOper PROC NEAR

; 13946: {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 13947:    LPTASK      hCurrentTask = zGETHNDL( lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hCurrentTask$[ebp], eax

; 13948:    LPVIEWOD    lpViewOD;
; 13949:    LPLIBRARY   hLibrary;
; 13950:    LPTASKOPER  lpTaskOperation;
; 13951:    zPVOID      hTaskOperation;
; 13952:    zPCHAR      pchOperLibName;
; 13953:    zLONG       lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 13954: 
; 13955:    // No Object Constraint operation pointer, return 0 ==> not found.
; 13956:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 13957:    if ( lpViewOD->szOCEOpername[ 0 ] == 0 )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+175]
	test	ecx, ecx
	jne	SHORT $L12308

; 13958:       return( 0 );

	xor	eax, eax
	jmp	$L12298
$L12308:

; 13959: 
; 13960:    for ( lpTaskOperation = zGETPTR( lpViewOD->hFirstTaskOperation );
; 13961:          lpTaskOperation;
; 13962:          lpTaskOperation = zGETPTR( lpTaskOperation->hNextTaskOperationForOEA ) )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+216]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax
	jmp	SHORT $L12311
$L12312:
	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax
$L12311:
	cmp	DWORD PTR _lpTaskOperation$[ebp], 0
	je	SHORT $L12313

; 13964:       if ( lpTaskOperation->hTask == hCurrentTask &&
; 13965:            lpTaskOperation->lProcessID == lProcessID )

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	cmp	ecx, DWORD PTR _hCurrentTask$[ebp]
	jne	SHORT $L12314
	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [edx+34]
	cmp	eax, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $L12314

; 13967:          return( (zPOCEOPER) lpTaskOperation->pfnTaskOper );

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [ecx+30]
	jmp	$L12298
$L12314:

; 13969:    }

	jmp	SHORT $L12312
$L12313:

; 13970: 
; 13971:    // No task object oper exists yet, create one if possible.
; 13972:    pchOperLibName = lpViewOD->szOperLibname;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 142				; 0000008eH
	mov	DWORD PTR _pchOperLibName$[ebp], edx

; 13973:    if ( pchOperLibName == 0 || pchOperLibName[ 0 ] == 0 )

	cmp	DWORD PTR _pchOperLibName$[ebp], 0
	je	SHORT $L12317
	mov	eax, DWORD PTR _pchOperLibName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L12316
$L12317:

; 13974:       return( 0 );

	xor	eax, eax
	jmp	$L12298
$L12316:

; 13975: 
; 13976:    hLibrary = SysLoadLibrary( lpView, pchOperLibName );

	mov	edx, DWORD PTR _pchOperLibName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 13977: 
; 13978:    if ( hLibrary )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	$L12318

; 13980:       zBOOL bMutexLocked;
; 13981: 
; 13982:       hTaskOperation = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,
; 13983:                                          sizeof( TaskOperationRecord ), 1, 0,
; 13984:                                          iTaskOperation );

	push	10034					; 00002732H
	push	0
	push	1
	push	38					; 00000026H
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskOperation$[ebp], eax

; 13985:       if ( hTaskOperation == 0 )

	cmp	DWORD PTR _hTaskOperation$[ebp], 0
	jne	SHORT $L12321

; 13986:          return( 0 );

	xor	eax, eax
	jmp	$L12298
$L12321:

; 13987: 
; 13988:       lpTaskOperation              = zGETPTR( hTaskOperation );

	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax

; 13989:       lpTaskOperation->hViewOD     = lpView->hViewOD;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR [ecx+18], eax

; 13990:       lpTaskOperation->hTask       = hCurrentTask;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _hCurrentTask$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 13991:       lpTaskOperation->lProcessID  = lProcessID;

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [eax+34], ecx

; 13992: 
; 13993:       // Set pointers for TaskOperation chain off of Task structure
; 13994:       // Note: this is a single linked list
; 13995:       if ( hCurrentTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _hCurrentTask$[ebp]
	cmp	eax, DWORD PTR [edx+106]
	jne	SHORT $L12323

; 13997:          bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$12319[ebp], 1

; 13998:          zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 14000:       else

	jmp	SHORT $L12324
$L12323:

; 14001:          bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$12319[ebp], 0
$L12324:

; 14002: 
; 14003:       lpTaskOperation->hNextTaskOperationForTask =
; 14004:                                           lpCurrentTask->hFirstTaskOperation;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+130]
	mov	DWORD PTR [ecx+2], eax

; 14005:       lpCurrentTask->hFirstTaskOperation = hTaskOperation;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [ecx+130], edx

; 14006: 
; 14007:       if ( bMutexLocked )

	mov	eax, DWORD PTR _bMutexLocked$12319[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L12325

; 14008:          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$L12325:

; 14009: 
; 14010:       lpTaskOperation->pfnTaskOper = SysGetProc( hLibrary,
; 14011:                                                  lpViewOD->szOCEOpername );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 175				; 000000afH
	push	ecx
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 14012: 
; 14013:       // Set pointers for TaskOperation chain off of ViewOD structure
; 14014:       // Note: this is a double linked list
; 14015:       if ( lpViewOD->hLastTaskOperation )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	cmp	DWORD PTR [edx+220], 0
	je	SHORT $L12326

; 14017:          LPTASKOPER lpLastTaskOperation =
; 14018:                                      zGETPTR( lpViewOD->hLastTaskOperation );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastTaskOperation$12327[ebp], eax

; 14019: 
; 14020:          lpLastTaskOperation->hNextTaskOperationForOEA = hTaskOperation;

	mov	edx, DWORD PTR _lpLastTaskOperation$12327[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+6], eax

; 14021:          lpTaskOperation->hPrevTaskOperationForOEA =
; 14022:                                                 lpViewOD->hLastTaskOperation;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+220]
	mov	DWORD PTR [ecx+10], eax

; 14023:          lpViewOD->hLastTaskOperation = hTaskOperation;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [ecx+220], edx

; 14025:       else

	jmp	SHORT $L12329
$L12326:

; 14027:          lpViewOD->hFirstTaskOperation = hTaskOperation;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 14028:          lpViewOD->hLastTaskOperation  = hTaskOperation;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+220], eax
$L12329:

; 14031:    else

	jmp	SHORT $L12330
$L12318:

; 14032:       return( 0 );

	xor	eax, eax
	jmp	SHORT $L12298
$L12330:

; 14033: 
; 14034:    return( (zPOCEOPER) lpTaskOperation->pfnTaskOper );

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [ecx+30]
$L12298:

; 14035: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetObjCnstrntOper ENDP
_lpView$ = 8
_lpCurrentTask$ = 12
_nEvent$ = 16
_nState$ = 20
_pfn$ = -4
_fnInvokeOCEOperation PROC NEAR

; 14057: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 14058:    zPOCEOPER   pfn;
; 14059: 
; 14060:    pfn = fnGetObjCnstrntOper( lpView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnGetObjCnstrntOper
	add	esp, 8
	mov	DWORD PTR _pfn$[ebp], eax

; 14061:    if ( pfn )

	cmp	DWORD PTR _pfn$[ebp], 0
	je	SHORT $L12342

; 14062:       return( (zSHORT) (*pfn)( lpView, nEvent, nState ) );

	mov	dx, WORD PTR _nState$[ebp]
	push	edx
	mov	ax, WORD PTR _nEvent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _pfn$[ebp]
	jmp	SHORT $L12340
$L12342:

; 14063: 
; 14064:    return( 0 );

	xor	ax, ax
$L12340:

; 14065: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInvokeOCEOperation ENDP
_TEXT	ENDS
PUBLIC	_fnQualError@8
PUBLIC	??_C@_0BF@DGOD@Error?5occurs?5after?3?5?$AA@	; `string'
PUBLIC	??_C@_0CM@MJO@Error?5parsing?5command?4?5?5See?5trac@ ; `string'
;	COMDAT ??_C@_0BF@DGOD@Error?5occurs?5after?3?5?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BF@DGOD@Error?5occurs?5after?3?5?$AA@ DB 'Error occurs after: ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@MJO@Error?5parsing?5command?4?5?5See?5trac@
_DATA	SEGMENT
??_C@_0CM@MJO@Error?5parsing?5command?4?5?5See?5trac@ DB 'Error parsing c'
	DB	'ommand.  See trace for more.', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchCommand$ = 8
_fnQualError@8 PROC NEAR

; 14069: {

	push	ebp
	mov	ebp, esp

; 14070:    TraceLineS( "Error occurs after: ", pchCommand );

	mov	eax, DWORD PTR _pchCommand$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@DGOD@Error?5occurs?5after?3?5?$AA@ ; `string'
	call	_TraceLineS@8

; 14071:    SysMessageBox( 0, szlOE_SystemError,
; 14072:                   "Error parsing command.  See trace for more.", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CM@MJO@Error?5parsing?5command?4?5?5See?5trac@ ; `string'
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 14073: }

	pop	ebp
	ret	8
_fnQualError@8 ENDP
_TEXT	ENDS
PUBLIC	_CreateQualFromCommand
PUBLIC	??_C@_09MHIP@ACTIVATE?5?$AA@			; `string'
PUBLIC	??_C@_06ICCC@WHERE?5?$AA@			; `string'
EXTRN	__imp___pctype:DWORD
EXTRN	__imp___isctype:NEAR
EXTRN	__imp____mb_cur_max:DWORD
;	COMDAT ??_C@_09MHIP@ACTIVATE?5?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_09MHIP@ACTIVATE?5?$AA@ DB 'ACTIVATE ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06ICCC@WHERE?5?$AA@
_DATA	SEGMENT
??_C@_06ICCC@WHERE?5?$AA@ DB 'WHERE ', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchOD_Name$ = 12
_vSubtask$ = 16
_pchCommand$ = 20
_lControl$ = 24
_vaList$ = -60
_lpViewOD$ = -44
_vQual$ = -56
_pch$ = -40
_szActivateView$ = -36
_nExpecting$ = -52
_nRC$ = -48
_k$12388 = -68
_lpViewEntity$12389 = -64
_CreateQualFromCommand PROC NEAR

; 14100: {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 14101:    va_list     vaList;
; 14102:    LPVIEWOD    lpViewOD;
; 14103:    zVIEW       vQual = 0;

	mov	DWORD PTR _vQual$[ebp], 0

; 14104:    zPCHAR      pch;
; 14105:    zCHAR       szActivateView[ zZEIDON_NAME_LTH + 1 ];
; 14106:    zSHORT      nExpecting = ACTIVATE;

	mov	WORD PTR _nExpecting$[ebp], 1

; 14107:    zSHORT      nRC = zCALL_ERROR;  // We'll assume an error.

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 14108: 
; 14109:    va_start( vaList, lControl );

	lea	eax, DWORD PTR _lControl$[ebp+4]
	mov	DWORD PTR _vaList$[ebp], eax

; 14110: 
; 14111:    lpViewOD = ActivateViewObject( vSubtask, pchOD_Name, FALSE );

	push	0
	mov	ecx, DWORD PTR _pchOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 14112:    if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $L12374

; 14113:       goto EndOfFunction;

	jmp	$EndOfFunction$12375
$L12374:

; 14114: 
; 14115:    // Create an empty qualification.
; 14116:    if ( SfActivateSysEmptyOI( &vQual, "KZDBHQUA", vSubtask, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08ILBJ@KZDBHQUA?$AA@	; `string'
	lea	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L12376

; 14117:       goto EndOfFunction;

	jmp	$EndOfFunction$12375
$L12376:

; 14118: 
; 14119:    pch = pchCommand;

	mov	eax, DWORD PTR _pchCommand$[ebp]
	mov	DWORD PTR _pch$[ebp], eax
$L12378:

; 14120:    while ( *pch )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$L12379

; 14122:       // skip blanks.
; 14123:       if ( zisspace( *pch ) )

	mov	eax, DWORD PTR __imp____mb_cur_max
	cmp	DWORD PTR [eax], 1
	jle	SHORT $L12869
	push	8
	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp___isctype
	add	esp, 8
	mov	DWORD PTR -72+[ebp], eax
	jmp	SHORT $L12870
$L12869:
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR __imp___pctype
	mov	eax, DWORD PTR [edx]
	xor	edx, edx
	mov	dx, WORD PTR [eax+ecx*2]
	and	edx, 8
	mov	DWORD PTR -72+[ebp], edx
$L12870:
	cmp	DWORD PTR -72+[ebp], 0
	je	SHORT $L12380

; 14125:          pch++;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax

; 14126:          continue;

	jmp	SHORT $L12378
$L12380:

; 14128: 
; 14129:       switch ( ztoupper( *pch ) )
; 14130:       {

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	DWORD PTR -76+[ebp], eax
	cmp	DWORD PTR -76+[ebp], 65			; 00000041H
	je	SHORT $L12385
	cmp	DWORD PTR -76+[ebp], 87			; 00000057H
	je	$L12398
	jmp	$L12382
$L12385:

; 14131:          case 'A':
; 14132:             if ( zstrncmpi( pch, "ACTIVATE ", 9 ) == 0 )

	push	9
	push	OFFSET FLAT:??_C@_09MHIP@ACTIVATE?5?$AA@ ; `string'
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$L12386

; 14134:                zSHORT       k;
; 14135:                LPVIEWENTITY lpViewEntity;
; 14136: 
; 14137:                if ( nExpecting != ACTIVATE )

	movsx	ecx, WORD PTR _nExpecting$[ebp]
	cmp	ecx, 1
	je	SHORT $L12390

; 14139:                   fnQualError( pch, 0 );

	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_fnQualError@8

; 14140:                   goto EndOfFunction;

	jmp	$EndOfFunction$12375
$L12390:

; 14142: 
; 14143:                // Skip over activate text.
; 14144:                pch += 9;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 9
	mov	DWORD PTR _pch$[ebp], eax

; 14145: 
; 14146:                // Get activate view name.
; 14147:                for ( k = 0; !zisspace( *pch ) && *pch != 0 ; pch++, k++ )

	mov	WORD PTR _k$12388[ebp], 0
	jmp	SHORT $L12391
$L12392:
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
	mov	dx, WORD PTR _k$12388[ebp]
	add	dx, 1
	mov	WORD PTR _k$12388[ebp], dx
$L12391:
	mov	eax, DWORD PTR __imp____mb_cur_max
	cmp	DWORD PTR [eax], 1
	jle	SHORT $L12871
	push	8
	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp___isctype
	add	esp, 8
	mov	DWORD PTR -80+[ebp], eax
	jmp	SHORT $L12872
$L12871:
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR __imp___pctype
	mov	eax, DWORD PTR [edx]
	xor	edx, edx
	mov	dx, WORD PTR [eax+ecx*2]
	and	edx, 8
	mov	DWORD PTR -80+[ebp], edx
$L12872:
	cmp	DWORD PTR -80+[ebp], 0
	jne	SHORT $L12393
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L12393

; 14149:                   if ( k > zZEIDON_NAME_LTH )

	movsx	edx, WORD PTR _k$12388[ebp]
	cmp	edx, 32					; 00000020H
	jle	SHORT $L12394

; 14151:                      fnQualError( pch, 0 );

	push	0
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_fnQualError@8

; 14152:                      goto EndOfFunction;

	jmp	$EndOfFunction$12375
$L12394:

; 14154: 
; 14155:                   szActivateView[ k ] = *pch;

	movsx	ecx, WORD PTR _k$12388[ebp]
	mov	edx, DWORD PTR _pch$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _szActivateView$[ebp+ecx], al

; 14156:                }

	jmp	$L12392
$L12393:

; 14157: 
; 14158:                lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$12389[ebp], eax

; 14159:                CreateEntity( vQual, "EntitySpec", zPOS_NEXT );

	push	3
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_CreateEntity@12

; 14160:                SetAttributeFromString( vQual, "EntitySpec", "EntityName",
; 14161:                                        lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$12389[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 14162: 
; 14163:                nExpecting = WHERE;

	mov	WORD PTR _nExpecting$[ebp], 2

; 14165:             else

	jmp	SHORT $L12397
$L12386:

; 14167:                fnQualError( pch, 0 );

	push	0
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_fnQualError@8

; 14168:                goto EndOfFunction;

	jmp	SHORT $EndOfFunction$12375
$L12397:

; 14170: 
; 14171:             break;

	jmp	SHORT $L12382
$L12398:

; 14172: 
; 14173:          case 'W':
; 14174:             if ( zstrncmpi( pch, "WHERE ", 6 ) == 0 )

	push	6
	push	OFFSET FLAT:??_C@_06ICCC@WHERE?5?$AA@	; `string'
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L12399

; 14176:                if ( nExpecting != WHERE )

	movsx	edx, WORD PTR _nExpecting$[ebp]
	cmp	edx, 2
	je	SHORT $L12401

; 14178:                   fnQualError( pch, 0 );

	push	0
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_fnQualError@8

; 14179:                   goto EndOfFunction;

	jmp	SHORT $EndOfFunction$12375
$L12401:

; 14181: 
; 14182:                // Skip over where text.
; 14183:                pch += 6;

	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 6
	mov	DWORD PTR _pch$[ebp], ecx

; 14184: 
; 14185:                nExpecting = QUAL;

	mov	WORD PTR _nExpecting$[ebp], 3

; 14187:             else

	jmp	SHORT $L12402
$L12399:

; 14189:                fnQualError( pch, 0 );

	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_fnQualError@8

; 14190:                goto EndOfFunction;

	jmp	SHORT $EndOfFunction$12375
$L12402:
$L12382:

; 14196: 
; 14197:    } // while ( *pch )...

	jmp	$L12378
$L12379:

; 14198: 
; 14199:    // If we get here then everything's good.
; 14200:    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$12375:

; 14201: 
; 14202: EndOfFunction:
; 14203:    va_end( vaList );

	mov	DWORD PTR _vaList$[ebp], 0

; 14204: 
; 14205:    // We need to clean up a little more if we have an error.
; 14206:    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L12405

; 14208:       if ( vQual )

	cmp	DWORD PTR _vQual$[ebp], 0
	je	SHORT $L12405

; 14209:          DropObjectInstance( vQual );

	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_DropObjectInstance@4
$L12405:

; 14211: 
; 14212:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 14213: }

	mov	esp, ebp
	pop	ebp
	ret	0
_CreateQualFromCommand ENDP
_pchLineOut$ = 8
_pchBuffer$ = 12
_ulBufferLth$ = 16
_pulBufferPos$ = 20
_k$ = -16
_nChars$ = -20
_c$ = -4
_pchIn$ = -12
_pchOut$ = -8
_UUENCODE_NextEncodedLine@16 PROC NEAR

; 14253: {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 14254: 
; 14255: // The encode macro masks the lower 6 bits and adds 32 (a space), but
; 14256: // it translates a binary zero to a "`" rather than leaving it a space.
; 14257: // This is the generally accepted current technique (although not in the standard).
; 14258: #define ENC(c) ((c) ? ((c) & 0x3F) + 0x20: 0x60)
; 14259: 
; 14260:    zSHORT k, nChars;
; 14261:    zCHAR  c;
; 14262:    register zPCHAR pchIn;
; 14263:    register zPCHAR pchOut;
; 14264: 
; 14265:    pchOut = pchLineOut;

	mov	eax, DWORD PTR _pchLineOut$[ebp]
	mov	DWORD PTR _pchOut$[ebp], eax

; 14266:    nChars = (zSHORT) (ulBufferLth - *pulBufferPos);

	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	edx, DWORD PTR _ulBufferLth$[ebp]
	sub	edx, DWORD PTR [ecx]
	mov	WORD PTR _nChars$[ebp], dx

; 14267:    if ( nChars <= 0 )

	movsx	eax, WORD PTR _nChars$[ebp]
	test	eax, eax
	jg	SHORT $L12421

; 14269:       // Buffer encoding complete
; 14270:       *pchOut++ = '`';

	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], 96			; 00000060H
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14271:       *pchOut = 0;

	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax], 0

; 14272:       return( 0 );

	xor	ax, ax
	jmp	$L12414
$L12421:

; 14274: 
; 14275:    if ( nChars > 45 )

	movsx	ecx, WORD PTR _nChars$[ebp]
	cmp	ecx, 45					; 0000002dH
	jle	SHORT $L12422

; 14276:       nChars = 45;

	mov	WORD PTR _nChars$[ebp], 45		; 0000002dH
$L12422:

; 14277: 
; 14278:    // store the length as the first byte encoded
; 14279:    *pchOut++ = ENC( nChars );

	movsx	edx, WORD PTR _nChars$[ebp]
	test	edx, edx
	je	SHORT $L12874
	movsx	eax, WORD PTR _nChars$[ebp]
	and	eax, 63					; 0000003fH
	add	eax, 32					; 00000020H
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L12875
$L12874:
	mov	DWORD PTR -24+[ebp], 96			; 00000060H
$L12875:
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	dl, BYTE PTR -24+[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax

; 14280:    pchIn = pchBuffer + *pulBufferPos;

	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pchIn$[ebp], edx

; 14281:    for ( k = nChars; k > 0; k -= 3, pchIn += 3 )

	mov	ax, WORD PTR _nChars$[ebp]
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $L12423
$L12424:
	mov	cx, WORD PTR _k$[ebp]
	sub	cx, 3
	mov	WORD PTR _k$[ebp], cx
	mov	edx, DWORD PTR _pchIn$[ebp]
	add	edx, 3
	mov	DWORD PTR _pchIn$[ebp], edx
$L12423:
	movsx	eax, WORD PTR _k$[ebp]
	test	eax, eax
	jle	$L12425

; 14283:       c = *pchIn >> 2;

	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sar	edx, 2
	mov	BYTE PTR _c$[ebp], dl

; 14284:       *pchOut++ = ENC( c );

	movsx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	je	SHORT $L12876
	movsx	ecx, BYTE PTR _c$[ebp]
	and	ecx, 63					; 0000003fH
	add	ecx, 32					; 00000020H
	mov	DWORD PTR -28+[ebp], ecx
	jmp	SHORT $L12877
$L12876:
	mov	DWORD PTR -28+[ebp], 96			; 00000060H
$L12877:
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	al, BYTE PTR -28+[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14285: 
; 14286:       if ( k == 1 )

	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 1
	jne	SHORT $L12426

; 14288:          // only one byte valid - use 0 for next 2 input bytes
; 14289:          c = (*pchIn << 4) & 0x30;

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	shl	ecx, 4
	and	ecx, 48					; 00000030H
	mov	BYTE PTR _c$[ebp], cl

; 14290:          *pchOut++ = ENC( c );

	movsx	edx, BYTE PTR _c$[ebp]
	test	edx, edx
	je	SHORT $L12878
	movsx	eax, BYTE PTR _c$[ebp]
	and	eax, 63					; 0000003fH
	add	eax, 32					; 00000020H
	mov	DWORD PTR -32+[ebp], eax
	jmp	SHORT $L12879
$L12878:
	mov	DWORD PTR -32+[ebp], 96			; 00000060H
$L12879:
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	dl, BYTE PTR -32+[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax

; 14291:          *pchOut++ = ENC( 0 );

	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], 96			; 00000060H
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14292:          *pchOut++ = ENC( 0 );

	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax], 96			; 00000060H
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14294:       else

	jmp	$L12429
$L12426:

; 14295:       if ( k == 2 )

	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 2
	jne	$L12428

; 14297:          // only 2 bytes valid - use 0 for last input byte
; 14298:          c = ((*pchIn << 4) & 0x30) | ((pchIn[ 1 ] >> 4) & 0x0F);

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	shl	ecx, 4
	and	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	or	ecx, eax
	mov	BYTE PTR _c$[ebp], cl

; 14299:          *pchOut++ = ENC( c );

	movsx	ecx, BYTE PTR _c$[ebp]
	test	ecx, ecx
	je	SHORT $L12880
	movsx	edx, BYTE PTR _c$[ebp]
	and	edx, 63					; 0000003fH
	add	edx, 32					; 00000020H
	mov	DWORD PTR -36+[ebp], edx
	jmp	SHORT $L12881
$L12880:
	mov	DWORD PTR -36+[ebp], 96			; 00000060H
$L12881:
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR -36+[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14300:          c = (pchIn[ 1 ] << 2) & 0x3C;

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	shl	ecx, 2
	and	ecx, 60					; 0000003cH
	mov	BYTE PTR _c$[ebp], cl

; 14301:          *pchOut++ = ENC( c );

	movsx	edx, BYTE PTR _c$[ebp]
	test	edx, edx
	je	SHORT $L12882
	movsx	eax, BYTE PTR _c$[ebp]
	and	eax, 63					; 0000003fH
	add	eax, 32					; 00000020H
	mov	DWORD PTR -40+[ebp], eax
	jmp	SHORT $L12883
$L12882:
	mov	DWORD PTR -40+[ebp], 96			; 00000060H
$L12883:
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	dl, BYTE PTR -40+[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax

; 14302:          *pchOut++ = ENC( 0 );

	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], 96			; 00000060H
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14304:       else

	jmp	$L12429
$L12428:

; 14306:          // all 3 bytes valid - use all 3 input bytes for the 4 output bytes
; 14307:          c = ((*pchIn << 4) & 0x30) | ((pchIn[ 1 ] >> 4) & 0x0F);

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	shl	ecx, 4
	and	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	or	ecx, eax
	mov	BYTE PTR _c$[ebp], cl

; 14308:          *pchOut++ = ENC( c );

	movsx	ecx, BYTE PTR _c$[ebp]
	test	ecx, ecx
	je	SHORT $L12884
	movsx	edx, BYTE PTR _c$[ebp]
	and	edx, 63					; 0000003fH
	add	edx, 32					; 00000020H
	mov	DWORD PTR -44+[ebp], edx
	jmp	SHORT $L12885
$L12884:
	mov	DWORD PTR -44+[ebp], 96			; 00000060H
$L12885:
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR -44+[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14309:          c = ((pchIn[ 1 ] << 2) & 0x3C) | ((pchIn[ 2 ] >> 6) & 0x03);

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	shl	ecx, 2
	and	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	sar	eax, 6
	and	eax, 3
	or	ecx, eax
	mov	BYTE PTR _c$[ebp], cl

; 14310:          *pchOut++ = ENC( c );

	movsx	ecx, BYTE PTR _c$[ebp]
	test	ecx, ecx
	je	SHORT $L12886
	movsx	edx, BYTE PTR _c$[ebp]
	and	edx, 63					; 0000003fH
	add	edx, 32					; 00000020H
	mov	DWORD PTR -48+[ebp], edx
	jmp	SHORT $L12887
$L12886:
	mov	DWORD PTR -48+[ebp], 96			; 00000060H
$L12887:
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR -48+[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14311:          c = pchIn[ 2 ] & 0x3F;

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	and	ecx, 63					; 0000003fH
	mov	BYTE PTR _c$[ebp], cl

; 14312:          *pchOut++ = ENC( c );

	movsx	edx, BYTE PTR _c$[ebp]
	test	edx, edx
	je	SHORT $L12888
	movsx	eax, BYTE PTR _c$[ebp]
	and	eax, 63					; 0000003fH
	add	eax, 32					; 00000020H
	mov	DWORD PTR -52+[ebp], eax
	jmp	SHORT $L12889
$L12888:
	mov	DWORD PTR -52+[ebp], 96			; 00000060H
$L12889:
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	dl, BYTE PTR -52+[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax
$L12429:

; 14314:    }

	jmp	$L12424
$L12425:

; 14315: 
; 14316:    *pulBufferPos = *pulBufferPos + nChars;

	movsx	ecx, WORD PTR _nChars$[ebp]
	mov	edx, DWORD PTR _pulBufferPos$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	DWORD PTR [ecx], eax

; 14317:    *pchOut = 0;

	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], 0

; 14318: 
; 14319:    return( 1 );

	mov	ax, 1
$L12414:

; 14320: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_UUENCODE_NextEncodedLine@16 ENDP
_pchEncodedLine$ = 8
_pchBuffer$ = 12
_ulBufferLth$ = 16
_pulBufferPos$ = 20
_k$ = -12
_nChars$ = -16
_nAvail$ = -20
_pchIn$ = -8
_pchOut$ = -4
_UUDECODE_NextLineToBuffer@16 PROC NEAR

; 14371: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 14372: 
; 14373: // The decode macro subtracts 32 (a space) and masks the lower 6 bits
; 14374: #define DEC(c)  (((c) - 0x20) & 0x3F)
; 14375: 
; 14376:    zSHORT k, nChars, nAvail;
; 14377:    register zPCHAR pchIn;
; 14378:    register zPCHAR pchOut;
; 14379: 
; 14380:    nAvail = (zSHORT) (ulBufferLth - *pulBufferPos);

	mov	eax, DWORD PTR _pulBufferPos$[ebp]
	mov	ecx, DWORD PTR _ulBufferLth$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	WORD PTR _nAvail$[ebp], cx

; 14381:    pchIn = pchEncodedLine;

	mov	edx, DWORD PTR _pchEncodedLine$[ebp]
	mov	DWORD PTR _pchIn$[ebp], edx

; 14382:    nChars = DEC( *pchIn );

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	mov	WORD PTR _nChars$[ebp], cx

; 14383:    if ( nChars == 0 )

	movsx	edx, WORD PTR _nChars$[ebp]
	test	edx, edx
	jne	SHORT $L12445

; 14384:       return( 0 );

	xor	ax, ax
	jmp	$L12438
$L12445:

; 14385: 
; 14386:    if ( nChars > nAvail || nChars > 45 )

	movsx	eax, WORD PTR _nChars$[ebp]
	movsx	ecx, WORD PTR _nAvail$[ebp]
	cmp	eax, ecx
	jg	SHORT $L12447
	movsx	edx, WORD PTR _nChars$[ebp]
	cmp	edx, 45					; 0000002dH
	jle	SHORT $L12446
$L12447:

; 14388:       // no room left in buffer or invalid line length.
; 14389:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12438
$L12446:

; 14391: 
; 14392:    // check line length is correct
; 14393:    //    this can be eliminated if it is too much overhead
; 14394:    if ( (zUSHORT) zstrlen( pchEncodedLine ) != (zUSHORT) (((((nChars - 1) / 3) + 1) * 4) + 1))

	mov	eax, DWORD PTR _pchEncodedLine$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, eax
	and	ecx, 65535				; 0000ffffH
	movsx	eax, WORD PTR _nChars$[ebp]
	sub	eax, 1
	cdq
	mov	esi, 3
	idiv	esi
	lea	edx, DWORD PTR [eax*4+5]
	and	edx, 65535				; 0000ffffH
	cmp	ecx, edx
	je	SHORT $L12450

; 14396:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12438
$L12450:

; 14398: 
; 14399:    // fill the buffer (4 bytes go to 3)
; 14400:    pchOut = pchBuffer + *pulBufferPos;

	mov	eax, DWORD PTR _pulBufferPos$[ebp]
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14401:    for ( pchIn++, k = nChars; k > 0; pchIn += 4, k -= 3 )

	mov	edx, DWORD PTR _pchIn$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchIn$[ebp], edx
	mov	ax, WORD PTR _nChars$[ebp]
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $L12451
$L12452:
	mov	ecx, DWORD PTR _pchIn$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchIn$[ebp], ecx
	mov	dx, WORD PTR _k$[ebp]
	sub	dx, 3
	mov	WORD PTR _k$[ebp], dx
$L12451:
	movsx	eax, WORD PTR _k$[ebp]
	test	eax, eax
	jle	$L12453

; 14403:       if ( k >= 3 )

	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 3
	jl	$L12454

; 14405:          *pchOut++ = DEC (*pchIn) << 2 | DEC (pchIn[ 1 ]) >> 4;

	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	eax, 32					; 00000020H
	and	eax, 63					; 0000003fH
	shl	eax, 2
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	sub	edx, 32					; 00000020H
	and	edx, 63					; 0000003fH
	sar	edx, 4
	or	eax, edx
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14406:          *pchOut++ = DEC (pchIn[ 1 ]) << 4 | DEC (pchIn[ 2 ]) >> 2;

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	shl	ecx, 4
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	sub	eax, 32					; 00000020H
	and	eax, 63					; 0000003fH
	sar	eax, 2
	or	ecx, eax
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax

; 14407:          *pchOut++ = DEC (pchIn[ 2 ]) << 6 | DEC (pchIn[ 3 ]);

	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	sub	edx, 32					; 00000020H
	and	edx, 63					; 0000003fH
	shl	edx, 6
	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+3]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	or	edx, ecx
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14409:       else

	jmp	SHORT $L12457
$L12454:

; 14411:          if ( k >= 1 )

	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 1
	jl	SHORT $L12456

; 14413:             *pchOut++ = DEC (*pchIn) << 2 | DEC (pchIn[ 1 ]) >> 4;

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	shl	ecx, 2
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	sub	eax, 32					; 00000020H
	and	eax, 63					; 0000003fH
	sar	eax, 4
	or	ecx, eax
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax
$L12456:

; 14415: 
; 14416:          if ( k >= 2 )

	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 2
	jl	SHORT $L12457

; 14418:             *pchOut++ = DEC (pchIn[ 1 ]) << 4 | DEC (pchIn[ 2 ]) >> 2;

	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	sub	eax, 32					; 00000020H
	and	eax, 63					; 0000003fH
	shl	eax, 4
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	sub	edx, 32					; 00000020H
	and	edx, 63					; 0000003fH
	sar	edx, 2
	or	eax, edx
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx
$L12457:

; 14421:    }

	jmp	$L12452
$L12453:

; 14422: 
; 14423:    *pulBufferPos = *pulBufferPos + nChars;

	movsx	eax, WORD PTR _nChars$[ebp]
	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _pulBufferPos$[ebp]
	mov	DWORD PTR [eax], edx

; 14424: 
; 14425:    return( nChars );

	mov	ax, WORD PTR _nChars$[ebp]
$L12438:

; 14426: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_UUDECODE_NextLineToBuffer@16 ENDP
_TEXT	ENDS
EXTRN	_SysMalloc@4:NEAR
_TEXT	SEGMENT
_pViewArrayBlock$ = 8
_nViewCount$ = 12
_pv$ = -8
_nViewCount1$ = -4
_fnInitViewArrayBlock PROC NEAR

; 14441: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 14442:    zPVOID *pv;
; 14443:    zLONG nViewCount1 = nViewCount + 1; // we need a trailing NULL pointer

	mov	eax, DWORD PTR _nViewCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _nViewCount1$[ebp], eax

; 14444: 
; 14445:    zmemset( pViewArrayBlock, 0, sizeof(VIEWARRAYBLOCK) );

	push	64					; 00000040H
	push	0
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 14446: 
; 14447:    if ( nViewCount > 1 )

	cmp	DWORD PTR _nViewCount$[ebp], 1
	jle	SHORT $L12466

; 14449:       // allocate 5 PVOID arrays of size nViewCount + 1
; 14450:       pv = SysMalloc( 5 * nViewCount1 * sizeof( zPVOID ) );

	mov	edx, DWORD PTR _nViewCount1$[ebp]
	imul	edx, 5
	shl	edx, 2
	push	edx
	call	_SysMalloc@4
	mov	DWORD PTR _pv$[ebp], eax

; 14451:       if ( pv == 0 )

	cmp	DWORD PTR _pv$[ebp], 0
	jne	SHORT $L12468

; 14452:          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L12462
$L12468:

; 14454:    else

	jmp	SHORT $L12469
$L12466:

; 14456:       // Usually there is only 1 view in the cluster ... in which case we
; 14457:       // we do NOT malloc for performance reasons.
; 14458:       pv = pViewArrayBlock->pvDyn;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _pv$[ebp], eax
$L12469:

; 14460: 
; 14461:    pViewArrayBlock->lCount = nViewCount1;

	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	edx, DWORD PTR _nViewCount1$[ebp]
	mov	DWORD PTR [ecx], edx

; 14462:    pViewArrayBlock->pvArray = (zVIEW *) pv;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 14463:    pViewArrayBlock->pViewOI_Array = (LPVIEWOI *)(pv + nViewCount1);

	mov	edx, DWORD PTR _nViewCount1$[ebp]
	mov	eax, DWORD PTR _pv$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 14464:    pViewArrayBlock->pViewOD_Array = (LPVIEWOD *)(pv + 2 * nViewCount1);

	mov	eax, DWORD PTR _nViewCount1$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _pv$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [eax+12], edx

; 14465:    pViewArrayBlock->pbGenkeyNeededArray = (zBOOL *)(pv + 3 * nViewCount1);

	mov	ecx, DWORD PTR _nViewCount1$[ebp]
	imul	ecx, 3
	mov	edx, DWORD PTR _pv$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 14466:    pViewArrayBlock->pbFK_NeededArray    = (zBOOL *)(pv + 4 * nViewCount1);

	mov	edx, DWORD PTR _nViewCount1$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _pv$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 14467: 
; 14468:    return( 0 );

	xor	ax, ax
$L12462:

; 14469: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInitViewArrayBlock ENDP
_TEXT	ENDS
EXTRN	_SysFree@4:NEAR
_TEXT	SEGMENT
_pViewArrayBlock$ = 8
_fnFreeViewArrayBlock PROC NEAR

; 14483: {

	push	ebp
	mov	ebp, esp

; 14484:    if ( pViewArrayBlock->pvArray && pViewArrayBlock->lCount > 2 )

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L12478
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	cmp	DWORD PTR [ecx], 2
	jle	SHORT $L12478

; 14485:       SysFree( pViewArrayBlock->pvArray );

	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_SysFree@4
$L12478:

; 14486: 
; 14487:    zmemset( pViewArrayBlock, 0, sizeof( VIEWARRAYBLOCK ) );

	push	64					; 00000040H
	push	0
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 14488: }

	pop	ebp
	ret	0
_fnFreeViewArrayBlock ENDP
_TEXT	ENDS
PUBLIC	??_C@_06KGGE@?$CKroot?$CK?$AA@			; `string'
PUBLIC	??_C@_07CHNO@KeyList?$AA@			; `string'
PUBLIC	??_C@_0N@GDFL@IntegerValue?$AA@			; `string'
PUBLIC	_GenerateQualFromEntityList@20
EXTRN	_fnValidateCursorParameters:NEAR
;	COMDAT ??_C@_06KGGE@?$CKroot?$CK?$AA@
; File C:\10C\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_06KGGE@?$CKroot?$CK?$AA@ DB '*root*', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CHNO@KeyList?$AA@
_DATA	SEGMENT
??_C@_07CHNO@KeyList?$AA@ DB 'KeyList', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@GDFL@IntegerValue?$AA@
_DATA	SEGMENT
??_C@_0N@GDFL@IntegerValue?$AA@ DB 'IntegerValue', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvQual$ = 8
_vEntityList$ = 12
_pchEntityName$ = 16
_pchScoping$ = 20
_lpCurrentTask$ = -32
_lpViewEntity$ = -12
_lpScopingViewEntity$ = -20
_lpViewEntityCsr$ = -28
_lpScopingViewEntityCsr$ = -8
_lpKey$ = -24
_vQual$ = -16
_nRC$ = -4
_GenerateQualFromEntityList@20 PROC NEAR

; 14512: {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 14513:    LPTASK            lpCurrentTask;
; 14514:    LPVIEWENTITY      lpViewEntity;
; 14515:    LPVIEWENTITY      lpScopingViewEntity;
; 14516:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 14517:    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 14518:    LPVIEWATTRIB      lpKey;
; 14519:    zVIEW             vQual;
; 14520:    zSHORT            nRC;
; 14521: 
; 14522:    // Validate parameters
; 14523:    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 14524:                                            &lpViewEntity,
; 14525:                                            &lpScopingViewEntity,
; 14526:                                            &lpViewEntityCsr,
; 14527:                                            &lpScopingViewEntityCsr,
; 14528:                                            iGenerateQualFromEntityList,
; 14529:                                            vEntityList,
; 14530:                                            pchEntityName,
; 14531:                                            pchScoping )) != 0 )

	mov	eax, DWORD PTR _pchScoping$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vEntityList$[ebp]
	push	edx
	push	65					; 00000041H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L12499

; 14533:       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L12490
$L12499:

; 14535: 
; 14536:    // Find the key attribute.
; 14537:    for ( lpKey = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 14538:          lpKey->bKey == FALSE;
; 14539:          lpKey = zGETPTR( lpKey->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpKey$[ebp], eax
	jmp	SHORT $L12502
$L12503:
	mov	edx, DWORD PTR _lpKey$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpKey$[ebp], eax
$L12502:
	mov	ecx, DWORD PTR _lpKey$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	jne	SHORT $L12504

; 14541:       // nothing needs to be done here
; 14542:    }

	jmp	SHORT $L12503
$L12504:

; 14543: 
; 14544:    SfActivateSysEmptyOI( &vQual, "KZDBHQUA", vEntityList, zMULTIPLE );

	push	256					; 00000100H
	mov	eax, DWORD PTR _vEntityList$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08ILBJ@KZDBHQUA?$AA@	; `string'
	lea	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16

; 14545:    CreateEntity( vQual, "EntitySpec", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_CreateEntity@12

; 14546:    SetAttributeFromString( vQual, "EntitySpec", "EntityName", "*root*" );

	push	OFFSET FLAT:??_C@_06KGGE@?$CKroot?$CK?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 14547: 
; 14548:    CreateEntity( vQual, "QualAttrib", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_CreateEntity@12

; 14549:    SetAttributeFromString( vQual, "QualAttrib", "EntityName", "*root*" );

	push	OFFSET FLAT:??_C@_06KGGE@?$CKroot?$CK?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 14550:    SetAttributeFromString( vQual, "QualAttrib", "AttributeName", lpKey->szName );

	mov	eax, DWORD PTR _lpKey$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_0O@JICG@AttributeName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 14551:    SetAttributeFromString( vQual, "QualAttrib", "Oper", "=" );

	push	OFFSET FLAT:??_C@_01KPOD@?$DN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 14552: 
; 14553:    // Loop through the entities and copy the key values to the qual OI.
; 14554:    for ( nRC = fnSetEntityCursor( vEntityList, lpViewEntity, lpViewEntityCsr,
; 14555:                                   0, (zLONG) zPOS_FIRST,
; 14556:                                   0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 14557:                                   lpCurrentTask );
; 14558:          nRC >= zCURSOR_SET;
; 14559:          nRC = fnSetEntityCursor( vEntityList, lpViewEntity, lpViewEntityCsr,
; 14560:                                   0, (zLONG) zPOS_NEXT,
; 14561:                                   0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 14562:                                   lpCurrentTask ) )

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vEntityList$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L12512
$L12513:
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	3
	push	0
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vEntityList$[ebp]
	push	eax
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax
$L12512:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $L12514

; 14564:       CreateEntity( vQual, "KeyList", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_07CHNO@KeyList?$AA@	; `string'
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_CreateEntity@12

; 14565:       SetAttributeFromAttribute( vQual, "KeyList", "IntegerValue",
; 14566:                                  vEntityList, pchEntityName, lpKey->szName );

	mov	eax, DWORD PTR _lpKey$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vEntityList$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0N@GDFL@IntegerValue?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_07CHNO@KeyList?$AA@	; `string'
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_SetAttributeFromAttribute@24

; 14567:    }

	jmp	SHORT $L12513
$L12514:

; 14568: 
; 14569:    // Reset the cursor back to the first entity.
; 14570:    nRC = fnSetEntityCursor( vEntityList, lpViewEntity, lpViewEntityCsr,
; 14571:                             0, (zLONG) zPOS_FIRST,
; 14572:                             0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 14573:                             lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	push	0
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vEntityList$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 14574: 
; 14575:    *pvQual = vQual;

	mov	eax, DWORD PTR _pvQual$[ebp]
	mov	ecx, DWORD PTR _vQual$[ebp]
	mov	DWORD PTR [eax], ecx

; 14576: 
; 14577:    fnOperationReturn( iGenerateQualFromEntityList, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	65					; 00000041H
	call	_fnOperationReturn
	add	esp, 8

; 14578:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L12490:

; 14579: }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_GenerateQualFromEntityList@20 ENDP
_TEXT	ENDS
END
